/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 25710:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 25710;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 18523:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 18523;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 14929:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 14929;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 97656:
/***/ ((module) => {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 69262:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cfApi = exports.cfGetApps = exports.cfGetServiceInstancesList = exports.cfGetInstanceKeyParameters = exports.cfGetInstanceCredentials = exports.cfGetServiceKeys = exports.cfLogout = exports.cfGetServicePlans = exports.cfGetTarget = exports.cfGetAuthToken = exports.cfGetInstanceMetadata = exports.cfBindLocalUps = exports.cfBindLocalServices = exports.cfGetSpaceServices = exports.cfGetServices = exports.cfGetTargets = exports.cfSetOrgSpace = exports.cfGetManagedServiceInstances = exports.cfGetServiceInstances = exports.cfGetServicePlansList = exports.cfGetAvailableSpaces = exports.cfGetAvailableOrgs = exports.cfLogin = exports.cfCreateUpsInstance = exports.cfCreateService = exports.cfGetUpsInstances = exports.clearCacheServiceInstances = exports.resolveEndpoint = void 0;
const comment_json_1 = __webpack_require__(36862);
const _ = __webpack_require__(40180);
const cli_1 = __webpack_require__(55458);
const messages_1 = __webpack_require__(39866);
const types_1 = __webpack_require__(223);
const utils_1 = __webpack_require__(86022);
const url_1 = __webpack_require__(57310);
const baseParams = [
    types_1.eFilters.page, types_1.eFilters.per_page, types_1.eFilters.oder_by, types_1.eFilters.label_selector, types_1.eFilters.created_ats, types_1.eFilters.updated_ats
];
const resourceServiceInstances = {
    name: "service_instances",
    params: _.uniq(_.concat(baseParams, [
        types_1.eFilters.names, types_1.eFilters.type, types_1.eFilters.space_guids, types_1.eFilters.organization_guids, types_1.eFilters.service_plan_guids,
        types_1.eFilters.service_plan, types_1.eFilters.service_plan_names
    ]))
};
const resourceOrganizations = {
    name: "organizations",
    params: _.uniq(_.concat(baseParams, [types_1.eFilters.names, types_1.eFilters.guids]))
};
const resourceSpaces = {
    name: "spaces",
    params: _.uniq(_.concat(baseParams, [types_1.eFilters.names, types_1.eFilters.guids, types_1.eFilters.organization_guids, types_1.eFilters.include]))
};
const resourceServicePlan = {
    name: "service_plan",
    params: _.uniq(_.concat(baseParams, [types_1.eFilters.names, types_1.eFilters.guids, types_1.eFilters.available, types_1.eFilters.broker_catalog_ids, types_1.eFilters.space_guids,
        types_1.eFilters.organization_guids, types_1.eFilters.service_broker_guids, types_1.eFilters.service_broker_names, types_1.eFilters.service_offering_guids,
        types_1.eFilters.service_offering_names, types_1.eFilters.service_instance_guids, types_1.eFilters.include
    ]))
};
const resourceServiceOfferings = {
    name: "service_offerings",
    params: _.uniq(_.concat(baseParams, [types_1.eFilters.names, types_1.eFilters.available, types_1.eFilters.service_broker_guids,
        types_1.eFilters.service_broker_names, types_1.eFilters.space_guids, types_1.eFilters.organization_guids
    ]))
};
const resourceServiceCredentialsBinding = {
    name: "service_credential_bindings",
    params: _.uniq(_.concat(baseParams, [types_1.eFilters.names, types_1.eFilters.guids, types_1.eFilters.include, types_1.eFilters.service_instance_guids,
        types_1.eFilters.broker_catalog_ids, types_1.eFilters.space_guids, types_1.eFilters.service_instance_names, types_1.eFilters.app_guids, types_1.eFilters.app_names,
        types_1.eFilters.service_plan_names, types_1.eFilters.service_offering_guids, types_1.eFilters.service_offering_names, types_1.eFilters.type
    ]))
};
const resourceApps = {
    name: "apps",
    params: _.uniq(_.concat(baseParams, [types_1.eFilters.names, types_1.eFilters.space_guids, types_1.eFilters.organization_guids, types_1.eFilters.guids, types_1.eFilters.include]))
};
function evaluateResponse(data) {
    if (_.size(_.get(data, 'errors'))) {
        throw new Error(`${_.get(data, ['errors', '0', 'detail'])} [code: ${_.get(data, ['errors', '0', 'code'])} title: ${_.get(data, ['errors', '0', 'title'])}]`);
    }
    return data;
}
function resolveEndpoint(query) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return /http/.test(new url_1.URL(query).protocol) ? _.replace(query, (yield cfGetTarget(true))["api endpoint"], '') : query;
        }
        catch (e) {
            return query;
        }
    });
}
exports.resolveEndpoint = resolveEndpoint;
let cacheServiceInstanceTypes = {};
function clearCacheServiceInstances() {
    cacheServiceInstanceTypes = {};
}
exports.clearCacheServiceInstances = clearCacheServiceInstances;
function evaluateQueryFilters(query, resource) {
    _.each(query === null || query === void 0 ? void 0 : query.filters, filter => {
        if (!resource.params.includes(filter.key)) {
            throw new Error(messages_1.messages.not_allowed_filter(filter.key, resource.name));
        }
    });
}
const ENTITY_STATE_INPROGRESS = "in progress";
const ENTITY_STATE_FAILED = "failed";
function composeQuery(query) {
    query = (0, utils_1.ensureQuery)(query);
    function _generate_statement(filter) {
        const value = _.get(filter, 'value');
        if (value) {
            return (filter.op === types_1.eOperation.fields)
                ? `${filter.op}[${filter.key}]=${value}`
                : `${filter.key}` + (filter.op ? `[${filter.op}]` : ``) + `=${value}`;
        }
    }
    function _queryFilters(filters) {
        return _.compact(_.values(_.map(filters, _generate_statement)));
    }
    function _queryParams(object) {
        return _.compact(_.map(_.keys(object), key => {
            const value = _.get(object, key);
            if (value) {
                return `${key}=${value}`;
            }
        }));
    }
    return _.compact(_.concat(_queryFilters(query.filters).join('&'), _queryParams(_.omit(query, 'filters')))).join('&');
}
function waitForEntity(resolve, reject, resource, attempt, maxNumberOfAttemps, jobFunction, progress) {
    if (_.size(_.get(resource, 'errors'))) {
        reject(new Error(messages_1.messages.service_creation_failed(_.get(resource, ['errors', '0', 'detail']))));
        return;
    }
    if (attempt < maxNumberOfAttemps) {
        if (progress.cancelToken.isCancellationRequested) {
            reject(new Error(messages_1.messages.create_service_canceled_by_requester));
            return;
        }
        const state = _.get(resource, "last_operation.state", ENTITY_STATE_INPROGRESS);
        if (state === ENTITY_STATE_INPROGRESS) {
            progress.progress.report({ "message": `\n${messages_1.messages.service_creation_started}`, increment: Math.floor(1 / maxNumberOfAttemps * 100) });
            setTimeout(() => {
                jobFunction().then(retriedResource => {
                    waitForEntity(resolve, reject, retriedResource, attempt + 1, maxNumberOfAttemps, jobFunction, progress);
                }).catch(error => {
                    reject(error);
                });
            }, 2000);
        }
        else if (state === ENTITY_STATE_FAILED) {
            reject(new Error(messages_1.messages.failed_creating_entity(_.get(resource, "last_operation.description"), (0, utils_1.getName)(resource))));
        }
        else {
            progress.progress.report({ "message": `\n${messages_1.messages.service_creation_started}`, increment: 100 });
            resolve(resource);
        }
    }
    else {
        reject(new Error(messages_1.messages.exceed_number_of_attempts((0, utils_1.getName)(resource))));
    }
}
function execQuery(args, fncParse, reverseErrorOrder) {
    return __awaiter(this, void 0, void 0, function* () {
        const cliResult = yield cli_1.Cli.execute(args.query, args.options, args.token);
        if (cliResult.exitCode !== 0) {
            throw new Error(reverseErrorOrder ?
                (cliResult.stdout || cliResult.stderr || cliResult.error) :
                (cliResult.error || cliResult.stderr || cliResult.stdout));
        }
        return fncParse ? yield fncParse(evaluateResponse((0, comment_json_1.parse)(cliResult.stdout))) : cliResult.stdout || cliResult.stderr;
    });
}
function execTotal(args, fncParse) {
    return __awaiter(this, void 0, void 0, function* () {
        const collection = [];
        let query = args.query;
        while (query) {
            const result = (0, comment_json_1.parse)(yield execQuery({ query: ["curl", yield resolveEndpoint(query)], options: args.options, token: args.token }));
            for (const resource of _.get(result, "resources", [])) {
                collection.push(fncParse ? yield fncParse(resource, _.get(result, "included")) : resource);
            }
            query = _.get(result, ['pagination', 'next', 'href']);
        }
        return _.compact(collection);
    });
}
function getServiceInstance(query, token) {
    return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceServiceInstances);
        query = yield (0, utils_1.padQuerySpace)(query, [{ key: types_1.eFilters.type, value: types_1.eServiceTypes.managed }]);
        const result = yield execTotal({ query: `/v3/service_instances?${composeQuery(query)}`, token });
        if (_.size(result) >= 1) {
            return _.head(result);
        }
        throw new Error(messages_1.messages.service_not_found(decodeURIComponent(_.get(_.find(query.filters, ['key', types_1.eFilters.names]), 'value')) || 'unknown'));
    });
}
function getUpsCredentials(instanceGuid, token) {
    return __awaiter(this, void 0, void 0, function* () {
        return execQuery({ query: ['curl', `/v3/service_instances/${instanceGuid}/credentials`], token }, (data) => data);
    });
}
function resolveCfResource(data, service) {
    return _.merge({
        name: (0, utils_1.getName)(data),
        guid: (0, utils_1.getGuid)(data),
        description: (0, utils_1.getDescription)(data)
    }, service ? {
        service_offering: {
            guid: (0, utils_1.getGuid)(service),
            description: (0, utils_1.getDescription)(service),
            name: (0, utils_1.getName)(service)
        }
    } : {});
}
function getCachedServicePlan(plan) {
    if (!cacheServiceInstanceTypes[plan.guid]) {
        cacheServiceInstanceTypes[plan.guid] = execQuery({ query: ['curl', `/v3/service_plans/${plan.guid}?include=service_offering`] }, (data) => {
            return Promise.resolve(resolveCfResource(data, _.find(_.get(data, ['included', 'service_offerings']), ['guid', _.get(data, ['relationships', 'service_offering', 'data', 'guid'])])));
        });
    }
    return cacheServiceInstanceTypes[plan.guid];
}
function getServiceInstanceItem(item) {
    const planGuid = _.get(item, ['relationships', 'service_plan', 'data', 'guid']);
    return Promise.resolve({
        guid: (0, utils_1.getGuid)(item),
        label: (0, utils_1.getName)(item),
        tags: (0, utils_1.getTags)(item),
        serviceName: (0, utils_1.isUpsType)(item)
            ? Promise.resolve({ service_offering: { name: types_1.eServiceTypes.user_provided }, name: '' })
            : getCachedServicePlan({ guid: planGuid }).then(plan => plan).catch(() => { return {}; }),
        plan_guid: planGuid,
        credentials: (0, utils_1.isUpsType)(item)
            ? getUpsCredentials((0, utils_1.getGuid)(item)).then(data => data).catch(() => { return {}; })
            : Promise.resolve()
    });
}
function resolveServiceInstances(results) {
    return __awaiter(this, void 0, void 0, function* () {
        const queries = _.concat(_.map(results, 'serviceName'), _.map(results, 'credentials'));
        if (!_.size(queries)) {
            return [];
        }
        return Promise.all(queries).then(() => __awaiter(this, void 0, void 0, function* () {
            const instances = [];
            for (const result of results) {
                const serviceName = yield _.get(result, 'serviceName');
                instances.push({
                    guid: (0, utils_1.getGuid)(result),
                    label: (0, utils_1.getLabel)(result),
                    serviceName: _.get(serviceName, ['service_offering', 'name'], 'unknown'),
                    plan_guid: _.get(result, 'plan_guid'),
                    plan: _.get(serviceName, 'name', 'unknown'),
                    tags: _.get(result, 'tags'),
                    credentials: yield result.credentials
                });
            }
            return _.compact(instances);
        }));
    });
}
function cfGetUpsInstances(query, token) {
    return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceServiceInstances);
        query = yield (0, utils_1.padQuerySpace)(query, [{ key: types_1.eFilters.type, value: types_1.eServiceTypes.user_provided }]);
        return resolveServiceInstances(yield execTotal({ query: `/v3/service_instances?${composeQuery(query)}`, token }, (info) => __awaiter(this, void 0, void 0, function* () { return getServiceInstanceItem(info); })));
    });
}
exports.cfGetUpsInstances = cfGetUpsInstances;
function cfCreateService(planGuid, instanceName, params, tags, progress, maxNumberOfAttemps) {
    return __awaiter(this, void 0, void 0, function* () {
        const spaceGuid = yield (0, utils_1.getSpaceGuidThrowIfUndefined)();
        maxNumberOfAttemps = _.isNil(maxNumberOfAttemps) ? 45 : maxNumberOfAttemps;
        progress = _.defaults(progress, { progress: { report: () => '' } }, { cancelToken: { isCancellationRequested: false, onCancellationRequested: () => '' } });
        const request = {
            type: types_1.eServiceTypes.managed,
            name: instanceName,
            relationships: {
                space: { data: { guid: spaceGuid } },
                service_plan: { data: { guid: planGuid } }
            },
            parameters: params, tags
        };
        const result = yield execQuery({ query: ["curl", "/v3/service_instances", "-d", (0, comment_json_1.stringify)(request), "-X", "POST"], token: progress.cancelToken });
        progress.progress.report({ "message": `\n${messages_1.messages.service_creation_started}`, increment: 1 });
        const query = { filters: [{ key: types_1.eFilters.names, value: encodeURIComponent(instanceName) }, { key: types_1.eFilters.space_guids, value: spaceGuid }] };
        return new Promise((resolve, reject) => {
            waitForEntity(resolve, reject, !_.isEmpty(_.replace(result, '\n', '')) ? (0, comment_json_1.parse)(result) : result, 0, maxNumberOfAttemps, () => getServiceInstance(query, progress.cancelToken), progress);
        });
    });
}
exports.cfCreateService = cfCreateService;
function cfCreateUpsInstance(info) {
    return __awaiter(this, void 0, void 0, function* () {
        let spaceGuid = info.space_guid;
        if (!spaceGuid) {
            spaceGuid = yield (0, utils_1.getSpaceGuidThrowIfUndefined)();
        }
        return evaluateResponse((0, comment_json_1.parse)(yield execQuery({
            query: ["curl", `/v3/service_instances`, '-d', (0, comment_json_1.stringify)(_.merge({
                    name: info.instanceName,
                    type: types_1.eServiceTypes.user_provided,
                    relationships: { space: { data: { guid: spaceGuid } } }
                }, info.credentials ? { "credentials": info.credentials } : {}, info.route_service_url ? { "route_service_url": info.route_service_url } : {}, info.syslog_drain_url ? { "syslog_drain_url": info.syslog_drain_url } : {}, info.tags ? { "tags": info.tags } : {})), "-X", "POST"]
        })));
    });
}
exports.cfCreateUpsInstance = cfCreateUpsInstance;
function cfLogin(endpoint, user, pwd) {
    return __awaiter(this, void 0, void 0, function* () {
        let result;
        try {
            result = yield execQuery({ query: ["login", "-a", endpoint, "-u", user, "-p", pwd, "-o", "no-org-for-now", "-s", "no-space-for-now"], options: { env: { "CF_COLOR": "false" } } }, undefined, true);
        }
        catch (e) {
            result = _.get(e, 'message', '');
        }
        return result.includes(`Authenticating...${types_1.NEW_LINE}${types_1.OK}`) ? types_1.OK : result;
    });
}
exports.cfLogin = cfLogin;
function cfGetAvailableOrgs(query) {
    return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceOrganizations);
        return execTotal({ query: `/v3/organizations?${composeQuery(query)}` }, (resource) => {
            return Promise.resolve({ label: (0, utils_1.getName)(resource), guid: (0, utils_1.getGuid)(resource) });
        });
    });
}
exports.cfGetAvailableOrgs = cfGetAvailableOrgs;
function cfGetAvailableSpaces(orgGuid) {
    return __awaiter(this, void 0, void 0, function* () {
        const query = (0, utils_1.ensureQuery)();
        if (orgGuid) {
            _.merge(query.filters, [{ key: types_1.eFilters.organization_guids, value: orgGuid }]);
        }
        evaluateQueryFilters(query, resourceSpaces);
        return execTotal({ query: `/v3/spaces?${composeQuery(query)}` }, (resource) => {
            return Promise.resolve({
                label: (0, utils_1.getName)(resource),
                guid: (0, utils_1.getGuid)(resource),
                orgGUID: (0, utils_1.getOrgGUID)(resource)
            });
        });
    });
}
exports.cfGetAvailableSpaces = cfGetAvailableSpaces;
function resolvePlanInfo(data, service) {
    return _.merge({
        label: (0, utils_1.getName)(data),
        guid: (0, utils_1.getGuid)(data),
        description: (0, utils_1.getDescription)(data)
    }, service ? {
        service_offering: {
            guid: (0, utils_1.getGuid)(service),
            description: (0, utils_1.getDescription)(service),
            name: (0, utils_1.getName)(service)
        }
    } : {});
}
function cfGetServicePlansList(query, token) {
    return __awaiter(this, void 0, void 0, function* () {
        query = yield (0, utils_1.padQuerySpace)(query, [{ key: types_1.eFilters.include, value: 'service_offering' }]);
        evaluateQueryFilters(query, resourceServicePlan);
        return execTotal({ query: `/v3/service_plans?${composeQuery(query)}`, token }, (data, included) => {
            return Promise.resolve(resolvePlanInfo(data, _.find(_.get(included, 'service_offerings'), ['guid', _.get(data, ['relationships', 'service_offering', 'data', 'guid'])])));
        });
    });
}
exports.cfGetServicePlansList = cfGetServicePlansList;
function cfGetServiceInstances(query, token) {
    return __awaiter(this, void 0, void 0, function* () {
        query = yield (0, utils_1.padQuerySpace)(query, [
            { key: types_1.eFilters.service_plan, value: 'guid,name', op: types_1.eOperation.fields },
            { key: types_1.eFilters.type, value: types_1.eServiceTypes.managed }
        ]);
        evaluateQueryFilters(query, resourceServiceInstances);
        return resolveServiceInstances(yield execTotal({ query: `/v3/service_instances?${composeQuery(query)}`, token }, (info) => getServiceInstanceItem(info)));
    });
}
exports.cfGetServiceInstances = cfGetServiceInstances;
function cfGetManagedServiceInstances(query, token) {
    return __awaiter(this, void 0, void 0, function* () {
        return cfGetServiceInstances(query, token);
    });
}
exports.cfGetManagedServiceInstances = cfGetManagedServiceInstances;
function cfSetOrgSpace(org, space) {
    return __awaiter(this, void 0, void 0, function* () {
        yield execQuery({ query: _.concat(["target", "-o", org], (space ? ["-s", space] : [])) });
        clearCacheServiceInstances();
        void cfGetManagedServiceInstances();
    });
}
exports.cfSetOrgSpace = cfSetOrgSpace;
function cfGetTargets() {
    return __awaiter(this, void 0, void 0, function* () {
        const targets = yield execQuery({ query: ["targets"] });
        if (_.includes(targets, "No targets have been saved yet") || _.includes(targets, "is not a registered command")) {
            return [{ label: types_1.DEFAULT_TARGET, isCurrent: true, isDirty: false }];
        }
        const targetSubstrings = _.compact(_.map(targets.split(types_1.NEW_LINE), targetSubstring => targetSubstring.trim()));
        return _.map(targetSubstrings, targetSubstring => {
            const parentthesisPos = targetSubstring.indexOf("(current");
            if (parentthesisPos > 0) {
                targetSubstring = targetSubstring.substring(0, parentthesisPos);
                return { label: targetSubstring.trim(), isCurrent: true, isDirty: targetSubstring.includes("modified") };
            }
            return { label: targetSubstring, isCurrent: false, isDirty: false };
        });
    });
}
exports.cfGetTargets = cfGetTargets;
function cfGetServices(query, cancellationToken) {
    return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceServiceOfferings);
        return execTotal({ query: `/v3/service_offerings?${composeQuery(yield (0, utils_1.padQuerySpace)(query))}`, token: cancellationToken }, (service) => {
            return Promise.resolve({
                label: (0, utils_1.getName)(service),
                service_plans_url: _.get(service, ['links', 'service_plans', 'href']),
                guid: (0, utils_1.getGuid)(service),
                description: (0, utils_1.getDescription)(service)
            });
        });
    });
}
exports.cfGetServices = cfGetServices;
function cfGetSpaceServices(query, spaceGUID, cancellationToken) {
    return __awaiter(this, void 0, void 0, function* () {
        return cfGetServices((0, utils_1.padQuery)(query, [{ key: types_1.eFilters.space_guids, value: spaceGUID }]), cancellationToken);
    });
}
exports.cfGetSpaceServices = cfGetSpaceServices;
function cfBindLocalServices(filePath, instanceNames, tags, serviceKeyNames, serviceKeyParams) {
    return __awaiter(this, void 0, void 0, function* () {
        yield execQuery({
            query: [
                "bind-local",
                "-path",
                filePath,
                "-service-names",
                ...instanceNames,
                ...(_.size(tags) ? _.concat(["-tags"], tags) : []),
                ...(_.size(serviceKeyNames) ? _.concat(["-service-keys"], serviceKeyNames) : []),
                ...(_.size(serviceKeyParams) ? _.concat(["-params"], _.map(serviceKeyParams, param => { return (0, comment_json_1.stringify)(param); })) : [])
            ]
        });
    });
}
exports.cfBindLocalServices = cfBindLocalServices;
function cfBindLocalUps(filePath, instanceNames, tags) {
    return __awaiter(this, void 0, void 0, function* () {
        yield execQuery({
            query: _.concat(["bind-local-ups", "-path", filePath], _.reduce(instanceNames, (result, instanceName) => {
                result = _.concat(result, [`-service-names`, `${instanceName}`]);
                return result;
            }, []), _.reduce(tags, (result, tag) => {
                result = _.concat(result, [`-tags`, `${tag}`]);
                return result;
            }, []))
        });
    });
}
exports.cfBindLocalUps = cfBindLocalUps;
function cfGetInstanceMetadata(instanceName) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield cfGetServiceInstances(yield (0, utils_1.padQuerySpace)({
            filters: [
                { key: types_1.eFilters.names, value: encodeURIComponent(instanceName) },
                { key: types_1.eFilters.type, value: types_1.eServiceTypes.managed }
            ]
        }));
        if (!_.size(result)) {
            throw new Error(messages_1.messages.service_not_found(instanceName));
        }
        const serviceInstance = _.head(result);
        return {
            serviceName: (0, utils_1.getLabel)(serviceInstance),
            plan: _.get(serviceInstance, 'plan'),
            plan_guid: _.get(serviceInstance, 'plan_guid'),
            service: _.get(serviceInstance, 'serviceName')
        };
    });
}
exports.cfGetInstanceMetadata = cfGetInstanceMetadata;
function cfGetAuthToken() {
    return __awaiter(this, void 0, void 0, function* () {
        return yield execQuery({ query: ["oauth-token"] });
    });
}
exports.cfGetAuthToken = cfGetAuthToken;
function cfGetTarget(weak) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!weak) {
            yield cfGetAuthToken();
        }
        return (0, utils_1.parseRawDictData)(yield execQuery({ query: ["target"], options: { env: { "CF_COLOR": "false" } } }));
    });
}
exports.cfGetTarget = cfGetTarget;
function cfGetServicePlans(servicePlansUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        return execTotal({ query: servicePlansUrl }, (data) => {
            return Promise.resolve({ label: (0, utils_1.getName)(data), guid: (0, utils_1.getGuid)(data), description: (0, utils_1.getDescription)(data) });
        });
    });
}
exports.cfGetServicePlans = cfGetServicePlans;
function cfLogout() {
    return __awaiter(this, void 0, void 0, function* () {
        yield execQuery({ query: ["logout"] });
    });
}
exports.cfLogout = cfLogout;
function cfGetServiceKeys(query, token) {
    return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceServiceCredentialsBinding);
        return execTotal({ query: `/v3/service_credential_bindings?${composeQuery((0, utils_1.padQuery)(query, [{ key: types_1.eFilters.type, value: 'key' }]))}`, token });
    });
}
exports.cfGetServiceKeys = cfGetServiceKeys;
function cfGetInstanceCredentials(query, token) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = _.map(yield cfGetServiceKeys(query, token), (resource) => {
            return execQuery({ query: ['curl', `/v3/service_credential_bindings/${(0, utils_1.getGuid)(resource)}/details`], token }, (data) => data)
                .then(data => data).catch(() => { return {}; });
        });
        return Promise.all(_.compact(results));
    });
}
exports.cfGetInstanceCredentials = cfGetInstanceCredentials;
function cfGetInstanceKeyParameters(instanceName) {
    return __awaiter(this, void 0, void 0, function* () {
        const instance = yield getServiceInstance({ filters: [{ key: types_1.eFilters.names, value: encodeURIComponent(instanceName) }] });
        const query = { filters: [{ key: types_1.eFilters.service_instance_guids, value: (0, utils_1.getGuid)(instance) }] };
        let keys = yield cfGetServiceKeys(query);
        if (!_.size(keys)) {
            yield cli_1.Cli.execute(["create-service-key", encodeURIComponent(instanceName), "key"]);
            keys = yield cfGetServiceKeys((0, utils_1.padQuery)(query, [{ key: types_1.eFilters.names, value: 'key' }]));
        }
        return execQuery({ query: ['curl', `/v3/service_credential_bindings/${(0, utils_1.getGuid)(_.head(keys))}/details`] }, (data) => data)
            .then(data => data).catch(() => { return {}; });
    });
}
exports.cfGetInstanceKeyParameters = cfGetInstanceKeyParameters;
function cfGetServiceInstancesList(query, token) {
    return __awaiter(this, void 0, void 0, function* () {
        query = yield (0, utils_1.padQuerySpace)(query, [{ key: types_1.eFilters.service_plan, value: 'guid,name', op: types_1.eOperation.fields }]);
        evaluateQueryFilters(query, resourceServiceInstances);
        return resolveServiceInstances(yield execTotal({ query: `/v3/service_instances?${composeQuery(query)}`, token }, (info) => getServiceInstanceItem(info)));
    });
}
exports.cfGetServiceInstancesList = cfGetServiceInstancesList;
function cfGetApps(query, token) {
    return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceApps);
        return execTotal({ query: `/v3/apps?${composeQuery(yield (0, utils_1.padQuerySpace)(query))}`, token });
    });
}
exports.cfGetApps = cfGetApps;
function cfApi(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const query = ['api'];
        if (params === null || params === void 0 ? void 0 : params.url) {
            query.push(params.url);
        }
        if (params === null || params === void 0 ? void 0 : params.skip_ssl_validation) {
            query.push('--skip-ssl-validation');
        }
        if (params === null || params === void 0 ? void 0 : params.unset) {
            query.push('--unset');
        }
        return (0, utils_1.parseRawDictData)(yield execQuery({ query: [...query] }));
    });
}
exports.cfApi = cfApi;
//# sourceMappingURL=cf-local.js.map

/***/ }),

/***/ 42012:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTargetSet = exports.getInstanceMetadata = exports.createServiceInstance = exports.getInstanceCredentials = exports.getServicesInstancesFilteredByType = void 0;
const cli_1 = __webpack_require__(55458);
const _ = __webpack_require__(40180);
const types_1 = __webpack_require__(223);
const cf_local_1 = __webpack_require__(69262);
function getServicesInstancesFilteredByType(serviceTypes) {
    return __awaiter(this, void 0, void 0, function* () {
        const guids = _.map(yield (0, cf_local_1.cfGetServicePlansList)({ filters: [{ key: types_1.eFilters.service_offering_names, value: _.join(_.map(serviceTypes, encodeURIComponent)) }] }), 'guid');
        return _.size(guids) ? (0, cf_local_1.cfGetManagedServiceInstances)({ 'filters': [{ key: types_1.eFilters.service_plan_guids, value: _.join(guids) }] }) : [];
    });
}
exports.getServicesInstancesFilteredByType = getServicesInstancesFilteredByType;
function getInstanceCredentials(instanceName) {
    return (0, cf_local_1.cfGetInstanceKeyParameters)(instanceName);
}
exports.getInstanceCredentials = getInstanceCredentials;
function createServiceInstance(serviceType, servicePlan, serviceInstanceName, config) {
    let args = ["create-service", serviceType, servicePlan, serviceInstanceName];
    if (config) {
        args = args.concat(["-c", config]);
    }
    return cli_1.Cli.execute(args);
}
exports.createServiceInstance = createServiceInstance;
function getInstanceMetadata(instanceName) {
    return (0, cf_local_1.cfGetInstanceMetadata)(instanceName);
}
exports.getInstanceMetadata = getInstanceMetadata;
function isTargetSet() {
    return __awaiter(this, void 0, void 0, function* () {
        const target = yield (0, cf_local_1.cfGetTarget)();
        return !_.isEmpty(target.org) && !_.isEmpty(target.space);
    });
}
exports.isTargetSet = isTargetSet;
//# sourceMappingURL=cfServicesUtil.js.map

/***/ }),

/***/ 55458:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Cli = void 0;
const child_process_1 = __webpack_require__(32081);
const comment_json_1 = __webpack_require__(36862);
const _ = __webpack_require__(40180);
const types_1 = __webpack_require__(223);
class Cli {
    static execute(args, options, token) {
        token = token || { isCancellationRequested: false, onCancellationRequested: () => { return; } };
        Cli.updateSpawnOptions(options);
        return new Promise(resolve => {
            let stderr = "";
            let stdout = "";
            if (token.isCancellationRequested) {
                Cli.cliResultOnExit(stdout, resolve, stderr, types_1.CF_CMD_EXIT_CODE.CANCEL_REQ);
                return;
            }
            const childProcess = (0, child_process_1.spawn)(Cli.CF_CMD, args, options);
            childProcess.stdin.end();
            childProcess.stdout.on('data', (data) => {
                stdout = stdout.concat(data);
            });
            childProcess.stderr.on('data', (data) => {
                stderr = stderr.concat(data);
            });
            childProcess.on('exit', (code) => {
                Cli.cliResultOnExit(stdout, resolve, stderr, code);
            });
            childProcess.on('error', (err) => {
                const message = ((_.get(err, 'code') === "ENOENT") ? `${Cli.CF_CMD}: command not found` : _.get(err, 'message'));
                resolve({ "stdout": stdout, "stderr": stderr, error: message, exitCode: types_1.CF_CMD_EXIT_CODE.ERROR });
            });
            token.onCancellationRequested(() => {
                childProcess.kill();
                Cli.cliResultOnExit("", resolve, "", types_1.CF_CMD_EXIT_CODE.CANCELED);
            });
        });
    }
    static cliResultOnExit(stdout, resolve, stderr, code) {
        if (stdout) {
            if (stdout.indexOf("error_code") > 0) {
                try {
                    const cfErr = (0, comment_json_1.parse)(stdout);
                    const message = ((_.get(cfErr, 'code') === 10002) ? Cli.CF_LOGIN_ERROR : _.get(cfErr, 'description', 'Internal error occured'));
                    resolve({ "stdout": stdout, "stderr": stderr, exitCode: types_1.CF_CMD_EXIT_CODE.ERROR, error: message });
                    return;
                }
                catch (e) {
                }
            }
            else if (stdout.startsWith("FAILED") && stdout.indexOf("Error creating request") > 0) {
                resolve({ "stdout": stdout, "stderr": stderr, error: Cli.CF_LOGIN_ERROR, exitCode: types_1.CF_CMD_EXIT_CODE.ERROR });
                return;
            }
            else if (/failed.*\bError\b:/g.test(stdout)) {
                try {
                    (0, comment_json_1.parse)(stdout);
                }
                catch (e) {
                    resolve({ "stdout": stdout, "stderr": stderr, error: stdout, exitCode: types_1.CF_CMD_EXIT_CODE.ERROR });
                    return;
                }
            }
            else if (stdout.startsWith('FAILED') && stdout.indexOf("No API endpoint set") > 0) {
                resolve({ "stdout": stdout, "stderr": stderr, error: stdout, exitCode: types_1.CF_CMD_EXIT_CODE.ERROR });
                return;
            }
        }
        resolve({ "stdout": stdout, "stderr": stderr, exitCode: code });
    }
    static updateSpawnOptions(options) {
        if (options) {
            options.env = Object.assign(Object.assign(Object.assign({}, process.env), { NODE_VERSION: process.versions.node }), options.env);
            _.defaults(options, { cwd: _.get(options, "cmd", __dirname) });
        }
    }
}
exports.Cli = Cli;
Cli.CF_LOGIN_ERROR = "Not logged in. Use 'cf login' to log in.";
Cli.CF_CMD = "cf";
//# sourceMappingURL=cli.js.map

/***/ }),

/***/ 47213:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.apiGetInstanceMetadata = exports.apiCreateServiceInstance = exports.apiGetInstanceCredentials = exports.apiGetServicesInstancesFilteredByType = void 0;
__exportStar(__webpack_require__(223), exports);
__exportStar(__webpack_require__(55458), exports);
__exportStar(__webpack_require__(69262), exports);
__exportStar(__webpack_require__(39866), exports);
__exportStar(__webpack_require__(86022), exports);
const serviceUtils = __webpack_require__(42012);
function apiGetServicesInstancesFilteredByType(serviceTypes) {
    return __awaiter(this, void 0, void 0, function* () {
        return serviceUtils.getServicesInstancesFilteredByType(serviceTypes);
    });
}
exports.apiGetServicesInstancesFilteredByType = apiGetServicesInstancesFilteredByType;
function apiGetInstanceCredentials(instanceName) {
    return __awaiter(this, void 0, void 0, function* () {
        return serviceUtils.getInstanceCredentials(instanceName);
    });
}
exports.apiGetInstanceCredentials = apiGetInstanceCredentials;
function apiCreateServiceInstance(serviceType, servicePlan, instanceName, config) {
    return __awaiter(this, void 0, void 0, function* () {
        return serviceUtils.createServiceInstance(serviceType, servicePlan, instanceName, config);
    });
}
exports.apiCreateServiceInstance = apiCreateServiceInstance;
function apiGetInstanceMetadata(instanceName) {
    return __awaiter(this, void 0, void 0, function* () {
        return serviceUtils.getInstanceMetadata(instanceName);
    });
}
exports.apiGetInstanceMetadata = apiGetInstanceMetadata;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 39866:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.messages = void 0;
exports.messages = {
    space_not_set: `The selected action failed because there is no Cloud Foundry space assigned.`,
    service_creation_started: `Service instance creation started, waiting for 'Ready' state...`,
    create_service_canceled_by_requester: `The service instance creation was cancelled by the requester. The service may have been partially created, consider deleting it using the 'cf delete-service' command.`,
    cf_setting_not_set: `Could not find the Cloud Foundry settings. Make sure you have assigned an org and space in Cloud Foundry.`,
    no_valid_filters: `Could not find any valid filters.`,
    failed_creating_entity: (description, name) => `Could not create the entity since ${description}, consider deleting it using the 'cf delete-service ${name} command'.`,
    exceed_number_of_attempts: (name) => `Could not verify the service instance creation. Check its status using the 'cf service ${name}' command.`,
    service_not_found: (instanceName) => `Could not find the '${instanceName}' service instance.`,
    service_creation_failed: (error) => `Service instance creation failed: ${error}`,
    not_allowed_filter: (param, query) => `The '${param}' parameter is not allowed in the '${query}' query.`
};
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ 223:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.eServiceTypes = exports.eOrderDirection = exports.eOperation = exports.eFilters = exports.CF_CMD_EXIT_CODE = exports.DEFAULT_TARGET = exports.CF_PAGE_SIZE = exports.NEW_LINE = exports.OK = void 0;
exports.OK = "OK";
exports.NEW_LINE = "\n";
exports.CF_PAGE_SIZE = 99 * 3;
exports.DEFAULT_TARGET = "Default (no targets)";
var CF_CMD_EXIT_CODE;
(function (CF_CMD_EXIT_CODE) {
    CF_CMD_EXIT_CODE[CF_CMD_EXIT_CODE["OK"] = 0] = "OK";
    CF_CMD_EXIT_CODE[CF_CMD_EXIT_CODE["ERROR"] = -1] = "ERROR";
    CF_CMD_EXIT_CODE[CF_CMD_EXIT_CODE["CANCEL_REQ"] = -2] = "CANCEL_REQ";
    CF_CMD_EXIT_CODE[CF_CMD_EXIT_CODE["CANCELED"] = -3] = "CANCELED";
})(CF_CMD_EXIT_CODE = exports.CF_CMD_EXIT_CODE || (exports.CF_CMD_EXIT_CODE = {}));
var eFilters;
(function (eFilters) {
    eFilters["type"] = "type";
    eFilters["names"] = "names";
    eFilters["guids"] = "guids";
    eFilters["app_guids"] = "app_guids";
    eFilters["app_names"] = "app_names";
    eFilters["space_guids"] = "space_guids";
    eFilters["available"] = "available";
    eFilters["broker_catalog_ids"] = "broker_catalog_ids";
    eFilters["service_broker_guids"] = "service_broker_guids";
    eFilters["service_broker_names"] = "service_broker_names";
    eFilters["service_plan_guids"] = "service_plan_guids";
    eFilters["organization_guids"] = "organization_guids";
    eFilters["service_plan_names"] = "service_plan_names";
    eFilters["service_plan"] = "service_plan";
    eFilters["service_instance_guids"] = "service_instance_guids";
    eFilters["service_instance_names"] = "service_instance_names";
    eFilters["service_offering_guids"] = "service_offering_guids";
    eFilters["service_offering_names"] = "service_offering_names";
    eFilters["label_selector"] = "label_selector";
    eFilters["page"] = "page";
    eFilters["per_page"] = "per_page";
    eFilters["oder_by"] = "order_by";
    eFilters["created_ats"] = "created_ats";
    eFilters["updated_ats"] = "updated_ats";
    eFilters["status"] = "status";
    eFilters["include"] = "include";
})(eFilters = exports.eFilters || (exports.eFilters = {}));
var eOperation;
(function (eOperation) {
    eOperation["gte"] = "gte";
    eOperation["lte"] = "lte";
    eOperation["lt"] = "lt";
    eOperation["gt"] = "gt";
    eOperation["not"] = "not";
    eOperation["fields"] = "fields";
})(eOperation = exports.eOperation || (exports.eOperation = {}));
var eOrderDirection;
(function (eOrderDirection) {
    eOrderDirection[eOrderDirection["asc"] = 0] = "asc";
    eOrderDirection[eOrderDirection["desc"] = 1] = "desc";
})(eOrderDirection = exports.eOrderDirection || (exports.eOrderDirection = {}));
var eServiceTypes;
(function (eServiceTypes) {
    eServiceTypes["managed"] = "managed";
    eServiceTypes["user_provided"] = "user-provided";
})(eServiceTypes = exports.eServiceTypes || (exports.eServiceTypes = {}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 86022:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseRawDictData = exports.padQuerySpace = exports.getSpaceGuidThrowIfUndefined = exports.cfGetConfigFileField = exports.cfGetConfigFileJson = exports.isUpsType = exports.cfGetConfigFilePath = exports.getTags = exports.getOrgGUID = exports.getSpaceFieldGUID = exports.getDescription = exports.getLabel = exports.getName = exports.getGuid = exports.padQuery = exports.ensureQuery = exports.dataContentAsObject = void 0;
const _ = __webpack_require__(40180);
const os = __webpack_require__(22037);
const fs = __webpack_require__(57147);
const path = __webpack_require__(71017);
const comment_json_1 = __webpack_require__(36862);
const messages_1 = __webpack_require__(39866);
const types_1 = __webpack_require__(223);
function dataContentAsObject(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return _.reduce(_.split(yield fs.promises.readFile(filePath, { encoding: "utf8" }), os.EOL), (data, line) => {
                const parts = _.split(line, '=');
                if (_.size(parts) > 1) {
                    data[_.trim(parts[0])] = _.trim(parts[1]);
                }
                return data;
            }, {});
        }
        catch (error) {
            return {};
        }
    });
}
exports.dataContentAsObject = dataContentAsObject;
function ensureQuery(query) {
    query = query || {};
    _.defaults(query, { filters: [] });
    _.defaults(query, { per_page: types_1.CF_PAGE_SIZE });
    return query;
}
exports.ensureQuery = ensureQuery;
function padQuery(query, otherFilters) {
    query = ensureQuery(query);
    _.each(otherFilters, other => {
        const filter = _.find(query.filters, ['key', other.key]);
        if (!_.size(filter === null || filter === void 0 ? void 0 : filter.value)) {
            query.filters = _.concat(query.filters, [other]);
        }
    });
    return query;
}
exports.padQuery = padQuery;
function getGuid(resource) {
    return _.get(resource, "guid", '');
}
exports.getGuid = getGuid;
function getName(resource) {
    return _.get(resource, "name", '');
}
exports.getName = getName;
function getLabel(resource) {
    return _.get(resource, "label", '');
}
exports.getLabel = getLabel;
function getDescription(resource) {
    return _.get(resource, "description", '');
}
exports.getDescription = getDescription;
function getSpaceFieldGUID(spaceField) {
    return _.get(spaceField, "GUID", '');
}
exports.getSpaceFieldGUID = getSpaceFieldGUID;
function getOrgGUID(resource) {
    return _.get(resource, ["relationships", "organization", "data", "guid"], '');
}
exports.getOrgGUID = getOrgGUID;
function getTags(resource) {
    return _.get(resource, "tags", []);
}
exports.getTags = getTags;
function cfGetConfigFilePath(target) {
    const relatives = target ? ['targets', `${target}.config.json`] : [`config.json`];
    return path.join(_.get(process, "env.CF_HOME", os.homedir()), ".cf", ...relatives);
}
exports.cfGetConfigFilePath = cfGetConfigFilePath;
function isUpsType(resource) {
    return _.get(resource, "type", types_1.eServiceTypes.managed) === types_1.eServiceTypes.user_provided;
}
exports.isUpsType = isUpsType;
function cfGetConfigFileJson(target) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return (0, comment_json_1.parse)(yield fs.promises.readFile(cfGetConfigFilePath(target), { encoding: "utf8" }));
        }
        catch (error) {
        }
    });
}
exports.cfGetConfigFileJson = cfGetConfigFileJson;
function cfGetConfigFileField(field, target) {
    return __awaiter(this, void 0, void 0, function* () {
        return _.get(yield cfGetConfigFileJson(target), `${field}`);
    });
}
exports.cfGetConfigFileField = cfGetConfigFileField;
function getSpaceGuidThrowIfUndefined() {
    return __awaiter(this, void 0, void 0, function* () {
        const space = getSpaceFieldGUID(yield cfGetConfigFileField("SpaceFields"));
        if (!space) {
            throw new Error(messages_1.messages.cf_setting_not_set);
        }
        return space;
    });
}
exports.getSpaceGuidThrowIfUndefined = getSpaceGuidThrowIfUndefined;
function padQuerySpace(query, otherFilters) {
    return __awaiter(this, void 0, void 0, function* () {
        query = padQuery(query, otherFilters);
        const filter = _.find(query.filters, ['key', types_1.eFilters.space_guids]);
        if (!_.size(filter === null || filter === void 0 ? void 0 : filter.value)) {
            query.filters = _.concat(query.filters, [{ key: types_1.eFilters.space_guids, value: yield getSpaceGuidThrowIfUndefined() }]);
        }
        return query;
    });
}
exports.padQuerySpace = padQuerySpace;
function parseRawDictData(data) {
    const result = {};
    _.each(_.compact(_.split(data, '\n')), item => {
        item = _.replace(_.trim(item), /^['"]|['"]$/g, '');
        const sep = _.indexOf(item, ':');
        if (sep > -1) {
            const key = _.toLower(_.trim(_.join(_.slice(item, 0, sep), '')));
            const value = _.trim(_.join(_.slice(item, sep + 1), ''));
            result[`${key}`] = value;
        }
    });
    return result;
}
exports.parseRawDictData = parseRawDictData;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 78998:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*! For license information please see index-min.js.LICENSE.txt */
(()=>{var e={601:e=>{"use strict";e.exports=JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON Schema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}')},8938:e=>{"use strict";e.exports=JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}')},7740:e=>{"use strict";e.exports={i8:"3.1.6"}},921:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createFileSystemAdapter=t.FILE_SYSTEM_ADAPTER=void 0;const a=n(5747);t.FILE_SYSTEM_ADAPTER={lstat:a.lstat,stat:a.stat,lstatSync:a.lstatSync,statSync:a.statSync,readdir:a.readdir,readdirSync:a.readdirSync},t.createFileSystemAdapter=function(e){return void 0===e?t.FILE_SYSTEM_ADAPTER:Object.assign(Object.assign({},t.FILE_SYSTEM_ADAPTER),e)}},5354:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.IS_SUPPORT_READDIR_WITH_FILE_TYPES=void 0;const n=process.versions.node.split("."),a=parseInt(n[0],10),r=parseInt(n[1],10),i=a>10,o=10===a&&r>=10;t.IS_SUPPORT_READDIR_WITH_FILE_TYPES=i||o},3453:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Settings=t.scandirSync=t.scandir=void 0;const a=n(7346),r=n(938),i=n(4643);function o(e={}){return e instanceof i.default?e:new i.default(e)}t.Settings=i.default,t.scandir=function(e,t,n){if("function"==typeof t)return a.read(e,o(),t);a.read(e,o(t),n)},t.scandirSync=function(e,t){const n=o(t);return r.read(e,n)}},7346:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.readdir=t.readdirWithFileTypes=t.read=void 0;const a=n(1992),r=n(1670),i=n(5354),o=n(869),s=n(4514);function c(e,t,n){t.fs.readdir(e,{withFileTypes:!0},((a,i)=>{if(null!==a)return u(n,a);const c=i.map((n=>({dirent:n,name:n.name,path:s.joinPathSegments(e,n.name,t.pathSegmentSeparator)})));if(!t.followSymbolicLinks)return p(n,c);const l=c.map((e=>function(e,t){return n=>{if(!e.dirent.isSymbolicLink())return n(null,e);t.fs.stat(e.path,((a,r)=>null!==a?t.throwErrorOnBrokenSymbolicLink?n(a):n(null,e):(e.dirent=o.fs.createDirentFromStats(e.name,r),n(null,e))))}}(e,t)));r(l,((e,t)=>{if(null!==e)return u(n,e);p(n,t)}))}))}function l(e,t,n){t.fs.readdir(e,((i,c)=>{if(null!==i)return u(n,i);const l=c.map((n=>s.joinPathSegments(e,n,t.pathSegmentSeparator))),f=l.map((e=>n=>a.stat(e,t.fsStatSettings,n)));r(f,((e,a)=>{if(null!==e)return u(n,e);const r=[];c.forEach(((e,n)=>{const i=a[n],s={name:e,path:l[n],dirent:o.fs.createDirentFromStats(e,i)};t.stats&&(s.stats=i),r.push(s)})),p(n,r)}))}))}function u(e,t){e(t)}function p(e,t){e(null,t)}t.read=function(e,t,n){return!t.stats&&i.IS_SUPPORT_READDIR_WITH_FILE_TYPES?c(e,t,n):l(e,t,n)},t.readdirWithFileTypes=c,t.readdir=l},4514:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.joinPathSegments=void 0,t.joinPathSegments=function(e,t,n){return e.endsWith(n)?e+t:e+n+t}},938:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.readdir=t.readdirWithFileTypes=t.read=void 0;const a=n(1992),r=n(5354),i=n(869),o=n(4514);function s(e,t){return t.fs.readdirSync(e,{withFileTypes:!0}).map((n=>{const a={dirent:n,name:n.name,path:o.joinPathSegments(e,n.name,t.pathSegmentSeparator)};if(a.dirent.isSymbolicLink()&&t.followSymbolicLinks)try{const e=t.fs.statSync(a.path);a.dirent=i.fs.createDirentFromStats(a.name,e)}catch(e){if(t.throwErrorOnBrokenSymbolicLink)throw e}return a}))}function c(e,t){return t.fs.readdirSync(e).map((n=>{const r=o.joinPathSegments(e,n,t.pathSegmentSeparator),s=a.statSync(r,t.fsStatSettings),c={name:n,path:r,dirent:i.fs.createDirentFromStats(n,s)};return t.stats&&(c.stats=s),c}))}t.read=function(e,t){return!t.stats&&r.IS_SUPPORT_READDIR_WITH_FILE_TYPES?s(e,t):c(e,t)},t.readdirWithFileTypes=s,t.readdir=c},4643:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5622),r=n(1992),i=n(921);t.default=class Settings{constructor(e={}){this._options=e,this.followSymbolicLinks=this._getValue(this._options.followSymbolicLinks,!1),this.fs=i.createFileSystemAdapter(this._options.fs),this.pathSegmentSeparator=this._getValue(this._options.pathSegmentSeparator,a.sep),this.stats=this._getValue(this._options.stats,!1),this.throwErrorOnBrokenSymbolicLink=this._getValue(this._options.throwErrorOnBrokenSymbolicLink,!0),this.fsStatSettings=new r.Settings({followSymbolicLink:this.followSymbolicLinks,fs:this.fs,throwErrorOnBrokenSymbolicLink:this.throwErrorOnBrokenSymbolicLink})}_getValue(e,t){return null!=e?e:t}}},2526:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createDirentFromStats=void 0;class DirentFromStats{constructor(e,t){this.name=e,this.isBlockDevice=t.isBlockDevice.bind(t),this.isCharacterDevice=t.isCharacterDevice.bind(t),this.isDirectory=t.isDirectory.bind(t),this.isFIFO=t.isFIFO.bind(t),this.isFile=t.isFile.bind(t),this.isSocket=t.isSocket.bind(t),this.isSymbolicLink=t.isSymbolicLink.bind(t)}}t.createDirentFromStats=function(e,t){return new DirentFromStats(e,t)}},869:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.fs=void 0;const a=n(2526);t.fs=a},6963:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createFileSystemAdapter=t.FILE_SYSTEM_ADAPTER=void 0;const a=n(5747);t.FILE_SYSTEM_ADAPTER={lstat:a.lstat,stat:a.stat,lstatSync:a.lstatSync,statSync:a.statSync},t.createFileSystemAdapter=function(e){return void 0===e?t.FILE_SYSTEM_ADAPTER:Object.assign(Object.assign({},t.FILE_SYSTEM_ADAPTER),e)}},1992:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.statSync=t.stat=t.Settings=void 0;const a=n(4820),r=n(6728),i=n(3326);function o(e={}){return e instanceof i.default?e:new i.default(e)}t.Settings=i.default,t.stat=function(e,t,n){if("function"==typeof t)return a.read(e,o(),t);a.read(e,o(t),n)},t.statSync=function(e,t){const n=o(t);return r.read(e,n)}},4820:(e,t)=>{"use strict";function n(e,t){e(t)}function a(e,t){e(null,t)}Object.defineProperty(t,"__esModule",{value:!0}),t.read=void 0,t.read=function(e,t,r){t.fs.lstat(e,((i,o)=>null!==i?n(r,i):o.isSymbolicLink()&&t.followSymbolicLink?void t.fs.stat(e,((e,i)=>{if(null!==e)return t.throwErrorOnBrokenSymbolicLink?n(r,e):a(r,o);t.markSymbolicLink&&(i.isSymbolicLink=()=>!0),a(r,i)})):a(r,o)))}},6728:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.read=void 0,t.read=function(e,t){const n=t.fs.lstatSync(e);if(!n.isSymbolicLink()||!t.followSymbolicLink)return n;try{const n=t.fs.statSync(e);return t.markSymbolicLink&&(n.isSymbolicLink=()=>!0),n}catch(e){if(!t.throwErrorOnBrokenSymbolicLink)return n;throw e}}},3326:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(6963);t.default=class Settings{constructor(e={}){this._options=e,this.followSymbolicLink=this._getValue(this._options.followSymbolicLink,!0),this.fs=a.createFileSystemAdapter(this._options.fs),this.markSymbolicLink=this._getValue(this._options.markSymbolicLink,!1),this.throwErrorOnBrokenSymbolicLink=this._getValue(this._options.throwErrorOnBrokenSymbolicLink,!0)}_getValue(e,t){return null!=e?e:t}}},4833:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Settings=t.walkStream=t.walkSync=t.walk=void 0;const a=n(9428),r=n(927),i=n(4440),o=n(2134);function s(e={}){return e instanceof o.default?e:new o.default(e)}t.Settings=o.default,t.walk=function(e,t,n){if("function"==typeof t)return new a.default(e,s()).read(t);new a.default(e,s(t)).read(n)},t.walkSync=function(e,t){const n=s(t);return new i.default(e,n).read()},t.walkStream=function(e,t){const n=s(t);return new r.default(e,n).read()}},9428:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5749);t.default=class AsyncProvider{constructor(e,t){this._root=e,this._settings=t,this._reader=new a.default(this._root,this._settings),this._storage=new Set}read(e){this._reader.onError((t=>{!function(e,t){e(t)}(e,t)})),this._reader.onEntry((e=>{this._storage.add(e)})),this._reader.onEnd((()=>{!function(e,t){e(null,t)}(e,[...this._storage])})),this._reader.read()}}},927:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(2413),r=n(5749);t.default=class StreamProvider{constructor(e,t){this._root=e,this._settings=t,this._reader=new r.default(this._root,this._settings),this._stream=new a.Readable({objectMode:!0,read:()=>{},destroy:()=>{this._reader.isDestroyed||this._reader.destroy()}})}read(){return this._reader.onError((e=>{this._stream.emit("error",e)})),this._reader.onEntry((e=>{this._stream.push(e)})),this._reader.onEnd((()=>{this._stream.push(null)})),this._reader.read(),this._stream}}},4440:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(9359);t.default=class SyncProvider{constructor(e,t){this._root=e,this._settings=t,this._reader=new a.default(this._root,this._settings)}read(){return this._reader.read()}}},5749:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(8614),r=n(3453),i=n(1582),o=n(8488),s=n(7236);class AsyncReader extends s.default{constructor(e,t){super(e,t),this._settings=t,this._scandir=r.scandir,this._emitter=new a.EventEmitter,this._queue=i(this._worker.bind(this),this._settings.concurrency),this._isFatalError=!1,this._isDestroyed=!1,this._queue.drain=()=>{this._isFatalError||this._emitter.emit("end")}}read(){return this._isFatalError=!1,this._isDestroyed=!1,setImmediate((()=>{this._pushToQueue(this._root,this._settings.basePath)})),this._emitter}get isDestroyed(){return this._isDestroyed}destroy(){if(this._isDestroyed)throw new Error("The reader is already destroyed");this._isDestroyed=!0,this._queue.killAndDrain()}onEntry(e){this._emitter.on("entry",e)}onError(e){this._emitter.once("error",e)}onEnd(e){this._emitter.once("end",e)}_pushToQueue(e,t){const n={directory:e,base:t};this._queue.push(n,(e=>{null!==e&&this._handleError(e)}))}_worker(e,t){this._scandir(e.directory,this._settings.fsScandirSettings,((n,a)=>{if(null!==n)return t(n,void 0);for(const t of a)this._handleEntry(t,e.base);t(null,void 0)}))}_handleError(e){!this._isDestroyed&&o.isFatalError(this._settings,e)&&(this._isFatalError=!0,this._isDestroyed=!0,this._emitter.emit("error",e))}_handleEntry(e,t){if(this._isDestroyed||this._isFatalError)return;const n=e.path;void 0!==t&&(e.path=o.joinPathSegments(t,e.name,this._settings.pathSegmentSeparator)),o.isAppliedFilter(this._settings.entryFilter,e)&&this._emitEntry(e),e.dirent.isDirectory()&&o.isAppliedFilter(this._settings.deepFilter,e)&&this._pushToQueue(n,e.path)}_emitEntry(e){this._emitter.emit("entry",e)}}t.default=AsyncReader},8488:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.joinPathSegments=t.replacePathSegmentSeparator=t.isAppliedFilter=t.isFatalError=void 0,t.isFatalError=function(e,t){return null===e.errorFilter||!e.errorFilter(t)},t.isAppliedFilter=function(e,t){return null===e||e(t)},t.replacePathSegmentSeparator=function(e,t){return e.split(/[/\\]/).join(t)},t.joinPathSegments=function(e,t,n){return""===e?t:e.endsWith(n)?e+t:e+n+t}},7236:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(8488);t.default=class Reader{constructor(e,t){this._root=e,this._settings=t,this._root=a.replacePathSegmentSeparator(e,t.pathSegmentSeparator)}}},9359:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(3453),r=n(8488),i=n(7236);class SyncReader extends i.default{constructor(){super(...arguments),this._scandir=a.scandirSync,this._storage=new Set,this._queue=new Set}read(){return this._pushToQueue(this._root,this._settings.basePath),this._handleQueue(),[...this._storage]}_pushToQueue(e,t){this._queue.add({directory:e,base:t})}_handleQueue(){for(const e of this._queue.values())this._handleDirectory(e.directory,e.base)}_handleDirectory(e,t){try{const n=this._scandir(e,this._settings.fsScandirSettings);for(const e of n)this._handleEntry(e,t)}catch(e){this._handleError(e)}}_handleError(e){if(r.isFatalError(this._settings,e))throw e}_handleEntry(e,t){const n=e.path;void 0!==t&&(e.path=r.joinPathSegments(t,e.name,this._settings.pathSegmentSeparator)),r.isAppliedFilter(this._settings.entryFilter,e)&&this._pushToStorage(e),e.dirent.isDirectory()&&r.isAppliedFilter(this._settings.deepFilter,e)&&this._pushToQueue(n,e.path)}_pushToStorage(e){this._storage.add(e)}}t.default=SyncReader},2134:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5622),r=n(3453);t.default=class Settings{constructor(e={}){this._options=e,this.basePath=this._getValue(this._options.basePath,void 0),this.concurrency=this._getValue(this._options.concurrency,1/0),this.deepFilter=this._getValue(this._options.deepFilter,null),this.entryFilter=this._getValue(this._options.entryFilter,null),this.errorFilter=this._getValue(this._options.errorFilter,null),this.pathSegmentSeparator=this._getValue(this._options.pathSegmentSeparator,a.sep),this.fsScandirSettings=new r.Settings({followSymbolicLinks:this._options.followSymbolicLinks,fs:this._options.fs,pathSegmentSeparator:this._options.pathSegmentSeparator,stats:this._options.stats,throwErrorOnBrokenSymbolicLink:this._options.throwErrorOnBrokenSymbolicLink})}_getValue(e,t){return null!=e?e:t}}},4350:function(e,t,n){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,n,a){void 0===a&&(a=n),Object.defineProperty(e,a,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,a){void 0===a&&(a=n),e[a]=t[n]}),r=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||t.hasOwnProperty(n)||a(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),r(n(9335),t)},9335:function(e,t){"use strict";var n=this&&this.__assign||function(){return(n=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.revertTermToGenericType=t.convertTypes=t.defaultReferences=void 0;var a,r=function(e,t,n,a,r){this.path=e.Path,this.type="Path",this.$target=t,this.term=r,this.annotationType=a,this.annotationsTerm=n};function i(e,t){if(e.reverseReferenceMap||(e.reverseReferenceMap=e.reduce((function(e,t){return e[t.namespace]=t,e}),{})),!t)return t;var n=t.lastIndexOf("."),a=t.substr(0,n),r=t.substr(n+1),o=e.reverseReferenceMap[a];if(o)return o.alias+"."+r;if(-1!==t.indexOf("@")){var s=t.split("@");return s[0]+"@"+i(e,s.slice(1).join("@"))}return t}function o(e,t){if(e.referenceMap||(e.referenceMap=e.reduce((function(e,t){return e[t.alias]=t,e}),{})),!t)return t;var n=t.split("."),a=n[0],r=n.slice(1),i=e.referenceMap[a];if(i)return i.namespace+"."+r.join(".");if(-1!==t.indexOf("@")){var s=t.split("@");return s[0]+"@"+o(e,s.slice(1).join("@"))}return t}function s(e,n){return n.startsWith("@")?e+o(t.defaultReferences,n):e+"/"+n}function c(e,t){b[e]?b[e].push(t):b[e]=[t]}function l(e,t,n,a,r,i,o){if(void 0===a&&(a=!1),void 0===r&&(r=!1),n){var u=[];t&&"Property"===t._type&&(t=e[t.fullyQualifiedName.split("/")[0]]);var p=(n=s(t.fullyQualifiedName,n)).split("/"),f=[];p.forEach((function(e){if(-1!==e.indexOf("@")){var t=e.split("@"),n=t[0],a=t[1];f.push(n),f.push("@"+a)}else f.push(e)}));var d=n,h=t,g=f.reduce((function(n,a){if("$Type"===a&&"EntityType"===n._type)return n;if(0===a.length)return n&&"EntitySet"===n._type&&n.entityType&&(r&&u.push(n),n=n.entityType),n&&"NavigationProperty"===n._type&&n.targetType&&(r&&u.push(n),n=n.targetType),n;if(r&&null!=n&&u.push(n),n){if("EntitySet"===n._type&&"$Type"===a)return n=n.targetType;if("EntitySet"===n._type&&n.entityType)d=s(n.entityTypeName,a);else if("NavigationProperty"===n._type&&n.targetTypeName)d=s(n.targetTypeName,a);else if("NavigationProperty"===n._type&&n.targetType)d=s(n.targetType.fullyQualifiedName,a);else if("Property"===n._type)d=n.targetType?s(n.targetType.fullyQualifiedName,a):s(n.fullyQualifiedName,a);else if("Action"===n._type&&n.isBound)d=s(n.fullyQualifiedName,a),e[d]||(d=s(n.sourceType,a));else if("ActionParameter"===n._type&&n.isEntitySet)d=s(n.type,a);else if("ActionParameter"!==n._type||n.isEntitySet){if(d=s(n.fullyQualifiedName,a),"name"!==a&&void 0!==n[a])return n[a];if("$AnnotationPath"===a&&n.$target){var i=e[n.fullyQualifiedName.split("@")[0]];return(o=l(e,i,n.value,!1,!0)).visitedObjects.forEach((function(e){-1===u.indexOf(e)&&u.push(e)})),o.target}var o;if("$Path"===a&&n.$target)return(h=u.concat().reverse().find((function(e){return"EntityType"===e._type||"EntitySet"===e._type||"NavigationProperty"===e._type})))?((o=l(e,h,n.path,!1,!0)).visitedObjects.forEach((function(e){-1===u.indexOf(e)&&u.push(e)})),o.target):n.$target;if(a.startsWith("$Path")&&n.$target){var c=n.$target;d=s(c.fullyQualifiedName,a.substr(5))}else if(n.hasOwnProperty("$Type")&&!e[d]){var p=e[n.fullyQualifiedName.split("@")[0]];p&&(d=s(p.fullyQualifiedName,a))}}else if(d=s(t.fullyQualifiedName.substr(0,t.fullyQualifiedName.lastIndexOf("/")),a),!e[d]){var f=t.fullyQualifiedName.lastIndexOf("/");-1===f&&(f=t.fullyQualifiedName.length),d=s(e[t.fullyQualifiedName.substr(0,f)].sourceType,a)}}else d=a;return e[d]}),null);if(!g)if(o&&i)c(n,{message:"Unable to resolve the path expression: \n"+n+"\n\nHint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n<Annotation Term = "+o+">\n<Record Type = "+i+">\n<AnnotationPath = "+n+">"});else c(n,{message:"Unable to resolve the path expression: "+n+"\n\nHint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n<Annotation Term = "+p[0]+">\n<PropertyValue  Path= "+p[1]+">"});return a?d:r?{visitedObjects:u,target:g}:g}}function u(e){return-1!==e.indexOf("@")}function p(e,t,n,a,s,c,p,f,g,m){if(void 0!==e)switch(e.type){case"String":return e.String;case"Int":return e.Int;case"Bool":return e.Bool;case"Decimal":return e.Decimal;case"Date":return e.Date;case"EnumMember":return i(n.references,e.EnumMember);case"PropertyPath":return{type:"PropertyPath",value:e.PropertyPath,fullyQualifiedName:t,$target:l(s,a,e.PropertyPath,!1,!1,g,m)};case"NavigationPropertyPath":return{type:"NavigationPropertyPath",value:e.NavigationPropertyPath,fullyQualifiedName:t,$target:l(s,a,e.NavigationPropertyPath,!1,!1,g,m)};case"AnnotationPath":var y=l(s,a,o(n.references,e.AnnotationPath),!0,!1,g,m),v={type:"AnnotationPath",value:e.AnnotationPath,fullyQualifiedName:t,$target:y,annotationType:g,annotationsTerm:m,term:"",path:""};return c.push({inline:!1,toResolve:v}),v;case"Path":var b=l(s,a,e.Path,!0,!1,g,m),P=new r(e,b,m,g,"");return c.push({inline:u(e.Path),toResolve:P}),P;case"Record":return d(e.Record,t,n,a,s,c,p,f,g,m);case"Collection":return h(e.Collection,t,n,a,s,c,p,f,g,m);case"Apply":case"Null":case"Not":case"Eq":case"Ne":case"Gt":case"Ge":case"Lt":case"Le":case"If":case"And":case"Or":return e}}function f(e,t,n){var r=a[e];return c(n+"/"+e,{isError:!1,message:"The type of the record used within the term "+e+" was not defined and was inferred as "+r+'.\nHint: If possible, try to maintain the Type property for each Record.\n<Annotations Target="'+n+'">\n\t<Annotation Term="'+e+'">\n\t\t<Record>...</Record>\n\t</Annotation>\n</Annotations>'}),r}function d(e,t,n,a,r,i,s,c,l,u){var d={$Type:!e.type&&u?f(u,0,a.fullyQualifiedName):o(n.references,e.type),fullyQualifiedName:t},h={};if(e.annotations&&Array.isArray(e.annotations)){var g={target:t,annotations:e.annotations,__source:s};c.push(g)}return e.propertyValues&&e.propertyValues.forEach((function(e){if(h[e.name]=p(e.value,t+"/"+e.name,n,a,r,i,s,c,l,u),e.annotations&&Array.isArray(e.annotations)){var o={target:t+"/"+e.name,annotations:e.annotations,__source:s};c.push(o)}!h.hasOwnProperty("Action")||"com.sap.vocabularies.UI.v1.DataFieldForAction"!==d.$Type&&"com.sap.vocabularies.UI.v1.DataFieldWithAction"!==d.$Type||(h.ActionTarget=a.actions&&a.actions[h.Action]||r[h.Action],h.ActionTarget||v.push({message:"Unable to resolve the action "+h.Action+" defined for "+d.fullyQualifiedName}))})),Object.assign(d,h)}function h(e,t,n,a,i,o,s,c,p,f){switch(function(e){var t=e.type;if(void 0===t&&e.length>0){var n=e[0];n.hasOwnProperty("PropertyPath")?t="PropertyPath":n.hasOwnProperty("Path")?t="Path":n.hasOwnProperty("AnnotationPath")?t="AnnotationPath":n.hasOwnProperty("NavigationPropertyPath")?t="NavigationPropertyPath":"object"==typeof n&&(n.hasOwnProperty("type")||n.hasOwnProperty("propertyValues"))?t="Record":"string"==typeof n&&(t="String")}else void 0===t&&(t="EmptyCollection");return t}(e)){case"PropertyPath":return e.map((function(e,n){return{type:"PropertyPath",value:e.PropertyPath,fullyQualifiedName:t+"/"+n,$target:l(i,a,e.PropertyPath,!1,!1,p,f)}}));case"Path":return e.map((function(e){var t=l(i,a,e.Path,!0,!1,p,f),n=new r(e,t,f,p,"");return o.push({inline:u(e.Path),toResolve:n}),n}));case"AnnotationPath":return e.map((function(e,n){var r=l(i,a,e.AnnotationPath,!0,!1,p,f),s={type:"AnnotationPath",value:e.AnnotationPath,fullyQualifiedName:t+"/"+n,$target:r,annotationType:p,annotationsTerm:f,term:"",path:""};return o.push({inline:!1,toResolve:s}),s}));case"NavigationPropertyPath":return e.map((function(e,n){return{type:"NavigationPropertyPath",value:e.NavigationPropertyPath,fullyQualifiedName:t+"/"+n,$target:l(i,a,e.NavigationPropertyPath,!1,!1,p,f)}}));case"Record":return e.map((function(e,r){return d(e,t+"/"+r,n,a,i,o,s,c,p,f)}));case"Apply":case"Null":case"If":case"Eq":case"Ne":case"Lt":case"Gt":case"Le":case"Ge":case"Not":case"And":case"Or":return e.map((function(e){return e}));case"String":return e.map((function(e){return"string"==typeof e||void 0===e?e:e.String}));default:if(0===e.length)return[];throw new Error("Unsupported case")}}function g(e,t,n,a,r,i,s){if(e.record){var c=e.record.type?o(t.references,e.record.type):f(e.term,0,n.fullyQualifiedName),l={$Type:c,fullyQualifiedName:e.fullyQualifiedName,qualifier:e.qualifier},u={};return e.record.propertyValues.forEach((function(o){u[o.name]=p(o.value,e.fullyQualifiedName+"/"+o.name,t,n,a,r,i,s,c,e.term),!u.hasOwnProperty("Action")||e.record&&"com.sap.vocabularies.UI.v1.DataFieldForAction"!==l.$Type&&"com.sap.vocabularies.UI.v1.DataFieldWithAction"!==l.$Type||(u.ActionTarget=n.actions&&n.actions[u.Action]||a[u.Action],u.ActionTarget||v.push({message:"Unable to resolve the action "+u.Action+" defined for "+e.fullyQualifiedName}))})),Object.assign(l,u)}if(void 0===e.collection)return!e.value||p(e.value,e.fullyQualifiedName,t,n,a,r,i,s,"",e.term);if(e.collection){var d=h(e.collection,e.fullyQualifiedName,t,n,a,r,i,s,"",e.term);return d.fullyQualifiedName=e.fullyQualifiedName,d}throw new Error("Unsupported case")}function m(e,t,n){e.forEach((function(e){e.navigationProperties=e.navigationProperties.map((function(e){var a={_type:"NavigationProperty",name:e.name,fullyQualifiedName:e.fullyQualifiedName,partner:e.hasOwnProperty("partner")?e.partner:void 0,isCollection:!!e.hasOwnProperty("isCollection")&&e.isCollection,containsTarget:!!e.hasOwnProperty("containsTarget")&&e.containsTarget,referentialConstraint:e.referentialConstraint?e.referentialConstraint:[],annotations:{}};if(e.targetTypeName)a.targetType=n[e.targetTypeName];else if(e.relationship){var r=t.find((function(t){return t.fullyQualifiedName===e.relationship}));if(r){var i=r.associationEnd.find((function(t){return t.role===e.toRole}));i&&(a.targetType=n[i.type],a.isCollection="*"===i.multiplicity)}}a.targetType&&(a.targetTypeName=a.targetType.fullyQualifiedName);var o=a;return n[o.fullyQualifiedName]=o,o})),e.resolvePath=function(e,t){return function(n,a){return l(t,e,n,!1,a,"","")}}(e,n)}))}function y(e,t){var n=i(e,t),a=n.lastIndexOf(".");return[n.substr(0,a),n.substr(a+1)]}!function(e){e["Org.OData.Authorization.V1.SecuritySchemes"]="Org.OData.Authorization.V1.SecurityScheme",e["Org.OData.Authorization.V1.Authorizations"]="Org.OData.Authorization.V1.Authorization",e["Org.OData.Core.V1.Revisions"]="Org.OData.Core.V1.RevisionType",e["Org.OData.Core.V1.Links"]="Org.OData.Core.V1.Link",e["Org.OData.Core.V1.Example"]="Org.OData.Core.V1.ExampleValue",e["Org.OData.Core.V1.Messages"]="Org.OData.Core.V1.MessageType",e["Org.OData.Core.V1.ValueException"]="Org.OData.Core.V1.ValueExceptionType",e["Org.OData.Core.V1.ResourceException"]="Org.OData.Core.V1.ResourceExceptionType",e["Org.OData.Core.V1.DataModificationException"]="Org.OData.Core.V1.DataModificationExceptionType",e["Org.OData.Core.V1.IsLanguageDependent"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.DereferenceableIDs"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.ConventionalIDs"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.Permissions"]="Org.OData.Core.V1.Permission",e["Org.OData.Core.V1.DefaultNamespace"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.Immutable"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.Computed"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.ComputedDefaultValue"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.IsURL"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.IsMediaType"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.ContentDisposition"]="Org.OData.Core.V1.ContentDispositionType",e["Org.OData.Core.V1.OptimisticConcurrency"]="Edm.PropertyPath",e["Org.OData.Core.V1.AdditionalProperties"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.AutoExpand"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.AutoExpandReferences"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.MayImplement"]="Org.OData.Core.V1.QualifiedTypeName",e["Org.OData.Core.V1.Ordered"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.PositionalInsert"]="Org.OData.Core.V1.Tag",e["Org.OData.Core.V1.AlternateKeys"]="Org.OData.Core.V1.AlternateKey",e["Org.OData.Core.V1.OptionalParameter"]="Org.OData.Core.V1.OptionalParameterType",e["Org.OData.Core.V1.OperationAvailable"]="Edm.Boolean",e["Org.OData.Core.V1.SymbolicName"]="Org.OData.Core.V1.SimpleIdentifier",e["Org.OData.Capabilities.V1.ConformanceLevel"]="Org.OData.Capabilities.V1.ConformanceLevelType",e["Org.OData.Capabilities.V1.AsynchronousRequestsSupported"]="Org.OData.Core.V1.Tag",e["Org.OData.Capabilities.V1.BatchContinueOnErrorSupported"]="Org.OData.Core.V1.Tag",e["Org.OData.Capabilities.V1.IsolationSupported"]="Org.OData.Capabilities.V1.IsolationLevel",e["Org.OData.Capabilities.V1.CrossJoinSupported"]="Org.OData.Core.V1.Tag",e["Org.OData.Capabilities.V1.CallbackSupported"]="Org.OData.Capabilities.V1.CallbackType",e["Org.OData.Capabilities.V1.ChangeTracking"]="Org.OData.Capabilities.V1.ChangeTrackingType",e["Org.OData.Capabilities.V1.CountRestrictions"]="Org.OData.Capabilities.V1.CountRestrictionsType",e["Org.OData.Capabilities.V1.NavigationRestrictions"]="Org.OData.Capabilities.V1.NavigationRestrictionsType",e["Org.OData.Capabilities.V1.IndexableByKey"]="Org.OData.Core.V1.Tag",e["Org.OData.Capabilities.V1.TopSupported"]="Org.OData.Core.V1.Tag",e["Org.OData.Capabilities.V1.SkipSupported"]="Org.OData.Core.V1.Tag",e["Org.OData.Capabilities.V1.ComputeSupported"]="Org.OData.Core.V1.Tag",e["Org.OData.Capabilities.V1.SelectSupport"]="Org.OData.Capabilities.V1.SelectSupportType",e["Org.OData.Capabilities.V1.BatchSupported"]="Org.OData.Core.V1.Tag",e["Org.OData.Capabilities.V1.BatchSupport"]="Org.OData.Capabilities.V1.BatchSupportType",e["Org.OData.Capabilities.V1.FilterRestrictions"]="Org.OData.Capabilities.V1.FilterRestrictionsType",e["Org.OData.Capabilities.V1.SortRestrictions"]="Org.OData.Capabilities.V1.SortRestrictionsType",e["Org.OData.Capabilities.V1.ExpandRestrictions"]="Org.OData.Capabilities.V1.ExpandRestrictionsType",e["Org.OData.Capabilities.V1.SearchRestrictions"]="Org.OData.Capabilities.V1.SearchRestrictionsType",e["Org.OData.Capabilities.V1.KeyAsSegmentSupported"]="Org.OData.Core.V1.Tag",e["Org.OData.Capabilities.V1.QuerySegmentSupported"]="Org.OData.Core.V1.Tag",e["Org.OData.Capabilities.V1.InsertRestrictions"]="Org.OData.Capabilities.V1.InsertRestrictionsType",e["Org.OData.Capabilities.V1.DeepInsertSupport"]="Org.OData.Capabilities.V1.DeepInsertSupportType",e["Org.OData.Capabilities.V1.UpdateRestrictions"]="Org.OData.Capabilities.V1.UpdateRestrictionsType",e["Org.OData.Capabilities.V1.DeepUpdateSupport"]="Org.OData.Capabilities.V1.DeepUpdateSupportType",e["Org.OData.Capabilities.V1.DeleteRestrictions"]="Org.OData.Capabilities.V1.DeleteRestrictionsType",e["Org.OData.Capabilities.V1.CollectionPropertyRestrictions"]="Org.OData.Capabilities.V1.CollectionPropertyRestrictionsType",e["Org.OData.Capabilities.V1.OperationRestrictions"]="Org.OData.Capabilities.V1.OperationRestrictionsType",e["Org.OData.Capabilities.V1.AnnotationValuesInQuerySupported"]="Org.OData.Core.V1.Tag",e["Org.OData.Capabilities.V1.ModificationQueryOptions"]="Org.OData.Capabilities.V1.ModificationQueryOptionsType",e["Org.OData.Capabilities.V1.ReadRestrictions"]="Org.OData.Capabilities.V1.ReadRestrictionsType",e["Org.OData.Capabilities.V1.CustomHeaders"]="Org.OData.Capabilities.V1.CustomParameter",e["Org.OData.Capabilities.V1.CustomQueryOptions"]="Org.OData.Capabilities.V1.CustomParameter",e["Org.OData.Capabilities.V1.MediaLocationUpdateSupported"]="Org.OData.Core.V1.Tag",e["Org.OData.Aggregation.V1.ApplySupported"]="Org.OData.Aggregation.V1.ApplySupportedType",e["Org.OData.Aggregation.V1.Groupable"]="Org.OData.Core.V1.Tag",e["Org.OData.Aggregation.V1.Aggregatable"]="Org.OData.Core.V1.Tag",e["Org.OData.Aggregation.V1.ContextDefiningProperties"]="Edm.PropertyPath",e["Org.OData.Aggregation.V1.LeveledHierarchy"]="Edm.PropertyPath",e["Org.OData.Aggregation.V1.RecursiveHierarchy"]="Org.OData.Aggregation.V1.RecursiveHierarchyType",e["Org.OData.Aggregation.V1.AvailableOnAggregates"]="Org.OData.Aggregation.V1.AvailableOnAggregatesType",e["Org.OData.Validation.V1.Minimum"]="Edm.PrimitiveType",e["Org.OData.Validation.V1.Maximum"]="Edm.PrimitiveType",e["Org.OData.Validation.V1.Exclusive"]="Org.OData.Core.V1.Tag",e["Org.OData.Validation.V1.AllowedValues"]="Org.OData.Validation.V1.AllowedValue",e["Org.OData.Validation.V1.MultipleOf"]="Edm.Decimal",e["Org.OData.Validation.V1.Constraint"]="Org.OData.Validation.V1.ConstraintType",e["Org.OData.Validation.V1.ItemsOf"]="Org.OData.Validation.V1.ItemsOfType",e["Org.OData.Validation.V1.OpenPropertyTypeConstraint"]="Org.OData.Core.V1.QualifiedTypeName",e["Org.OData.Validation.V1.DerivedTypeConstraint"]="Org.OData.Core.V1.QualifiedTypeName",e["Org.OData.Validation.V1.AllowedTerms"]="Org.OData.Core.V1.QualifiedTermName",e["Org.OData.Validation.V1.ApplicableTerms"]="Org.OData.Core.V1.QualifiedTermName",e["Org.OData.Validation.V1.MaxItems"]="Edm.Int64",e["Org.OData.Validation.V1.MinItems"]="Edm.Int64",e["Org.OData.Measures.V1.Scale"]="Edm.Byte",e["Org.OData.Measures.V1.DurationGranularity"]="Org.OData.Measures.V1.DurationGranularityType",e["com.sap.vocabularies.Analytics.v1.Dimension"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Analytics.v1.Measure"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Analytics.v1.AccumulativeMeasure"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Analytics.v1.RolledUpPropertyCount"]="Edm.Int16",e["com.sap.vocabularies.Analytics.v1.PlanningAction"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Analytics.v1.AggregatedProperties"]="com.sap.vocabularies.Analytics.v1.AggregatedPropertyType",e["com.sap.vocabularies.Common.v1.ServiceVersion"]="Edm.Int32",e["com.sap.vocabularies.Common.v1.ServiceSchemaVersion"]="Edm.Int32",e["com.sap.vocabularies.Common.v1.TextFor"]="Edm.PropertyPath",e["com.sap.vocabularies.Common.v1.IsLanguageIdentifier"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.TextFormat"]="com.sap.vocabularies.Common.v1.TextFormatType",e["com.sap.vocabularies.Common.v1.IsDigitSequence"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsUpperCase"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsCurrency"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsUnit"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.UnitSpecificScale"]="Edm.PrimitiveType",e["com.sap.vocabularies.Common.v1.UnitSpecificPrecision"]="Edm.PrimitiveType",e["com.sap.vocabularies.Common.v1.SecondaryKey"]="Edm.PropertyPath",e["com.sap.vocabularies.Common.v1.MinOccurs"]="Edm.Int64",e["com.sap.vocabularies.Common.v1.MaxOccurs"]="Edm.Int64",e["com.sap.vocabularies.Common.v1.AssociationEntity"]="Edm.NavigationPropertyPath",e["com.sap.vocabularies.Common.v1.DerivedNavigation"]="Edm.NavigationPropertyPath",e["com.sap.vocabularies.Common.v1.Masked"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.MaskedAlways"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.SemanticObjectMapping"]="com.sap.vocabularies.Common.v1.SemanticObjectMappingType",e["com.sap.vocabularies.Common.v1.IsInstanceAnnotation"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.FilterExpressionRestrictions"]="com.sap.vocabularies.Common.v1.FilterExpressionRestrictionType",e["com.sap.vocabularies.Common.v1.FieldControl"]="com.sap.vocabularies.Common.v1.FieldControlType",e["com.sap.vocabularies.Common.v1.Application"]="com.sap.vocabularies.Common.v1.ApplicationType",e["com.sap.vocabularies.Common.v1.Timestamp"]="Edm.DateTimeOffset",e["com.sap.vocabularies.Common.v1.ErrorResolution"]="com.sap.vocabularies.Common.v1.ErrorResolutionType",e["com.sap.vocabularies.Common.v1.Messages"]="Edm.ComplexType",e["com.sap.vocabularies.Common.v1.numericSeverity"]="com.sap.vocabularies.Common.v1.NumericMessageSeverityType",e["com.sap.vocabularies.Common.v1.MaximumNumericMessageSeverity"]="com.sap.vocabularies.Common.v1.NumericMessageSeverityType",e["com.sap.vocabularies.Common.v1.IsActionCritical"]="Edm.Boolean",e["com.sap.vocabularies.Common.v1.Attributes"]="Edm.PropertyPath",e["com.sap.vocabularies.Common.v1.RelatedRecursiveHierarchy"]="Edm.AnnotationPath",e["com.sap.vocabularies.Common.v1.Interval"]="com.sap.vocabularies.Common.v1.IntervalType",e["com.sap.vocabularies.Common.v1.ResultContext"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.WeakReferentialConstraint"]="com.sap.vocabularies.Common.v1.WeakReferentialConstraintType",e["com.sap.vocabularies.Common.v1.IsNaturalPerson"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.ValueList"]="com.sap.vocabularies.Common.v1.ValueListType",e["com.sap.vocabularies.Common.v1.ValueListRelevantQualifiers"]="com.sap.vocabularies.Common.v1.SimpleIdentifier",e["com.sap.vocabularies.Common.v1.ValueListWithFixedValues"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.ValueListMapping"]="com.sap.vocabularies.Common.v1.ValueListMappingType",e["com.sap.vocabularies.Common.v1.IsCalendarYear"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsCalendarHalfyear"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsCalendarQuarter"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsCalendarMonth"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsCalendarWeek"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsDayOfCalendarMonth"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsDayOfCalendarYear"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsCalendarYearHalfyear"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsCalendarYearQuarter"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsCalendarYearMonth"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsCalendarYearWeek"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsCalendarDate"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsFiscalYear"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsFiscalPeriod"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsFiscalYearPeriod"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsFiscalQuarter"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsFiscalYearQuarter"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsFiscalWeek"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsFiscalYearWeek"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsDayOfFiscalYear"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.IsFiscalYearVariant"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.MutuallyExclusiveTerm"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Common.v1.DraftRoot"]="com.sap.vocabularies.Common.v1.DraftRootType",e["com.sap.vocabularies.Common.v1.DraftNode"]="com.sap.vocabularies.Common.v1.DraftNodeType",e["com.sap.vocabularies.Common.v1.DraftActivationVia"]="com.sap.vocabularies.Common.v1.SimpleIdentifier",e["com.sap.vocabularies.Common.v1.EditableFieldFor"]="Edm.PropertyPath",e["com.sap.vocabularies.Common.v1.SemanticKey"]="Edm.PropertyPath",e["com.sap.vocabularies.Common.v1.SideEffects"]="com.sap.vocabularies.Common.v1.SideEffectsType",e["com.sap.vocabularies.Common.v1.DefaultValuesFunction"]="com.sap.vocabularies.Common.v1.QualifiedName",e["com.sap.vocabularies.Common.v1.FilterDefaultValue"]="Edm.PrimitiveType",e["com.sap.vocabularies.Common.v1.FilterDefaultValueHigh"]="Edm.PrimitiveType",e["com.sap.vocabularies.Common.v1.SortOrder"]="com.sap.vocabularies.Common.v1.SortOrderType",e["com.sap.vocabularies.Common.v1.RecursiveHierarchy"]="com.sap.vocabularies.Common.v1.RecursiveHierarchyType",e["com.sap.vocabularies.Common.v1.CreatedAt"]="Edm.DateTimeOffset",e["com.sap.vocabularies.Common.v1.CreatedBy"]="com.sap.vocabularies.Common.v1.UserID",e["com.sap.vocabularies.Common.v1.ChangedAt"]="Edm.DateTimeOffset",e["com.sap.vocabularies.Common.v1.ChangedBy"]="com.sap.vocabularies.Common.v1.UserID",e["com.sap.vocabularies.Common.v1.ApplyMultiUnitBehaviorForSortingAndFiltering"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.CodeList.v1.CurrencyCodes"]="com.sap.vocabularies.CodeList.v1.CodeListSource",e["com.sap.vocabularies.CodeList.v1.UnitsOfMeasure"]="com.sap.vocabularies.CodeList.v1.CodeListSource",e["com.sap.vocabularies.CodeList.v1.StandardCode"]="Edm.PropertyPath",e["com.sap.vocabularies.CodeList.v1.ExternalCode"]="Edm.PropertyPath",e["com.sap.vocabularies.CodeList.v1.IsConfigurationDeprecationCode"]="Edm.Boolean",e["com.sap.vocabularies.Communication.v1.Contact"]="com.sap.vocabularies.Communication.v1.ContactType",e["com.sap.vocabularies.Communication.v1.Address"]="com.sap.vocabularies.Communication.v1.AddressType",e["com.sap.vocabularies.Communication.v1.IsEmailAddress"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Communication.v1.IsPhoneNumber"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Communication.v1.Event"]="com.sap.vocabularies.Communication.v1.EventData",e["com.sap.vocabularies.Communication.v1.Task"]="com.sap.vocabularies.Communication.v1.TaskData",e["com.sap.vocabularies.Communication.v1.Message"]="com.sap.vocabularies.Communication.v1.MessageData",e["com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchy"]="com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchyType",e["com.sap.vocabularies.PersonalData.v1.EntitySemantics"]="com.sap.vocabularies.PersonalData.v1.EntitySemanticsType",e["com.sap.vocabularies.PersonalData.v1.FieldSemantics"]="com.sap.vocabularies.PersonalData.v1.FieldSemanticsType",e["com.sap.vocabularies.PersonalData.v1.IsPotentiallyPersonal"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.PersonalData.v1.IsPotentiallySensitive"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.Session.v1.StickySessionSupported"]="com.sap.vocabularies.Session.v1.StickySessionSupportedType",e["com.sap.vocabularies.UI.v1.HeaderInfo"]="com.sap.vocabularies.UI.v1.HeaderInfoType",e["com.sap.vocabularies.UI.v1.Identification"]="com.sap.vocabularies.UI.v1.DataFieldAbstract",e["com.sap.vocabularies.UI.v1.Badge"]="com.sap.vocabularies.UI.v1.BadgeType",e["com.sap.vocabularies.UI.v1.LineItem"]="com.sap.vocabularies.UI.v1.DataFieldAbstract",e["com.sap.vocabularies.UI.v1.StatusInfo"]="com.sap.vocabularies.UI.v1.DataFieldAbstract",e["com.sap.vocabularies.UI.v1.FieldGroup"]="com.sap.vocabularies.UI.v1.FieldGroupType",e["com.sap.vocabularies.UI.v1.ConnectedFields"]="com.sap.vocabularies.UI.v1.ConnectedFieldsType",e["com.sap.vocabularies.UI.v1.GeoLocations"]="com.sap.vocabularies.UI.v1.GeoLocationType",e["com.sap.vocabularies.UI.v1.GeoLocation"]="com.sap.vocabularies.UI.v1.GeoLocationType",e["com.sap.vocabularies.UI.v1.Contacts"]="Edm.AnnotationPath",e["com.sap.vocabularies.UI.v1.MediaResource"]="com.sap.vocabularies.UI.v1.MediaResourceType",e["com.sap.vocabularies.UI.v1.DataPoint"]="com.sap.vocabularies.UI.v1.DataPointType",e["com.sap.vocabularies.UI.v1.KPI"]="com.sap.vocabularies.UI.v1.KPIType",e["com.sap.vocabularies.UI.v1.Chart"]="com.sap.vocabularies.UI.v1.ChartDefinitionType",e["com.sap.vocabularies.UI.v1.ValueCriticality"]="com.sap.vocabularies.UI.v1.ValueCriticalityType",e["com.sap.vocabularies.UI.v1.CriticalityLabels"]="com.sap.vocabularies.UI.v1.CriticalityLabelType",e["com.sap.vocabularies.UI.v1.SelectionFields"]="Edm.PropertyPath",e["com.sap.vocabularies.UI.v1.Facets"]="com.sap.vocabularies.UI.v1.Facet",e["com.sap.vocabularies.UI.v1.HeaderFacets"]="com.sap.vocabularies.UI.v1.Facet",e["com.sap.vocabularies.UI.v1.QuickViewFacets"]="com.sap.vocabularies.UI.v1.Facet",e["com.sap.vocabularies.UI.v1.QuickCreateFacets"]="com.sap.vocabularies.UI.v1.Facet",e["com.sap.vocabularies.UI.v1.FilterFacets"]="com.sap.vocabularies.UI.v1.ReferenceFacet",e["com.sap.vocabularies.UI.v1.SelectionPresentationVariant"]="com.sap.vocabularies.UI.v1.SelectionPresentationVariantType",e["com.sap.vocabularies.UI.v1.PresentationVariant"]="com.sap.vocabularies.UI.v1.PresentationVariantType",e["com.sap.vocabularies.UI.v1.SelectionVariant"]="com.sap.vocabularies.UI.v1.SelectionVariantType",e["com.sap.vocabularies.UI.v1.ThingPerspective"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.IsSummary"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.PartOfPreview"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.Map"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.Gallery"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.IsImageURL"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.IsImage"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.MultiLineText"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.TextArrangement"]="com.sap.vocabularies.UI.v1.TextArrangementType",e["com.sap.vocabularies.UI.v1.Importance"]="com.sap.vocabularies.UI.v1.ImportanceType",e["com.sap.vocabularies.UI.v1.Hidden"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.CreateHidden"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.UpdateHidden"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.DeleteHidden"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.HiddenFilter"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.DataFieldDefault"]="com.sap.vocabularies.UI.v1.DataFieldAbstract",e["com.sap.vocabularies.UI.v1.Criticality"]="com.sap.vocabularies.UI.v1.CriticalityType",e["com.sap.vocabularies.UI.v1.CriticalityCalculation"]="com.sap.vocabularies.UI.v1.CriticalityCalculationType",e["com.sap.vocabularies.UI.v1.Emphasized"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.UI.v1.OrderBy"]="Edm.PropertyPath",e["com.sap.vocabularies.UI.v1.ParameterDefaultValue"]="Edm.PrimitiveType",e["com.sap.vocabularies.UI.v1.RecommendationState"]="com.sap.vocabularies.UI.v1.RecommendationStateType",e["com.sap.vocabularies.UI.v1.RecommendationList"]="com.sap.vocabularies.UI.v1.RecommendationListType",e["com.sap.vocabularies.UI.v1.ExcludeFromNavigationContext"]="Org.OData.Core.V1.Tag",e["com.sap.vocabularies.HTML5.v1.CssDefaults"]="com.sap.vocabularies.HTML5.v1.CssDefaultsType"}(a||(a={})),t.defaultReferences=[{alias:"Capabilities",namespace:"Org.OData.Capabilities.V1",uri:""},{alias:"Aggregation",namespace:"Org.OData.Aggregation.V1",uri:""},{alias:"Validation",namespace:"Org.OData.Validation.V1",uri:""},{namespace:"Org.OData.Core.V1",alias:"Core",uri:""},{namespace:"Org.OData.Measures.V1",alias:"Measures",uri:""},{namespace:"com.sap.vocabularies.Common.v1",alias:"Common",uri:""},{namespace:"com.sap.vocabularies.UI.v1",alias:"UI",uri:""},{namespace:"com.sap.vocabularies.Session.v1",alias:"Session",uri:""},{namespace:"com.sap.vocabularies.Analytics.v1",alias:"Analytics",uri:""},{namespace:"com.sap.vocabularies.CodeList.v1",alias:"CodeList",uri:""},{namespace:"com.sap.vocabularies.PersonalData.v1",alias:"PersonalData",uri:""},{namespace:"com.sap.vocabularies.Communication.v1",alias:"Communication",uri:""},{namespace:"com.sap.vocabularies.HTML5.v1",alias:"HTML5",uri:""}];var v=[],b={};function P(e,t){var n;if("string"==typeof t){var a=t.match(/(\w+)\.\w+\/.*/);n=a&&e.find((function(e){return e.alias===a[1]}))?{type:"EnumMember",EnumMember:t}:{type:"String",String:t}}else Array.isArray(t)?n={type:"Collection",Collection:t.map((function(t){return S(e,t)}))}:"boolean"==typeof t?n={type:"Bool",Bool:t}:"number"==typeof t?n=t.toString()===t.toFixed()?{type:"Int",Int:t}:{type:"Decimal",Decimal:t}:"object"==typeof t&&t.isDecimal&&t.isDecimal()?n={type:"Decimal",Decimal:t.valueOf()}:"Path"===t.type?n={type:"Path",Path:t.path}:"AnnotationPath"===t.type?n={type:"AnnotationPath",AnnotationPath:t.value}:"Apply"===t.type?n={type:"Apply",Apply:t.Apply}:"Null"===t.type?n={type:"Null"}:"PropertyPath"===t.type?n={type:"PropertyPath",PropertyPath:t.value}:"NavigationPropertyPath"===t.type?n={type:"NavigationPropertyPath",NavigationPropertyPath:t.value}:Object.prototype.hasOwnProperty.call(t,"$Type")&&(n={type:"Record",Record:S(e,t)});return n}function S(e,t){if("string"==typeof t)return t;if("object"==typeof t){if(t.hasOwnProperty("$Type")){var n={type:t.$Type,propertyValues:[]};return Object.keys(t).forEach((function(a){if("$Type"!==a&&"term"!==a&&"__source"!==a&&"qualifier"!==a&&"ActionTarget"!==a&&"fullyQualifiedName"!==a&&"annotations"!==a){var r=t[a];n.propertyValues.push({name:a,value:P(e,r)})}else if("annotations"===a){var i=t[a];n.annotations=[],Object.keys(i).filter((function(e){return"_annotations"!==e})).forEach((function(t){Object.keys(i[t]).forEach((function(a){var r,s=T(e,i[t][a]);if(!s.term){var c=o(e,t+"."+a);if(c){var l=c.split("#");s.term=l[0],l.length>1&&(s.qualifier=l[1])}}null===(r=n.annotations)||void 0===r||r.push(s)}))}))}})),n}if("PropertyPath"===t.type)return{type:"PropertyPath",PropertyPath:t.value};if("AnnotationPath"===t.type)return{type:"AnnotationPath",AnnotationPath:t.value};if("NavigationPropertyPath"===t.type)return{type:"NavigationPropertyPath",NavigationPropertyPath:t.value}}}function T(e,t){var a={term:t.term,qualifier:t.qualifier};if(Array.isArray(t)){if(t.hasOwnProperty("annotations")){a.annotations=[];var r=t.annotations;Object.keys(r).filter((function(e){return"_annotations"!==e})).forEach((function(t){Object.keys(r[t]).forEach((function(n){var i,s=T(e,r[t][n]);if(!s.term){var c=o(e,t+"."+n);if(c){var l=c.split("#");s.term=l[0],l.length>1&&(s.qualifier=l[1])}}null===(i=a.annotations)||void 0===i||i.push(s)}))}))}return n(n({},a),{collection:t.map((function(t){return S(e,t)}))})}return t.hasOwnProperty("$Type")?n(n({},a),{record:S(e,t)}):n(n({},a),{value:P(e,t)})}t.convertTypes=function(e){v=[];var n=function(e){var t={};return e.schema.entityContainer&&e.schema.entityContainer.fullyQualifiedName&&(t[e.schema.entityContainer.fullyQualifiedName]=e.schema.entityContainer),e.schema.entitySets.forEach((function(e){t[e.fullyQualifiedName]=e})),e.schema.actions.forEach((function(e){if(t[e.fullyQualifiedName]=e,e.isBound){var n=e.fullyQualifiedName.split("(")[0];t[n]||(t[n]={_type:"UnboundGenericAction",actions:[]}),t[n].actions.push(e)}e.parameters.forEach((function(e){t[e.fullyQualifiedName]=e}))})),e.schema.complexTypes.forEach((function(e){t[e.fullyQualifiedName]=e,e.properties.forEach((function(e){t[e.fullyQualifiedName]=e}))})),e.schema.entityTypes.forEach((function(e){t[e.fullyQualifiedName]=e,e.entityProperties.forEach((function(e){if(t[e.fullyQualifiedName]=e,-1===e.type.indexOf("Edm")){var n=t[e.type];n&&n.properties&&n.properties.forEach((function(n){var a=Object.assign(n,{_type:"Property",fullyQualifiedName:e.fullyQualifiedName+"/"+n.name});t[a.fullyQualifiedName]=a}))}})),e.navigationProperties.forEach((function(e){t[e.fullyQualifiedName]=e}))})),Object.keys(e.schema.annotations).forEach((function(n){e.schema.annotations[n].forEach((function(n){var a=o(e.references,n.target);n.annotations.forEach((function(n){var r=a+"@"+o(e.references,n.term);n.qualifier&&(r+="#"+n.qualifier),t[r]=n,n.fullyQualifiedName=r}))}))})),t}(e);m(e.schema.entityTypes,e.schema.associations,n),e.schema.entityContainer.annotations||(e.schema.entityContainer.annotations={}),function(e,t,n){t.forEach((function(t){if(t.annotations||(t.annotations={}),t.isBound){var a=n[t.sourceType];t.sourceEntityType=a,a&&(a.actions||(a.actions={}),a.actions[t.name]=t,a.actions[e+"."+t.name]=t),t.returnEntityType=n[t.returnType]}}))}(e.schema.namespace,e.schema.actions,n),function(e,t,n){e.forEach((function(e){e.entityType=t[e.entityTypeName],e.entityType||(e.entityType=t[o(n,e.entityTypeName)]),e.annotations||(e.annotations={}),e.entityType.annotations||(e.entityType.annotations={}),e.entityType.keys.forEach((function(e){e.isKey=!0}))}))}(e.schema.entitySets,n,e.references),function(e,t,n){void 0===e&&(e=[]),e.forEach((function(e){e.type=t[e.typeName],e.type||(e.type=t[o(n,e.typeName)]),e.annotations||(e.annotations={}),e.type.annotations||(e.type.annotations={}),e.type.keys.forEach((function(e){e.isKey=!0}))}))}(e.schema.singletons,n,e.references),function(e,t){function n(e){if(e.annotations||(e.annotations={}),-1===e.type.indexOf("Edm")){var a=void 0;if(e.type.startsWith("Collection")){var r=e.type.substr(11,e.type.length-12);a=t[r]}else a=t[e.type];a&&(e.targetType=a,a.properties&&a.properties.forEach(n))}}e.forEach((function(e){e.entityProperties.forEach(n)}))}(e.schema.entityTypes,n),function(e,t,n){e.forEach((function(e){e.annotations={},e.properties.forEach((function(e){e.annotations||(e.annotations={})})),e.navigationProperties=e.navigationProperties.map((function(e){e.annotations||(e.annotations={});var a={_type:"NavigationProperty",name:e.name,fullyQualifiedName:e.fullyQualifiedName,partner:e.hasOwnProperty("partner")?e.partner:void 0,isCollection:!!e.hasOwnProperty("isCollection")&&e.isCollection,containsTarget:!!e.hasOwnProperty("containsTarget")&&e.containsTarget,referentialConstraint:e.referentialConstraint?e.referentialConstraint:[]};if(e.targetTypeName)a.targetType=n[e.targetTypeName];else if(e.relationship){var r=t.find((function(t){return t.fullyQualifiedName===e.relationship}));if(r){var i=r.associationEnd.find((function(t){return t.role===e.toRole}));i&&(a.targetType=n[i.type],a.isCollection="*"===i.multiplicity)}}a.targetType&&(a.targetTypeName=a.targetType.fullyQualifiedName);var o=a;return n[o.fullyQualifiedName]=o,o}))}))}(e.schema.complexTypes,e.schema.associations,n);var a=[],r=[];Object.keys(e.schema.annotations).forEach((function(i){e.schema.annotations[i].forEach((function(s){var c=o(e.references,s.target),l=n[c];if(l){if("object"==typeof l){var u=[l],p=!0;"UnboundGenericAction"===l._type&&(u=l.actions,p=!1),u.forEach((function(l){c!==l.fullyQualifiedName&&(c=l.fullyQualifiedName),l.annotations||(l.annotations={}),s.annotations.forEach((function(s){var u,f,d=y(t.defaultReferences,s.term),h=d[0],m=d[1];l.annotations[h]||(l.annotations[h]={}),l.annotations._annotations||(l.annotations._annotations={});var v=m+(s.qualifier?"#"+s.qualifier:"");if(p||void 0===(null===(f=null===(u=l.annotations)||void 0===u?void 0:u[h])||void 0===f?void 0:f[v])){switch(l.annotations[h][v]=g(s,e,l,n,a,i,r),typeof l.annotations[h][v]){case"string":l.annotations[h][v]=new String(l.annotations[h][v]);break;case"boolean":l.annotations[h][v]=new Boolean(l.annotations[h][v])}null!==l.annotations[h][v]&&"object"==typeof l.annotations[h][v]&&(l.annotations[h][v].term=o(t.defaultReferences,h+"."+m),l.annotations[h][v].qualifier=s.qualifier,l.annotations[h][v].__source=i);var b=c+"@"+o(t.defaultReferences,h+"."+v);if(s.annotations&&Array.isArray(s.annotations)){var P={target:b,annotations:s.annotations,__source:i};r.push(P)}else s.annotations&&!l.annotations[h][v].annotations&&(l.annotations[h][v].annotations=s.annotations);l.annotations._annotations[h+"."+v]=l.annotations[h][v],n[b]=l.annotations[h][v]}}))}))}}else c&&-1!==c.indexOf("@")&&(s.__source=i,r.push(s))}))}));var i=[];for(var s in r.forEach((function(r){var s=o(e.references,r.target),c=s.split("@"),l=c[0],u=c[1].split("/");l=l+"@"+u[0];var p=u.slice(1).reduce((function(e,t){return e?e[t]:null}),n[l]);p?"object"==typeof p&&(p.annotations||(p.annotations={}),r.annotations.forEach((function(c){var l=y(t.defaultReferences,c.term),u=l[0],f=l[1];p.annotations[u]||(p.annotations[u]={}),p.annotations._annotations||(p.annotations._annotations={});var d=f+(c.qualifier?"#"+c.qualifier:"");p.annotations[u][d]=g(c,e,p,n,a,r.__source,i),null!==p.annotations[u][d]&&"object"==typeof p.annotations[u][d]&&(p.annotations[u][d].term=o(t.defaultReferences,u+"."+f),p.annotations[u][d].qualifier=c.qualifier,p.annotations[u][d].__source=r.__source),p.annotations._annotations[u+"."+d]=p.annotations[u][d],n[s+"@"+o(t.defaultReferences,u+"."+d)]=p.annotations[u][d]}))):v.push({message:"The following annotation target was not found on the service "+s})})),a.forEach((function(e){var t=e.toResolve,a=t.$target,r=n[a],i=t.annotationsTerm,o=t.annotationType;if(delete t.annotationType,delete t.annotationsTerm,!e.inline||r instanceof String)t.$target=r;else{var s=void 0;for(s in t)delete t[s];Object.assign(t,r)}if(!r)if(t.targetString=a,i&&o){c(a,{message:"Unable to resolve the path expression: "+a+"\n\nHint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n<Annotation Term = "+i+">\n<Record Type = "+o+">\n<AnnotationPath = "+a+">"})}else{var l=t.term,u=t.path,p=a?a.split("/")[0]:a;c(a,{message:"Unable to resolve the path expression: "+a+"\n\nHint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n<Annotation Term = "+p+">\n<PropertyValue Property = "+l+"        Path= "+u+">"})}})),b)v.push(b[s][0]);e.entitySets=e.schema.entitySets;var u=e.references.filter((function(e){return void 0===t.defaultReferences.find((function(t){return t.namespace===e.namespace}))})),p={version:e.version,annotations:e.schema.annotations,namespace:e.schema.namespace,entityContainer:e.schema.entityContainer,actions:e.schema.actions,entitySets:e.schema.entitySets,singletons:e.schema.singletons,entityTypes:e.schema.entityTypes,complexTypes:e.schema.complexTypes,references:t.defaultReferences.concat(u),diagnostics:v.concat()};return p.resolvePath=function(e,t){return function(n){var a=n.split("/");if(""!==a.shift())throw new Error("Cannot deal with relative path");var r=a.shift(),i=e.entitySets.find((function(e){return e.name===r}));if(!i)return{target:e.entityContainer,objectPath:[e.entityContainer]};if(0===a.length)return{target:i,objectPath:[e.entityContainer,i]};var o=l(t,i,"/"+a.join("/"),!1,!0);return o.target&&o.visitedObjects.push(o.target),{target:o.target,objectPath:o.visitedObjects}}}(p,n),p},t.revertTermToGenericType=T},1014:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=n(5129);Object.defineProperty(t,"parseEDMX",{enumerable:!0,get:function(){return a.parseEDMX}});var r=n(8027);Object.defineProperty(t,"merge",{enumerable:!0,get:function(){return r.merge}})},8027:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.merge=void 0;const a=n(1878);t.merge=function(e){const t=new a.MergedParserOutput(e[0]);return e.forEach((e=>{t.addParserOutput(e)})),t}},5129:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseEDMX=void 0;const a=n(4139),r=n(1878),i=n(6162),o=n(6511),s=/Collection\(([^)]+)\)/;function c(e,t,n,a){return e.reduce(((e,r)=>{const i={_type:"Property",name:r._attributes.Name,fullyQualifiedName:`${n}/${r._attributes.Name}`,type:r._attributes.Type};if(r._attributes.MaxLength&&(i.maxLength=parseInt(r._attributes.MaxLength)),r._attributes.Precision&&(i.precision=parseInt(r._attributes.Precision)),r._attributes.Scale&&(i.scale=parseInt(r._attributes.Scale)),r._attributes.Nullable&&(i.nullable="false"!==r._attributes.Nullable),r._attributes.DefaultValue)switch(i.type){case"Edm.Int16":case"Edm.Byte":case"Edm.Int32":case"Edm.Int64":i.defaultValue=parseInt(r._attributes.DefaultValue);break;case"Edm.Decimal":i.defaultValue=parseFloat(r._attributes.DefaultValue);break;case"Edm.Boolean":i.defaultValue="true"===r._attributes.DefaultValue;break;default:i.defaultValue=r._attributes.DefaultValue}e.entityProperties.push(i),-1!==t.indexOf(i.name)&&e.entityKeys.push(i);const s=o.convertV2Annotations(r._attributes,"Property",r._attributes.Name);return s.length>0&&a.push(S(i.fullyQualifiedName,s)),e}),{entityProperties:[],entityKeys:[]})}function l(e,t,n,a){return e.reduce(((e,i)=>{const c=i._attributes;if(null!==(f=c).Type&&void 0!==f.Type){const a=c.Type.match(s),o=null!==a,f=a?a[1]:c.Type;e.push({_type:"NavigationProperty",name:c.Name,fullyQualifiedName:`${n}/${c.Name}`,partner:c.Partner,containsTarget:"true"===c.ContainsTarget,isCollection:o,targetTypeName:f,referentialConstraint:(l=r.ensureArray(i.ReferentialConstraint),u=t._attributes.Name,p=f,l.reduce(((e,t)=>(e.push({sourceTypeName:u,sourceProperty:t._attributes.Property,targetTypeName:p,targetProperty:t._attributes.ReferencedProperty}),e)),[]))})}else{const{Relationship:t,ToRole:r,FromRole:i}=c;e.push({_type:"NavigationProperty",name:c.Name,fullyQualifiedName:`${n}/${c.Name}`,relationship:t,toRole:r,fromRole:i});const s=o.convertV2Annotations(c,"Property",c.Name);s.length>0&&a.push(S(`${n}/${c.Name}`,s))}var l,u,p,f;return e}),[])}function u(e){switch(e){case"1":return i.Multiplicity.One;case"0..1":return i.Multiplicity.ZeroOrOne;case"*":return i.Multiplicity.Many}return i.Multiplicity.Unknown}function p(e,t,n=!1){return e.map((e=>{let a=`${r.ensureArray(e.Parameter).filter((t=>t._attributes.Name===e._attributes.EntitySetPath)).map((e=>e._attributes.Type))}`;const i="true"===e._attributes.IsBound;let o=`${e._attributes.Name}()`;return i&&(a||(a=`${r.ensureArray(e.Parameter)[0]._attributes.Type}`),o=`${t}.${e._attributes.Name}(${a})`),{_type:"Action",name:e._attributes.Name,isBound:i,sourceType:a,fullyQualifiedName:o,isFunction:n,parameters:r.ensureArray(e.Parameter).map((t=>({_type:"ActionParameter",fullyQualifiedName:`${o}/${t._attributes.Name}`,type:t._attributes.Type,isEntitySet:t._attributes.Name===e._attributes.EntitySetPath}))),returnType:e.ReturnType?e.ReturnType._attributes.Type:""}}))}function f(e,t,n){return e.map((e=>{const{Annotation:a,_attributes:i,...o}=e,s={};if(i){const a=Object.keys(i).find((e=>"Property"!==e));s.name=i.Property;let c=`${t}/${s.name}`;if(o&&Object.keys(o).length>0?s.value=b(o,c,n):a&&(s.value=v({[a]:i[a]},c,n)),e.Annotation){const t=P(r.ensureArray(e.Annotation),c,n);t&&t.length>0&&n.push(S(c,t))}}return s}))}function d(e,t,n){const a=P(r.ensureArray(e.Annotation),t,n);return a&&a.length>0&&n.push(S(t,a)),{type:e._attributes?E(e._attributes.Type):void 0,propertyValues:f(r.ensureArray(e.PropertyValue),t,n)}}function h(e,t){return null!=e[t]}function g(e,t){switch(t){case"NavigationPropertyPath":return{type:"NavigationPropertyPath",NavigationPropertyPath:e._text};case"PropertyPath":return{type:"PropertyPath",PropertyPath:e._text};case"AnnotationPath":return{type:"AnnotationPath",AnnotationPath:e._text};case"Path":return{type:"Path",Path:e._text}}}function m(e,t,n){if(h(e,"Record")){const a=r.ensureArray(e.Record).map(((e,a)=>d(e,t+"/"+a,n)));return a.type="Record",a}if(h(e,"PropertyPath")){const t=r.ensureArray(e.PropertyPath).map((e=>g(e,"PropertyPath")));return t.type="PropertyPath",t}if(h(e,"NavigationPropertyPath")){const t=r.ensureArray(e.NavigationPropertyPath).map((e=>g(e,"NavigationPropertyPath")));return t.type="NavigationPropertyPath",t}if(h(e,"String")){const t=r.ensureArray(e.String).map((e=>e._text));return t.type="String",t}if(h(e,"AnnotationPath")){const t=r.ensureArray(e.AnnotationPath).map((e=>g(e,"AnnotationPath")));return t.type="AnnotationPath",t}if(h(e,"Path")){const t=r.ensureArray(e.Path).map((e=>g(e,"Path")));return t.type="Path",t}if(h(e,"If")){const t=r.ensureArray(e.If).map((e=>e._text));return t.type="String",t}return 0===Object.keys(e).length||console.error(`Cannot parse ${JSON.stringify(e)}, collection type is not supported`),[]}function y(e,t){return null!=e[t]}function v(e,t,n){const a=Object.keys(e);if(a.length>1)throw new Error(`Too many expressions defined on a single object ${JSON.stringify(e)}`);const r=a[0];switch(r){case"String":return{type:"String",String:e[r]};case"Bool":return{type:"Bool",Bool:"true"===e.Bool};case"Decimal":return{type:"Decimal",Decimal:parseFloat(e.Decimal)};case"Date":return{type:"Date",Date:e.Date};case"Int":return{type:"Int",Int:parseInt(e.Int)};case"Path":return{type:"Path",Path:e.Path};case"PropertyPath":return{type:"PropertyPath",PropertyPath:e.PropertyPath};case"AnnotationPath":return{type:"AnnotationPath",AnnotationPath:e.AnnotationPath};case"NavigationPropertyPath":return{type:"NavigationPropertyPath",NavigationPropertyPath:e.NavigationPropertyPath};case"EnumMember":return{type:"EnumMember",EnumMember:e[r]};case"Collection":return{type:"Collection",Collection:m(e.Collection,t,n)};case"Record":return{type:"Record",Record:d(e.Record,t,n)};case"Apply":return{type:"Apply",Apply:e.Apply};case"Null":return{type:"Null"};default:return console.error("Unsupported inline expression type "+r),{type:"Unknown"}}}function b(e,t,n){const a=Object.keys(e);if(a.length>1)throw new Error(`Too many expressions defined on a single object ${JSON.stringify(e)}`);const r=a[0];switch(r){case"String":return{type:"String",String:e[r]._text};case"Bool":return{type:"Bool",Bool:"true"===e.Bool._text};case"Int":return{type:"Int",Int:parseInt(e.Int._text)};case"Decimal":return{type:"Decimal",Decimal:parseFloat(e.Decimal._text)};case"Path":return{type:"Path",Path:e.Path._text};case"PropertyPath":return{type:"PropertyPath",PropertyPath:e.PropertyPath._text};case"NavigationPropertyPath":return{type:"NavigationPropertyPath",NavigationPropertyPath:e.NavigationPropertyPath._text};case"AnnotationPath":return{type:"AnnotationPath",AnnotationPath:e.AnnotationPath._text};case"EnumMember":return{type:"EnumMember",EnumMember:e[r]._text};case"Collection":return{type:"Collection",Collection:m(e.Collection,t,n)};case"Record":return{type:"Record",Record:d(e.Record,t,n)};case"Apply":return{type:"Apply",Apply:e.Apply};case"Null":return{type:"Null"};default:return console.error("Unsupported expression type "+r),{type:"Unknown"}}}function P(e,t,n){return e.map((e=>function(e,t,n){const{Term:a,Qualifier:i,...o}=e._attributes;let s={term:E(a),qualifier:i},c=`${t}@${E(a)}`;if(""!==i&&void 0!==i&&(c+=`#${i}`),o&&Object.keys(o).length>0&&(s.value=v(o,c,n)),e.Annotation){const t=P(r.ensureArray(e.Annotation),c,n);t&&t.length>0&&n.push(S(c,t))}const l=Object.keys(e).filter((e=>"_attributes"!==e&&"Annotation"!==e));return y(e,"Record")?s.record=d(e.Record,c,n):y(e,"Collection")?s.collection=m(e.Collection,c,n):1===l.length?s.value=b({[l[0]]:e[l[0]]},c,n):l.length>1&&console.error(`Cannot parse ${JSON.stringify(e)}, expression type is not supported`),s}(e,t,n)))}function S(e,t){return{target:e,annotations:t}}function T(e,t){const n=e._attributes.Namespace,a=[],i=function(e,t,n){return e.reduce(((e,a)=>{const i=a.Key?r.ensureArray(a.Key.PropertyRef).map((e=>e._attributes.Name)):[],o=`${n}.${a._attributes.Name}`,{entityProperties:s,entityKeys:u}=c(r.ensureArray(a.Property),i,o,t),p=l(r.ensureArray(a.NavigationProperty),a,o,t);return e.push({_type:"EntityType",name:a._attributes.Name,fullyQualifiedName:o,keys:u,entityProperties:s,navigationProperties:p}),e}),[])}(r.ensureArray(e.EntityType),a,n),s=function(e,t,n){return e.reduce(((e,a)=>{const i=`${n}.${a._attributes.Name}`,{entityProperties:o,entityKeys:s}=c(r.ensureArray(a.Property),[],i,t),u=l(r.ensureArray(a.NavigationProperty),a,i,t);return e.push({_type:"ComplexType",name:a._attributes.Name,fullyQualifiedName:i,properties:o,navigationProperties:u}),e}),[])}(r.ensureArray(e.ComplexType),a,n);let f=[],d=[],h=[],g={},m=[];e.EntityContainer&&(f=function(e,t,n,a){const i=e.map((e=>{const r={_type:"EntitySet",name:e._attributes.Name,entityTypeName:e._attributes.EntityType,navigationPropertyBinding:{},fullyQualifiedName:`${t}.${n}/${e._attributes.Name}`},i=o.convertV2Annotations(e._attributes,"EntitySet",e._attributes.Name);return i.length>0&&a.push(S(r.fullyQualifiedName,i)),r}));return e.forEach((e=>{const t=i.find((t=>t.name===e._attributes.Name));t&&r.ensureArray(e.NavigationPropertyBinding).forEach((e=>{const n=i.find((t=>t.name===e._attributes.Target));n&&(t.navigationPropertyBinding[e._attributes.Path]=n)}))})),i}(r.ensureArray(e.EntityContainer.EntitySet),n,e.EntityContainer._attributes.Name,a),d=function(e,t,n,a){const i=e.map((e=>{const r={_type:"Singleton",name:e._attributes.Name,typeName:e._attributes.Type,nullable:"false"!==e._attributes.Nullable,navigationPropertyBinding:{},fullyQualifiedName:`${t}.${n}/${e._attributes.Name}`},i=o.convertV2Annotations(e._attributes,"Singleton",e._attributes.Name);return i.length>0&&a.push(S(r.fullyQualifiedName,i)),r}));return e.forEach((e=>{const t=i.find((t=>t.name===e._attributes.Name));t&&r.ensureArray(e.NavigationPropertyBinding).forEach((e=>{const n=i.find((t=>t.name===e._attributes.Target));n&&(t.navigationPropertyBinding[e._attributes.Path]=n)}))})),i}(r.ensureArray(e.EntityContainer.Singleton),n,e.EntityContainer._attributes.Name,a),h=function(e,t){return e.map((e=>{const n=`${t}.${e._attributes.Name}`,a=r.ensureArray(e.End).map((e=>({entitySet:e._attributes.EntitySet,role:e._attributes.Role})));return{fullyQualifiedName:n,name:e._attributes.Name,association:e._attributes.Association,associationEnd:a}}))}(r.ensureArray(e.EntityContainer.AssociationSet),n),g={name:e.EntityContainer._attributes.Name,fullyQualifiedName:`${n}.${e.EntityContainer._attributes.Name}`},m=m.concat(function(e,t,n){return e.map((e=>{const a=t.find((t=>t.name===e._attributes.EntitySet));let i=`${n}/${e._attributes.Name}()`;return{_type:"Action",name:e._attributes.Name,isBound:!1,sourceType:a?a.entityTypeName:"",fullyQualifiedName:i,isFunction:!1,parameters:r.ensureArray(e.Parameter).map((e=>({_type:"ActionParameter",fullyQualifiedName:`${i}/${e._attributes.Name}`,type:e._attributes.Type,isEntitySet:!1}))),returnType:e._attributes.ReturnType?e._attributes.ReturnType:""}}))}(r.ensureArray(e.EntityContainer.FunctionImport),f,g.fullyQualifiedName))),m=m.concat(p(r.ensureArray(e.Action),n)),m=m.concat(p(r.ensureArray(e.Function),n,!0));const y=function(e,t){return e.map((e=>{const n=`${t}.${e._attributes.Name}`,a=r.ensureArray(e.End).map((e=>({type:e._attributes.Type,role:e._attributes.Role,multiplicity:u(e._attributes.Multiplicity)})));return{fullyQualifiedName:n,name:e._attributes.Name,associationEnd:a,referentialConstraints:(i=r.ensureArray(e.ReferentialConstraint),o=a,i.reduce(((e,t)=>{let n=o.find((e=>e.role===t.Principal._attributes.Role)),a=o.find((e=>e.role===t.Dependent._attributes.Role));if(n&&a){let i=r.ensureArray(t.Principal.PropertyRef),s=r.ensureArray(t.Dependent.PropertyRef);"1"!==n.multiplicity&&(a=n,n=o.find((e=>e.role===t.Dependent._attributes.Role)),s=i,i=r.ensureArray(t.Dependent.PropertyRef)),i.forEach(((t,r)=>{e.push({sourceTypeName:n.type,sourceProperty:t._attributes.Name,targetTypeName:a.type,targetProperty:s[r]._attributes.Name})}))}return e}),[]))};var i,o}))}(r.ensureArray(e.Association),n);var v,b;h.length>0&&f.forEach((e=>{const t=i.find((t=>t.fullyQualifiedName===e.entityTypeName));null==t||t.navigationProperties.forEach((t=>{const n=t,a=h.find((e=>e.association===n.relationship));if(a){const n=a.associationEnd.map((e=>f.find((t=>t.name===e.entitySet)))).find((t=>(null==t?void 0:t.fullyQualifiedName)!==e.fullyQualifiedName));n&&(e.navigationPropertyBinding[t.name]=n)}}))})),y.length>0&&i.forEach((e=>{e.navigationProperties.forEach((e=>{const t=e,n=y.find((e=>e.fullyQualifiedName===t.relationship));n&&n.referentialConstraints&&(t.referentialConstraint=n.referentialConstraints)}))})),v=r.ensureArray(e.Annotations),b=a,v.filter((e=>void 0!==e._attributes)).forEach((e=>{b.push(S(e._attributes.Target,P(r.ensureArray(e.Annotation),e._attributes.Target,b)))}));var T={};return T[t]=a,{associations:y,associationSets:h,annotations:T,entityContainer:g,namespace:n,entitySets:f,singletons:d,complexTypes:s,actions:m,entityTypes:i}}let O={};function E(e){if(!e)return e;const[t,n]=e.split("."),a=O[t];if(a)return`${a.namespace}.${n}`;if(-1!==e.indexOf("@")){const[t,n]=e.split("@");return`${t}@${E(n)}`}return e}t.parseEDMX=function(e,t="serviceFile"){const n=a.xml2js(e,{compact:!0}),i=r.ensureArray(n["edmx:Edmx"]["edmx:DataServices"].Schema),o=function(e,t){const n=e.reduce(((e,t)=>(r.ensureArray(t["edmx:Include"]).forEach((n=>{e.push({uri:t._attributes.Uri,alias:n._attributes.Alias,namespace:n._attributes.Namespace})})),e)),[]);return t.forEach((e=>{e&&e._attributes.Alias&&n.push({uri:"",alias:e._attributes.Alias,namespace:e._attributes.Namespace})})),n}(r.ensureArray(n["edmx:Edmx"]["edmx:Reference"]),i);O=o.reduce(((e,t)=>(e[t.alias]=t,e)),{});const s=i.map((e=>T(e,t)));return new r.ParserOutputInstance(t,n["edmx:Edmx"]._attributes.Version,function(e){if(1===e.length)return e[0];const t=e.reduce(((e,t)=>e.concat(t.associations)),[]),n=e.reduce(((e,t)=>e.concat(t.associationSets)),[]),a=e.reduce(((e,t)=>e.concat(t.entitySets)),[]),r=e.reduce(((e,t)=>e.concat(t.singletons)),[]),i=e.reduce(((e,t)=>e.concat(t.entityTypes)),[]),o=e.reduce(((e,t)=>e.concat(t.actions)),[]),s=e.reduce(((e,t)=>e.concat(t.complexTypes)),[]);let c,l,u={};return e.forEach((e=>{u=Object.assign(u,e.annotations)})),e.forEach((e=>{e.entityContainer&&Object.keys(e.entityContainer).length>0&&(c=e.entityContainer,l=e.namespace)})),n.length>0&&a.forEach((e=>{const t=i.find((t=>t.fullyQualifiedName===e.entityTypeName));null==t||t.navigationProperties.forEach((t=>{const r=t,i=n.find((e=>e.association===r.relationship));if(i){const n=i.associationEnd.map((e=>a.find((t=>t.name===e.entitySet)))).find((t=>(null==t?void 0:t.fullyQualifiedName)!==e.fullyQualifiedName));n&&(e.navigationPropertyBinding[t.name]=n)}}))})),t.length>0&&i.forEach((e=>{e.navigationProperties.forEach((e=>{const n=e,a=t.find((e=>e.fullyQualifiedName===n.relationship));a&&a.referentialConstraints&&(n.referentialConstraint=a.referentialConstraints)}))})),{associations:t,associationSets:n,annotations:u,entityContainer:c,namespace:l,entitySets:a,singletons:r,complexTypes:s,actions:o,entityTypes:i}}(s),o)}},1878:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MergedParserOutput=t.ParserOutputInstance=t.ensureArray=void 0,t.ensureArray=function(e){return null==e?[]:Array.isArray(e)?e:[e]};t.ParserOutputInstance=class ParserOutputInstance{constructor(e,t,n,a){this.identification=e,this.references=a,this.version=t,this.schema=n}unalias(e){if(!e)return e;const[t,n]=e.split("."),a=this.references.find((e=>e.alias===t));if(a)return`${a.namespace}.${n}`;if(-1!==e.indexOf("@")){const[t,n]=e.split("@");return`${t}@${this.unalias(n)}`}return e}};t.MergedParserOutput=class MergedParserOutput{constructor(e){this._references=[],this._parserOutput=[],this._annotations={},this._associations=[],this._associationSets=[],this._entitySets=[],this._singletons=[],this._actions=[],this._entityContainer={},this._entityTypes=[],this._complexTypes=[],this.identification="mergedParserInstance",this.version=e.version,this._namespace=e.schema.namespace}get references(){return this._references}get schema(){return{associations:this._associations,associationSets:this._associationSets,annotations:this._annotations,entityContainer:this._entityContainer,namespace:this._namespace,entitySets:this._entitySets,singletons:this._singletons,complexTypes:this._complexTypes,actions:this._actions,entityTypes:this._entityTypes}}addParserOutput(e){this._parserOutput.push(e),this._references=this._references.concat(e.references),this._associations=this._associations.concat(e.schema.associations),this._associationSets=this._associationSets.concat(e.schema.associationSets),this._annotations=Object.assign(this._annotations,e.schema.annotations),this._entitySets=this._entitySets.concat(e.schema.entitySets),this._singletons=this._singletons.concat(e.schema.singletons),this._actions=this._actions.concat(e.schema.actions),this._entityTypes=this._entityTypes.concat(e.schema.entityTypes),this._complexTypes=this._complexTypes.concat(e.schema.complexTypes),this._entityContainer=Object.assign(this._entityContainer,e.schema.entityContainer)}unalias(e){if(!e)return e;const[t,n]=e.split("."),a=this.references.find((e=>e.alias===t));if(a)return`${a.namespace}.${n}`;if(-1!==e.indexOf("@")){const[t,n]=e.split("@");return`${t}@${this.unalias(n)}`}return e}}},6511:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.convertV2Annotations=void 0,t.convertV2Annotations=function(e,t,n){const a=[];if(e["sap:schema-version"]&&a.push({term:"Org.OData.Core.V1.SchemaVersion",value:{type:"String",String:e["sap:schema-version"]}}),e["sap:creatable"]&&"EntitySet"===t&&a.push({term:"Org.OData.Capabilities.V1.InsertRestrictions",record:{propertyValues:[{name:"Insertable",value:{type:"Bool",Bool:"true"===e["sap:creatable"]}}]}}),e["sap:creatable"]&&"NavigationProperty"===t&&a.push({term:"Org.OData.Capabilities.V1.NavigationRestrictions",record:{propertyValues:[{name:"RestrictedProperties",value:{type:"Record",Record:{propertyValues:[{name:"InsertRestrictrions",value:{type:"Record",Record:{propertyValues:[{name:"Insertable",value:{type:"Bool",Bool:"true"===e["sap:creatable"]}}]}}}]}}}]}}),e["sap:creatable-path"]&&"NavigationProperty"===t&&a.push({term:"Org.OData.Capabilities.V1.NavigationRestrictions",record:{propertyValues:[{name:"RestrictedProperties",value:{type:"Record",Record:{propertyValues:[{name:"InsertRestrictrions",value:{type:"Record",Record:{propertyValues:[{name:"Insertable",value:{type:"Path",Path:e["sap:creatable-path"]}}]}}}]}}}]}}),e["sap:updatable"]&&"EntitySet"===t&&a.push({term:"Org.OData.Capabilities.V1.UpdateRestrictions",record:{propertyValues:[{name:"Updatable",value:{type:"Bool",Bool:"true"===e["sap:updatable"]}}]}}),e["sap:updatable-path"]&&"EntitySet"===t&&a.push({term:"Org.OData.Capabilities.V1.UpdateRestrictions",record:{propertyValues:[{name:"Updatable",value:{type:"Path",Path:e["sap:updatable-path"]}}]}}),e["sap:deletable"]&&"EntitySet"===t&&a.push({term:"Org.OData.Capabilities.V1.DeleteRestrictions",record:{propertyValues:[{name:"Deletable",value:{type:"Bool",Bool:"true"===e["sap:updatable"]}}]}}),e["sap:deletable-path"]&&"EntitySet"===t&&a.push({term:"Org.OData.Capabilities.V1.DeleteRestrictions",record:{propertyValues:[{name:"Deletable",value:{type:"Path",Path:e["sap:deletable-path"]}}]}}),"true"===e["sap:creatable"]&&"false"===e["sap:updatable"]&&"Property"===t&&a.push({term:"Org.OData.Core.V1.Immutable",value:{type:"Bool",Bool:!0}}),"false"===e["sap:creatable"]&&"false"===e["sap:updatable"]&&"Property"===t&&a.push({term:"Org.OData.Core.V1.Computed",value:{type:"Bool",Bool:!0}}),e["sap:updatable-path"]&&"Property"===t&&a.push({term:"com.sap.vocabularies.Common.v1.FieldControl",value:{type:"Path",Path:e["sap:updatable-path"]}}),e["sap:searchable"]&&a.push({term:"Org.OData.Capabilities.V1.SearchRestrictions",record:{propertyValues:[{name:"Searachable",value:{type:"Bool",Bool:"true"===e["sap:searchable"]}}]}}),e["sap:pageable"]&&(a.push({term:"Org.OData.Capabilities.V1.TopSupported",value:{type:"Bool",Bool:"true"===e["sap:pageable"]}}),a.push({term:"Org.OData.Capabilities.V1.SkipSupported",value:{type:"Bool",Bool:"true"===e["sap:pageable"]}})),e["sap:topable"]&&a.push({term:"Org.OData.Capabilities.V1.TopSupported",value:{type:"Bool",Bool:"true"===e["sap:topable"]}}),e["sap:requires-filter"]&&a.push({term:"Org.OData.Capabilities.V1.FilterRestrictions",record:{propertyValues:[{name:"RequiresFilter",value:{type:"Bool",Bool:"true"===e["sap:requires-filter"]}}]}}),e["sap:required-in-filter"]&&a.push({term:"Org.OData.Capabilities.V1.FilterRestrictions",record:{propertyValues:[{name:"RequiredProperties",value:{type:"Collection",Collection:[{type:"PropertyPath",PropertyPath:n}]}}]}}),"false"===e["sap:filterable"]&&"Property"===t&&a.push({term:"Org.OData.Capabilities.V1.FilterRestrictions",record:{propertyValues:[{name:"NonFilterableProperties",value:{type:"Collection",Collection:[{type:"PropertyPath",PropertyPath:n}]}}]}}),"false"===e["sap:filterable"]&&"NavigationProperty"===t&&a.push({term:"Org.OData.Capabilities.V1.NavigationRestrictions",record:{propertyValues:[{name:"RestrictedProperties",value:{type:"Collection",Collection:[{type:"Record",propertyValues:[{name:"NavigationProperty",value:{type:"NavigationPropertyPath",NavigationPropertyPath:n}},{name:"FilterRestrictions",value:{type:"Record",Record:{propertyValues:[{name:"Filterable",value:{type:"Bool",Bool:!1}}]}}}]}]}}]}}),e["sap:filter-restricton"]&&a.push({term:"Org.OData.Capabilities.V1.FilterRestrictions",record:{propertyValues:[{name:"FilterExpressionRestrictions",value:{type:"Collection",Collection:[{type:"Record",propertyValues:[{name:"FilterExpressionRestrictions",value:{type:"String",String:e["sap:filter-restricton"]}},{name:"Property",value:{type:"PropertyPath",PropertyPath:n}}]}]}}]}}),"false"===e["sap:sortable"]&&a.push({term:"Org.OData.Capabilities.V1.SortRestrictions",record:{propertyValues:[{name:"NonSortableProperties",value:{type:"PropertyPath",PropertyPath:n}}]}}),"false"===e["sap:visible"]&&a.push({term:"com.sap.vocabularies.UI.v1.Hidden",value:{type:"Bool",Bool:!0}}),e["sap:label"]&&a.push({term:"com.sap.vocabularies.Common.v1.Label",value:{type:"String",String:e["sap:label"]}}),e["sap:heading"]&&a.push({term:"com.sap.vocabularies.Common.v1.Heading",value:{type:"String",String:e["sap:heading"]}}),e["sap:quickinfo"]&&a.push({term:"com.sap.vocabularies.Common.v1.QuickInfo",value:{type:"String",String:e["sap:quickinfo"]}}),e["sap:text"]&&a.push({term:"com.sap.vocabularies.Common.v1.Text",value:{type:"Path",Path:e["sap:text"]}}),e["sap:unit"]&&(a.push({term:"Org.OData.Measures.V1.Unit",value:{type:"Path",Path:e["sap:unit"]}}),a.push({term:"Org.OData.Measures.V1.ISOCurrency",value:{type:"Path",Path:e["sap:unit"]}})),e["sap:precision"]&&a.push({term:"Org.OData.Measures.V1.Scale",value:{type:"Int",Int:parseInt(e["sap:precision"])}}),"fixed-value"===e["sap:value-list"]&&a.push({term:"com.sap.vocabularies.Common.v1.ValueListWithFixedValues",value:{type:"Bool",Bool:!0}}),"NonNegative"===e["sap:display-format"]&&a.push({term:"com.sap.vocabularies.Common.v1.IsDigitSequence",value:{type:"Bool",Bool:!0}}),"UpperCase"===e["sap:display-format"]&&a.push({term:"com.sap.vocabularies.Common.v1.IsUpperCase",value:{type:"Bool",Bool:!0}}),e["sap:lower-boundary"]||e["sap:upper-boundary"]){const t=[];e["sap:lower-boundary"]&&t.push({name:"LowerBoundary",value:{type:"PropertyPath",PropertyPath:e["sap:lower-boundary"]}}),e["sap:upper-boundary"]&&t.push({name:"UpperBoundary",value:{type:"PropertyPath",PropertyPath:e["sap:upper-boundary"]}}),a.push({term:"com.sap.vocabularies.Common.v1.Interval",record:{propertyValues:t}})}return e["sap:field-control"]&&a.push({term:"com.sap.vocabularies.Common.v1.FieldControl",value:{type:"Path",Path:e["sap:field-control"]}}),e["sap:applicable-path"]&&a.push({term:"Org.OData.Core.V1.OperationAvailable",value:{type:"Path",Path:e["sap:applicable-path"]}}),e["sap:minoccurs"]&&a.push({term:"com.sap.vocabularies.Common.v1.MinOccurs",value:{type:"Int",Int:parseInt(e["sap:minoccurs"])}}),e["sap:maxoccurs"]&&a.push({term:"com.sap.vocabularies.Common.v1.MaxOccurs",value:{type:"Int",Int:parseInt(e["sap:maxoccurs"])}}),"mandatory"===e["sap:parameter"]&&a.push({term:"com.sap.vocabularies.Common.v1.FieldControl",value:{type:"EnumMember",EnumMember:"Common.FieldControlType/Mandatory"}}),"optional"===e["sap:parameter"]&&a.push({term:"com.sap.vocabularies.Common.v1.FieldControl",value:{type:"EnumMember",EnumMember:"Common.FieldControlType/Optional"}}),e["sap:attribute-for"]&&a.push({term:"com.sap.vocabularies.Common.v1.Attributes",value:{type:"Collection",Collection:[{type:"PropertyPath",PropertyPath:n}]}}),a}},9520:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.generateCustomAction=t.enhanceManifestAndGetActionsElementReference=void 0;const a=n(5955),r=n(6244),i=n(4022),o=n(5622),s=n(5179),c=n(1386),l=n(6201);function u(e,t){const n=e["sap.ui5"].routing.targets[t.page];if(n.options=n.options||{},n.options.settings=n.options.settings||{},t.control===i.TargetControl.header||t.control===i.TargetControl.footer)return n.options.settings.content=n.options.settings.content||{},n.options.settings.content[t.control]=n.options.settings.content[t.control]||{},n.options.settings.content[t.control].actions=n.options.settings.content[t.control].actions||{},n.options.settings.content[t.control].actions;{const e=t.navProperty?t.navProperty+"/":"",a=t.qualifier?"#"+t.qualifier:"",r=`${e}${t.control}${a}`;return n.options.settings.controlConfiguration=n.options.settings.controlConfiguration||{},n.options.settings.controlConfiguration[r]=n.options.settings.controlConfiguration[r]||{},n.options.settings.controlConfiguration[r].actions=n.options.settings.controlConfiguration[r].actions||{},n.options.settings.controlConfiguration[r].actions}}t.enhanceManifestAndGetActionsElementReference=u,t.generateCustomAction=function(e,t,n){(0,c.validateVersion)(t.ui5Version),n||(n=(0,r.create)((0,a.create)())),(0,c.validateBasePath)(e,n);const i=(0,o.join)(e,"webapp/manifest.json"),p=n.readJSON(i),f=function(e,t,n){const a=Object.assign(Object.assign({},e),{target:Object.assign({},e.target),settings:Object.assign({},e.settings)});return(0,l.setCommonDefaults)(a,t,n),a.settings.enabled=a.settings.enabled||!0,a.settings.visible=a.settings.visible||!0,a}(t,i,p),d=(0,o.join)(__dirname,"../../templates");!0===f.settings.eventHandler&&(n.copyTpl((0,o.join)(d,"common/EventHandler.js"),(0,o.join)(f.path,`${f.name}.js`),f),f.settings.eventHandler=`${f.ns}.${f.name}.onPress`);const h=u(p,f.target);return Object.assign(h,JSON.parse((0,s.render)(n.read((0,o.join)(d,"action/manifest.action.json")),f))),n.writeJSON(i,p),n}},4022:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TargetControl=void 0,function(e){e.header="header",e.footer="footer",e.section="@com.sap.vocabularies.UI.v1.FieldGroup",e.table="@com.sap.vocabularies.UI.v1.LineItem"}(t.TargetControl||(t.TargetControl={}))},8536:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.generateCustomColumn=t.getManifestRoot=void 0;const a=n(1386),r=n(5955),i=n(6244),o=n(5622),s=n(5179),c=n(6201);function l(e){return void 0===e||e>=1.86?(0,o.join)(__dirname,"../../templates/column/1.86"):1.85===e?(0,o.join)(__dirname,"../../templates/column/1.85"):(0,o.join)(__dirname,"../../templates/column/1.84")}t.getManifestRoot=l,t.generateCustomColumn=function(e,t,n){(0,a.validateVersion)(t.ui5Version),n||(n=(0,i.create)((0,r.create)())),(0,a.validateBasePath)(e,n);const u=(0,o.join)(e,"webapp/manifest.json"),p=n.readJSON(u),f=(0,o.join)(__dirname,"../../templates"),d=function(e,t,n){const a=Object.assign({},e);if((0,c.setCommonDefaults)(a,t,n),!0===a.eventHandler&&(a.eventHandler=`${a.ns}.${a.name}.onPress`),a.control)a.content=a.control;else{const e=a.properties&&a.properties.length>0?`{=%{${a.properties.join("} + ' ' + %{")}}}`:"Sample Text";if(a.eventHandler){const t=a.eventHandler.split("."),n=t.pop(),r=t.join("/");a.content=`<Button core:require="{ handler: '${r}'}" text="${e}" press="handler.${n}" />`}else a.content=`<Text text="${e}" />`}return a}(t,u,p);d.eventHandler&&n.copyTpl((0,o.join)(f,"common/EventHandler.js"),(0,o.join)(d.path,`${d.name}.js`),d);const h=l(t.ui5Version),g=(0,s.render)(n.read((0,o.join)(h,"manifest.json")),d);n.extendJSON(u,JSON.parse(g));const m=(0,o.join)(d.path,`${d.name}.fragment.xml`);return n.copyTpl((0,o.join)(f,"column/ext/CustomColumnFragment.xml"),m,d),n}},6201:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setCommonDefaults=void 0;const a=n(5622);t.setCommonDefaults=function(e,t,n){const r=e.name[0];return e.name=r.toUpperCase()+e.name.substring(1),e.folder=e.folder||`ext/${r.toLocaleLowerCase()+e.name.substring(1)}`,e.ns=`${n["sap.app"].id}.${e.folder.replace(/\//g,".")}`,e.path=(0,a.join)((0,a.dirname)(t),e.folder),e}},1386:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.validateBasePath=t.validateVersion=void 0;const a=n(5622),r=n(5955),i=n(6244);t.validateVersion=function(e){if(e&&e<1.84)throw new Error("SAP Fiori elements for OData v4 is only supported starting with SAPUI5 1.84.");return!0},t.validateBasePath=function(e,t){var n,o,s;t||(t=(0,i.create)((0,r.create)()));const c=(0,a.join)(e,"webapp","manifest.json");if(!t.exists(c))throw new Error(`Invalid project folder. Cannot find required file ${c}`);if(void 0!==(null===(s=null===(o=null===(n=t.readJSON(c)["sap.ui5"])||void 0===n?void 0:n.dependencies)||void 0===o?void 0:o.libs)||void 0===s?void 0:s["sap.fe.templates"])==!1)throw new Error("Dependency sap.fe.templates is missing in the manifest.json. Fiori elements FPM requires the SAP FE libraries.");return!0}},8861:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.validateVersion=t.validateBasePath=t.generateCustomColumn=t.generateCustomAction=t.TargetControl=t.generateCustomPage=void 0;var a=n(8071);Object.defineProperty(t,"generateCustomPage",{enumerable:!0,get:function(){return a.generateCustomPage}});var r=n(4022);Object.defineProperty(t,"TargetControl",{enumerable:!0,get:function(){return r.TargetControl}});var i=n(9520);Object.defineProperty(t,"generateCustomAction",{enumerable:!0,get:function(){return i.generateCustomAction}});var o=n(8536);Object.defineProperty(t,"generateCustomColumn",{enumerable:!0,get:function(){return o.generateCustomColumn}});var s=n(1386);Object.defineProperty(t,"validateBasePath",{enumerable:!0,get:function(){return s.validateBasePath}}),Object.defineProperty(t,"validateVersion",{enumerable:!0,get:function(){return s.validateVersion}})},4822:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.enhanceData=void 0;const a=n(6201);t.enhanceData=function(e,t,n){const r=n.readJSON(t),i=(0,a.setCommonDefaults)(e,t,r);return void 0===i.view&&(i.view={title:i.name}),i}},8071:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.generateCustomPage=t.validateCustomPageConfig=t.getTemplateRoot=void 0;const a=n(5622),r=n(5955),i=n(6244),o=n(5179),s=n(4822),c=n(1386);function l(e){return void 0===e||e>=1.94?(0,a.join)(__dirname,"../../templates/page/1.94"):(0,a.join)(__dirname,"../../templates/page/1.84")}function u(e,t,n){var o,s;(0,c.validateVersion)(t.ui5Version),n||(n=(0,i.create)((0,r.create)())),(0,c.validateBasePath)(e,n);const l=n.readJSON((0,a.join)(e,"webapp/manifest.json"));if(t.navigation){if(!(null===(s=null===(o=l["sap.ui5"])||void 0===o?void 0:o.routing)||void 0===s?void 0:s.targets[t.navigation.sourcePage]))throw new Error(`Could not find navigation source ${t.navigation.sourcePage}!`);const e=l["sap.ui5"].routing.routes.find((e=>{var n;return e.name===(null===(n=t.navigation)||void 0===n?void 0:n.sourcePage)}));if(!e||!e.pattern||!e.target)throw new Error(`Missing or invalid routing configuration for navigation source ${t.navigation.sourcePage}!`)}return n}t.getTemplateRoot=l,t.validateCustomPageConfig=u,t.generateCustomPage=function(e,t,n){n=u(e,t,n);const r=(0,a.join)(e,"webapp/manifest.json"),i=(0,s.enhanceData)(t,r,n),c=l(t.ui5Version);return n.extendJSON(r,JSON.parse((0,o.render)(n.read((0,a.join)(c,"manifest.json")),i)),((e,t)=>("routes"===e&&function(e,t){const n={name:`${t.entity}${t.name}`};if(t.navigation){const a=e.find((e=>{var n;return e.name===(null===(n=t.navigation)||void 0===n?void 0:n.sourcePage)}));if(n.pattern=`${null==a?void 0:a.pattern.replace(":?query:","")}/${t.navigation.navEntity}({${t.navigation.navEntity}Key}):?query:`,(null==a?void 0:a.target.constructor)===Array){const e=a.target;n.target=e.length>2?[n.name]:[...e,n.name]}else n.target=n.name}else n.pattern=`${t.entity}({key}):?query:`,n.target=n.name;e.push(n)}(t,i),t))),n.copyTpl((0,a.join)(c,"ext/View.xml"),(0,a.join)(i.path,`${i.name}.view.xml`),i),n.copyTpl((0,a.join)(c,"ext/Controller.js"),(0,a.join)(i.path,`${i.name}.controller.js`),i),n}},6162:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Multiplicity=void 0,function(e){e.One="1",e.ZeroOrOne="0..1",e.Many="*",e.Unknown="unknown"}(t.Multiplicity||(t.Multiplicity={}))},2281:(e,t,n)=>{e.exports={change:n(6527)}},6527:e=>{let t=0;const n="changeUtils: ";function a(e){return JSON.stringify({fileName:e.id||("id-"+(new Date).valueOf()+"-"+t++).replace(/-/g,"_")+"_"+e.type,fileType:"change",changeType:e.type,moduleName:"",reference:e.reference,packageName:"",content:e.content||{},selector:{id:e.controlId,idIsLocal:!1,type:e.controlType},layer:e.isCustomer?"CUSTOMER_BASE":"VENDOR",texts:{},namespace:"apps/"+e.reference.replace(".Component","")+"/changes/",projectId:e.projectId,creation:e.creation||(new Date).valueOf(),originalLanguage:"",support:{generator:n+e.creatingTool,service:"",user:"",sapui5Version:e.sapui5Version,sourceChangeFileName:"",compositeCommand:""},oDataInformation:{},dependentSelector:{},validAppVersions:{from:e.appVersion,to:e.appVersion,creation:e.appVersion},jsOnly:!1,variantReference:"",appDescriptorChange:!1})}e.exports={parse:function(e){const t=JSON.parse(e);if(!(t.fileName&&t.changeType&&t.selector&&t.reference&&t.creation&&t.content&&t.layer&&t.support))throw Error("Parsed object does not contain all required parameters");return{id:t.fileName,reference:t.reference,appVersion:t.validAppVersions?t.validAppVersions.creation:"",creation:t.creation,projectId:t.projectId,type:t.changeType,controlId:t.selector.id,controlType:t.selector.type,isCustomer:"CUSTOMER_BASE"===t.layer,creatingTool:t.support.generator.replace(n,""),content:t.content,sapui5Version:t.support.sapui5Version}},createChangeString:function(e,t){if(!e.type||!e.controlId||"boolean"!=typeof e.isCustomer||!e.creatingTool)throw Error("not all property parameters of the change were provided");if(!t)throw Error("no manifest was provided");return e.reference=function(e){const t=e["sap.ui5"];if(t){if(t.appVariantId)return t.appVariantId;if(t.componentName)return(n=t.componentName)&&n.indexOf(".Component")<0&&(n+=".Component"),n}var n;const a=e["sap.app"];if(!a||!a.id)throw Error("app ID could not be determined");return a.id}(t),e.appVersion=function(e){const t=e["sap.app"];if(!t||!t.applicationVersion||!t.applicationVersion.version)throw Error("app version could not be determined");return t.applicationVersion.version}(t),e.projectId=function(e,t){return e&&e["sap.app"]&&e["sap.app"].sourceTemplate&&["ui5template.smartTemplate","ui5template.smarttemplate"].includes(e["sap.app"].sourceTemplate.id)?t:""}(t,e.reference),a(e)},toString:function(e){if(!(e.type&&e.controlId&&"boolean"==typeof e.isCustomer&&e.creatingTool&&e.reference&&e.appVersion))throw Error("not all parameters of the change were provided");return a(e)}}},1199:(e,t,n)=>{"use strict";var a=n(5520),r=n(216),i=n(294),o=n(493),s=n(9003),c=n(8636),l=n(4653),u=n(5701),p=n(7559);e.exports=y,y.prototype.validate=function(e,t){var n;if("string"==typeof e){if(!(n=this.getSchema(e)))throw new Error('no schema with key or ref "'+e+'"')}else{var a=this._addSchema(e);n=a.validate||this._compile(a)}var r=n(t);!0!==n.$async&&(this.errors=n.errors);return r},y.prototype.compile=function(e,t){var n=this._addSchema(e,void 0,t);return n.validate||this._compile(n)},y.prototype.addSchema=function(e,t,n,a){if(Array.isArray(e)){for(var i=0;i<e.length;i++)this.addSchema(e[i],void 0,n,a);return this}var o=this._getId(e);if(void 0!==o&&"string"!=typeof o)throw new Error("schema id must be string");return O(this,t=r.normalizeId(t||o)),this._schemas[t]=this._addSchema(e,n,a,!0),this},y.prototype.addMetaSchema=function(e,t,n){return this.addSchema(e,t,n,!0),this},y.prototype.validateSchema=function(e,t){var n=e.$schema;if(void 0!==n&&"string"!=typeof n)throw new Error("$schema must be a string");if(!(n=n||this._opts.defaultMeta||function(e){var t=e._opts.meta;return e._opts.defaultMeta="object"==typeof t?e._getId(t)||t:e.getSchema(h)?h:void 0,e._opts.defaultMeta}(this)))return this.logger.warn("meta-schema not available"),this.errors=null,!0;var a=this.validate(n,e);if(!a&&t){var r="schema is invalid: "+this.errorsText();if("log"!=this._opts.validateSchema)throw new Error(r);this.logger.error(r)}return a},y.prototype.getSchema=function(e){var t=v(this,e);switch(typeof t){case"object":return t.validate||this._compile(t);case"string":return this.getSchema(t);case"undefined":return function(e,t){var n=r.schema.call(e,{schema:{}},t);if(n){var i=n.schema,s=n.root,c=n.baseId,l=a.call(e,i,s,void 0,c);return e._fragments[t]=new o({ref:t,fragment:!0,schema:i,root:s,baseId:c,validate:l}),l}}(this,e)}},y.prototype.removeSchema=function(e){if(e instanceof RegExp)return b(this,this._schemas,e),b(this,this._refs,e),this;switch(typeof e){case"undefined":return b(this,this._schemas),b(this,this._refs),this._cache.clear(),this;case"string":var t=v(this,e);return t&&this._cache.del(t.cacheKey),delete this._schemas[e],delete this._refs[e],this;case"object":var n=this._opts.serialize,a=n?n(e):e;this._cache.del(a);var i=this._getId(e);i&&(i=r.normalizeId(i),delete this._schemas[i],delete this._refs[i])}return this},y.prototype.addFormat=function(e,t){"string"==typeof t&&(t=new RegExp(t));return this._formats[e]=t,this},y.prototype.errorsText=function(e,t){if(!(e=e||this.errors))return"No errors";for(var n=void 0===(t=t||{}).separator?", ":t.separator,a=void 0===t.dataVar?"data":t.dataVar,r="",i=0;i<e.length;i++){var o=e[i];o&&(r+=a+o.dataPath+" "+o.message+n)}return r.slice(0,-n.length)},y.prototype._addSchema=function(e,t,n,a){if("object"!=typeof e&&"boolean"!=typeof e)throw new Error("schema should be object or boolean");var i=this._opts.serialize,s=i?i(e):e,c=this._cache.get(s);if(c)return c;a=a||!1!==this._opts.addUsedSchema;var l=r.normalizeId(this._getId(e));l&&a&&O(this,l);var u,p=!1!==this._opts.validateSchema&&!t;p&&!(u=l&&l==r.normalizeId(e.$schema))&&this.validateSchema(e,!0);var f=r.ids.call(this,e),d=new o({id:l,schema:e,localRefs:f,cacheKey:s,meta:n});"#"!=l[0]&&a&&(this._refs[l]=d);this._cache.put(s,d),p&&u&&this.validateSchema(e,!0);return d},y.prototype._compile=function(e,t){if(e.compiling)return e.validate=i,i.schema=e.schema,i.errors=null,i.root=t||i,!0===e.schema.$async&&(i.$async=!0),i;var n,r;e.compiling=!0,e.meta&&(n=this._opts,this._opts=this._metaOpts);try{r=a.call(this,e.schema,t,e.localRefs)}catch(t){throw delete e.validate,t}finally{e.compiling=!1,e.meta&&(this._opts=n)}return e.validate=r,e.refs=r.refs,e.refVal=r.refVal,e.root=r.root,r;function i(){var t=e.validate,n=t.apply(this,arguments);return i.errors=t.errors,n}},y.prototype.compileAsync=n(7850);var f=n(6019);y.prototype.addKeyword=f.add,y.prototype.getKeyword=f.get,y.prototype.removeKeyword=f.remove,y.prototype.validateKeyword=f.validate;var d=n(5587);y.ValidationError=d.Validation,y.MissingRefError=d.MissingRef,y.$dataMetaSchema=u;var h="http://json-schema.org/draft-07/schema",g=["removeAdditional","useDefaults","coerceTypes","strictDefaults"],m=["/properties"];function y(e){if(!(this instanceof y))return new y(e);e=this._opts=p.copy(e)||{},function(e){var t=e._opts.logger;if(!1===t)e.logger={log:E,warn:E,error:E};else{if(void 0===t&&(t=console),!("object"==typeof t&&t.log&&t.warn&&t.error))throw new Error("logger must implement log, warn and error methods");e.logger=t}}(this),this._schemas={},this._refs={},this._fragments={},this._formats=c(e.format),this._cache=e.cache||new i,this._loadingSchemas={},this._compilations=[],this.RULES=l(),this._getId=function(e){switch(e.schemaId){case"auto":return T;case"id":return P;default:return S}}(e),e.loopRequired=e.loopRequired||1/0,"property"==e.errorDataPath&&(e._errorDataPathProperty=!0),void 0===e.serialize&&(e.serialize=s),this._metaOpts=function(e){for(var t=p.copy(e._opts),n=0;n<g.length;n++)delete t[g[n]];return t}(this),e.formats&&function(e){for(var t in e._opts.formats){var n=e._opts.formats[t];e.addFormat(t,n)}}(this),e.keywords&&function(e){for(var t in e._opts.keywords){var n=e._opts.keywords[t];e.addKeyword(t,n)}}(this),function(e){var t;e._opts.$data&&(t=n(601),e.addMetaSchema(t,t.$id,!0));if(!1===e._opts.meta)return;var a=n(8938);e._opts.$data&&(a=u(a,m));e.addMetaSchema(a,h,!0),e._refs["http://json-schema.org/schema"]=h}(this),"object"==typeof e.meta&&this.addMetaSchema(e.meta),e.nullable&&this.addKeyword("nullable",{metaSchema:{type:"boolean"}}),function(e){var t=e._opts.schemas;if(!t)return;if(Array.isArray(t))e.addSchema(t);else for(var n in t)e.addSchema(t[n],n)}(this)}function v(e,t){return t=r.normalizeId(t),e._schemas[t]||e._refs[t]||e._fragments[t]}function b(e,t,n){for(var a in t){var r=t[a];r.meta||n&&!n.test(a)||(e._cache.del(r.cacheKey),delete t[a])}}function P(e){return e.$id&&this.logger.warn("schema $id ignored",e.$id),e.id}function S(e){return e.id&&this.logger.warn("schema id ignored",e.id),e.$id}function T(e){if(e.$id&&e.id&&e.$id!=e.id)throw new Error("schema $id is different from id");return e.$id||e.id}function O(e,t){if(e._schemas[t]||e._refs[t])throw new Error('schema with key or id "'+t+'" already exists')}function E(){}},294:e=>{"use strict";var t=e.exports=function(){this._cache={}};t.prototype.put=function(e,t){this._cache[e]=t},t.prototype.get=function(e){return this._cache[e]},t.prototype.del=function(e){delete this._cache[e]},t.prototype.clear=function(){this._cache={}}},7850:(e,t,n)=>{"use strict";var a=n(5587).MissingRef;e.exports=function e(t,n,r){var i=this;if("function"!=typeof this._opts.loadSchema)throw new Error("options.loadSchema should be a function");"function"==typeof n&&(r=n,n=void 0);var o=s(t).then((function(){var e=i._addSchema(t,void 0,n);return e.validate||c(e)}));r&&o.then((function(e){r(null,e)}),r);return o;function s(t){var n=t.$schema;return n&&!i.getSchema(n)?e.call(i,{$ref:n},!0):Promise.resolve()}function c(e){try{return i._compile(e)}catch(t){if(t instanceof a)return function(t){var a=t.missingSchema;if(l(a))throw new Error("Schema "+a+" is loaded but "+t.missingRef+" cannot be resolved");var r=i._loadingSchemas[a];r||(r=i._loadingSchemas[a]=i._opts.loadSchema(a)).then(o,o);return r.then((function(e){if(!l(a))return s(e).then((function(){l(a)||i.addSchema(e,a,void 0,n)}))})).then((function(){return c(e)}));function o(){delete i._loadingSchemas[a]}function l(e){return i._refs[e]||i._schemas[e]}}(t);throw t}}}},5587:(e,t,n)=>{"use strict";var a=n(216);function r(e,t,n){this.message=n||r.message(e,t),this.missingRef=a.url(e,t),this.missingSchema=a.normalizeId(a.fullPath(this.missingRef))}function i(e){return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}e.exports={Validation:i((function(e){this.message="validation failed",this.errors=e,this.ajv=this.validation=!0})),MissingRef:i(r)},r.message=function(e,t){return"can't resolve reference "+t+" from id "+e}},8636:(e,t,n)=>{"use strict";var a=n(7559),r=/^(\d\d\d\d)-(\d\d)-(\d\d)$/,i=[0,31,28,31,30,31,30,31,31,30,31,30,31],o=/^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i,s=/^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,c=/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,l=/^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,u=/^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,p=/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,f=/^(?:\/(?:[^~/]|~0|~1)*)*$/,d=/^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,h=/^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;function g(e){return e="full"==e?"full":"fast",a.copy(g[e])}function m(e){var t=e.match(r);if(!t)return!1;var n=+t[1],a=+t[2],o=+t[3];return a>=1&&a<=12&&o>=1&&o<=(2==a&&function(e){return e%4==0&&(e%100!=0||e%400==0)}(n)?29:i[a])}function y(e,t){var n=e.match(o);if(!n)return!1;var a=n[1],r=n[2],i=n[3],s=n[5];return(a<=23&&r<=59&&i<=59||23==a&&59==r&&60==i)&&(!t||s)}e.exports=g,g.fast={date:/^\d\d\d\d-[0-1]\d-[0-3]\d$/,time:/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,"date-time":/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,uri:/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,"uri-reference":/^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,"uri-template":l,url:u,email:/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,hostname:s,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:S,uuid:p,"json-pointer":f,"json-pointer-uri-fragment":d,"relative-json-pointer":h},g.full={date:m,time:y,"date-time":function(e){var t=e.split(v);return 2==t.length&&m(t[0])&&y(t[1],!0)},uri:function(e){return b.test(e)&&c.test(e)},"uri-reference":/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-template":l,url:u,email:/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,hostname:s,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:S,uuid:p,"json-pointer":f,"json-pointer-uri-fragment":d,"relative-json-pointer":h};var v=/t|\s/i;var b=/\/|:/;var P=/[^\\]\\Z/;function S(e){if(P.test(e))return!1;try{return new RegExp(e),!0}catch(e){return!1}}},5520:(e,t,n)=>{"use strict";var a=n(216),r=n(7559),i=n(5587),o=n(9003),s=n(2599),c=r.ucs2length,l=n(8926),u=i.Validation;function p(e,t,n){var a=d.call(this,e,t,n);return a>=0?{index:a,compiling:!0}:(a=this._compilations.length,this._compilations[a]={schema:e,root:t,baseId:n},{index:a,compiling:!1})}function f(e,t,n){var a=d.call(this,e,t,n);a>=0&&this._compilations.splice(a,1)}function d(e,t,n){for(var a=0;a<this._compilations.length;a++){var r=this._compilations[a];if(r.schema==e&&r.root==t&&r.baseId==n)return a}return-1}function h(e,t){return"var pattern"+e+" = new RegExp("+r.toQuotedString(t[e])+");"}function g(e){return"var default"+e+" = defaults["+e+"];"}function m(e,t){return void 0===t[e]?"":"var refVal"+e+" = refVal["+e+"];"}function y(e){return"var customRule"+e+" = customRules["+e+"];"}function v(e,t){if(!e.length)return"";for(var n="",a=0;a<e.length;a++)n+=t(a,e);return n}e.exports=function e(t,n,d,b){var P=this,S=this._opts,T=[void 0],O={},E=[],_={},C=[],A={},I=[];n=n||{schema:t,refVal:T,refs:O};var R=p.call(this,t,n,b),F=this._compilations[R.index];if(R.compiling)return F.callValidate=function e(){var t=F.validate,n=t.apply(this,arguments);return e.errors=t.errors,n};var x=this._formats,w=this.RULES;try{var j=L(t,n,d,b);F.validate=j;var N=F.callValidate;return N&&(N.schema=j.schema,N.errors=null,N.refs=j.refs,N.refVal=j.refVal,N.root=j.root,N.$async=j.$async,S.sourceCode&&(N.source=j.source)),j}finally{f.call(this,t,n,b)}function L(t,o,p,f){var d=!o||o&&o.schema==t;if(o.schema!=n.schema)return e.call(P,t,o,p,f);var b,_=!0===t.$async,A=s({isTop:!0,schema:t,isRoot:d,baseId:f,root:o,schemaPath:"",errSchemaPath:"#",errorPath:'""',MissingRefError:i.MissingRef,RULES:w,validate:s,util:r,resolve:a,resolveRef:D,usePattern:k,useDefault:$,useCustomRule:B,opts:S,formats:x,logger:P.logger,self:P});A=v(T,m)+v(E,h)+v(C,g)+v(I,y)+A,S.processCode&&(A=S.processCode(A,t));try{b=new Function("self","RULES","formats","root","refVal","defaults","customRules","equal","ucs2length","ValidationError",A)(P,w,x,n,T,C,I,l,c,u),T[0]=b}catch(e){throw P.logger.error("Error compiling schema, function code:",A),e}return b.schema=t,b.errors=null,b.refs=O,b.refVal=T,b.root=d?b:o,_&&(b.$async=!0),!0===S.sourceCode&&(b.source={code:A,patterns:E,defaults:C}),b}function D(t,r,i){r=a.url(t,r);var o,s,c=O[r];if(void 0!==c)return M(o=T[c],s="refVal["+c+"]");if(!i&&n.refs){var l=n.refs[r];if(void 0!==l)return M(o=n.refVal[l],s=V(r,o))}s=V(r);var u=a.call(P,L,n,r);if(void 0===u){var p=d&&d[r];p&&(u=a.inlineRef(p,S.inlineRefs)?p:e.call(P,p,n,d,t))}if(void 0!==u)return function(e,t){var n=O[e];T[n]=t}(r,u),M(u,s);!function(e){delete O[e]}(r)}function V(e,t){var n=T.length;return T[n]=t,O[e]=n,"refVal"+n}function M(e,t){return"object"==typeof e||"boolean"==typeof e?{code:t,schema:e,inline:!0}:{code:t,$async:e&&!!e.$async}}function k(e){var t=_[e];return void 0===t&&(t=_[e]=E.length,E[t]=e),"pattern"+t}function $(e){switch(typeof e){case"boolean":case"number":return""+e;case"string":return r.toQuotedString(e);case"object":if(null===e)return"null";var t=o(e),n=A[t];return void 0===n&&(n=A[t]=C.length,C[n]=e),"default"+n}}function B(e,t,n,a){if(!1!==P._opts.validateSchema){var r=e.definition.dependencies;if(r&&!r.every((function(e){return Object.prototype.hasOwnProperty.call(n,e)})))throw new Error("parent schema must have all required keywords: "+r.join(","));var i=e.definition.validateSchema;if(i)if(!i(t)){var o="keyword schema is invalid: "+P.errorsText(i.errors);if("log"!=P._opts.validateSchema)throw new Error(o);P.logger.error(o)}}var s,c=e.definition.compile,l=e.definition.inline,u=e.definition.macro;if(c)s=c.call(P,t,n,a);else if(u)s=u.call(P,t,n,a),!1!==S.validateSchema&&P.validateSchema(s,!0);else if(l)s=l.call(P,a,e.keyword,t,n);else if(!(s=e.definition.validate))return;if(void 0===s)throw new Error('custom keyword "'+e.keyword+'"failed to compile');var p=I.length;return I[p]=s,{code:"customRule"+p,validate:s}}}},216:(e,t,n)=>{"use strict";var a=n(5858),r=n(8926),i=n(7559),o=n(493),s=n(8125);function c(e,t,n){var a=this._refs[n];if("string"==typeof a){if(!this._refs[a])return c.call(this,e,t,a);a=this._refs[a]}if((a=a||this._schemas[n])instanceof o)return h(a.schema,this._opts.inlineRefs)?a.schema:a.validate||this._compile(a);var r,i,s,u=l.call(this,t,n);return u&&(r=u.schema,t=u.root,s=u.baseId),r instanceof o?i=r.validate||e.call(this,r.schema,t,void 0,s):void 0!==r&&(i=h(r,this._opts.inlineRefs)?r:e.call(this,r,t,void 0,s)),i}function l(e,t){var n=a.parse(t),r=v(n),i=y(this._getId(e.schema));if(0===Object.keys(e.schema).length||r!==i){var s=P(r),c=this._refs[s];if("string"==typeof c)return u.call(this,e,c,n);if(c instanceof o)c.validate||this._compile(c),e=c;else{if(!((c=this._schemas[s])instanceof o))return;if(c.validate||this._compile(c),s==P(t))return{schema:c,root:e,baseId:i};e=c}if(!e.schema)return;i=y(this._getId(e.schema))}return f.call(this,n,i,e.schema,e)}function u(e,t,n){var a=l.call(this,e,t);if(a){var r=a.schema,i=a.baseId;e=a.root;var o=this._getId(r);return o&&(i=S(i,o)),f.call(this,n,i,r,e)}}e.exports=c,c.normalizeId=P,c.fullPath=y,c.url=S,c.ids=function(e){var t=P(this._getId(e)),n={"":t},o={"":y(t,!1)},c={},l=this;return s(e,{allKeys:!0},(function(e,t,s,u,p,f,d){if(""!==t){var h=l._getId(e),g=n[u],m=o[u]+"/"+p;if(void 0!==d&&(m+="/"+("number"==typeof d?d:i.escapeFragment(d))),"string"==typeof h){h=g=P(g?a.resolve(g,h):h);var y=l._refs[h];if("string"==typeof y&&(y=l._refs[y]),y&&y.schema){if(!r(e,y.schema))throw new Error('id "'+h+'" resolves to more than one schema')}else if(h!=P(m))if("#"==h[0]){if(c[h]&&!r(e,c[h]))throw new Error('id "'+h+'" resolves to more than one schema');c[h]=e}else l._refs[h]=m}n[t]=g,o[t]=m}})),c},c.inlineRef=h,c.schema=l;var p=i.toHash(["properties","patternProperties","enum","dependencies","definitions"]);function f(e,t,n,a){if(e.fragment=e.fragment||"","/"==e.fragment.slice(0,1)){for(var r=e.fragment.split("/"),o=1;o<r.length;o++){var s=r[o];if(s){if(void 0===(n=n[s=i.unescapeFragment(s)]))break;var c;if(!p[s]&&((c=this._getId(n))&&(t=S(t,c)),n.$ref)){var u=S(t,n.$ref),f=l.call(this,a,u);f&&(n=f.schema,a=f.root,t=f.baseId)}}}return void 0!==n&&n!==a.schema?{schema:n,root:a,baseId:t}:void 0}}var d=i.toHash(["type","format","pattern","maxLength","minLength","maxProperties","minProperties","maxItems","minItems","maximum","minimum","uniqueItems","multipleOf","required","enum"]);function h(e,t){return!1!==t&&(void 0===t||!0===t?g(e):t?m(e)<=t:void 0)}function g(e){var t;if(Array.isArray(e)){for(var n=0;n<e.length;n++)if("object"==typeof(t=e[n])&&!g(t))return!1}else for(var a in e){if("$ref"==a)return!1;if("object"==typeof(t=e[a])&&!g(t))return!1}return!0}function m(e){var t,n=0;if(Array.isArray(e)){for(var a=0;a<e.length;a++)if("object"==typeof(t=e[a])&&(n+=m(t)),n==1/0)return 1/0}else for(var r in e){if("$ref"==r)return 1/0;if(d[r])n++;else if("object"==typeof(t=e[r])&&(n+=m(t)+1),n==1/0)return 1/0}return n}function y(e,t){return!1!==t&&(e=P(e)),v(a.parse(e))}function v(e){return a.serialize(e).split("#")[0]+"#"}var b=/#\/?$/;function P(e){return e?e.replace(b,""):""}function S(e,t){return t=P(t),a.resolve(e,t)}},4653:(e,t,n)=>{"use strict";var a=n(4478),r=n(7559).toHash;e.exports=function(){var e=[{type:"number",rules:[{maximum:["exclusiveMaximum"]},{minimum:["exclusiveMinimum"]},"multipleOf","format"]},{type:"string",rules:["maxLength","minLength","pattern","format"]},{type:"array",rules:["maxItems","minItems","items","contains","uniqueItems"]},{type:"object",rules:["maxProperties","minProperties","required","dependencies","propertyNames",{properties:["additionalProperties","patternProperties"]}]},{rules:["$ref","const","enum","not","anyOf","oneOf","allOf","if"]}],t=["type","$comment"];return e.all=r(t),e.types=r(["number","integer","string","array","object","boolean","null"]),e.forEach((function(n){n.rules=n.rules.map((function(n){var r;if("object"==typeof n){var i=Object.keys(n)[0];r=n[i],n=i,r.forEach((function(n){t.push(n),e.all[n]=!0}))}return t.push(n),e.all[n]={keyword:n,code:a[n],implements:r}})),e.all.$comment={keyword:"$comment",code:a.$comment},n.type&&(e.types[n.type]=n)})),e.keywords=r(t.concat(["$schema","$id","id","$data","$async","title","description","default","definitions","examples","readOnly","writeOnly","contentMediaType","contentEncoding","additionalItems","then","else"])),e.custom={},e}},493:(e,t,n)=>{"use strict";var a=n(7559);e.exports=function(e){a.copy(e,this)}},7463:e=>{"use strict";e.exports=function(e){for(var t,n=0,a=e.length,r=0;r<a;)n++,(t=e.charCodeAt(r++))>=55296&&t<=56319&&r<a&&56320==(64512&(t=e.charCodeAt(r)))&&r++;return n}},7559:(e,t,n)=>{"use strict";function a(e,t,n,a){var r=a?" !== ":" === ",i=a?" || ":" && ",o=a?"!":"",s=a?"":"!";switch(e){case"null":return t+r+"null";case"array":return o+"Array.isArray("+t+")";case"object":return"("+o+t+i+"typeof "+t+r+'"object"'+i+s+"Array.isArray("+t+"))";case"integer":return"(typeof "+t+r+'"number"'+i+s+"("+t+" % 1)"+i+t+r+t+(n?i+o+"isFinite("+t+")":"")+")";case"number":return"(typeof "+t+r+'"'+e+'"'+(n?i+o+"isFinite("+t+")":"")+")";default:return"typeof "+t+r+'"'+e+'"'}}e.exports={copy:function(e,t){for(var n in t=t||{},e)t[n]=e[n];return t},checkDataType:a,checkDataTypes:function(e,t,n){switch(e.length){case 1:return a(e[0],t,n,!0);default:var r="",o=i(e);for(var s in o.array&&o.object&&(r=o.null?"(":"(!"+t+" || ",r+="typeof "+t+' !== "object")',delete o.null,delete o.array,delete o.object),o.number&&delete o.integer,o)r+=(r?" && ":"")+a(s,t,n,!0);return r}},coerceToTypes:function(e,t){if(Array.isArray(t)){for(var n=[],a=0;a<t.length;a++){var i=t[a];(r[i]||"array"===e&&"array"===i)&&(n[n.length]=i)}if(n.length)return n}else{if(r[t])return[t];if("array"===e&&"array"===t)return["array"]}},toHash:i,getProperty:c,escapeQuotes:l,equal:n(8926),ucs2length:n(7463),varOccurences:function(e,t){t+="[^0-9]";var n=e.match(new RegExp(t,"g"));return n?n.length:0},varReplace:function(e,t,n){return t+="([^0-9])",n=n.replace(/\$/g,"$$$$"),e.replace(new RegExp(t,"g"),n+"$1")},schemaHasRules:function(e,t){if("boolean"==typeof e)return!e;for(var n in e)if(t[n])return!0},schemaHasRulesExcept:function(e,t,n){if("boolean"==typeof e)return!e&&"not"!=n;for(var a in e)if(a!=n&&t[a])return!0},schemaUnknownRules:function(e,t){if("boolean"==typeof e)return;for(var n in e)if(!t[n])return n},toQuotedString:u,getPathExpr:function(e,t,n,a){return d(e,n?"'/' + "+t+(a?"":".replace(/~/g, '~0').replace(/\\//g, '~1')"):a?"'[' + "+t+" + ']'":"'[\\'' + "+t+" + '\\']'")},getPath:function(e,t,n){var a=u(n?"/"+h(t):c(t));return d(e,a)},getData:function(e,t,n){var a,r,i,o;if(""===e)return"rootData";if("/"==e[0]){if(!p.test(e))throw new Error("Invalid JSON-pointer: "+e);r=e,i="rootData"}else{if(!(o=e.match(f)))throw new Error("Invalid JSON-pointer: "+e);if(a=+o[1],"#"==(r=o[2])){if(a>=t)throw new Error("Cannot access property/index "+a+" levels up, current level is "+t);return n[t-a]}if(a>t)throw new Error("Cannot access data "+a+" levels up, current level is "+t);if(i="data"+(t-a||""),!r)return i}for(var s=i,l=r.split("/"),u=0;u<l.length;u++){var d=l[u];d&&(i+=c(g(d)),s+=" && "+i)}return s},unescapeFragment:function(e){return g(decodeURIComponent(e))},unescapeJsonPointer:g,escapeFragment:function(e){return encodeURIComponent(h(e))},escapeJsonPointer:h};var r=i(["string","number","integer","boolean","null"]);function i(e){for(var t={},n=0;n<e.length;n++)t[e[n]]=!0;return t}var o=/^[a-z$_][a-z$_0-9]*$/i,s=/'|\\/g;function c(e){return"number"==typeof e?"["+e+"]":o.test(e)?"."+e:"['"+l(e)+"']"}function l(e){return e.replace(s,"\\$&").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/\f/g,"\\f").replace(/\t/g,"\\t")}function u(e){return"'"+l(e)+"'"}var p=/^\/(?:[^~]|~0|~1)*$/,f=/^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;function d(e,t){return'""'==e?t:(e+" + "+t).replace(/([^\\])' \+ '/g,"$1")}function h(e){return e.replace(/~/g,"~0").replace(/\//g,"~1")}function g(e){return e.replace(/~1/g,"/").replace(/~0/g,"~")}},5701:e=>{"use strict";var t=["multipleOf","maximum","exclusiveMaximum","minimum","exclusiveMinimum","maxLength","minLength","pattern","additionalItems","maxItems","minItems","uniqueItems","maxProperties","minProperties","required","additionalProperties","enum","format","const"];e.exports=function(e,n){for(var a=0;a<n.length;a++){e=JSON.parse(JSON.stringify(e));var r,i=n[a].split("/"),o=e;for(r=1;r<i.length;r++)o=o[i[r]];for(r=0;r<t.length;r++){var s=t[r],c=o[s];c&&(o[s]={anyOf:[c,{$ref:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}]})}}return e}},4614:(e,t,n)=>{"use strict";var a=n(8938);e.exports={$id:"https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",definitions:{simpleTypes:a.definitions.simpleTypes},type:"object",dependencies:{schema:["validate"],$data:["validate"],statements:["inline"],valid:{not:{required:["macro"]}}},properties:{type:a.properties.type,schema:{type:"boolean"},statements:{type:"boolean"},dependencies:{type:"array",items:{type:"string"}},metaSchema:{type:"object"},modifying:{type:"boolean"},valid:{type:"boolean"},$data:{type:"boolean"},async:{type:"boolean"},errors:{anyOf:[{type:"boolean"},{const:"full"}]}}}},5946:e=>{"use strict";e.exports=function(e,t,n){var a,r=" ",i=e.level,o=e.dataLevel,s=e.schema[t],c=e.schemaPath+e.util.getProperty(t),l=e.errSchemaPath+"/"+t,u=!e.opts.allErrors,p="data"+(o||""),f=e.opts.$data&&s&&s.$data;f?(r+=" var schema"+i+" = "+e.util.getData(s.$data,o,e.dataPathArr)+"; ",a="schema"+i):a=s;var d="maximum"==t,h=d?"exclusiveMaximum":"exclusiveMinimum",g=e.schema[h],m=e.opts.$data&&g&&g.$data,y=d?"<":">",v=d?">":"<",b=void 0;if(!f&&"number"!=typeof s&&void 0!==s)throw new Error(t+" must be number");if(!m&&void 0!==g&&"number"!=typeof g&&"boolean"!=typeof g)throw new Error(h+" must be number or boolean");if(m){var P=e.util.getData(g.$data,o,e.dataPathArr),S="exclusive"+i,T="exclType"+i,O="exclIsNumber"+i,E="' + "+(A="op"+i)+" + '";r+=" var schemaExcl"+i+" = "+P+"; ",r+=" var "+S+"; var "+T+" = typeof "+(P="schemaExcl"+i)+"; if ("+T+" != 'boolean' && "+T+" != 'undefined' && "+T+" != 'number') { ";var _;b=h;(_=_||[]).push(r),r="",!1!==e.createErrors?(r+=" { keyword: '"+(b||"_exclusiveLimit")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: {} ",!1!==e.opts.messages&&(r+=" , message: '"+h+" should be boolean' "),e.opts.verbose&&(r+=" , schema: validate.schema"+c+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" "),r+=" } "):r+=" {} ";var C=r;r=_.pop(),!e.compositeRule&&u?e.async?r+=" throw new ValidationError(["+C+"]); ":r+=" validate.errors = ["+C+"]; return false; ":r+=" var err = "+C+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",r+=" } else if ( ",f&&(r+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),r+=" "+T+" == 'number' ? ( ("+S+" = "+a+" === undefined || "+P+" "+y+"= "+a+") ? "+p+" "+v+"= "+P+" : "+p+" "+v+" "+a+" ) : ( ("+S+" = "+P+" === true) ? "+p+" "+v+"= "+a+" : "+p+" "+v+" "+a+" ) || "+p+" !== "+p+") { var op"+i+" = "+S+" ? '"+y+"' : '"+y+"='; ",void 0===s&&(b=h,l=e.errSchemaPath+"/"+h,a=P,f=m)}else{E=y;if((O="number"==typeof g)&&f){var A="'"+E+"'";r+=" if ( ",f&&(r+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),r+=" ( "+a+" === undefined || "+g+" "+y+"= "+a+" ? "+p+" "+v+"= "+g+" : "+p+" "+v+" "+a+" ) || "+p+" !== "+p+") { "}else{O&&void 0===s?(S=!0,b=h,l=e.errSchemaPath+"/"+h,a=g,v+="="):(O&&(a=Math[d?"min":"max"](g,s)),g===(!O||a)?(S=!0,b=h,l=e.errSchemaPath+"/"+h,v+="="):(S=!1,E+="="));A="'"+E+"'";r+=" if ( ",f&&(r+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),r+=" "+p+" "+v+" "+a+" || "+p+" !== "+p+") { "}}b=b||t,(_=_||[]).push(r),r="",!1!==e.createErrors?(r+=" { keyword: '"+(b||"_limit")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { comparison: "+A+", limit: "+a+", exclusive: "+S+" } ",!1!==e.opts.messages&&(r+=" , message: 'should be "+E+" ",r+=f?"' + "+a:a+"'"),e.opts.verbose&&(r+=" , schema:  ",r+=f?"validate.schema"+c:""+s,r+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" "),r+=" } "):r+=" {} ";C=r;return r=_.pop(),!e.compositeRule&&u?e.async?r+=" throw new ValidationError(["+C+"]); ":r+=" validate.errors = ["+C+"]; return false; ":r+=" var err = "+C+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",r+=" } ",u&&(r+=" else { "),r}},953:e=>{"use strict";e.exports=function(e,t,n){var a,r=" ",i=e.level,o=e.dataLevel,s=e.schema[t],c=e.schemaPath+e.util.getProperty(t),l=e.errSchemaPath+"/"+t,u=!e.opts.allErrors,p="data"+(o||""),f=e.opts.$data&&s&&s.$data;if(f?(r+=" var schema"+i+" = "+e.util.getData(s.$data,o,e.dataPathArr)+"; ",a="schema"+i):a=s,!f&&"number"!=typeof s)throw new Error(t+" must be number");r+="if ( ",f&&(r+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),r+=" "+p+".length "+("maxItems"==t?">":"<")+" "+a+") { ";var d=t,h=h||[];h.push(r),r="",!1!==e.createErrors?(r+=" { keyword: '"+(d||"_limitItems")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { limit: "+a+" } ",!1!==e.opts.messages&&(r+=" , message: 'should NOT have ",r+="maxItems"==t?"more":"fewer",r+=" than ",r+=f?"' + "+a+" + '":""+s,r+=" items' "),e.opts.verbose&&(r+=" , schema:  ",r+=f?"validate.schema"+c:""+s,r+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" "),r+=" } "):r+=" {} ";var g=r;return r=h.pop(),!e.compositeRule&&u?e.async?r+=" throw new ValidationError(["+g+"]); ":r+=" validate.errors = ["+g+"]; return false; ":r+=" var err = "+g+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",r+="} ",u&&(r+=" else { "),r}},849:e=>{"use strict";e.exports=function(e,t,n){var a,r=" ",i=e.level,o=e.dataLevel,s=e.schema[t],c=e.schemaPath+e.util.getProperty(t),l=e.errSchemaPath+"/"+t,u=!e.opts.allErrors,p="data"+(o||""),f=e.opts.$data&&s&&s.$data;if(f?(r+=" var schema"+i+" = "+e.util.getData(s.$data,o,e.dataPathArr)+"; ",a="schema"+i):a=s,!f&&"number"!=typeof s)throw new Error(t+" must be number");var d="maxLength"==t?">":"<";r+="if ( ",f&&(r+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),!1===e.opts.unicode?r+=" "+p+".length ":r+=" ucs2length("+p+") ",r+=" "+d+" "+a+") { ";var h=t,g=g||[];g.push(r),r="",!1!==e.createErrors?(r+=" { keyword: '"+(h||"_limitLength")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { limit: "+a+" } ",!1!==e.opts.messages&&(r+=" , message: 'should NOT be ",r+="maxLength"==t?"longer":"shorter",r+=" than ",r+=f?"' + "+a+" + '":""+s,r+=" characters' "),e.opts.verbose&&(r+=" , schema:  ",r+=f?"validate.schema"+c:""+s,r+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" "),r+=" } "):r+=" {} ";var m=r;return r=g.pop(),!e.compositeRule&&u?e.async?r+=" throw new ValidationError(["+m+"]); ":r+=" validate.errors = ["+m+"]; return false; ":r+=" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",r+="} ",u&&(r+=" else { "),r}},6107:e=>{"use strict";e.exports=function(e,t,n){var a,r=" ",i=e.level,o=e.dataLevel,s=e.schema[t],c=e.schemaPath+e.util.getProperty(t),l=e.errSchemaPath+"/"+t,u=!e.opts.allErrors,p="data"+(o||""),f=e.opts.$data&&s&&s.$data;if(f?(r+=" var schema"+i+" = "+e.util.getData(s.$data,o,e.dataPathArr)+"; ",a="schema"+i):a=s,!f&&"number"!=typeof s)throw new Error(t+" must be number");r+="if ( ",f&&(r+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),r+=" Object.keys("+p+").length "+("maxProperties"==t?">":"<")+" "+a+") { ";var d=t,h=h||[];h.push(r),r="",!1!==e.createErrors?(r+=" { keyword: '"+(d||"_limitProperties")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { limit: "+a+" } ",!1!==e.opts.messages&&(r+=" , message: 'should NOT have ",r+="maxProperties"==t?"more":"fewer",r+=" than ",r+=f?"' + "+a+" + '":""+s,r+=" properties' "),e.opts.verbose&&(r+=" , schema:  ",r+=f?"validate.schema"+c:""+s,r+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" "),r+=" } "):r+=" {} ";var g=r;return r=h.pop(),!e.compositeRule&&u?e.async?r+=" throw new ValidationError(["+g+"]); ":r+=" validate.errors = ["+g+"]; return false; ":r+=" var err = "+g+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",r+="} ",u&&(r+=" else { "),r}},2809:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.schema[t],i=e.schemaPath+e.util.getProperty(t),o=e.errSchemaPath+"/"+t,s=!e.opts.allErrors,c=e.util.copy(e),l="";c.level++;var u="valid"+c.level,p=c.baseId,f=!0,d=r;if(d)for(var h,g=-1,m=d.length-1;g<m;)h=d[g+=1],(e.opts.strictKeywords?"object"==typeof h&&Object.keys(h).length>0||!1===h:e.util.schemaHasRules(h,e.RULES.all))&&(f=!1,c.schema=h,c.schemaPath=i+"["+g+"]",c.errSchemaPath=o+"/"+g,a+="  "+e.validate(c)+" ",c.baseId=p,s&&(a+=" if ("+u+") { ",l+="}"));return s&&(a+=f?" if (true) { ":" "+l.slice(0,-1)+" "),a}},3407:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="valid"+r,f="errs__"+r,d=e.util.copy(e),h="";d.level++;var g="valid"+d.level;if(o.every((function(t){return e.opts.strictKeywords?"object"==typeof t&&Object.keys(t).length>0||!1===t:e.util.schemaHasRules(t,e.RULES.all)}))){var m=d.baseId;a+=" var "+f+" = errors; var "+p+" = false;  ";var y=e.compositeRule;e.compositeRule=d.compositeRule=!0;var v=o;if(v)for(var b,P=-1,S=v.length-1;P<S;)b=v[P+=1],d.schema=b,d.schemaPath=s+"["+P+"]",d.errSchemaPath=c+"/"+P,a+="  "+e.validate(d)+" ",d.baseId=m,a+=" "+p+" = "+p+" || "+g+"; if (!"+p+") { ",h+="}";e.compositeRule=d.compositeRule=y,a+=" "+h+" if (!"+p+") {   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'anyOf' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: {} ",!1!==e.opts.messages&&(a+=" , message: 'should match some schema in anyOf' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&&l&&(e.async?a+=" throw new ValidationError(vErrors); ":a+=" validate.errors = vErrors; return false; "),a+=" } else {  errors = "+f+"; if (vErrors !== null) { if ("+f+") vErrors.length = "+f+"; else vErrors = null; } ",e.opts.allErrors&&(a+=" } ")}else l&&(a+=" if (true) { ");return a}},8667:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.schema[t],i=e.errSchemaPath+"/"+t,o=(e.opts.allErrors,e.util.toQuotedString(r));return!0===e.opts.$comment?a+=" console.log("+o+");":"function"==typeof e.opts.$comment&&(a+=" self._opts.$comment("+o+", "+e.util.toQuotedString(i)+", validate.root.schema);"),a}},737:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="valid"+r,f=e.opts.$data&&o&&o.$data;f&&(a+=" var schema"+r+" = "+e.util.getData(o.$data,i,e.dataPathArr)+"; "),f||(a+=" var schema"+r+" = validate.schema"+s+";"),a+="var "+p+" = equal("+u+", schema"+r+"); if (!"+p+") {   ";var d=d||[];d.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'const' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { allowedValue: schema"+r+" } ",!1!==e.opts.messages&&(a+=" , message: 'should be equal to constant' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ";var h=a;return a=d.pop(),!e.compositeRule&&l?e.async?a+=" throw new ValidationError(["+h+"]); ":a+=" validate.errors = ["+h+"]; return false; ":a+=" var err = "+h+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" }",l&&(a+=" else { "),a}},5894:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="valid"+r,f="errs__"+r,d=e.util.copy(e);d.level++;var h="valid"+d.level,g="i"+r,m=d.dataLevel=e.dataLevel+1,y="data"+m,v=e.baseId,b=e.opts.strictKeywords?"object"==typeof o&&Object.keys(o).length>0||!1===o:e.util.schemaHasRules(o,e.RULES.all);if(a+="var "+f+" = errors;var "+p+";",b){var P=e.compositeRule;e.compositeRule=d.compositeRule=!0,d.schema=o,d.schemaPath=s,d.errSchemaPath=c,a+=" var "+h+" = false; for (var "+g+" = 0; "+g+" < "+u+".length; "+g+"++) { ",d.errorPath=e.util.getPathExpr(e.errorPath,g,e.opts.jsonPointers,!0);var S=u+"["+g+"]";d.dataPathArr[m]=g;var T=e.validate(d);d.baseId=v,e.util.varOccurences(T,y)<2?a+=" "+e.util.varReplace(T,y,S)+" ":a+=" var "+y+" = "+S+"; "+T+" ",a+=" if ("+h+") break; }  ",e.compositeRule=d.compositeRule=P,a+="  if (!"+h+") {"}else a+=" if ("+u+".length == 0) {";var O=O||[];O.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'contains' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: {} ",!1!==e.opts.messages&&(a+=" , message: 'should contain a valid item' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ";var E=a;return a=O.pop(),!e.compositeRule&&l?e.async?a+=" throw new ValidationError(["+E+"]); ":a+=" validate.errors = ["+E+"]; return false; ":a+=" var err = "+E+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else { ",b&&(a+="  errors = "+f+"; if (vErrors !== null) { if ("+f+") vErrors.length = "+f+"; else vErrors = null; } "),e.opts.allErrors&&(a+=" } "),a}},1120:e=>{"use strict";e.exports=function(e,t,n){var a,r,i=" ",o=e.level,s=e.dataLevel,c=e.schema[t],l=e.schemaPath+e.util.getProperty(t),u=e.errSchemaPath+"/"+t,p=!e.opts.allErrors,f="data"+(s||""),d="valid"+o,h="errs__"+o,g=e.opts.$data&&c&&c.$data;g?(i+=" var schema"+o+" = "+e.util.getData(c.$data,s,e.dataPathArr)+"; ",r="schema"+o):r=c;var m,y,v,b,P,S=this,T="definition"+o,O=S.definition,E="";if(g&&O.$data){P="keywordValidate"+o;var _=O.validateSchema;i+=" var "+T+" = RULES.custom['"+t+"'].definition; var "+P+" = "+T+".validate;"}else{if(!(b=e.useCustomRule(S,c,e.schema,e)))return;r="validate.schema"+l,P=b.code,m=O.compile,y=O.inline,v=O.macro}var C=P+".errors",A="i"+o,I="ruleErr"+o,R=O.async;if(R&&!e.async)throw new Error("async keyword in sync schema");if(y||v||(i+=C+" = null;"),i+="var "+h+" = errors;var "+d+";",g&&O.$data&&(E+="}",i+=" if ("+r+" === undefined) { "+d+" = true; } else { ",_&&(E+="}",i+=" "+d+" = "+T+".validateSchema("+r+"); if ("+d+") { ")),y)O.statements?i+=" "+b.validate+" ":i+=" "+d+" = "+b.validate+"; ";else if(v){var F=e.util.copy(e);E="";F.level++;var x="valid"+F.level;F.schema=b.validate,F.schemaPath="";var w=e.compositeRule;e.compositeRule=F.compositeRule=!0;var j=e.validate(F).replace(/validate\.schema/g,P);e.compositeRule=F.compositeRule=w,i+=" "+j}else{(V=V||[]).push(i),i="",i+="  "+P+".call( ",e.opts.passContext?i+="this":i+="self",m||!1===O.schema?i+=" , "+f+" ":i+=" , "+r+" , "+f+" , validate.schema"+e.schemaPath+" ",i+=" , (dataPath || '')",'""'!=e.errorPath&&(i+=" + "+e.errorPath);var N=s?"data"+(s-1||""):"parentData",L=s?e.dataPathArr[s]:"parentDataProperty",D=i+=" , "+N+" , "+L+" , rootData )  ";i=V.pop(),!1===O.errors?(i+=" "+d+" = ",R&&(i+="await "),i+=D+"; "):i+=R?" var "+(C="customErrors"+o)+" = null; try { "+d+" = await "+D+"; } catch (e) { "+d+" = false; if (e instanceof ValidationError) "+C+" = e.errors; else throw e; } ":" "+C+" = null; "+d+" = "+D+"; "}if(O.modifying&&(i+=" if ("+N+") "+f+" = "+N+"["+L+"];"),i+=""+E,O.valid)p&&(i+=" if (true) { ");else{var V;i+=" if ( ",void 0===O.valid?(i+=" !",i+=v?""+x:""+d):i+=" "+!O.valid+" ",i+=") { ",a=S.keyword,(V=V||[]).push(i),i="",(V=V||[]).push(i),i="",!1!==e.createErrors?(i+=" { keyword: '"+(a||"custom")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { keyword: '"+S.keyword+"' } ",!1!==e.opts.messages&&(i+=" , message: 'should pass \""+S.keyword+"\" keyword validation' "),e.opts.verbose&&(i+=" , schema: validate.schema"+l+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+f+" "),i+=" } "):i+=" {} ";var M=i;i=V.pop(),!e.compositeRule&&p?e.async?i+=" throw new ValidationError(["+M+"]); ":i+=" validate.errors = ["+M+"]; return false; ":i+=" var err = "+M+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";var k=i;i=V.pop(),y?O.errors?"full"!=O.errors&&(i+="  for (var "+A+"="+h+"; "+A+"<errors; "+A+"++) { var "+I+" = vErrors["+A+"]; if ("+I+".dataPath === undefined) "+I+".dataPath = (dataPath || '') + "+e.errorPath+"; if ("+I+".schemaPath === undefined) { "+I+'.schemaPath = "'+u+'"; } ',e.opts.verbose&&(i+=" "+I+".schema = "+r+"; "+I+".data = "+f+"; "),i+=" } "):!1===O.errors?i+=" "+k+" ":(i+=" if ("+h+" == errors) { "+k+" } else {  for (var "+A+"="+h+"; "+A+"<errors; "+A+"++) { var "+I+" = vErrors["+A+"]; if ("+I+".dataPath === undefined) "+I+".dataPath = (dataPath || '') + "+e.errorPath+"; if ("+I+".schemaPath === undefined) { "+I+'.schemaPath = "'+u+'"; } ',e.opts.verbose&&(i+=" "+I+".schema = "+r+"; "+I+".data = "+f+"; "),i+=" } } "):v?(i+="   var err =   ",!1!==e.createErrors?(i+=" { keyword: '"+(a||"custom")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { keyword: '"+S.keyword+"' } ",!1!==e.opts.messages&&(i+=" , message: 'should pass \""+S.keyword+"\" keyword validation' "),e.opts.verbose&&(i+=" , schema: validate.schema"+l+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+f+" "),i+=" } "):i+=" {} ",i+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&&p&&(e.async?i+=" throw new ValidationError(vErrors); ":i+=" validate.errors = vErrors; return false; ")):!1===O.errors?i+=" "+k+" ":(i+=" if (Array.isArray("+C+")) { if (vErrors === null) vErrors = "+C+"; else vErrors = vErrors.concat("+C+"); errors = vErrors.length;  for (var "+A+"="+h+"; "+A+"<errors; "+A+"++) { var "+I+" = vErrors["+A+"]; if ("+I+".dataPath === undefined) "+I+".dataPath = (dataPath || '') + "+e.errorPath+";  "+I+'.schemaPath = "'+u+'";  ',e.opts.verbose&&(i+=" "+I+".schema = "+r+"; "+I+".data = "+f+"; "),i+=" } } else { "+k+" } "),i+=" } ",p&&(i+=" else { ")}return i}},3995:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="errs__"+r,f=e.util.copy(e),d="";f.level++;var h="valid"+f.level,g={},m={},y=e.opts.ownProperties;for(S in o)if("__proto__"!=S){var v=o[S],b=Array.isArray(v)?m:g;b[S]=v}a+="var "+p+" = errors;";var P=e.errorPath;for(var S in a+="var missing"+r+";",m)if((b=m[S]).length){if(a+=" if ( "+u+e.util.getProperty(S)+" !== undefined ",y&&(a+=" && Object.prototype.hasOwnProperty.call("+u+", '"+e.util.escapeQuotes(S)+"') "),l){a+=" && ( ";var T=b;if(T)for(var O=-1,E=T.length-1;O<E;){F=T[O+=1],O&&(a+=" || "),a+=" ( ( "+(N=u+(j=e.util.getProperty(F)))+" === undefined ",y&&(a+=" || ! Object.prototype.hasOwnProperty.call("+u+", '"+e.util.escapeQuotes(F)+"') "),a+=") && (missing"+r+" = "+e.util.toQuotedString(e.opts.jsonPointers?F:j)+") ) "}a+=")) {  ";var _="missing"+r,C="' + "+_+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.opts.jsonPointers?e.util.getPathExpr(P,_,!0):P+" + "+_);var A=A||[];A.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'dependencies' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { property: '"+e.util.escapeQuotes(S)+"', missingProperty: '"+C+"', depsCount: "+b.length+", deps: '"+e.util.escapeQuotes(1==b.length?b[0]:b.join(", "))+"' } ",!1!==e.opts.messages&&(a+=" , message: 'should have ",1==b.length?a+="property "+e.util.escapeQuotes(b[0]):a+="properties "+e.util.escapeQuotes(b.join(", ")),a+=" when property "+e.util.escapeQuotes(S)+" is present' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ";var I=a;a=A.pop(),!e.compositeRule&&l?e.async?a+=" throw new ValidationError(["+I+"]); ":a+=" validate.errors = ["+I+"]; return false; ":a+=" var err = "+I+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}else{a+=" ) { ";var R=b;if(R)for(var F,x=-1,w=R.length-1;x<w;){F=R[x+=1];var j=e.util.getProperty(F),N=(C=e.util.escapeQuotes(F),u+j);e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPath(P,F,e.opts.jsonPointers)),a+=" if ( "+N+" === undefined ",y&&(a+=" || ! Object.prototype.hasOwnProperty.call("+u+", '"+e.util.escapeQuotes(F)+"') "),a+=") {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'dependencies' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { property: '"+e.util.escapeQuotes(S)+"', missingProperty: '"+C+"', depsCount: "+b.length+", deps: '"+e.util.escapeQuotes(1==b.length?b[0]:b.join(", "))+"' } ",!1!==e.opts.messages&&(a+=" , message: 'should have ",1==b.length?a+="property "+e.util.escapeQuotes(b[0]):a+="properties "+e.util.escapeQuotes(b.join(", ")),a+=" when property "+e.util.escapeQuotes(S)+" is present' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "}}a+=" }   ",l&&(d+="}",a+=" else { ")}e.errorPath=P;var L=f.baseId;for(var S in g){v=g[S];(e.opts.strictKeywords?"object"==typeof v&&Object.keys(v).length>0||!1===v:e.util.schemaHasRules(v,e.RULES.all))&&(a+=" "+h+" = true; if ( "+u+e.util.getProperty(S)+" !== undefined ",y&&(a+=" && Object.prototype.hasOwnProperty.call("+u+", '"+e.util.escapeQuotes(S)+"') "),a+=") { ",f.schema=v,f.schemaPath=s+e.util.getProperty(S),f.errSchemaPath=c+"/"+e.util.escapeFragment(S),a+="  "+e.validate(f)+" ",f.baseId=L,a+=" }  ",l&&(a+=" if ("+h+") { ",d+="}"))}return l&&(a+="   "+d+" if ("+p+" == errors) {"),a}},6783:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="valid"+r,f=e.opts.$data&&o&&o.$data;f&&(a+=" var schema"+r+" = "+e.util.getData(o.$data,i,e.dataPathArr)+"; ");var d="i"+r,h="schema"+r;f||(a+=" var "+h+" = validate.schema"+s+";"),a+="var "+p+";",f&&(a+=" if (schema"+r+" === undefined) "+p+" = true; else if (!Array.isArray(schema"+r+")) "+p+" = false; else {"),a+=p+" = false;for (var "+d+"=0; "+d+"<"+h+".length; "+d+"++) if (equal("+u+", "+h+"["+d+"])) { "+p+" = true; break; }",f&&(a+="  }  "),a+=" if (!"+p+") {   ";var g=g||[];g.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'enum' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { allowedValues: schema"+r+" } ",!1!==e.opts.messages&&(a+=" , message: 'should be equal to one of the allowed values' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ";var m=a;return a=g.pop(),!e.compositeRule&&l?e.async?a+=" throw new ValidationError(["+m+"]); ":a+=" validate.errors = ["+m+"]; return false; ":a+=" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" }",l&&(a+=" else { "),a}},184:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||"");if(!1===e.opts.format)return l&&(a+=" if (true) { "),a;var p,f=e.opts.$data&&o&&o.$data;f?(a+=" var schema"+r+" = "+e.util.getData(o.$data,i,e.dataPathArr)+"; ",p="schema"+r):p=o;var d=e.opts.unknownFormats,h=Array.isArray(d);if(f){a+=" var "+(g="format"+r)+" = formats["+p+"]; var "+(m="isObject"+r)+" = typeof "+g+" == 'object' && !("+g+" instanceof RegExp) && "+g+".validate; var "+(y="formatType"+r)+" = "+m+" && "+g+".type || 'string'; if ("+m+") { ",e.async&&(a+=" var async"+r+" = "+g+".async; "),a+=" "+g+" = "+g+".validate; } if (  ",f&&(a+=" ("+p+" !== undefined && typeof "+p+" != 'string') || "),a+=" (","ignore"!=d&&(a+=" ("+p+" && !"+g+" ",h&&(a+=" && self._opts.unknownFormats.indexOf("+p+") == -1 "),a+=") || "),a+=" ("+g+" && "+y+" == '"+n+"' && !(typeof "+g+" == 'function' ? ",e.async?a+=" (async"+r+" ? await "+g+"("+u+") : "+g+"("+u+")) ":a+=" "+g+"("+u+") ",a+=" : "+g+".test("+u+"))))) {"}else{var g;if(!(g=e.formats[o])){if("ignore"==d)return e.logger.warn('unknown format "'+o+'" ignored in schema at path "'+e.errSchemaPath+'"'),l&&(a+=" if (true) { "),a;if(h&&d.indexOf(o)>=0)return l&&(a+=" if (true) { "),a;throw new Error('unknown format "'+o+'" is used in schema at path "'+e.errSchemaPath+'"')}var m,y=(m="object"==typeof g&&!(g instanceof RegExp)&&g.validate)&&g.type||"string";if(m){var v=!0===g.async;g=g.validate}if(y!=n)return l&&(a+=" if (true) { "),a;if(v){if(!e.async)throw new Error("async format in sync schema");a+=" if (!(await "+(b="formats"+e.util.getProperty(o)+".validate")+"("+u+"))) { "}else{a+=" if (! ";var b="formats"+e.util.getProperty(o);m&&(b+=".validate"),a+="function"==typeof g?" "+b+"("+u+") ":" "+b+".test("+u+") ",a+=") { "}}var P=P||[];P.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'format' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { format:  ",a+=f?""+p:""+e.util.toQuotedString(o),a+="  } ",!1!==e.opts.messages&&(a+=" , message: 'should match format \"",a+=f?"' + "+p+" + '":""+e.util.escapeQuotes(o),a+="\"' "),e.opts.verbose&&(a+=" , schema:  ",a+=f?"validate.schema"+s:""+e.util.toQuotedString(o),a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ";var S=a;return a=P.pop(),!e.compositeRule&&l?e.async?a+=" throw new ValidationError(["+S+"]); ":a+=" validate.errors = ["+S+"]; return false; ":a+=" var err = "+S+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ",l&&(a+=" else { "),a}},555:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="valid"+r,f="errs__"+r,d=e.util.copy(e);d.level++;var h="valid"+d.level,g=e.schema.then,m=e.schema.else,y=void 0!==g&&(e.opts.strictKeywords?"object"==typeof g&&Object.keys(g).length>0||!1===g:e.util.schemaHasRules(g,e.RULES.all)),v=void 0!==m&&(e.opts.strictKeywords?"object"==typeof m&&Object.keys(m).length>0||!1===m:e.util.schemaHasRules(m,e.RULES.all)),b=d.baseId;if(y||v){var P;d.createErrors=!1,d.schema=o,d.schemaPath=s,d.errSchemaPath=c,a+=" var "+f+" = errors; var "+p+" = true;  ";var S=e.compositeRule;e.compositeRule=d.compositeRule=!0,a+="  "+e.validate(d)+" ",d.baseId=b,d.createErrors=!0,a+="  errors = "+f+"; if (vErrors !== null) { if ("+f+") vErrors.length = "+f+"; else vErrors = null; }  ",e.compositeRule=d.compositeRule=S,y?(a+=" if ("+h+") {  ",d.schema=e.schema.then,d.schemaPath=e.schemaPath+".then",d.errSchemaPath=e.errSchemaPath+"/then",a+="  "+e.validate(d)+" ",d.baseId=b,a+=" "+p+" = "+h+"; ",y&&v?a+=" var "+(P="ifClause"+r)+" = 'then'; ":P="'then'",a+=" } ",v&&(a+=" else { ")):a+=" if (!"+h+") { ",v&&(d.schema=e.schema.else,d.schemaPath=e.schemaPath+".else",d.errSchemaPath=e.errSchemaPath+"/else",a+="  "+e.validate(d)+" ",d.baseId=b,a+=" "+p+" = "+h+"; ",y&&v?a+=" var "+(P="ifClause"+r)+" = 'else'; ":P="'else'",a+=" } "),a+=" if (!"+p+") {   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'if' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { failingKeyword: "+P+" } ",!1!==e.opts.messages&&(a+=" , message: 'should match \"' + "+P+" + '\" schema' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&&l&&(e.async?a+=" throw new ValidationError(vErrors); ":a+=" validate.errors = vErrors; return false; "),a+=" }   ",l&&(a+=" else { ")}else l&&(a+=" if (true) { ");return a}},4478:(e,t,n)=>{"use strict";e.exports={$ref:n(1954),allOf:n(2809),anyOf:n(3407),$comment:n(8667),const:n(737),contains:n(5894),dependencies:n(3995),enum:n(6783),format:n(184),if:n(555),items:n(1244),maximum:n(5946),minimum:n(5946),maxItems:n(953),minItems:n(953),maxLength:n(849),minLength:n(849),maxProperties:n(6107),minProperties:n(6107),multipleOf:n(9159),not:n(3537),oneOf:n(9426),pattern:n(2955),properties:n(5224),propertyNames:n(3194),required:n(395),uniqueItems:n(1628),validate:n(2599)}},1244:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="valid"+r,f="errs__"+r,d=e.util.copy(e),h="";d.level++;var g="valid"+d.level,m="i"+r,y=d.dataLevel=e.dataLevel+1,v="data"+y,b=e.baseId;if(a+="var "+f+" = errors;var "+p+";",Array.isArray(o)){var P=e.schema.additionalItems;if(!1===P){a+=" "+p+" = "+u+".length <= "+o.length+"; ";var S=c;c=e.errSchemaPath+"/additionalItems",a+="  if (!"+p+") {   ";var T=T||[];T.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'additionalItems' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { limit: "+o.length+" } ",!1!==e.opts.messages&&(a+=" , message: 'should NOT have more than "+o.length+" items' "),e.opts.verbose&&(a+=" , schema: false , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ";var O=a;a=T.pop(),!e.compositeRule&&l?e.async?a+=" throw new ValidationError(["+O+"]); ":a+=" validate.errors = ["+O+"]; return false; ":a+=" var err = "+O+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ",c=S,l&&(h+="}",a+=" else { ")}var E=o;if(E)for(var _,C=-1,A=E.length-1;C<A;)if(_=E[C+=1],e.opts.strictKeywords?"object"==typeof _&&Object.keys(_).length>0||!1===_:e.util.schemaHasRules(_,e.RULES.all)){a+=" "+g+" = true; if ("+u+".length > "+C+") { ";var I=u+"["+C+"]";d.schema=_,d.schemaPath=s+"["+C+"]",d.errSchemaPath=c+"/"+C,d.errorPath=e.util.getPathExpr(e.errorPath,C,e.opts.jsonPointers,!0),d.dataPathArr[y]=C;var R=e.validate(d);d.baseId=b,e.util.varOccurences(R,v)<2?a+=" "+e.util.varReplace(R,v,I)+" ":a+=" var "+v+" = "+I+"; "+R+" ",a+=" }  ",l&&(a+=" if ("+g+") { ",h+="}")}if("object"==typeof P&&(e.opts.strictKeywords?"object"==typeof P&&Object.keys(P).length>0||!1===P:e.util.schemaHasRules(P,e.RULES.all))){d.schema=P,d.schemaPath=e.schemaPath+".additionalItems",d.errSchemaPath=e.errSchemaPath+"/additionalItems",a+=" "+g+" = true; if ("+u+".length > "+o.length+") {  for (var "+m+" = "+o.length+"; "+m+" < "+u+".length; "+m+"++) { ",d.errorPath=e.util.getPathExpr(e.errorPath,m,e.opts.jsonPointers,!0);I=u+"["+m+"]";d.dataPathArr[y]=m;R=e.validate(d);d.baseId=b,e.util.varOccurences(R,v)<2?a+=" "+e.util.varReplace(R,v,I)+" ":a+=" var "+v+" = "+I+"; "+R+" ",l&&(a+=" if (!"+g+") break; "),a+=" } }  ",l&&(a+=" if ("+g+") { ",h+="}")}}else if(e.opts.strictKeywords?"object"==typeof o&&Object.keys(o).length>0||!1===o:e.util.schemaHasRules(o,e.RULES.all)){d.schema=o,d.schemaPath=s,d.errSchemaPath=c,a+="  for (var "+m+" = 0; "+m+" < "+u+".length; "+m+"++) { ",d.errorPath=e.util.getPathExpr(e.errorPath,m,e.opts.jsonPointers,!0);I=u+"["+m+"]";d.dataPathArr[y]=m;R=e.validate(d);d.baseId=b,e.util.varOccurences(R,v)<2?a+=" "+e.util.varReplace(R,v,I)+" ":a+=" var "+v+" = "+I+"; "+R+" ",l&&(a+=" if (!"+g+") break; "),a+=" }"}return l&&(a+=" "+h+" if ("+f+" == errors) {"),a}},9159:e=>{"use strict";e.exports=function(e,t,n){var a,r=" ",i=e.level,o=e.dataLevel,s=e.schema[t],c=e.schemaPath+e.util.getProperty(t),l=e.errSchemaPath+"/"+t,u=!e.opts.allErrors,p="data"+(o||""),f=e.opts.$data&&s&&s.$data;if(f?(r+=" var schema"+i+" = "+e.util.getData(s.$data,o,e.dataPathArr)+"; ",a="schema"+i):a=s,!f&&"number"!=typeof s)throw new Error(t+" must be number");r+="var division"+i+";if (",f&&(r+=" "+a+" !== undefined && ( typeof "+a+" != 'number' || "),r+=" (division"+i+" = "+p+" / "+a+", ",e.opts.multipleOfPrecision?r+=" Math.abs(Math.round(division"+i+") - division"+i+") > 1e-"+e.opts.multipleOfPrecision+" ":r+=" division"+i+" !== parseInt(division"+i+") ",r+=" ) ",f&&(r+="  )  "),r+=" ) {   ";var d=d||[];d.push(r),r="",!1!==e.createErrors?(r+=" { keyword: 'multipleOf' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { multipleOf: "+a+" } ",!1!==e.opts.messages&&(r+=" , message: 'should be multiple of ",r+=f?"' + "+a:a+"'"),e.opts.verbose&&(r+=" , schema:  ",r+=f?"validate.schema"+c:""+s,r+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" "),r+=" } "):r+=" {} ";var h=r;return r=d.pop(),!e.compositeRule&&u?e.async?r+=" throw new ValidationError(["+h+"]); ":r+=" validate.errors = ["+h+"]; return false; ":r+=" var err = "+h+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",r+="} ",u&&(r+=" else { "),r}},3537:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="errs__"+r,f=e.util.copy(e);f.level++;var d="valid"+f.level;if(e.opts.strictKeywords?"object"==typeof o&&Object.keys(o).length>0||!1===o:e.util.schemaHasRules(o,e.RULES.all)){f.schema=o,f.schemaPath=s,f.errSchemaPath=c,a+=" var "+p+" = errors;  ";var h,g=e.compositeRule;e.compositeRule=f.compositeRule=!0,f.createErrors=!1,f.opts.allErrors&&(h=f.opts.allErrors,f.opts.allErrors=!1),a+=" "+e.validate(f)+" ",f.createErrors=!0,h&&(f.opts.allErrors=h),e.compositeRule=f.compositeRule=g,a+=" if ("+d+") {   ";var m=m||[];m.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'not' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: {} ",!1!==e.opts.messages&&(a+=" , message: 'should NOT be valid' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ";var y=a;a=m.pop(),!e.compositeRule&&l?e.async?a+=" throw new ValidationError(["+y+"]); ":a+=" validate.errors = ["+y+"]; return false; ":a+=" var err = "+y+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else {  errors = "+p+"; if (vErrors !== null) { if ("+p+") vErrors.length = "+p+"; else vErrors = null; } ",e.opts.allErrors&&(a+=" } ")}else a+="  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'not' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: {} ",!1!==e.opts.messages&&(a+=" , message: 'should NOT be valid' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",l&&(a+=" if (false) { ");return a}},9426:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="valid"+r,f="errs__"+r,d=e.util.copy(e),h="";d.level++;var g="valid"+d.level,m=d.baseId,y="prevValid"+r,v="passingSchemas"+r;a+="var "+f+" = errors , "+y+" = false , "+p+" = false , "+v+" = null; ";var b=e.compositeRule;e.compositeRule=d.compositeRule=!0;var P=o;if(P)for(var S,T=-1,O=P.length-1;T<O;)S=P[T+=1],(e.opts.strictKeywords?"object"==typeof S&&Object.keys(S).length>0||!1===S:e.util.schemaHasRules(S,e.RULES.all))?(d.schema=S,d.schemaPath=s+"["+T+"]",d.errSchemaPath=c+"/"+T,a+="  "+e.validate(d)+" ",d.baseId=m):a+=" var "+g+" = true; ",T&&(a+=" if ("+g+" && "+y+") { "+p+" = false; "+v+" = ["+v+", "+T+"]; } else { ",h+="}"),a+=" if ("+g+") { "+p+" = "+y+" = true; "+v+" = "+T+"; }";return e.compositeRule=d.compositeRule=b,a+=h+"if (!"+p+") {   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'oneOf' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { passingSchemas: "+v+" } ",!1!==e.opts.messages&&(a+=" , message: 'should match exactly one schema in oneOf' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&&l&&(e.async?a+=" throw new ValidationError(vErrors); ":a+=" validate.errors = vErrors; return false; "),a+="} else {  errors = "+f+"; if (vErrors !== null) { if ("+f+") vErrors.length = "+f+"; else vErrors = null; }",e.opts.allErrors&&(a+=" } "),a}},2955:e=>{"use strict";e.exports=function(e,t,n){var a,r=" ",i=e.level,o=e.dataLevel,s=e.schema[t],c=e.schemaPath+e.util.getProperty(t),l=e.errSchemaPath+"/"+t,u=!e.opts.allErrors,p="data"+(o||""),f=e.opts.$data&&s&&s.$data;f?(r+=" var schema"+i+" = "+e.util.getData(s.$data,o,e.dataPathArr)+"; ",a="schema"+i):a=s,r+="if ( ",f&&(r+=" ("+a+" !== undefined && typeof "+a+" != 'string') || "),r+=" !"+(f?"(new RegExp("+a+"))":e.usePattern(s))+".test("+p+") ) {   ";var d=d||[];d.push(r),r="",!1!==e.createErrors?(r+=" { keyword: 'pattern' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { pattern:  ",r+=f?""+a:""+e.util.toQuotedString(s),r+="  } ",!1!==e.opts.messages&&(r+=" , message: 'should match pattern \"",r+=f?"' + "+a+" + '":""+e.util.escapeQuotes(s),r+="\"' "),e.opts.verbose&&(r+=" , schema:  ",r+=f?"validate.schema"+c:""+e.util.toQuotedString(s),r+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" "),r+=" } "):r+=" {} ";var h=r;return r=d.pop(),!e.compositeRule&&u?e.async?r+=" throw new ValidationError(["+h+"]); ":r+=" validate.errors = ["+h+"]; return false; ":r+=" var err = "+h+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",r+="} ",u&&(r+=" else { "),r}},5224:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="errs__"+r,f=e.util.copy(e),d="";f.level++;var h="valid"+f.level,g="key"+r,m="idx"+r,y=f.dataLevel=e.dataLevel+1,v="data"+y,b="dataProperties"+r,P=Object.keys(o||{}).filter(j),S=e.schema.patternProperties||{},T=Object.keys(S).filter(j),O=e.schema.additionalProperties,E=P.length||T.length,_=!1===O,C="object"==typeof O&&Object.keys(O).length,A=e.opts.removeAdditional,I=_||C||A,R=e.opts.ownProperties,F=e.baseId,x=e.schema.required;if(x&&(!e.opts.$data||!x.$data)&&x.length<e.opts.loopRequired)var w=e.util.toHash(x);function j(e){return"__proto__"!==e}if(a+="var "+p+" = errors;var "+h+" = true;",R&&(a+=" var "+b+" = undefined;"),I){if(a+=R?" "+b+" = "+b+" || Object.keys("+u+"); for (var "+m+"=0; "+m+"<"+b+".length; "+m+"++) { var "+g+" = "+b+"["+m+"]; ":" for (var "+g+" in "+u+") { ",E){if(a+=" var isAdditional"+r+" = !(false ",P.length)if(P.length>8)a+=" || validate.schema"+s+".hasOwnProperty("+g+") ";else{var N=P;if(N)for(var L=-1,D=N.length-1;L<D;)J=N[L+=1],a+=" || "+g+" == "+e.util.toQuotedString(J)+" "}if(T.length){var V=T;if(V)for(var M=-1,k=V.length-1;M<k;)ie=V[M+=1],a+=" || "+e.usePattern(ie)+".test("+g+") "}a+=" ); if (isAdditional"+r+") { "}if("all"==A)a+=" delete "+u+"["+g+"]; ";else{var $=e.errorPath,B="' + "+g+" + '";if(e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPathExpr(e.errorPath,g,e.opts.jsonPointers)),_)if(A)a+=" delete "+u+"["+g+"]; ";else{a+=" "+h+" = false; ";var U=c;c=e.errSchemaPath+"/additionalProperties",(ne=ne||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'additionalProperties' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { additionalProperty: '"+B+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is an invalid additional property":a+="should NOT have additional properties",a+="' "),e.opts.verbose&&(a+=" , schema: false , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ";var H=a;a=ne.pop(),!e.compositeRule&&l?e.async?a+=" throw new ValidationError(["+H+"]); ":a+=" validate.errors = ["+H+"]; return false; ":a+=" var err = "+H+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",c=U,l&&(a+=" break; ")}else if(C)if("failing"==A){a+=" var "+p+" = errors;  ";var K=e.compositeRule;e.compositeRule=f.compositeRule=!0,f.schema=O,f.schemaPath=e.schemaPath+".additionalProperties",f.errSchemaPath=e.errSchemaPath+"/additionalProperties",f.errorPath=e.opts._errorDataPathProperty?e.errorPath:e.util.getPathExpr(e.errorPath,g,e.opts.jsonPointers);var Q=u+"["+g+"]";f.dataPathArr[y]=g;var G=e.validate(f);f.baseId=F,e.util.varOccurences(G,v)<2?a+=" "+e.util.varReplace(G,v,Q)+" ":a+=" var "+v+" = "+Q+"; "+G+" ",a+=" if (!"+h+") { errors = "+p+"; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete "+u+"["+g+"]; }  ",e.compositeRule=f.compositeRule=K}else{f.schema=O,f.schemaPath=e.schemaPath+".additionalProperties",f.errSchemaPath=e.errSchemaPath+"/additionalProperties",f.errorPath=e.opts._errorDataPathProperty?e.errorPath:e.util.getPathExpr(e.errorPath,g,e.opts.jsonPointers);Q=u+"["+g+"]";f.dataPathArr[y]=g;G=e.validate(f);f.baseId=F,e.util.varOccurences(G,v)<2?a+=" "+e.util.varReplace(G,v,Q)+" ":a+=" var "+v+" = "+Q+"; "+G+" ",l&&(a+=" if (!"+h+") break; ")}e.errorPath=$}E&&(a+=" } "),a+=" }  ",l&&(a+=" if ("+h+") { ",d+="}")}var W=e.opts.useDefaults&&!e.compositeRule;if(P.length){var q=P;if(q)for(var J,X=-1,z=q.length-1;X<z;){var Y=o[J=q[X+=1]];if(e.opts.strictKeywords?"object"==typeof Y&&Object.keys(Y).length>0||!1===Y:e.util.schemaHasRules(Y,e.RULES.all)){var Z=e.util.getProperty(J),ee=(Q=u+Z,W&&void 0!==Y.default);f.schema=Y,f.schemaPath=s+Z,f.errSchemaPath=c+"/"+e.util.escapeFragment(J),f.errorPath=e.util.getPath(e.errorPath,J,e.opts.jsonPointers),f.dataPathArr[y]=e.util.toQuotedString(J);G=e.validate(f);if(f.baseId=F,e.util.varOccurences(G,v)<2){G=e.util.varReplace(G,v,Q);var te=Q}else{te=v;a+=" var "+v+" = "+Q+"; "}if(ee)a+=" "+G+" ";else{if(w&&w[J]){a+=" if ( "+te+" === undefined ",R&&(a+=" || ! Object.prototype.hasOwnProperty.call("+u+", '"+e.util.escapeQuotes(J)+"') "),a+=") { "+h+" = false; ";$=e.errorPath,U=c;var ne,ae=e.util.escapeQuotes(J);e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPath($,J,e.opts.jsonPointers)),c=e.errSchemaPath+"/required",(ne=ne||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { missingProperty: '"+ae+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+ae+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ";H=a;a=ne.pop(),!e.compositeRule&&l?e.async?a+=" throw new ValidationError(["+H+"]); ":a+=" validate.errors = ["+H+"]; return false; ":a+=" var err = "+H+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",c=U,e.errorPath=$,a+=" } else { "}else l?(a+=" if ( "+te+" === undefined ",R&&(a+=" || ! Object.prototype.hasOwnProperty.call("+u+", '"+e.util.escapeQuotes(J)+"') "),a+=") { "+h+" = true; } else { "):(a+=" if ("+te+" !== undefined ",R&&(a+=" &&   Object.prototype.hasOwnProperty.call("+u+", '"+e.util.escapeQuotes(J)+"') "),a+=" ) { ");a+=" "+G+" } "}}l&&(a+=" if ("+h+") { ",d+="}")}}if(T.length){var re=T;if(re)for(var ie,oe=-1,se=re.length-1;oe<se;){Y=S[ie=re[oe+=1]];if(e.opts.strictKeywords?"object"==typeof Y&&Object.keys(Y).length>0||!1===Y:e.util.schemaHasRules(Y,e.RULES.all)){f.schema=Y,f.schemaPath=e.schemaPath+".patternProperties"+e.util.getProperty(ie),f.errSchemaPath=e.errSchemaPath+"/patternProperties/"+e.util.escapeFragment(ie),a+=R?" "+b+" = "+b+" || Object.keys("+u+"); for (var "+m+"=0; "+m+"<"+b+".length; "+m+"++) { var "+g+" = "+b+"["+m+"]; ":" for (var "+g+" in "+u+") { ",a+=" if ("+e.usePattern(ie)+".test("+g+")) { ",f.errorPath=e.util.getPathExpr(e.errorPath,g,e.opts.jsonPointers);Q=u+"["+g+"]";f.dataPathArr[y]=g;G=e.validate(f);f.baseId=F,e.util.varOccurences(G,v)<2?a+=" "+e.util.varReplace(G,v,Q)+" ":a+=" var "+v+" = "+Q+"; "+G+" ",l&&(a+=" if (!"+h+") break; "),a+=" } ",l&&(a+=" else "+h+" = true; "),a+=" }  ",l&&(a+=" if ("+h+") { ",d+="}")}}}return l&&(a+=" "+d+" if ("+p+" == errors) {"),a}},3194:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="errs__"+r,f=e.util.copy(e);f.level++;var d="valid"+f.level;if(a+="var "+p+" = errors;",e.opts.strictKeywords?"object"==typeof o&&Object.keys(o).length>0||!1===o:e.util.schemaHasRules(o,e.RULES.all)){f.schema=o,f.schemaPath=s,f.errSchemaPath=c;var h="key"+r,g="idx"+r,m="i"+r,y="' + "+h+" + '",v="data"+(f.dataLevel=e.dataLevel+1),b="dataProperties"+r,P=e.opts.ownProperties,S=e.baseId;P&&(a+=" var "+b+" = undefined; "),a+=P?" "+b+" = "+b+" || Object.keys("+u+"); for (var "+g+"=0; "+g+"<"+b+".length; "+g+"++) { var "+h+" = "+b+"["+g+"]; ":" for (var "+h+" in "+u+") { ",a+=" var startErrs"+r+" = errors; ";var T=h,O=e.compositeRule;e.compositeRule=f.compositeRule=!0;var E=e.validate(f);f.baseId=S,e.util.varOccurences(E,v)<2?a+=" "+e.util.varReplace(E,v,T)+" ":a+=" var "+v+" = "+T+"; "+E+" ",e.compositeRule=f.compositeRule=O,a+=" if (!"+d+") { for (var "+m+"=startErrs"+r+"; "+m+"<errors; "+m+"++) { vErrors["+m+"].propertyName = "+h+"; }   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'propertyNames' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { propertyName: '"+y+"' } ",!1!==e.opts.messages&&(a+=" , message: 'property name \\'"+y+"\\' is invalid' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&&l&&(e.async?a+=" throw new ValidationError(vErrors); ":a+=" validate.errors = vErrors; return false; "),l&&(a+=" break; "),a+=" } }"}return l&&(a+="  if ("+p+" == errors) {"),a}},1954:e=>{"use strict";e.exports=function(e,t,n){var a,r,i=" ",o=e.level,s=e.dataLevel,c=e.schema[t],l=e.errSchemaPath+"/"+t,u=!e.opts.allErrors,p="data"+(s||""),f="valid"+o;if("#"==c||"#/"==c)e.isRoot?(a=e.async,r="validate"):(a=!0===e.root.schema.$async,r="root.refVal[0]");else{var d=e.resolveRef(e.baseId,c,e.isRoot);if(void 0===d){var h=e.MissingRefError.message(e.baseId,c);if("fail"==e.opts.missingRefs){e.logger.error(h),(v=v||[]).push(i),i="",!1!==e.createErrors?(i+=" { keyword: '$ref' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { ref: '"+e.util.escapeQuotes(c)+"' } ",!1!==e.opts.messages&&(i+=" , message: 'can\\'t resolve reference "+e.util.escapeQuotes(c)+"' "),e.opts.verbose&&(i+=" , schema: "+e.util.toQuotedString(c)+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" "),i+=" } "):i+=" {} ";var g=i;i=v.pop(),!e.compositeRule&&u?e.async?i+=" throw new ValidationError(["+g+"]); ":i+=" validate.errors = ["+g+"]; return false; ":i+=" var err = "+g+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",u&&(i+=" if (false) { ")}else{if("ignore"!=e.opts.missingRefs)throw new e.MissingRefError(e.baseId,c,h);e.logger.warn(h),u&&(i+=" if (true) { ")}}else if(d.inline){var m=e.util.copy(e);m.level++;var y="valid"+m.level;m.schema=d.schema,m.schemaPath="",m.errSchemaPath=c,i+=" "+e.validate(m).replace(/validate\.schema/g,d.code)+" ",u&&(i+=" if ("+y+") { ")}else a=!0===d.$async||e.async&&!1!==d.$async,r=d.code}if(r){var v;(v=v||[]).push(i),i="",e.opts.passContext?i+=" "+r+".call(this, ":i+=" "+r+"( ",i+=" "+p+", (dataPath || '')",'""'!=e.errorPath&&(i+=" + "+e.errorPath);var b=i+=" , "+(s?"data"+(s-1||""):"parentData")+" , "+(s?e.dataPathArr[s]:"parentDataProperty")+", rootData)  ";if(i=v.pop(),a){if(!e.async)throw new Error("async schema referenced by sync schema");u&&(i+=" var "+f+"; "),i+=" try { await "+b+"; ",u&&(i+=" "+f+" = true; "),i+=" } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ",u&&(i+=" "+f+" = false; "),i+=" } ",u&&(i+=" if ("+f+") { ")}else i+=" if (!"+b+") { if (vErrors === null) vErrors = "+r+".errors; else vErrors = vErrors.concat("+r+".errors); errors = vErrors.length; } ",u&&(i+=" else { ")}return i}},395:e=>{"use strict";e.exports=function(e,t,n){var a=" ",r=e.level,i=e.dataLevel,o=e.schema[t],s=e.schemaPath+e.util.getProperty(t),c=e.errSchemaPath+"/"+t,l=!e.opts.allErrors,u="data"+(i||""),p="valid"+r,f=e.opts.$data&&o&&o.$data;f&&(a+=" var schema"+r+" = "+e.util.getData(o.$data,i,e.dataPathArr)+"; ");var d="schema"+r;if(!f)if(o.length<e.opts.loopRequired&&e.schema.properties&&Object.keys(e.schema.properties).length){var h=[],g=o;if(g)for(var m,y=-1,v=g.length-1;y<v;){m=g[y+=1];var b=e.schema.properties[m];b&&(e.opts.strictKeywords?"object"==typeof b&&Object.keys(b).length>0||!1===b:e.util.schemaHasRules(b,e.RULES.all))||(h[h.length]=m)}}else h=o;if(f||h.length){var P=e.errorPath,S=f||h.length>=e.opts.loopRequired,T=e.opts.ownProperties;if(l)if(a+=" var missing"+r+"; ",S){f||(a+=" var "+d+" = validate.schema"+s+"; ");var O="' + "+(R="schema"+r+"["+(C="i"+r)+"]")+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPathExpr(P,R,e.opts.jsonPointers)),a+=" var "+p+" = true; ",f&&(a+=" if (schema"+r+" === undefined) "+p+" = true; else if (!Array.isArray(schema"+r+")) "+p+" = false; else {"),a+=" for (var "+C+" = 0; "+C+" < "+d+".length; "+C+"++) { "+p+" = "+u+"["+d+"["+C+"]] !== undefined ",T&&(a+=" &&   Object.prototype.hasOwnProperty.call("+u+", "+d+"["+C+"]) "),a+="; if (!"+p+") break; } ",f&&(a+="  }  "),a+="  if (!"+p+") {   ",(I=I||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { missingProperty: '"+O+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+O+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ";var E=a;a=I.pop(),!e.compositeRule&&l?e.async?a+=" throw new ValidationError(["+E+"]); ":a+=" validate.errors = ["+E+"]; return false; ":a+=" var err = "+E+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else { "}else{a+=" if ( ";var _=h;if(_)for(var C=-1,A=_.length-1;C<A;){x=_[C+=1],C&&(a+=" || "),a+=" ( ( "+(L=u+(N=e.util.getProperty(x)))+" === undefined ",T&&(a+=" || ! Object.prototype.hasOwnProperty.call("+u+", '"+e.util.escapeQuotes(x)+"') "),a+=") && (missing"+r+" = "+e.util.toQuotedString(e.opts.jsonPointers?x:N)+") ) "}a+=") {  ";var I;O="' + "+(R="missing"+r)+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.opts.jsonPointers?e.util.getPathExpr(P,R,!0):P+" + "+R),(I=I||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { missingProperty: '"+O+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+O+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ";E=a;a=I.pop(),!e.compositeRule&&l?e.async?a+=" throw new ValidationError(["+E+"]); ":a+=" validate.errors = ["+E+"]; return false; ":a+=" var err = "+E+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else { "}else if(S){f||(a+=" var "+d+" = validate.schema"+s+"; ");var R;O="' + "+(R="schema"+r+"["+(C="i"+r)+"]")+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPathExpr(P,R,e.opts.jsonPointers)),f&&(a+=" if ("+d+" && !Array.isArray("+d+")) {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { missingProperty: '"+O+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+O+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if ("+d+" !== undefined) { "),a+=" for (var "+C+" = 0; "+C+" < "+d+".length; "+C+"++) { if ("+u+"["+d+"["+C+"]] === undefined ",T&&(a+=" || ! Object.prototype.hasOwnProperty.call("+u+", "+d+"["+C+"]) "),a+=") {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { missingProperty: '"+O+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+O+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ",f&&(a+="  }  ")}else{var F=h;if(F)for(var x,w=-1,j=F.length-1;w<j;){x=F[w+=1];var N=e.util.getProperty(x),L=(O=e.util.escapeQuotes(x),u+N);e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPath(P,x,e.opts.jsonPointers)),a+=" if ( "+L+" === undefined ",T&&(a+=" || ! Object.prototype.hasOwnProperty.call("+u+", '"+e.util.escapeQuotes(x)+"') "),a+=") {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { missingProperty: '"+O+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+O+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "}}e.errorPath=P}else l&&(a+=" if (true) {");return a}},1628:e=>{"use strict";e.exports=function(e,t,n){var a,r=" ",i=e.level,o=e.dataLevel,s=e.schema[t],c=e.schemaPath+e.util.getProperty(t),l=e.errSchemaPath+"/"+t,u=!e.opts.allErrors,p="data"+(o||""),f="valid"+i,d=e.opts.$data&&s&&s.$data;if(d?(r+=" var schema"+i+" = "+e.util.getData(s.$data,o,e.dataPathArr)+"; ",a="schema"+i):a=s,(s||d)&&!1!==e.opts.uniqueItems){d&&(r+=" var "+f+"; if ("+a+" === false || "+a+" === undefined) "+f+" = true; else if (typeof "+a+" != 'boolean') "+f+" = false; else { "),r+=" var i = "+p+".length , "+f+" = true , j; if (i > 1) { ";var h=e.schema.items&&e.schema.items.type,g=Array.isArray(h);if(!h||"object"==h||"array"==h||g&&(h.indexOf("object")>=0||h.indexOf("array")>=0))r+=" outer: for (;i--;) { for (j = i; j--;) { if (equal("+p+"[i], "+p+"[j])) { "+f+" = false; break outer; } } } ";else{r+=" var itemIndices = {}, item; for (;i--;) { var item = "+p+"[i]; ";var m="checkDataType"+(g?"s":"");r+=" if ("+e.util[m](h,"item",e.opts.strictNumbers,!0)+") continue; ",g&&(r+=" if (typeof item == 'string') item = '\"' + item; "),r+=" if (typeof itemIndices[item] == 'number') { "+f+" = false; j = itemIndices[item]; break; } itemIndices[item] = i; } "}r+=" } ",d&&(r+="  }  "),r+=" if (!"+f+") {   ";var y=y||[];y.push(r),r="",!1!==e.createErrors?(r+=" { keyword: 'uniqueItems' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { i: i, j: j } ",!1!==e.opts.messages&&(r+=" , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "),e.opts.verbose&&(r+=" , schema:  ",r+=d?"validate.schema"+c:""+s,r+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+p+" "),r+=" } "):r+=" {} ";var v=r;r=y.pop(),!e.compositeRule&&u?e.async?r+=" throw new ValidationError(["+v+"]); ":r+=" validate.errors = ["+v+"]; return false; ":r+=" var err = "+v+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",r+=" } ",u&&(r+=" else { ")}else u&&(r+=" if (true) { ");return r}},2599:e=>{"use strict";e.exports=function(e,t,n){var a="",r=!0===e.schema.$async,i=e.util.schemaHasRulesExcept(e.schema,e.RULES.all,"$ref"),o=e.self._getId(e.schema);if(e.opts.strictKeywords){var s=e.util.schemaUnknownRules(e.schema,e.RULES.keywords);if(s){var c="unknown keyword: "+s;if("log"!==e.opts.strictKeywords)throw new Error(c);e.logger.warn(c)}}if(e.isTop&&(a+=" var validate = ",r&&(e.async=!0,a+="async "),a+="function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ",o&&(e.opts.sourceCode||e.opts.processCode)&&(a+=" /*# sourceURL="+o+" */ ")),"boolean"==typeof e.schema||!i&&!e.schema.$ref){t="false schema";var l=e.level,u=e.dataLevel,p=e.schema[t],f=e.schemaPath+e.util.getProperty(t),d=e.errSchemaPath+"/"+t,h=!e.opts.allErrors,g="data"+(u||""),m="valid"+l;if(!1===e.schema){e.isTop?h=!0:a+=" var "+m+" = false; ",(X=X||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'false schema' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(d)+" , params: {} ",!1!==e.opts.messages&&(a+=" , message: 'boolean schema is false' "),e.opts.verbose&&(a+=" , schema: false , parentSchema: validate.schema"+e.schemaPath+" , data: "+g+" "),a+=" } "):a+=" {} ";var y=a;a=X.pop(),!e.compositeRule&&h?e.async?a+=" throw new ValidationError(["+y+"]); ":a+=" validate.errors = ["+y+"]; return false; ":a+=" var err = "+y+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}else e.isTop?a+=r?" return data; ":" validate.errors = null; return true; ":a+=" var "+m+" = true; ";return e.isTop&&(a+=" }; return validate; "),a}if(e.isTop){var v=e.isTop;l=e.level=0,u=e.dataLevel=0,g="data";if(e.rootId=e.resolve.fullPath(e.self._getId(e.root.schema)),e.baseId=e.baseId||e.rootId,delete e.isTop,e.dataPathArr=[""],void 0!==e.schema.default&&e.opts.useDefaults&&e.opts.strictDefaults){var b="default is ignored in the schema root";if("log"!==e.opts.strictDefaults)throw new Error(b);e.logger.warn(b)}a+=" var vErrors = null; ",a+=" var errors = 0;     ",a+=" if (rootData === undefined) rootData = data; "}else{l=e.level,g="data"+((u=e.dataLevel)||"");if(o&&(e.baseId=e.resolve.url(e.baseId,o)),r&&!e.async)throw new Error("async schema in sync schema");a+=" var errs_"+l+" = errors;"}m="valid"+l,h=!e.opts.allErrors;var P="",S="",T=e.schema.type,O=Array.isArray(T);if(T&&e.opts.nullable&&!0===e.schema.nullable&&(O?-1==T.indexOf("null")&&(T=T.concat("null")):"null"!=T&&(T=[T,"null"],O=!0)),O&&1==T.length&&(T=T[0],O=!1),e.schema.$ref&&i){if("fail"==e.opts.extendRefs)throw new Error('$ref: validation keywords used in schema at path "'+e.errSchemaPath+'" (see option extendRefs)');!0!==e.opts.extendRefs&&(i=!1,e.logger.warn('$ref: keywords ignored in schema at path "'+e.errSchemaPath+'"'))}if(e.schema.$comment&&e.opts.$comment&&(a+=" "+e.RULES.all.$comment.code(e,"$comment")),T){if(e.opts.coerceTypes)var E=e.util.coerceToTypes(e.opts.coerceTypes,T);var _=e.RULES.types[T];if(E||O||!0===_||_&&!z(_)){f=e.schemaPath+".type",d=e.errSchemaPath+"/type",f=e.schemaPath+".type",d=e.errSchemaPath+"/type";var C=O?"checkDataTypes":"checkDataType";if(a+=" if ("+e.util[C](T,g,e.opts.strictNumbers,!0)+") { ",E){var A="dataType"+l,I="coerced"+l;a+=" var "+A+" = typeof "+g+"; var "+I+" = undefined; ","array"==e.opts.coerceTypes&&(a+=" if ("+A+" == 'object' && Array.isArray("+g+") && "+g+".length == 1) { "+g+" = "+g+"[0]; "+A+" = typeof "+g+"; if ("+e.util.checkDataType(e.schema.type,g,e.opts.strictNumbers)+") "+I+" = "+g+"; } "),a+=" if ("+I+" !== undefined) ; ";var R=E;if(R)for(var F,x=-1,w=R.length-1;x<w;)"string"==(F=R[x+=1])?a+=" else if ("+A+" == 'number' || "+A+" == 'boolean') "+I+" = '' + "+g+"; else if ("+g+" === null) "+I+" = ''; ":"number"==F||"integer"==F?(a+=" else if ("+A+" == 'boolean' || "+g+" === null || ("+A+" == 'string' && "+g+" && "+g+" == +"+g+" ","integer"==F&&(a+=" && !("+g+" % 1)"),a+=")) "+I+" = +"+g+"; "):"boolean"==F?a+=" else if ("+g+" === 'false' || "+g+" === 0 || "+g+" === null) "+I+" = false; else if ("+g+" === 'true' || "+g+" === 1) "+I+" = true; ":"null"==F?a+=" else if ("+g+" === '' || "+g+" === 0 || "+g+" === false) "+I+" = null; ":"array"==e.opts.coerceTypes&&"array"==F&&(a+=" else if ("+A+" == 'string' || "+A+" == 'number' || "+A+" == 'boolean' || "+g+" == null) "+I+" = ["+g+"]; ");a+=" else {   ",(X=X||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'type' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(d)+" , params: { type: '",a+=O?""+T.join(","):""+T,a+="' } ",!1!==e.opts.messages&&(a+=" , message: 'should be ",a+=O?""+T.join(","):""+T,a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+f+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+g+" "),a+=" } "):a+=" {} ";y=a;a=X.pop(),!e.compositeRule&&h?e.async?a+=" throw new ValidationError(["+y+"]); ":a+=" validate.errors = ["+y+"]; return false; ":a+=" var err = "+y+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } if ("+I+" !== undefined) {  ";var j=u?"data"+(u-1||""):"parentData";a+=" "+g+" = "+I+"; ",u||(a+="if ("+j+" !== undefined)"),a+=" "+j+"["+(u?e.dataPathArr[u]:"parentDataProperty")+"] = "+I+"; } "}else{(X=X||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'type' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(d)+" , params: { type: '",a+=O?""+T.join(","):""+T,a+="' } ",!1!==e.opts.messages&&(a+=" , message: 'should be ",a+=O?""+T.join(","):""+T,a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+f+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+g+" "),a+=" } "):a+=" {} ";y=a;a=X.pop(),!e.compositeRule&&h?e.async?a+=" throw new ValidationError(["+y+"]); ":a+=" validate.errors = ["+y+"]; return false; ":a+=" var err = "+y+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}a+=" } "}}if(e.schema.$ref&&!i)a+=" "+e.RULES.all.$ref.code(e,"$ref")+" ",h&&(a+=" } if (errors === ",a+=v?"0":"errs_"+l,a+=") { ",S+="}");else{var N=e.RULES;if(N)for(var L=-1,D=N.length-1;L<D;)if(z(_=N[L+=1])){if(_.type&&(a+=" if ("+e.util.checkDataType(_.type,g,e.opts.strictNumbers)+") { "),e.opts.useDefaults)if("object"==_.type&&e.schema.properties){p=e.schema.properties;var V=Object.keys(p);if(V)for(var M,k=-1,$=V.length-1;k<$;){if(void 0!==(H=p[M=V[k+=1]]).default){var B=g+e.util.getProperty(M);if(e.compositeRule){if(e.opts.strictDefaults){b="default is ignored for: "+B;if("log"!==e.opts.strictDefaults)throw new Error(b);e.logger.warn(b)}}else a+=" if ("+B+" === undefined ","empty"==e.opts.useDefaults&&(a+=" || "+B+" === null || "+B+" === '' "),a+=" ) "+B+" = ","shared"==e.opts.useDefaults?a+=" "+e.useDefault(H.default)+" ":a+=" "+JSON.stringify(H.default)+" ",a+="; "}}}else if("array"==_.type&&Array.isArray(e.schema.items)){var U=e.schema.items;if(U){x=-1;for(var H,K=U.length-1;x<K;)if(void 0!==(H=U[x+=1]).default){B=g+"["+x+"]";if(e.compositeRule){if(e.opts.strictDefaults){b="default is ignored for: "+B;if("log"!==e.opts.strictDefaults)throw new Error(b);e.logger.warn(b)}}else a+=" if ("+B+" === undefined ","empty"==e.opts.useDefaults&&(a+=" || "+B+" === null || "+B+" === '' "),a+=" ) "+B+" = ","shared"==e.opts.useDefaults?a+=" "+e.useDefault(H.default)+" ":a+=" "+JSON.stringify(H.default)+" ",a+="; "}}}var Q=_.rules;if(Q)for(var G,W=-1,q=Q.length-1;W<q;)if(Y(G=Q[W+=1])){var J=G.code(e,G.keyword,_.type);J&&(a+=" "+J+" ",h&&(P+="}"))}if(h&&(a+=" "+P+" ",P=""),_.type&&(a+=" } ",T&&T===_.type&&!E)){a+=" else { ";var X;f=e.schemaPath+".type",d=e.errSchemaPath+"/type";(X=X||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'type' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(d)+" , params: { type: '",a+=O?""+T.join(","):""+T,a+="' } ",!1!==e.opts.messages&&(a+=" , message: 'should be ",a+=O?""+T.join(","):""+T,a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+f+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+g+" "),a+=" } "):a+=" {} ";y=a;a=X.pop(),!e.compositeRule&&h?e.async?a+=" throw new ValidationError(["+y+"]); ":a+=" validate.errors = ["+y+"]; return false; ":a+=" var err = "+y+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } "}h&&(a+=" if (errors === ",a+=v?"0":"errs_"+l,a+=") { ",S+="}")}}function z(e){for(var t=e.rules,n=0;n<t.length;n++)if(Y(t[n]))return!0}function Y(t){return void 0!==e.schema[t.keyword]||t.implements&&function(t){for(var n=t.implements,a=0;a<n.length;a++)if(void 0!==e.schema[n[a]])return!0}(t)}return h&&(a+=" "+S+" "),v?(r?(a+=" if (errors === 0) return data;           ",a+=" else throw new ValidationError(vErrors); "):(a+=" validate.errors = vErrors; ",a+=" return errors === 0;       "),a+=" }; return validate;"):a+=" var "+m+" = errors === errs_"+l+";",a}},6019:(e,t,n)=>{"use strict";var a=/^[a-z_$][a-z0-9_$-]*$/i,r=n(1120),i=n(4614);e.exports={add:function(e,t){var n=this.RULES;if(n.keywords[e])throw new Error("Keyword "+e+" is already defined");if(!a.test(e))throw new Error("Keyword "+e+" is not a valid identifier");if(t){this.validateKeyword(t,!0);var i=t.type;if(Array.isArray(i))for(var o=0;o<i.length;o++)c(e,i[o],t);else c(e,i,t);var s=t.metaSchema;s&&(t.$data&&this._opts.$data&&(s={anyOf:[s,{$ref:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}]}),t.validateSchema=this.compile(s,!0))}function c(e,t,a){for(var i,o=0;o<n.length;o++){var s=n[o];if(s.type==t){i=s;break}}i||(i={type:t,rules:[]},n.push(i));var c={keyword:e,definition:a,custom:!0,code:r,implements:a.implements};i.rules.push(c),n.custom[e]=c}return n.keywords[e]=n.all[e]=!0,this},get:function(e){var t=this.RULES.custom[e];return t?t.definition:this.RULES.keywords[e]||!1},remove:function(e){var t=this.RULES;delete t.keywords[e],delete t.all[e],delete t.custom[e];for(var n=0;n<t.length;n++)for(var a=t[n].rules,r=0;r<a.length;r++)if(a[r].keyword==e){a.splice(r,1);break}return this},validate:function e(t,n){e.errors=null;var a=this._validateKeyword=this._validateKeyword||this.compile(i,!0);if(a(t))return!0;if(e.errors=a.errors,n)throw new Error("custom keyword definition is invalid: "+this.errorsText(a.errors));return!1}}},2245:e=>{"use strict";e.exports=(...e)=>[...new Set([].concat(...e))]},7361:e=>{"use strict";function t(e,t,r){e instanceof RegExp&&(e=n(e,r)),t instanceof RegExp&&(t=n(t,r));var i=a(e,t,r);return i&&{start:i[0],end:i[1],pre:r.slice(0,i[0]),body:r.slice(i[0]+e.length,i[1]),post:r.slice(i[1]+t.length)}}function n(e,t){var n=t.match(e);return n?n[0]:null}function a(e,t,n){var a,r,i,o,s,c=n.indexOf(e),l=n.indexOf(t,c+1),u=c;if(c>=0&&l>0){for(a=[],i=n.length;u>=0&&!s;)u==c?(a.push(u),c=n.indexOf(e,u+1)):1==a.length?s=[a.pop(),l]:((r=a.pop())<i&&(i=r,o=l),l=n.indexOf(t,u+1)),u=c<l&&c>=0?c:l;a.length&&(s=[i,o])}return s}e.exports=t,t.range=a},1672:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=["dds","eot","gif","ico","jar","jpeg","jpg","pdf","png","swf","tga","ttf","zip"]},8063:(e,t,n)=>{var a=n(9834),r=n(7361);e.exports=function(e){if(!e)return[];"{}"===e.substr(0,2)&&(e="\\{\\}"+e.substr(2));return y(function(e){return e.split("\\\\").join(i).split("\\{").join(o).split("\\}").join(s).split("\\,").join(c).split("\\.").join(l)}(e),!0).map(p)};var i="\0SLASH"+Math.random()+"\0",o="\0OPEN"+Math.random()+"\0",s="\0CLOSE"+Math.random()+"\0",c="\0COMMA"+Math.random()+"\0",l="\0PERIOD"+Math.random()+"\0";function u(e){return parseInt(e,10)==e?parseInt(e,10):e.charCodeAt(0)}function p(e){return e.split(i).join("\\").split(o).join("{").split(s).join("}").split(c).join(",").split(l).join(".")}function f(e){if(!e)return[""];var t=[],n=r("{","}",e);if(!n)return e.split(",");var a=n.pre,i=n.body,o=n.post,s=a.split(",");s[s.length-1]+="{"+i+"}";var c=f(o);return o.length&&(s[s.length-1]+=c.shift(),s.push.apply(s,c)),t.push.apply(t,s),t}function d(e){return"{"+e+"}"}function h(e){return/^-?0\d/.test(e)}function g(e,t){return e<=t}function m(e,t){return e>=t}function y(e,t){var n=[],i=r("{","}",e);if(!i||/\$$/.test(i.pre))return[e];var o,c=/^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(i.body),l=/^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(i.body),p=c||l,v=i.body.indexOf(",")>=0;if(!p&&!v)return i.post.match(/,.*\}/)?y(e=i.pre+"{"+i.body+s+i.post):[e];if(p)o=i.body.split(/\.\./);else if(1===(o=f(i.body)).length&&1===(o=y(o[0],!1).map(d)).length)return(S=i.post.length?y(i.post,!1):[""]).map((function(e){return i.pre+o[0]+e}));var b,P=i.pre,S=i.post.length?y(i.post,!1):[""];if(p){var T=u(o[0]),O=u(o[1]),E=Math.max(o[0].length,o[1].length),_=3==o.length?Math.abs(u(o[2])):1,C=g;O<T&&(_*=-1,C=m);var A=o.some(h);b=[];for(var I=T;C(I,O);I+=_){var R;if(l)"\\"===(R=String.fromCharCode(I))&&(R="");else if(R=String(I),A){var F=E-R.length;if(F>0){var x=new Array(F+1).join("0");R=I<0?"-"+x+R.slice(1):x+R}}b.push(R)}}else b=a(o,(function(e){return y(e,!1)}));for(var w=0;w<b.length;w++)for(var j=0;j<S.length;j++){var N=P+b[w]+S[j];(!t||p||N)&&n.push(N)}return n}},9111:(e,t,n)=>{"use strict";var a=n(4293).Buffer;function r(){return a.hasOwnProperty("from")&&"function"==typeof a.from}function i(e){if(!a.isBuffer(e))throw new Error("Can only clone Buffer.");if(r())return a.from(e);var t=new a(e.length);return e.copy(t),t}i.hasFrom=r,e.exports=i},4736:(e,t,n)=>{var a=n(5747).Stats;e.exports=function(e){var t=new a;return Object.keys(e).forEach((function(n){t[n]=e[n]})),t}},2059:(e,t,n)=>{"use strict";var a=n(8295).PassThrough,r=n(5822),i=n(5552);function o(e,t){if(!(this instanceof o))return new o(e,t);var n=e._readableState.objectMode;this._original=e,this._clonesCount=1,(t=t||{}).objectMode=n,a.call(this,t),l(e,this),this.on("newListener",s),this.once("resume",c),this._hasListener=!0}function s(e,t){"data"!==e&&"readable"!==e||(this._hasListener=!1,this.removeListener("newListener",s),this.removeListener("resume",c),i.nextTick(u,this))}function c(){this._hasListener=!1,this.removeListener("newListener",s),i.nextTick(u,this)}function l(e,t){function n(){t.end()}e.on("error",(function(a){e.removeListener("close",n),t.destroy(a)})),e.on("close",n)}function u(e){0!=--e._clonesCount||e._readableState.destroyed||(e._original.pipe(e),e._original=void 0)}function p(e,t){if(!(this instanceof p))return new p(e,t);var n=e._readableState.objectMode;(t=t||{}).objectMode=n,this.parent=e,a.call(this,t),l(e,this),e.pipe(this),this.on("newListener",f),this.on("resume",d)}function f(e,t){"data"!==e&&"readable"!==e&&"close"!==e||(i.nextTick(u,this.parent),this.removeListener("newListener",f))}function d(){this.removeListener("newListener",f),i.nextTick(u,this.parent)}r(o,a),o.prototype.clone=function(){if(!this._original)throw new Error("already started");this._clonesCount++,this.removeListener("newListener",s);var e=new p(this);return this._hasListener&&this.on("newListener",s),e},o.prototype._destroy=function(e,t){e||(this.push(null),this.end(),this.emit("close")),i.nextTick(t,e)},r(p,a),p.prototype.clone=function(){return this.parent.clone()},o.isCloneable=function(e){return e instanceof o||e instanceof p},p.prototype._destroy=function(e,t){e||(this.push(null),this.end(),this.emit("close")),i.nextTick(t,e)},e.exports=o},2169:(e,t,n)=>{var a=n(5622);e.exports=function(e,t){if(t)var n=t.map((function(t){return a.resolve(e,t)}));else n=e;var r=n.slice(1).reduce((function(e,t){if(!t.match(/^([A-Za-z]:)?\/|\\/))throw new Error("relative path without a basedir");for(var n=t.split(/\/+|\\+/),a=0;e[a]===n[a]&&a<Math.min(e.length,n.length);a++);return e.slice(0,a)}),n[0].split(/\/+|\\+/));return r.length>1?r.join("/"):"/"}},9834:e=>{e.exports=function(e,n){for(var a=[],r=0;r<e.length;r++){var i=n(e[r],r);t(i)?a.push.apply(a,i):a.push(i)}return a};var t=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}},2862:(e,t)=>{function n(e){return Object.prototype.toString.call(e)}t.isArray=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===n(e)},t.isBoolean=function(e){return"boolean"==typeof e},t.isNull=function(e){return null===e},t.isNullOrUndefined=function(e){return null==e},t.isNumber=function(e){return"number"==typeof e},t.isString=function(e){return"string"==typeof e},t.isSymbol=function(e){return"symbol"==typeof e},t.isUndefined=function(e){return void 0===e},t.isRegExp=function(e){return"[object RegExp]"===n(e)},t.isObject=function(e){return"object"==typeof e&&null!==e},t.isDate=function(e){return"[object Date]"===n(e)},t.isError=function(e){return"[object Error]"===n(e)||e instanceof Error},t.isFunction=function(e){return"function"==typeof e},t.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},t.isBuffer=Buffer.isBuffer},103:e=>{"use strict";function t(e){return e instanceof Buffer||e instanceof Date||e instanceof RegExp}function n(e){if(e instanceof Buffer){var t=Buffer.alloc?Buffer.alloc(e.length):new Buffer(e.length);return e.copy(t),t}if(e instanceof Date)return new Date(e.getTime());if(e instanceof RegExp)return new RegExp(e);throw new Error("Unexpected situation")}function a(e){var r=[];return e.forEach((function(e,o){"object"==typeof e&&null!==e?Array.isArray(e)?r[o]=a(e):t(e)?r[o]=n(e):r[o]=i({},e):r[o]=e})),r}function r(e,t){return"__proto__"===t?void 0:e[t]}var i=e.exports=function(){if(arguments.length<1||"object"!=typeof arguments[0])return!1;if(arguments.length<2)return arguments[0];var e,o,s=arguments[0],c=Array.prototype.slice.call(arguments,1);return c.forEach((function(c){"object"!=typeof c||null===c||Array.isArray(c)||Object.keys(c).forEach((function(l){return o=r(s,l),(e=r(c,l))===s?void 0:"object"!=typeof e||null===e?void(s[l]=e):Array.isArray(e)?void(s[l]=a(e)):t(e)?void(s[l]=n(e)):"object"!=typeof o||null===o||Array.isArray(o)?void(s[l]=i({},e)):void(s[l]=i(o,e))}))})),s}},4225:e=>{"use strict";var t=function(e){return function(e){return!!e&&"object"==typeof e}(e)&&!function(e){var t=Object.prototype.toString.call(e);return"[object RegExp]"===t||"[object Date]"===t||function(e){return e.$$typeof===n}(e)}(e)};var n="function"==typeof Symbol&&Symbol.for?Symbol.for("react.element"):60103;function a(e,t){return!1!==t.clone&&t.isMergeableObject(e)?c((n=e,Array.isArray(n)?[]:{}),e,t):e;var n}function r(e,t,n){return e.concat(t).map((function(e){return a(e,n)}))}function i(e){return Object.keys(e).concat(function(e){return Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(e).filter((function(t){return e.propertyIsEnumerable(t)})):[]}(e))}function o(e,t){try{return t in e}catch(e){return!1}}function s(e,t,n){var r={};return n.isMergeableObject(e)&&i(e).forEach((function(t){r[t]=a(e[t],n)})),i(t).forEach((function(i){(function(e,t){return o(e,t)&&!(Object.hasOwnProperty.call(e,t)&&Object.propertyIsEnumerable.call(e,t))})(e,i)||(o(e,i)&&n.isMergeableObject(t[i])?r[i]=function(e,t){if(!t.customMerge)return c;var n=t.customMerge(e);return"function"==typeof n?n:c}(i,n)(e[i],t[i],n):r[i]=a(t[i],n))})),r}function c(e,n,i){(i=i||{}).arrayMerge=i.arrayMerge||r,i.isMergeableObject=i.isMergeableObject||t,i.cloneUnlessOtherwiseSpecified=a;var o=Array.isArray(n);return o===Array.isArray(e)?o?i.arrayMerge(e,n,i):s(e,n,i):a(n,i)}c.all=function(e,t){if(!Array.isArray(e))throw new Error("first argument should be an array");return e.reduce((function(e,n){return c(e,n,t)}),{})};var l=c;e.exports=l},4217:(e,t,n)=>{"use strict";const a=n(5622),r=n(5904),i=e=>e.length>1?`{${e.join(",")}}`:e[0],o=(e,t)=>{const n="!"===e[0]?e.slice(1):e;return a.isAbsolute(n)?n:a.join(t,n)},s=(e,t)=>{if(t.files&&!Array.isArray(t.files))throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof t.files}\``);if(t.extensions&&!Array.isArray(t.extensions))throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof t.extensions}\``);return t.files&&t.extensions?t.files.map((n=>{return a.posix.join(e,(r=n,o=t.extensions,a.extname(r)?`**/${r}`:`**/${r}.${i(o)}`));var r,o})):t.files?t.files.map((t=>a.posix.join(e,`**/${t}`))):t.extensions?[a.posix.join(e,`**/*.${i(t.extensions)}`)]:[a.posix.join(e,"**")]};e.exports=async(e,t)=>{if("string"!=typeof(t={cwd:process.cwd(),...t}).cwd)throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof t.cwd}\``);const n=await Promise.all([].concat(e).map((async e=>await r.isDirectory(o(e,t.cwd))?s(e,t):e)));return[].concat.apply([],n)},e.exports.sync=(e,t)=>{if("string"!=typeof(t={cwd:process.cwd(),...t}).cwd)throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof t.cwd}\``);const n=[].concat(e).map((e=>r.isDirectorySync(o(e,t.cwd))?s(e,t):e));return[].concat.apply([],n)}},5904:(e,t,n)=>{"use strict";const{promisify:a}=n(1669),r=n(5747);async function i(e,t,n){if("string"!=typeof n)throw new TypeError("Expected a string, got "+typeof n);try{return(await a(r[e])(n))[t]()}catch(e){if("ENOENT"===e.code)return!1;throw e}}function o(e,t,n){if("string"!=typeof n)throw new TypeError("Expected a string, got "+typeof n);try{return r[e](n)[t]()}catch(e){if("ENOENT"===e.code)return!1;throw e}}t.isFile=i.bind(null,"stat","isFile"),t.isDirectory=i.bind(null,"stat","isDirectory"),t.isSymlink=i.bind(null,"lstat","isSymbolicLink"),t.isFileSync=o.bind(null,"statSync","isFile"),t.isDirectorySync=o.bind(null,"statSync","isDirectory"),t.isSymlinkSync=o.bind(null,"lstatSync","isSymbolicLink")},5179:(e,t,n)=>{"use strict";var a=n(5747),r=n(5622),i=n(2781),o=!1,s=n(7740).i8,c="locals",l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],u=l.concat("cache"),p=/^\uFEFF/;function f(e,n){var r;if(n.some((function(n){return r=t.resolveInclude(e,n,!0),a.existsSync(r)})))return r}function d(e,n){var a,r=e.filename,i=arguments.length>1;if(e.cache){if(!r)throw new Error("cache option requires a filename");if(a=t.cache.get(r))return a;i||(n=g(r).toString().replace(p,""))}else if(!i){if(!r)throw new Error("Internal EJS error: no file name or template provided");n=g(r).toString().replace(p,"")}return a=t.compile(n,e),e.cache&&t.cache.set(r,a),a}function h(e,n,a){var r;if(!a){if("function"==typeof t.promiseImpl)return new t.promiseImpl((function(t,a){try{t(r=d(e)(n))}catch(e){a(e)}}));throw new Error("Please provide a callback function")}try{r=d(e)(n)}catch(e){return a(e)}a(null,r)}function g(e){return t.fileLoader(e)}function m(e,n){var r=i.shallowCopy({},n);if(r.filename=function(e,n){var r,i,o=n.views,s=/^[A-Za-z]+:\\|^\//.exec(e);if(s&&s.length)e=e.replace(/^\/*/,""),r=Array.isArray(n.root)?f(e,n.root):t.resolveInclude(e,n.root||"/",!0);else if(n.filename&&(i=t.resolveInclude(e,n.filename),a.existsSync(i)&&(r=i)),!r&&Array.isArray(o)&&(r=f(e,o)),!r&&"function"!=typeof n.includer)throw new Error('Could not find the include file "'+n.escapeFunction(e)+'"');return r}(e,r),"function"==typeof n.includer){var o=n.includer(e,r.filename);if(o&&(o.filename&&(r.filename=o.filename),o.template))return d(r,o.template)}return d(r)}function y(e,t,n,a,r){var i=t.split("\n"),o=Math.max(a-3,0),s=Math.min(i.length,a+3),c=r(n),l=i.slice(o,s).map((function(e,t){var n=t+o+1;return(n==a?" >> ":"    ")+n+"| "+e})).join("\n");throw e.path=c,e.message=(c||"ejs")+":"+a+"\n"+l+"\n\n"+e.message,e}function v(e){return e.replace(/;(\s*$)/,"$1")}function b(e,n){n=n||{};var a={};this.templateText=e,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",a.client=n.client||!1,a.escapeFunction=n.escape||n.escapeFunction||i.escapeXML,a.compileDebug=!1!==n.compileDebug,a.debug=!!n.debug,a.filename=n.filename,a.openDelimiter=n.openDelimiter||t.openDelimiter||"<",a.closeDelimiter=n.closeDelimiter||t.closeDelimiter||">",a.delimiter=n.delimiter||t.delimiter||"%",a.strict=n.strict||!1,a.context=n.context,a.cache=n.cache||!1,a.rmWhitespace=n.rmWhitespace,a.root=n.root,a.includer=n.includer,a.outputFunctionName=n.outputFunctionName,a.localsName=n.localsName||t.localsName||c,a.views=n.views,a.async=n.async,a.destructuredLocals=n.destructuredLocals,a.legacyInclude=void 0===n.legacyInclude||!!n.legacyInclude,a.strict?a._with=!1:a._with=void 0===n._with||n._with,this.opts=a,this.regex=this.createRegex()}t.cache=i.cache,t.fileLoader=a.readFileSync,t.localsName=c,t.promiseImpl=new Function("return this;")().Promise,t.resolveInclude=function(e,t,n){var a=r.dirname,i=r.extname,o=(0,r.resolve)(n?t:a(t),e);return i(e)||(o+=".ejs"),o},t.compile=function(e,t){return t&&t.scope&&(o||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),o=!0),t.context||(t.context=t.scope),delete t.scope),new b(e,t).compile()},t.render=function(e,t,n){var a=t||{},r=n||{};return 2==arguments.length&&i.shallowCopyFromList(r,a,l),d(r,e)(a)},t.renderFile=function(){var e,t,n,a=Array.prototype.slice.call(arguments),r=a.shift(),o={filename:r};return"function"==typeof arguments[arguments.length-1]&&(e=a.pop()),a.length?(t=a.shift(),a.length?i.shallowCopy(o,a.pop()):(t.settings&&(t.settings.views&&(o.views=t.settings.views),t.settings["view cache"]&&(o.cache=!0),(n=t.settings["view options"])&&i.shallowCopy(o,n)),i.shallowCopyFromList(o,t,u)),o.filename=r):t={},h(o,t,e)},t.Template=b,t.clearCache=function(){t.cache.reset()},b.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},b.prototype={createRegex:function(){var e="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",t=i.escapeRegExpChars(this.opts.delimiter),n=i.escapeRegExpChars(this.opts.openDelimiter),a=i.escapeRegExpChars(this.opts.closeDelimiter);return e=e.replace(/%/g,t).replace(/</g,n).replace(/>/g,a),new RegExp(e)},compile:function(){var e,t,n,a=this.opts,o="",s="",c=a.escapeFunction,l=a.filename?JSON.stringify(a.filename):"undefined";if(!this.source){if(this.generateSource(),o+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',a.outputFunctionName&&(o+="  var "+a.outputFunctionName+" = __append;\n"),a.destructuredLocals&&a.destructuredLocals.length){for(var u="  var __locals = ("+a.localsName+" || {}),\n",p=0;p<a.destructuredLocals.length;p++){var f=a.destructuredLocals[p];p>0&&(u+=",\n  "),u+=f+" = __locals."+f}o+=u+";\n"}!1!==a._with&&(o+="  with ("+a.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=o+this.source+s}e=a.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+l+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,a.client&&(e="escapeFn = escapeFn || "+c.toString()+";\n"+e,a.compileDebug&&(e="rethrow = rethrow || "+y.toString()+";\n"+e)),a.strict&&(e='"use strict";\n'+e),a.debug&&console.log(e),a.compileDebug&&a.filename&&(e=e+"\n//# sourceURL="+l+"\n");try{if(a.async)try{n=new Function("return (async function(){}).constructor;")()}catch(e){throw e instanceof SyntaxError?new Error("This environment does not support async/await"):e}else n=Function;t=new n(a.localsName+", escapeFn, include, rethrow",e)}catch(e){throw e instanceof SyntaxError&&(a.filename&&(e.message+=" in "+a.filename),e.message+=" while compiling ejs\n\n",e.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",e.message+="https://github.com/RyanZim/EJS-Lint",a.async||(e.message+="\n",e.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),e}var d=a.client?t:function(e){return t.apply(a.context,[e||{},c,function(t,n){var r=i.shallowCopy({},e);return n&&(r=i.shallowCopy(r,n)),m(t,a)(r)},y])};if(a.filename&&"function"==typeof Object.defineProperty){var h=a.filename,g=r.basename(h,r.extname(h));try{Object.defineProperty(d,"name",{value:g,writable:!1,enumerable:!1,configurable:!0})}catch(e){}}return d},generateSource:function(){this.opts.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var e=this,t=this.parseTemplateText(),n=this.opts.delimiter,a=this.opts.openDelimiter,r=this.opts.closeDelimiter;t&&t.length&&t.forEach((function(i,o){var s;if(0===i.indexOf(a+n)&&0!==i.indexOf(a+n+n)&&(s=t[o+2])!=n+r&&s!="-"+n+r&&s!="_"+n+r)throw new Error('Could not find matching close tag for "'+i+'".');e.scanLine(i)}))},parseTemplateText:function(){for(var e,t=this.templateText,n=this.regex,a=n.exec(t),r=[];a;)0!==(e=a.index)&&(r.push(t.substring(0,e)),t=t.slice(e)),r.push(a[0]),t=t.slice(a[0].length),a=n.exec(t);return t&&r.push(t),r},_addOutput:function(e){if(this.truncate&&(e=e.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!e)return e;e=(e=(e=(e=e.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+e+'")\n'},scanLine:function(e){var t,n=this.opts.delimiter,a=this.opts.openDelimiter,r=this.opts.closeDelimiter;switch(t=e.split("\n").length-1,e){case a+n:case a+n+"_":this.mode=b.modes.EVAL;break;case a+n+"=":this.mode=b.modes.ESCAPED;break;case a+n+"-":this.mode=b.modes.RAW;break;case a+n+"#":this.mode=b.modes.COMMENT;break;case a+n+n:this.mode=b.modes.LITERAL,this.source+='    ; __append("'+e.replace(a+n+n,a+n)+'")\n';break;case n+n+r:this.mode=b.modes.LITERAL,this.source+='    ; __append("'+e.replace(n+n+r,n+r)+'")\n';break;case n+r:case"-"+n+r:case"_"+n+r:this.mode==b.modes.LITERAL&&this._addOutput(e),this.mode=null,this.truncate=0===e.indexOf("-")||0===e.indexOf("_");break;default:if(this.mode){switch(this.mode){case b.modes.EVAL:case b.modes.ESCAPED:case b.modes.RAW:e.lastIndexOf("//")>e.lastIndexOf("\n")&&(e+="\n")}switch(this.mode){case b.modes.EVAL:this.source+="    ; "+e+"\n";break;case b.modes.ESCAPED:this.source+="    ; __append(escapeFn("+v(e)+"))\n";break;case b.modes.RAW:this.source+="    ; __append("+v(e)+")\n";break;case b.modes.COMMENT:break;case b.modes.LITERAL:this._addOutput(e)}}else this._addOutput(e)}this.opts.compileDebug&&t&&(this.currentLine+=t,this.source+="    ; __line = "+this.currentLine+"\n")}},t.escapeXML=i.escapeXML,t.__express=t.renderFile,t.VERSION=s,t.name="ejs","undefined"!=typeof window&&(window.ejs=t)},2781:(e,t)=>{"use strict";var n=/[|\\{}()[\]^$+*?.]/g;t.escapeRegExpChars=function(e){return e?String(e).replace(n,"\\$&"):""};var a={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},r=/[&<>'"]/g;function i(e){return a[e]||e}t.escapeXML=function(e){return null==e?"":String(e).replace(r,i)},t.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},t.shallowCopy=function(e,t){for(var n in t=t||{})e[n]=t[n];return e},t.shallowCopyFromList=function(e,t,n){for(var a=0;a<n.length;a++){var r=n[a];void 0!==t[r]&&(e[r]=t[r])}return e},t.cache={_data:{},set:function(e,t){this._data[e]=t},get:function(e){return this._data[e]},remove:function(e){delete this._data[e]},reset:function(){this._data={}}},t.hyphenToCamel=function(e){return e.replace(/-[a-z]/g,(function(e){return e[1].toUpperCase()}))}},8926:e=>{"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var a,r,i;if(Array.isArray(t)){if((a=t.length)!=n.length)return!1;for(r=a;0!=r--;)if(!e(t[r],n[r]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((a=(i=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(r=a;0!=r--;)if(!Object.prototype.hasOwnProperty.call(n,i[r]))return!1;for(r=a;0!=r--;){var o=i[r];if(!e(t[o],n[o]))return!1}return!0}return t!=t&&n!=n}},272:(e,t,n)=>{"use strict";const a=n(6464),r=n(5790),i=n(6004),o=n(1927),s=(e,t={})=>{let n=[];if(Array.isArray(e))for(let a of e){let e=s.create(a,t);Array.isArray(e)?n.push(...e):n.push(e)}else n=[].concat(s.create(e,t));return t&&!0===t.expand&&!0===t.nodupes&&(n=[...new Set(n)]),n};s.parse=(e,t={})=>o(e,t),s.stringify=(e,t={})=>a("string"==typeof e?s.parse(e,t):e,t),s.compile=(e,t={})=>("string"==typeof e&&(e=s.parse(e,t)),r(e,t)),s.expand=(e,t={})=>{"string"==typeof e&&(e=s.parse(e,t));let n=i(e,t);return!0===t.noempty&&(n=n.filter(Boolean)),!0===t.nodupes&&(n=[...new Set(n)]),n},s.create=(e,t={})=>""===e||e.length<3?[e]:!0!==t.expand?s.compile(e,t):s.expand(e,t),e.exports=s},5790:(e,t,n)=>{"use strict";const a=n(2564),r=n(3951);e.exports=(e,t={})=>{let n=(e,i={})=>{let o=r.isInvalidBrace(i),s=!0===e.invalid&&!0===t.escapeInvalid,c=!0===o||!0===s,l=!0===t.escapeInvalid?"\\":"",u="";if(!0===e.isOpen)return l+e.value;if(!0===e.isClose)return l+e.value;if("open"===e.type)return c?l+e.value:"(";if("close"===e.type)return c?l+e.value:")";if("comma"===e.type)return"comma"===e.prev.type?"":c?e.value:"|";if(e.value)return e.value;if(e.nodes&&e.ranges>0){let n=r.reduce(e.nodes),i=a(...n,{...t,wrap:!1,toRegex:!0});if(0!==i.length)return n.length>1&&i.length>1?`(${i})`:i}if(e.nodes)for(let t of e.nodes)u+=n(t,e);return u};return n(e)}},1331:e=>{"use strict";e.exports={MAX_LENGTH:65536,CHAR_0:"0",CHAR_9:"9",CHAR_UPPERCASE_A:"A",CHAR_LOWERCASE_A:"a",CHAR_UPPERCASE_Z:"Z",CHAR_LOWERCASE_Z:"z",CHAR_LEFT_PARENTHESES:"(",CHAR_RIGHT_PARENTHESES:")",CHAR_ASTERISK:"*",CHAR_AMPERSAND:"&",CHAR_AT:"@",CHAR_BACKSLASH:"\\",CHAR_BACKTICK:"`",CHAR_CARRIAGE_RETURN:"\r",CHAR_CIRCUMFLEX_ACCENT:"^",CHAR_COLON:":",CHAR_COMMA:",",CHAR_DOLLAR:"$",CHAR_DOT:".",CHAR_DOUBLE_QUOTE:'"',CHAR_EQUAL:"=",CHAR_EXCLAMATION_MARK:"!",CHAR_FORM_FEED:"\f",CHAR_FORWARD_SLASH:"/",CHAR_HASH:"#",CHAR_HYPHEN_MINUS:"-",CHAR_LEFT_ANGLE_BRACKET:"<",CHAR_LEFT_CURLY_BRACE:"{",CHAR_LEFT_SQUARE_BRACKET:"[",CHAR_LINE_FEED:"\n",CHAR_NO_BREAK_SPACE:"",CHAR_PERCENT:"%",CHAR_PLUS:"+",CHAR_QUESTION_MARK:"?",CHAR_RIGHT_ANGLE_BRACKET:">",CHAR_RIGHT_CURLY_BRACE:"}",CHAR_RIGHT_SQUARE_BRACKET:"]",CHAR_SEMICOLON:";",CHAR_SINGLE_QUOTE:"'",CHAR_SPACE:" ",CHAR_TAB:"\t",CHAR_UNDERSCORE:"_",CHAR_VERTICAL_LINE:"|",CHAR_ZERO_WIDTH_NOBREAK_SPACE:"\ufeff"}},6004:(e,t,n)=>{"use strict";const a=n(2564),r=n(6464),i=n(3951),o=(e="",t="",n=!1)=>{let a=[];if(e=[].concat(e),!(t=[].concat(t)).length)return e;if(!e.length)return n?i.flatten(t).map((e=>`{${e}}`)):t;for(let r of e)if(Array.isArray(r))for(let e of r)a.push(o(e,t,n));else for(let e of t)!0===n&&"string"==typeof e&&(e=`{${e}}`),a.push(Array.isArray(e)?o(r,e,n):r+e);return i.flatten(a)};e.exports=(e,t={})=>{let n=void 0===t.rangeLimit?1e3:t.rangeLimit,s=(e,c={})=>{e.queue=[];let l=c,u=c.queue;for(;"brace"!==l.type&&"root"!==l.type&&l.parent;)l=l.parent,u=l.queue;if(e.invalid||e.dollar)return void u.push(o(u.pop(),r(e,t)));if("brace"===e.type&&!0!==e.invalid&&2===e.nodes.length)return void u.push(o(u.pop(),["{}"]));if(e.nodes&&e.ranges>0){let s=i.reduce(e.nodes);if(i.exceedsLimit(...s,t.step,n))throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");let c=a(...s,t);return 0===c.length&&(c=r(e,t)),u.push(o(u.pop(),c)),void(e.nodes=[])}let p=i.encloseBrace(e),f=e.queue,d=e;for(;"brace"!==d.type&&"root"!==d.type&&d.parent;)d=d.parent,f=d.queue;for(let t=0;t<e.nodes.length;t++){let n=e.nodes[t];"comma"!==n.type||"brace"!==e.type?"close"!==n.type?n.value&&"open"!==n.type?f.push(o(f.pop(),n.value)):n.nodes&&s(n,e):u.push(o(u.pop(),f,p)):(1===t&&f.push(""),f.push(""))}return f};return i.flatten(s(e))}},1927:(e,t,n)=>{"use strict";const a=n(6464),{MAX_LENGTH:r,CHAR_BACKSLASH:i,CHAR_BACKTICK:o,CHAR_COMMA:s,CHAR_DOT:c,CHAR_LEFT_PARENTHESES:l,CHAR_RIGHT_PARENTHESES:u,CHAR_LEFT_CURLY_BRACE:p,CHAR_RIGHT_CURLY_BRACE:f,CHAR_LEFT_SQUARE_BRACKET:d,CHAR_RIGHT_SQUARE_BRACKET:h,CHAR_DOUBLE_QUOTE:g,CHAR_SINGLE_QUOTE:m,CHAR_NO_BREAK_SPACE:y,CHAR_ZERO_WIDTH_NOBREAK_SPACE:v}=n(1331);e.exports=(e,t={})=>{if("string"!=typeof e)throw new TypeError("Expected a string");let n=t||{},b="number"==typeof n.maxLength?Math.min(r,n.maxLength):r;if(e.length>b)throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${b})`);let P,S={type:"root",input:e,nodes:[]},T=[S],O=S,E=S,_=0,C=e.length,A=0,I=0;const R=()=>e[A++],F=e=>{if("text"===e.type&&"dot"===E.type&&(E.type="text"),!E||"text"!==E.type||"text"!==e.type)return O.nodes.push(e),e.parent=O,e.prev=E,E=e,e;E.value+=e.value};for(F({type:"bos"});A<C;)if(O=T[T.length-1],P=R(),P!==v&&P!==y)if(P!==i)if(P!==h)if(P!==d)if(P!==l)if(P!==u)if(P!==g&&P!==m&&P!==o)if(P!==p)if(P!==f)if(P===s&&I>0){if(O.ranges>0){O.ranges=0;let e=O.nodes.shift();O.nodes=[e,{type:"text",value:a(O)}]}F({type:"comma",value:P}),O.commas++}else if(P===c&&I>0&&0===O.commas){let e=O.nodes;if(0===I||0===e.length){F({type:"text",value:P});continue}if("dot"===E.type){if(O.range=[],E.value+=P,E.type="range",3!==O.nodes.length&&5!==O.nodes.length){O.invalid=!0,O.ranges=0,E.type="text";continue}O.ranges++,O.args=[];continue}if("range"===E.type){e.pop();let t=e[e.length-1];t.value+=E.value+P,E=t,O.ranges--;continue}F({type:"dot",value:P})}else F({type:"text",value:P});else{if("brace"!==O.type){F({type:"text",value:P});continue}let e="close";O=T.pop(),O.close=!0,F({type:e,value:P}),I--,O=T[T.length-1]}else{I++;let e=E.value&&"$"===E.value.slice(-1)||!0===O.dollar;O=F({type:"brace",open:!0,close:!1,dollar:e,depth:I,commas:0,ranges:0,nodes:[]}),T.push(O),F({type:"open",value:P})}else{let e,n=P;for(!0!==t.keepQuotes&&(P="");A<C&&(e=R());)if(e!==i){if(e===n){!0===t.keepQuotes&&(P+=e);break}P+=e}else P+=e+R();F({type:"text",value:P})}else{if("paren"!==O.type){F({type:"text",value:P});continue}O=T.pop(),F({type:"text",value:P}),O=T[T.length-1]}else O=F({type:"paren",nodes:[]}),T.push(O),F({type:"text",value:P});else{_++;let e;for(;A<C&&(e=R());)if(P+=e,e!==d)if(e!==i){if(e===h&&(_--,0===_))break}else P+=R();else _++;F({type:"text",value:P})}else F({type:"text",value:"\\"+P});else F({type:"text",value:(t.keepEscaping?P:"")+R()});do{if(O=T.pop(),"root"!==O.type){O.nodes.forEach((e=>{e.nodes||("open"===e.type&&(e.isOpen=!0),"close"===e.type&&(e.isClose=!0),e.nodes||(e.type="text"),e.invalid=!0)}));let e=T[T.length-1],t=e.nodes.indexOf(O);e.nodes.splice(t,1,...O.nodes)}}while(T.length>0);return F({type:"eos"}),S}},6464:(e,t,n)=>{"use strict";const a=n(3951);e.exports=(e,t={})=>{let n=(e,r={})=>{let i=t.escapeInvalid&&a.isInvalidBrace(r),o=!0===e.invalid&&!0===t.escapeInvalid,s="";if(e.value)return(i||o)&&a.isOpenOrClose(e)?"\\"+e.value:e.value;if(e.value)return e.value;if(e.nodes)for(let t of e.nodes)s+=n(t);return s};return n(e)}},3951:(e,t)=>{"use strict";t.isInteger=e=>"number"==typeof e?Number.isInteger(e):"string"==typeof e&&""!==e.trim()&&Number.isInteger(Number(e)),t.find=(e,t)=>e.nodes.find((e=>e.type===t)),t.exceedsLimit=(e,n,a=1,r)=>!1!==r&&(!(!t.isInteger(e)||!t.isInteger(n))&&(Number(n)-Number(e))/Number(a)>=r),t.escapeNode=(e,t=0,n)=>{let a=e.nodes[t];a&&(n&&a.type===n||"open"===a.type||"close"===a.type)&&!0!==a.escaped&&(a.value="\\"+a.value,a.escaped=!0)},t.encloseBrace=e=>"brace"===e.type&&(e.commas>>0+e.ranges>>0==0&&(e.invalid=!0,!0)),t.isInvalidBrace=e=>"brace"===e.type&&(!(!0!==e.invalid&&!e.dollar)||(e.commas>>0+e.ranges>>0==0||!0!==e.open||!0!==e.close)&&(e.invalid=!0,!0)),t.isOpenOrClose=e=>"open"===e.type||"close"===e.type||(!0===e.open||!0===e.close),t.reduce=e=>e.reduce(((e,t)=>("text"===t.type&&e.push(t.value),"range"===t.type&&(t.type="text"),e)),[]),t.flatten=(...e)=>{const t=[],n=e=>{for(let a=0;a<e.length;a++){let r=e[a];Array.isArray(r)?n(r,t):void 0!==r&&t.push(r)}return t};return n(e),t}},2564:(e,t,n)=>{"use strict";const a=n(1669),r=n(3267),i=e=>null!==e&&"object"==typeof e&&!Array.isArray(e),o=e=>"number"==typeof e||"string"==typeof e&&""!==e,s=e=>Number.isInteger(+e),c=e=>{let t=`${e}`,n=-1;if("-"===t[0]&&(t=t.slice(1)),"0"===t)return!1;for(;"0"===t[++n];);return n>0},l=(e,t,n)=>{if(t>0){let n="-"===e[0]?"-":"";n&&(e=e.slice(1)),e=n+e.padStart(n?t-1:t,"0")}return!1===n?String(e):e},u=(e,t)=>{let n="-"===e[0]?"-":"";for(n&&(e=e.slice(1),t--);e.length<t;)e="0"+e;return n?"-"+e:e},p=(e,t,n,a)=>{if(n)return r(e,t,{wrap:!1,...a});let i=String.fromCharCode(e);return e===t?i:`[${i}-${String.fromCharCode(t)}]`},f=(e,t,n)=>{if(Array.isArray(e)){let t=!0===n.wrap,a=n.capture?"":"?:";return t?`(${a}${e.join("|")})`:e.join("|")}return r(e,t,n)},d=(...e)=>new RangeError("Invalid range arguments: "+a.inspect(...e)),h=(e,t,n)=>{if(!0===n.strictRanges)throw d([e,t]);return[]},g=(e,t,n=1,a={})=>{let r=Number(e),i=Number(t);if(!Number.isInteger(r)||!Number.isInteger(i)){if(!0===a.strictRanges)throw d([e,t]);return[]}0===r&&(r=0),0===i&&(i=0);let o=r>i,s=String(e),h=String(t),g=String(n);n=Math.max(Math.abs(n),1);let m=c(s)||c(h)||c(g),y=m?Math.max(s.length,h.length,g.length):0,v=!1===m&&!1===((e,t,n)=>"string"==typeof e||"string"==typeof t||!0===n.stringify)(e,t,a),b=a.transform||(e=>t=>!0===e?Number(t):String(t))(v);if(a.toRegex&&1===n)return p(u(e,y),u(t,y),!0,a);let P={negatives:[],positives:[]},S=[],T=0;for(;o?r>=i:r<=i;)!0===a.toRegex&&n>1?P[(O=r)<0?"negatives":"positives"].push(Math.abs(O)):S.push(l(b(r,T),y,v)),r=o?r-n:r+n,T++;var O;return!0===a.toRegex?n>1?((e,t)=>{e.negatives.sort(((e,t)=>e<t?-1:e>t?1:0)),e.positives.sort(((e,t)=>e<t?-1:e>t?1:0));let n,a=t.capture?"":"?:",r="",i="";return e.positives.length&&(r=e.positives.join("|")),e.negatives.length&&(i=`-(${a}${e.negatives.join("|")})`),n=r&&i?`${r}|${i}`:r||i,t.wrap?`(${a}${n})`:n})(P,a):f(S,null,{wrap:!1,...a}):S},m=(e,t,n,a={})=>{if(null==t&&o(e))return[e];if(!o(e)||!o(t))return h(e,t,a);if("function"==typeof n)return m(e,t,1,{transform:n});if(i(n))return m(e,t,0,n);let r={...a};return!0===r.capture&&(r.wrap=!0),n=n||r.step||1,s(n)?s(e)&&s(t)?g(e,t,n,r):((e,t,n=1,a={})=>{if(!s(e)&&e.length>1||!s(t)&&t.length>1)return h(e,t,a);let r=a.transform||(e=>String.fromCharCode(e)),i=`${e}`.charCodeAt(0),o=`${t}`.charCodeAt(0),c=i>o,l=Math.min(i,o),u=Math.max(i,o);if(a.toRegex&&1===n)return p(l,u,!1,a);let d=[],g=0;for(;c?i>=o:i<=o;)d.push(r(i,g)),i=c?i-n:i+n,g++;return!0===a.toRegex?f(d,null,{wrap:!1,options:a}):d})(e,t,Math.max(Math.abs(n),1),r):null==n||i(n)?m(e,t,1,n):((e,t)=>{if(!0===t.strictRanges)throw new TypeError(`Expected step "${e}" to be a number`);return[]})(n,r)};e.exports=m},5407:e=>{"use strict";e.exports=function(e){return"number"==typeof e?e-e==0:"string"==typeof e&&""!==e.trim()&&(Number.isFinite?Number.isFinite(+e):isFinite(+e))}},8575:(e,t,n)=>{"use strict";const a=n(1669),r=n(272),i=n(4973),o=n(557),s=e=>"string"==typeof e&&(""===e||"./"===e),c=(e,t,n)=>{t=[].concat(t),e=[].concat(e);let a=new Set,r=new Set,o=new Set,s=0,c=e=>{o.add(e.output),n&&n.onResult&&n.onResult(e)};for(let o=0;o<t.length;o++){let l=i(String(t[o]),{...n,onResult:c},!0),u=l.state.negated||l.state.negatedExtglob;u&&s++;for(let t of e){let e=l(t,!0);(u?!e.isMatch:e.isMatch)&&(u?a.add(e.output):(a.delete(e.output),r.add(e.output)))}}let l=(s===t.length?[...o]:[...r]).filter((e=>!a.has(e)));if(n&&0===l.length){if(!0===n.failglob)throw new Error(`No matches found for "${t.join(", ")}"`);if(!0===n.nonull||!0===n.nullglob)return n.unescape?t.map((e=>e.replace(/\\/g,""))):t}return l};c.match=c,c.matcher=(e,t)=>i(e,t),c.any=c.isMatch=(e,t,n)=>i(t,n)(e),c.not=(e,t,n={})=>{t=[].concat(t).map(String);let a=new Set,r=[],i=c(e,t,{...n,onResult:e=>{n.onResult&&n.onResult(e),r.push(e.output)}});for(let e of r)i.includes(e)||a.add(e);return[...a]},c.contains=(e,t,n)=>{if("string"!=typeof e)throw new TypeError(`Expected a string: "${a.inspect(e)}"`);if(Array.isArray(t))return t.some((t=>c.contains(e,t,n)));if("string"==typeof t){if(s(e)||s(t))return!1;if(e.includes(t)||e.startsWith("./")&&e.slice(2).includes(t))return!0}return c.isMatch(e,t,{...n,contains:!0})},c.matchKeys=(e,t,n)=>{if(!o.isObject(e))throw new TypeError("Expected the first argument to be an object");let a=c(Object.keys(e),t,n),r={};for(let t of a)r[t]=e[t];return r},c.some=(e,t,n)=>{let a=[].concat(e);for(let e of[].concat(t)){let t=i(String(e),n);if(a.some((e=>t(e))))return!0}return!1},c.every=(e,t,n)=>{let a=[].concat(e);for(let e of[].concat(t)){let t=i(String(e),n);if(!a.every((e=>t(e))))return!1}return!0},c.all=(e,t,n)=>{if("string"!=typeof e)throw new TypeError(`Expected a string: "${a.inspect(e)}"`);return[].concat(t).every((t=>i(t,n)(e)))},c.capture=(e,t,n)=>{let a=o.isWindows(n),r=i.makeRe(String(e),{...n,capture:!0}).exec(a?o.toPosixSlashes(t):t);if(r)return r.slice(1).map((e=>void 0===e?"":e))},c.makeRe=(...e)=>i.makeRe(...e),c.scan=(...e)=>i.scan(...e),c.parse=(e,t)=>{let n=[];for(let a of[].concat(e||[]))for(let e of r(String(a),t))n.push(i.parse(e,t));return n},c.braces=(e,t)=>{if("string"!=typeof e)throw new TypeError("Expected a string");return t&&!0===t.nobrace||!/\{.*\}/.test(e)?[e]:r(e,t)},c.braceExpand=(e,t)=>{if("string"!=typeof e)throw new TypeError("Expected a string");return c.braces(e,{...t,expand:!0})},e.exports=c},3267:(e,t,n)=>{"use strict";const a=n(5407),r=(e,t,n)=>{if(!1===a(e))throw new TypeError("toRegexRange: expected the first argument to be a number");if(void 0===t||e===t)return String(e);if(!1===a(t))throw new TypeError("toRegexRange: expected the second argument to be a number.");let i={relaxZeros:!0,...n};"boolean"==typeof i.strictZeros&&(i.relaxZeros=!1===i.strictZeros);let c=e+":"+t+"="+String(i.relaxZeros)+String(i.shorthand)+String(i.capture)+String(i.wrap);if(r.cache.hasOwnProperty(c))return r.cache[c].result;let l=Math.min(e,t),u=Math.max(e,t);if(1===Math.abs(l-u)){let n=e+"|"+t;return i.capture?`(${n})`:!1===i.wrap?n:`(?:${n})`}let p=h(e)||h(t),f={min:e,max:t,a:l,b:u},d=[],g=[];if(p&&(f.isPadded=p,f.maxLen=String(f.max).length),l<0){g=o(u<0?Math.abs(u):1,Math.abs(l),f,i),l=f.a=0}return u>=0&&(d=o(l,u,f,i)),f.negatives=g,f.positives=d,f.result=function(e,t,n){let a=s(e,t,"-",!1,n)||[],r=s(t,e,"",!1,n)||[],i=s(e,t,"-?",!0,n)||[];return a.concat(i).concat(r).join("|")}(g,d,i),!0===i.capture?f.result=`(${f.result})`:!1!==i.wrap&&d.length+g.length>1&&(f.result=`(?:${f.result})`),r.cache[c]=f,f.result};function i(e,t,n){if(e===t)return{pattern:e,count:[],digits:0};let a=function(e,t){let n=[];for(let a=0;a<e.length;a++)n.push([e[a],t[a]]);return n}(e,t),r=a.length,i="",o=0;for(let e=0;e<r;e++){let[t,r]=a[e];t===r?i+=t:"0"!==t||"9"!==r?i+=d(t,r,n):o++}return o&&(i+=!0===n.shorthand?"\\d":"[0-9]"),{pattern:i,count:[o],digits:r}}function o(e,t,n,a){let r,o=function(e,t){let n=1,a=1,r=u(e,n),i=new Set([t]);for(;e<=r&&r<=t;)i.add(r),n+=1,r=u(e,n);for(r=p(t+1,a)-1;e<r&&r<=t;)i.add(r),a+=1,r=p(t+1,a)-1;return i=[...i],i.sort(c),i}(e,t),s=[],l=e;for(let e=0;e<o.length;e++){let t=o[e],c=i(String(l),String(t),a),u="";n.isPadded||!r||r.pattern!==c.pattern?(n.isPadded&&(u=g(t,n,a)),c.string=u+c.pattern+f(c.count),s.push(c),l=t+1,r=c):(r.count.length>1&&r.count.pop(),r.count.push(c.count[0]),r.string=r.pattern+f(r.count),l=t+1)}return s}function s(e,t,n,a,r){let i=[];for(let r of e){let{string:e}=r;a||l(t,"string",e)||i.push(n+e),a&&l(t,"string",e)&&i.push(n+e)}return i}function c(e,t){return e>t?1:t>e?-1:0}function l(e,t,n){return e.some((e=>e[t]===n))}function u(e,t){return Number(String(e).slice(0,-t)+"9".repeat(t))}function p(e,t){return e-e%Math.pow(10,t)}function f(e){let[t=0,n=""]=e;return n||t>1?`{${t+(n?","+n:"")}}`:""}function d(e,t,n){return`[${e}${t-e==1?"":"-"}${t}]`}function h(e){return/^-?(0+)\d/.test(e)}function g(e,t,n){if(!t.isPadded)return e;let a=Math.abs(t.maxLen-String(e).length),r=!1!==n.relaxZeros;switch(a){case 0:return"";case 1:return r?"0?":"0";case 2:return r?"0{0,2}":"00";default:return r?`0{0,${a}}`:`0{${a}}`}}r.cache={},r.clearCache=()=>r.cache={},e.exports=r},9689:(e,t,n)=>{"use strict";const a=n(6197),r=n(7637),i=n(8394),o=n(4790),s=n(9516),c=n(3065);async function l(e,t){p(e);const n=u(e,r.default,t),a=await Promise.all(n);return c.array.flatten(a)}function u(e,t,n){const r=[].concat(e),i=new s.default(n),o=a.generate(r,i),c=new t(i);return o.map(c.read,c)}function p(e){if(![].concat(e).every((e=>c.string.isString(e)&&!c.string.isEmpty(e))))throw new TypeError("Patterns must be a string (non empty) or an array of strings")}!function(e){e.sync=function(e,t){p(e);const n=u(e,o.default,t);return c.array.flatten(n)},e.stream=function(e,t){p(e);const n=u(e,i.default,t);return c.stream.merge(n)},e.generateTasks=function(e,t){p(e);const n=[].concat(e),r=new s.default(t);return a.generate(n,r)},e.isDynamicPattern=function(e,t){p(e);const n=new s.default(t);return c.pattern.isDynamicPattern(e,n)},e.escapePath=function(e){return p(e),c.path.escape(e)}}(l||(l={})),e.exports=l},6197:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.convertPatternGroupToTask=t.convertPatternGroupsToTasks=t.groupPatternsByBaseDirectory=t.getNegativePatternsAsPositive=t.getPositivePatterns=t.convertPatternsToTasks=t.generate=void 0;const a=n(3065);function r(e,t,n){const a=s(e);if("."in a){return[l(".",e,t,n)]}return c(a,t,n)}function i(e){return a.pattern.getPositivePatterns(e)}function o(e,t){return a.pattern.getNegativePatterns(e).concat(t).map(a.pattern.convertToPositivePattern)}function s(e){return e.reduce(((e,t)=>{const n=a.pattern.getBaseDirectory(t);return n in e?e[n].push(t):e[n]=[t],e}),{})}function c(e,t,n){return Object.keys(e).map((a=>l(a,e[a],t,n)))}function l(e,t,n,r){return{dynamic:r,positive:t,negative:n,base:e,patterns:[].concat(t,n.map(a.pattern.convertToNegativePattern))}}t.generate=function(e,t){const n=i(e),s=o(e,t.ignore),c=n.filter((e=>a.pattern.isStaticPattern(e,t))),l=n.filter((e=>a.pattern.isDynamicPattern(e,t))),u=r(c,s,!1),p=r(l,s,!0);return u.concat(p)},t.convertPatternsToTasks=r,t.getPositivePatterns=i,t.getNegativePatternsAsPositive=o,t.groupPatternsByBaseDirectory=s,t.convertPatternGroupsToTasks=c,t.convertPatternGroupToTask=l},7637:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(951),r=n(1646);class ProviderAsync extends r.default{constructor(){super(...arguments),this._reader=new a.default(this._settings)}read(e){const t=this._getRootDirectory(e),n=this._getReaderOptions(e),a=[];return new Promise(((r,i)=>{const o=this.api(t,e,n);o.once("error",i),o.on("data",(e=>a.push(n.transform(e)))),o.once("end",(()=>r(a)))}))}api(e,t,n){return t.dynamic?this._reader.dynamic(e,n):this._reader.static(t.patterns,n)}}t.default=ProviderAsync},8042:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(3065),r=n(5433);t.default=class DeepFilter{constructor(e,t){this._settings=e,this._micromatchOptions=t}getFilter(e,t,n){const a=this._getMatcher(t),r=this._getNegativePatternsRe(n);return t=>this._filter(e,t,a,r)}_getMatcher(e){return new r.default(e,this._settings,this._micromatchOptions)}_getNegativePatternsRe(e){const t=e.filter(a.pattern.isAffectDepthOfReadingPattern);return a.pattern.convertPatternsToRe(t,this._micromatchOptions)}_filter(e,t,n,r){if(this._isSkippedByDeep(e,t.path))return!1;if(this._isSkippedSymbolicLink(t))return!1;const i=a.path.removeLeadingDotSegment(t.path);return!this._isSkippedByPositivePatterns(i,n)&&this._isSkippedByNegativePatterns(i,r)}_isSkippedByDeep(e,t){return this._settings.deep!==1/0&&this._getEntryLevel(e,t)>=this._settings.deep}_getEntryLevel(e,t){const n=t.split("/").length;if(""===e)return n;return n-e.split("/").length}_isSkippedSymbolicLink(e){return!this._settings.followSymbolicLinks&&e.dirent.isSymbolicLink()}_isSkippedByPositivePatterns(e,t){return!this._settings.baseNameMatch&&!t.match(e)}_isSkippedByNegativePatterns(e,t){return!a.pattern.matchAny(e,t)}}},4273:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(3065);t.default=class EntryFilter{constructor(e,t){this._settings=e,this._micromatchOptions=t,this.index=new Map}getFilter(e,t){const n=a.pattern.convertPatternsToRe(e,this._micromatchOptions),r=a.pattern.convertPatternsToRe(t,this._micromatchOptions);return e=>this._filter(e,n,r)}_filter(e,t,n){if(this._settings.unique&&this._isDuplicateEntry(e))return!1;if(this._onlyFileFilter(e)||this._onlyDirectoryFilter(e))return!1;if(this._isSkippedByAbsoluteNegativePatterns(e.path,n))return!1;const a=this._settings.baseNameMatch?e.name:e.path,r=this._isMatchToPatterns(a,t)&&!this._isMatchToPatterns(e.path,n);return this._settings.unique&&r&&this._createIndexRecord(e),r}_isDuplicateEntry(e){return this.index.has(e.path)}_createIndexRecord(e){this.index.set(e.path,void 0)}_onlyFileFilter(e){return this._settings.onlyFiles&&!e.dirent.isFile()}_onlyDirectoryFilter(e){return this._settings.onlyDirectories&&!e.dirent.isDirectory()}_isSkippedByAbsoluteNegativePatterns(e,t){if(!this._settings.absolute)return!1;const n=a.path.makeAbsolute(this._settings.cwd,e);return a.pattern.matchAny(n,t)}_isMatchToPatterns(e,t){const n=a.path.removeLeadingDotSegment(e);return a.pattern.matchAny(n,t)}}},8936:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(3065);t.default=class ErrorFilter{constructor(e){this._settings=e}getFilter(){return e=>this._isNonFatalError(e)}_isNonFatalError(e){return a.errno.isEnoentCodeError(e)||this._settings.suppressErrors}}},4691:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(3065);t.default=class Matcher{constructor(e,t,n){this._patterns=e,this._settings=t,this._micromatchOptions=n,this._storage=[],this._fillStorage()}_fillStorage(){const e=a.pattern.expandPatternsWithBraceExpansion(this._patterns);for(const t of e){const e=this._getPatternSegments(t),n=this._splitSegmentsIntoSections(e);this._storage.push({complete:n.length<=1,pattern:t,segments:e,sections:n})}}_getPatternSegments(e){return a.pattern.getPatternParts(e,this._micromatchOptions).map((e=>a.pattern.isDynamicPattern(e,this._settings)?{dynamic:!0,pattern:e,patternRe:a.pattern.makeRe(e,this._micromatchOptions)}:{dynamic:!1,pattern:e}))}_splitSegmentsIntoSections(e){return a.array.splitWhen(e,(e=>e.dynamic&&a.pattern.hasGlobStar(e.pattern)))}}},5433:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(4691);class PartialMatcher extends a.default{match(e){const t=e.split("/"),n=t.length,a=this._storage.filter((e=>!e.complete||e.segments.length>n));for(const e of a){const a=e.sections[0];if(!e.complete&&n>a.length)return!0;if(t.every(((t,n)=>{const a=e.segments[n];return!(!a.dynamic||!a.patternRe.test(t))||!a.dynamic&&a.pattern===t})))return!0}return!1}}t.default=PartialMatcher},1646:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5622),r=n(8042),i=n(4273),o=n(8936),s=n(9415);t.default=class Provider{constructor(e){this._settings=e,this.errorFilter=new o.default(this._settings),this.entryFilter=new i.default(this._settings,this._getMicromatchOptions()),this.deepFilter=new r.default(this._settings,this._getMicromatchOptions()),this.entryTransformer=new s.default(this._settings)}_getRootDirectory(e){return a.resolve(this._settings.cwd,e.base)}_getReaderOptions(e){const t="."===e.base?"":e.base;return{basePath:t,pathSegmentSeparator:"/",concurrency:this._settings.concurrency,deepFilter:this.deepFilter.getFilter(t,e.positive,e.negative),entryFilter:this.entryFilter.getFilter(e.positive,e.negative),errorFilter:this.errorFilter.getFilter(),followSymbolicLinks:this._settings.followSymbolicLinks,fs:this._settings.fs,stats:this._settings.stats,throwErrorOnBrokenSymbolicLink:this._settings.throwErrorOnBrokenSymbolicLink,transform:this.entryTransformer.getTransformer()}}_getMicromatchOptions(){return{dot:this._settings.dot,matchBase:this._settings.baseNameMatch,nobrace:!this._settings.braceExpansion,nocase:!this._settings.caseSensitiveMatch,noext:!this._settings.extglob,noglobstar:!this._settings.globstar,posix:!0,strictSlashes:!1}}}},8394:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(2413),r=n(951),i=n(1646);class ProviderStream extends i.default{constructor(){super(...arguments),this._reader=new r.default(this._settings)}read(e){const t=this._getRootDirectory(e),n=this._getReaderOptions(e),r=this.api(t,e,n),i=new a.Readable({objectMode:!0,read:()=>{}});return r.once("error",(e=>i.emit("error",e))).on("data",(e=>i.emit("data",n.transform(e)))).once("end",(()=>i.emit("end"))),i.once("close",(()=>r.destroy())),i}api(e,t,n){return t.dynamic?this._reader.dynamic(e,n):this._reader.static(t.patterns,n)}}t.default=ProviderStream},4790:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(2360),r=n(1646);class ProviderSync extends r.default{constructor(){super(...arguments),this._reader=new a.default(this._settings)}read(e){const t=this._getRootDirectory(e),n=this._getReaderOptions(e);return this.api(t,e,n).map(n.transform)}api(e,t,n){return t.dynamic?this._reader.dynamic(e,n):this._reader.static(t.patterns,n)}}t.default=ProviderSync},9415:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(3065);t.default=class EntryTransformer{constructor(e){this._settings=e}getTransformer(){return e=>this._transform(e)}_transform(e){let t=e.path;return this._settings.absolute&&(t=a.path.makeAbsolute(this._settings.cwd,t),t=a.path.unixify(t)),this._settings.markDirectories&&e.dirent.isDirectory()&&(t+="/"),this._settings.objectMode?Object.assign(Object.assign({},e),{path:t}):t}}},2457:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5622),r=n(1992),i=n(3065);t.default=class Reader{constructor(e){this._settings=e,this._fsStatSettings=new r.Settings({followSymbolicLink:this._settings.followSymbolicLinks,fs:this._settings.fs,throwErrorOnBrokenSymbolicLink:this._settings.followSymbolicLinks})}_getFullEntryPath(e){return a.resolve(this._settings.cwd,e)}_makeEntry(e,t){const n={name:t,path:t,dirent:i.fs.createDirentFromStats(t,e)};return this._settings.stats&&(n.stats=e),n}_isFatalError(e){return!i.errno.isEnoentCodeError(e)&&!this._settings.suppressErrors}}},951:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(2413),r=n(1992),i=n(4833),o=n(2457);class ReaderStream extends o.default{constructor(){super(...arguments),this._walkStream=i.walkStream,this._stat=r.stat}dynamic(e,t){return this._walkStream(e,t)}static(e,t){const n=e.map(this._getFullEntryPath,this),r=new a.PassThrough({objectMode:!0});r._write=(a,i,o)=>this._getEntry(n[a],e[a],t).then((e=>{null!==e&&t.entryFilter(e)&&r.push(e),a===n.length-1&&r.end(),o()})).catch(o);for(let e=0;e<n.length;e++)r.write(e);return r}_getEntry(e,t,n){return this._getStat(e).then((e=>this._makeEntry(e,t))).catch((e=>{if(n.errorFilter(e))return null;throw e}))}_getStat(e){return new Promise(((t,n)=>{this._stat(e,this._fsStatSettings,((e,a)=>null===e?t(a):n(e)))}))}}t.default=ReaderStream},2360:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(1992),r=n(4833),i=n(2457);class ReaderSync extends i.default{constructor(){super(...arguments),this._walkSync=r.walkSync,this._statSync=a.statSync}dynamic(e,t){return this._walkSync(e,t)}static(e,t){const n=[];for(const a of e){const e=this._getFullEntryPath(a),r=this._getEntry(e,a,t);null!==r&&t.entryFilter(r)&&n.push(r)}return n}_getEntry(e,t,n){try{const n=this._getStat(e);return this._makeEntry(n,t)}catch(e){if(n.errorFilter(e))return null;throw e}}_getStat(e){return this._statSync(e,this._fsStatSettings)}}t.default=ReaderSync},9516:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DEFAULT_FILE_SYSTEM_ADAPTER=void 0;const a=n(5747),r=n(2087),i=Math.max(r.cpus().length,1);t.DEFAULT_FILE_SYSTEM_ADAPTER={lstat:a.lstat,lstatSync:a.lstatSync,stat:a.stat,statSync:a.statSync,readdir:a.readdir,readdirSync:a.readdirSync};t.default=class Settings{constructor(e={}){this._options=e,this.absolute=this._getValue(this._options.absolute,!1),this.baseNameMatch=this._getValue(this._options.baseNameMatch,!1),this.braceExpansion=this._getValue(this._options.braceExpansion,!0),this.caseSensitiveMatch=this._getValue(this._options.caseSensitiveMatch,!0),this.concurrency=this._getValue(this._options.concurrency,i),this.cwd=this._getValue(this._options.cwd,process.cwd()),this.deep=this._getValue(this._options.deep,1/0),this.dot=this._getValue(this._options.dot,!1),this.extglob=this._getValue(this._options.extglob,!0),this.followSymbolicLinks=this._getValue(this._options.followSymbolicLinks,!0),this.fs=this._getFileSystemMethods(this._options.fs),this.globstar=this._getValue(this._options.globstar,!0),this.ignore=this._getValue(this._options.ignore,[]),this.markDirectories=this._getValue(this._options.markDirectories,!1),this.objectMode=this._getValue(this._options.objectMode,!1),this.onlyDirectories=this._getValue(this._options.onlyDirectories,!1),this.onlyFiles=this._getValue(this._options.onlyFiles,!0),this.stats=this._getValue(this._options.stats,!1),this.suppressErrors=this._getValue(this._options.suppressErrors,!1),this.throwErrorOnBrokenSymbolicLink=this._getValue(this._options.throwErrorOnBrokenSymbolicLink,!1),this.unique=this._getValue(this._options.unique,!0),this.onlyDirectories&&(this.onlyFiles=!1),this.stats&&(this.objectMode=!0)}_getValue(e,t){return void 0===e?t:e}_getFileSystemMethods(e={}){return Object.assign(Object.assign({},t.DEFAULT_FILE_SYSTEM_ADAPTER),e)}}},8213:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.splitWhen=t.flatten=void 0,t.flatten=function(e){return e.reduce(((e,t)=>[].concat(e,t)),[])},t.splitWhen=function(e,t){const n=[[]];let a=0;for(const r of e)t(r)?(a++,n[a]=[]):n[a].push(r);return n}},8925:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isEnoentCodeError=void 0,t.isEnoentCodeError=function(e){return"ENOENT"===e.code}},6800:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createDirentFromStats=void 0;class DirentFromStats{constructor(e,t){this.name=e,this.isBlockDevice=t.isBlockDevice.bind(t),this.isCharacterDevice=t.isCharacterDevice.bind(t),this.isDirectory=t.isDirectory.bind(t),this.isFIFO=t.isFIFO.bind(t),this.isFile=t.isFile.bind(t),this.isSocket=t.isSocket.bind(t),this.isSymbolicLink=t.isSymbolicLink.bind(t)}}t.createDirentFromStats=function(e,t){return new DirentFromStats(e,t)}},3065:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.string=t.stream=t.pattern=t.path=t.fs=t.errno=t.array=void 0;const a=n(8213);t.array=a;const r=n(8925);t.errno=r;const i=n(6800);t.fs=i;const o=n(3224);t.path=o;const s=n(9496);t.pattern=s;const c=n(3749);t.stream=c;const l=n(7878);t.string=l},3224:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.removeLeadingDotSegment=t.escape=t.makeAbsolute=t.unixify=void 0;const a=n(5622),r=/(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;t.unixify=function(e){return e.replace(/\\/g,"/")},t.makeAbsolute=function(e,t){return a.resolve(e,t)},t.escape=function(e){return e.replace(r,"\\$2")},t.removeLeadingDotSegment=function(e){if("."===e.charAt(0)){const t=e.charAt(1);if("/"===t||"\\"===t)return e.slice(2)}return e}},9496:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.matchAny=t.convertPatternsToRe=t.makeRe=t.getPatternParts=t.expandBraceExpansion=t.expandPatternsWithBraceExpansion=t.isAffectDepthOfReadingPattern=t.endsWithSlashGlobStar=t.hasGlobStar=t.getBaseDirectory=t.getPositivePatterns=t.getNegativePatterns=t.isPositivePattern=t.isNegativePattern=t.convertToNegativePattern=t.convertToPositivePattern=t.isDynamicPattern=t.isStaticPattern=void 0;const a=n(5622),r=n(8637),i=n(8575),o=n(4973),s=/[*?]|^!/,c=/\[.*]/,l=/(?:^|[^!*+?@])\(.*\|.*\)/,u=/[!*+?@]\(.*\)/,p=/{.*(?:,|\.\.).*}/;function f(e,t={}){return!d(e,t)}function d(e,t={}){return""!==e&&(!(!1!==t.caseSensitiveMatch&&!e.includes("\\"))||(!!(s.test(e)||c.test(e)||l.test(e))||(!(!1===t.extglob||!u.test(e))||!(!1===t.braceExpansion||!p.test(e)))))}function h(e){return e.startsWith("!")&&"("!==e[1]}function g(e){return!h(e)}function m(e){return e.endsWith("/**")}function y(e){return i.braces(e,{expand:!0,nodupes:!0})}function v(e,t){return i.makeRe(e,t)}t.isStaticPattern=f,t.isDynamicPattern=d,t.convertToPositivePattern=function(e){return h(e)?e.slice(1):e},t.convertToNegativePattern=function(e){return"!"+e},t.isNegativePattern=h,t.isPositivePattern=g,t.getNegativePatterns=function(e){return e.filter(h)},t.getPositivePatterns=function(e){return e.filter(g)},t.getBaseDirectory=function(e){return r(e,{flipBackslashes:!1})},t.hasGlobStar=function(e){return e.includes("**")},t.endsWithSlashGlobStar=m,t.isAffectDepthOfReadingPattern=function(e){const t=a.basename(e);return m(e)||f(t)},t.expandPatternsWithBraceExpansion=function(e){return e.reduce(((e,t)=>e.concat(y(t))),[])},t.expandBraceExpansion=y,t.getPatternParts=function(e,t){let{parts:n}=o.scan(e,Object.assign(Object.assign({},t),{parts:!0}));return 0===n.length&&(n=[e]),n[0].startsWith("/")&&(n[0]=n[0].slice(1),n.unshift("")),n},t.makeRe=v,t.convertPatternsToRe=function(e,t){return e.map((e=>v(e,t)))},t.matchAny=function(e,t){return t.some((t=>t.test(e)))}},3749:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.merge=void 0;const a=n(1993);function r(e){e.forEach((e=>e.emit("close")))}t.merge=function(e){const t=a(e);return e.forEach((e=>{e.once("error",(e=>t.emit("error",e)))})),t.once("close",(()=>r(e))),t.once("end",(()=>r(e))),t}},7878:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isEmpty=t.isString=void 0,t.isString=function(e){return"string"==typeof e},t.isEmpty=function(e){return""===e}},9003:e=>{"use strict";e.exports=function(e,t){t||(t={}),"function"==typeof t&&(t={cmp:t});var n,a="boolean"==typeof t.cycles&&t.cycles,r=t.cmp&&(n=t.cmp,function(e){return function(t,a){var r={key:t,value:e[t]},i={key:a,value:e[a]};return n(r,i)}}),i=[];return function e(t){if(t&&t.toJSON&&"function"==typeof t.toJSON&&(t=t.toJSON()),void 0!==t){if("number"==typeof t)return isFinite(t)?""+t:"null";if("object"!=typeof t)return JSON.stringify(t);var n,o;if(Array.isArray(t)){for(o="[",n=0;n<t.length;n++)n&&(o+=","),o+=e(t[n])||"null";return o+"]"}if(null===t)return"null";if(-1!==i.indexOf(t)){if(a)return JSON.stringify("__cycle__");throw new TypeError("Converting circular structure to JSON")}var s=i.push(t)-1,c=Object.keys(t).sort(r&&r(t));for(o="",n=0;n<c.length;n++){var l=c[n],u=e(t[l]);u&&(o&&(o+=","),o+=JSON.stringify(l)+":"+u)}return i.splice(s,1),"{"+o+"}"}}(e)}},1582:(e,t,n)=>{"use strict";var a=n(7174);function r(){}function i(){this.value=null,this.callback=r,this.next=null,this.release=r,this.context=null,this.errorHandler=null;var e=this;this.worked=function(t,n){var a=e.callback,i=e.errorHandler,o=e.value;e.value=null,e.callback=r,e.errorHandler&&i(t,o),a.call(e.context,t,n),e.release(e)}}e.exports=function(e,t,n){if("function"==typeof e&&(n=t,t=e,e=null),n<1)throw new Error("fastqueue concurrency must be greater than 1");var o=a(i),s=null,c=null,l=0,u=null,p={push:function(n,a){var i=o.get();i.context=e,i.release=f,i.value=n,i.callback=a||r,i.errorHandler=u,l===p.concurrency||p.paused?c?(c.next=i,c=i):(s=i,c=i,p.saturated()):(l++,t.call(e,i.value,i.worked))},drain:r,saturated:r,pause:function(){p.paused=!0},paused:!1,concurrency:n,running:function(){return l},resume:function(){if(!p.paused)return;p.paused=!1;for(var e=0;e<p.concurrency;e++)l++,f()},idle:function(){return 0===l&&0===p.length()},length:function(){var e=s,t=0;for(;e;)e=e.next,t++;return t},getQueue:function(){var e=s,t=[];for(;e;)t.push(e.value),e=e.next;return t},unshift:function(n,a){var i=o.get();i.context=e,i.release=f,i.value=n,i.callback=a||r,l===p.concurrency||p.paused?s?(i.next=s,s=i):(s=i,c=i,p.saturated()):(l++,t.call(e,i.value,i.worked))},empty:r,kill:function(){s=null,c=null,p.drain=r},killAndDrain:function(){s=null,c=null,p.drain(),p.drain=r},error:function(e){u=e}};return p;function f(n){n&&o.release(n);var a=s;a?p.paused?l--:(c===s&&(c=null),s=a.next,a.next=null,t.call(e,a.value,a.worked),null===c&&p.empty()):0==--l&&p.drain()}}},2937:(e,t,n)=>{"use strict";var a=n(1669),r=n(8295).Duplex;function i(e,t){var n,a,o=this,s={sent:!1,chunks:[],size:0};if(!(this instanceof i))return new i(e,t);if(e=e||{},!(t instanceof Function))throw new Error("FirstChunkStream constructor requires a callback as its second argument.");if("number"!=typeof e.chunkLength)throw new Error("FirstChunkStream constructor requires `options.chunkLength` to be a number.");if(e.objectMode)throw new Error("FirstChunkStream doesn't support `objectMode` yet.");function c(e,n,a,r){e?setImmediate((function(){o.removeListener("error",s.errorHandler)})):o.removeListener("error",s.errorHandler),s.sent=!0,t(e,n,a,(function(e,t,n){e?setImmediate((function(){o.emit("error",e)})):t?s.manager.programPush(t,n,r):r()}))}r.call(this,e),s.manager=(a={waitPush:!0,programmedPushs:[],programPush:function(e,t,r){r=r||function(){},a.programmedPushs.push([e,t,r]),setImmediate(a.attemptPush),n.emit("readable"),n.emit("drain")},attemptPush:function(){var e;a.waitPush?a.programmedPushs.length&&(e=a.programmedPushs.shift(),a.waitPush=n.push(e[0],e[1]),e[2]()):setImmediate((function(){n.emit("readable")}))}},(n=this)._read=function(){a.waitPush=!0,setImmediate(a.attemptPush)},a),s.errorHandler=function(e){c(e,Buffer.concat(s.chunks,s.size),s.encoding,(function(){}))},this.on("error",s.errorHandler),this._write=function(t,n,a){s.encoding=n,s.sent?s.manager.programPush(t,s.encoding,a):t.length<e.chunkLength-s.size?(s.chunks.push(t),s.size+=t.length,a()):(s.chunks.push(t.slice(0,e.chunkLength-s.size)),t=t.slice(e.chunkLength-s.size),s.size+=s.chunks[s.chunks.length-1].length,c(null,Buffer.concat(s.chunks,s.size),s.encoding,(function(){t.length?s.manager.programPush(t,s.encoding,a):a()})))},this.on("finish",(function(){if(!s.sent)return c(null,Buffer.concat(s.chunks,s.size),s.encoding,(function(){s.manager.programPush(null,s.encoding)}));s.manager.programPush(null,s.encoding)}))}a.inherits(i,r),e.exports=i},8637:(e,t,n)=>{"use strict";var a=n(3490),r=n(5622).posix.dirname,i="win32"===n(2087).platform(),o=/\\/g,s=/[\{\[].*[\}\]]$/,c=/(^|[^\\])([\{\[]|\([^\)]+$)/,l=/\\([\!\*\?\|\[\]\(\)\{\}])/g;e.exports=function(e,t){Object.assign({flipBackslashes:!0},t).flipBackslashes&&i&&e.indexOf("/")<0&&(e=e.replace(o,"/")),s.test(e)&&(e+="/"),e+="a";do{e=r(e)}while(a(e)||c.test(e));return e.replace(l,"$1")}},346:e=>{"use strict";e.exports=function(e){if(null===e||"object"!=typeof e)return e;if(e instanceof Object)var t={__proto__:e.__proto__};else t=Object.create(null);return Object.getOwnPropertyNames(e).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))})),t}},2159:(e,t,n)=>{var a,r,i=n(5747),o=n(3489),s=n(4385),c=n(346),l=n(1669);function u(e,t){Object.defineProperty(e,a,{get:function(){return t}})}"function"==typeof Symbol&&"function"==typeof Symbol.for?(a=Symbol.for("graceful-fs.queue"),r=Symbol.for("graceful-fs.previous")):(a="___graceful-fs.queue",r="___graceful-fs.previous");var p=function(){};if(l.debuglog?p=l.debuglog("gfs4"):/\bgfs4\b/i.test(process.env.NODE_DEBUG||"")&&(p=function(){var e=l.format.apply(l,arguments);e="GFS4: "+e.split(/\n/).join("\nGFS4: "),console.error(e)}),!i[a]){var f=global[a]||[];u(i,f),i.close=function(e){function t(t,n){return e.call(i,t,(function(e){e||g(),"function"==typeof n&&n.apply(this,arguments)}))}return Object.defineProperty(t,r,{value:e}),t}(i.close),i.closeSync=function(e){function t(t){e.apply(i,arguments),g()}return Object.defineProperty(t,r,{value:e}),t}(i.closeSync),/\bgfs4\b/i.test(process.env.NODE_DEBUG||"")&&process.on("exit",(function(){p(i[a]),n(2357).equal(i[a].length,0)}))}function d(e){o(e),e.gracefulify=d,e.createReadStream=function(t,n){return new e.ReadStream(t,n)},e.createWriteStream=function(t,n){return new e.WriteStream(t,n)};var t=e.readFile;e.readFile=function(e,n,a){"function"==typeof n&&(a=n,n=null);return function e(n,a,r){return t(n,a,(function(t){!t||"EMFILE"!==t.code&&"ENFILE"!==t.code?("function"==typeof r&&r.apply(this,arguments),g()):h([e,[n,a,r]])}))}(e,n,a)};var n=e.writeFile;e.writeFile=function(e,t,a,r){"function"==typeof a&&(r=a,a=null);return function e(t,a,r,i){return n(t,a,r,(function(n){!n||"EMFILE"!==n.code&&"ENFILE"!==n.code?("function"==typeof i&&i.apply(this,arguments),g()):h([e,[t,a,r,i]])}))}(e,t,a,r)};var a=e.appendFile;a&&(e.appendFile=function(e,t,n,r){"function"==typeof n&&(r=n,n=null);return function e(t,n,r,i){return a(t,n,r,(function(a){!a||"EMFILE"!==a.code&&"ENFILE"!==a.code?("function"==typeof i&&i.apply(this,arguments),g()):h([e,[t,n,r,i]])}))}(e,t,n,r)});var r=e.readdir;function i(t){return r.apply(e,t)}if(e.readdir=function(e,t,n){var a=[e];"function"!=typeof t?a.push(t):n=t;return a.push((function(e,t){t&&t.sort&&t.sort();!e||"EMFILE"!==e.code&&"ENFILE"!==e.code?("function"==typeof n&&n.apply(this,arguments),g()):h([i,[a]])})),i(a)},"v0.8"===process.version.substr(0,4)){var c=s(e);m=c.ReadStream,y=c.WriteStream}var l=e.ReadStream;l&&(m.prototype=Object.create(l.prototype),m.prototype.open=function(){var e=this;b(e.path,e.flags,e.mode,(function(t,n){t?(e.autoClose&&e.destroy(),e.emit("error",t)):(e.fd=n,e.emit("open",n),e.read())}))});var u=e.WriteStream;u&&(y.prototype=Object.create(u.prototype),y.prototype.open=function(){var e=this;b(e.path,e.flags,e.mode,(function(t,n){t?(e.destroy(),e.emit("error",t)):(e.fd=n,e.emit("open",n))}))}),Object.defineProperty(e,"ReadStream",{get:function(){return m},set:function(e){m=e},enumerable:!0,configurable:!0}),Object.defineProperty(e,"WriteStream",{get:function(){return y},set:function(e){y=e},enumerable:!0,configurable:!0});var p=m;Object.defineProperty(e,"FileReadStream",{get:function(){return p},set:function(e){p=e},enumerable:!0,configurable:!0});var f=y;function m(e,t){return this instanceof m?(l.apply(this,arguments),this):m.apply(Object.create(m.prototype),arguments)}function y(e,t){return this instanceof y?(u.apply(this,arguments),this):y.apply(Object.create(y.prototype),arguments)}Object.defineProperty(e,"FileWriteStream",{get:function(){return f},set:function(e){f=e},enumerable:!0,configurable:!0});var v=e.open;function b(e,t,n,a){return"function"==typeof n&&(a=n,n=null),function e(t,n,a,r){return v(t,n,a,(function(i,o){!i||"EMFILE"!==i.code&&"ENFILE"!==i.code?("function"==typeof r&&r.apply(this,arguments),g()):h([e,[t,n,a,r]])}))}(e,t,n,a)}return e.open=b,e}function h(e){p("ENQUEUE",e[0].name,e[1]),i[a].push(e)}function g(){var e=i[a].shift();e&&(p("RETRY",e[0].name,e[1]),e[0].apply(null,e[1]))}global[a]||u(global,i[a]),e.exports=d(c(i)),process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH&&!i.__patched&&(e.exports=d(i),i.__patched=!0)},4385:(e,t,n)=>{var a=n(2413).Stream;e.exports=function(e){return{ReadStream:function t(n,r){if(!(this instanceof t))return new t(n,r);a.call(this);var i=this;this.path=n,this.fd=null,this.readable=!0,this.paused=!1,this.flags="r",this.mode=438,this.bufferSize=65536,r=r||{};for(var o=Object.keys(r),s=0,c=o.length;s<c;s++){var l=o[s];this[l]=r[l]}this.encoding&&this.setEncoding(this.encoding);if(void 0!==this.start){if("number"!=typeof this.start)throw TypeError("start must be a Number");if(void 0===this.end)this.end=1/0;else if("number"!=typeof this.end)throw TypeError("end must be a Number");if(this.start>this.end)throw new Error("start must be <= end");this.pos=this.start}if(null!==this.fd)return void process.nextTick((function(){i._read()}));e.open(this.path,this.flags,this.mode,(function(e,t){if(e)return i.emit("error",e),void(i.readable=!1);i.fd=t,i.emit("open",t),i._read()}))},WriteStream:function t(n,r){if(!(this instanceof t))return new t(n,r);a.call(this),this.path=n,this.fd=null,this.writable=!0,this.flags="w",this.encoding="binary",this.mode=438,this.bytesWritten=0,r=r||{};for(var i=Object.keys(r),o=0,s=i.length;o<s;o++){var c=i[o];this[c]=r[c]}if(void 0!==this.start){if("number"!=typeof this.start)throw TypeError("start must be a Number");if(this.start<0)throw new Error("start must be >= zero");this.pos=this.start}this.busy=!1,this._queue=[],null===this.fd&&(this._open=e.open,this._queue.push([this._open,this.path,this.flags,this.mode,void 0]),this.flush())}}}},3489:(e,t,n)=>{var a=n(7619),r=process.cwd,i=null,o=process.env.GRACEFUL_FS_PLATFORM||process.platform;process.cwd=function(){return i||(i=r.call(process)),i};try{process.cwd()}catch(e){}var s=process.chdir;process.chdir=function(e){i=null,s.call(process,e)},e.exports=function(e){a.hasOwnProperty("O_SYMLINK")&&process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)&&function(e){e.lchmod=function(t,n,r){e.open(t,a.O_WRONLY|a.O_SYMLINK,n,(function(t,a){t?r&&r(t):e.fchmod(a,n,(function(t){e.close(a,(function(e){r&&r(t||e)}))}))}))},e.lchmodSync=function(t,n){var r,i=e.openSync(t,a.O_WRONLY|a.O_SYMLINK,n),o=!0;try{r=e.fchmodSync(i,n),o=!1}finally{if(o)try{e.closeSync(i)}catch(e){}else e.closeSync(i)}return r}}(e);e.lutimes||function(e){a.hasOwnProperty("O_SYMLINK")?(e.lutimes=function(t,n,r,i){e.open(t,a.O_SYMLINK,(function(t,a){t?i&&i(t):e.futimes(a,n,r,(function(t){e.close(a,(function(e){i&&i(t||e)}))}))}))},e.lutimesSync=function(t,n,r){var i,o=e.openSync(t,a.O_SYMLINK),s=!0;try{i=e.futimesSync(o,n,r),s=!1}finally{if(s)try{e.closeSync(o)}catch(e){}else e.closeSync(o)}return i}):(e.lutimes=function(e,t,n,a){a&&process.nextTick(a)},e.lutimesSync=function(){})}(e);e.chown=i(e.chown),e.fchown=i(e.fchown),e.lchown=i(e.lchown),e.chmod=n(e.chmod),e.fchmod=n(e.fchmod),e.lchmod=n(e.lchmod),e.chownSync=s(e.chownSync),e.fchownSync=s(e.fchownSync),e.lchownSync=s(e.lchownSync),e.chmodSync=r(e.chmodSync),e.fchmodSync=r(e.fchmodSync),e.lchmodSync=r(e.lchmodSync),e.stat=c(e.stat),e.fstat=c(e.fstat),e.lstat=c(e.lstat),e.statSync=l(e.statSync),e.fstatSync=l(e.fstatSync),e.lstatSync=l(e.lstatSync),e.lchmod||(e.lchmod=function(e,t,n){n&&process.nextTick(n)},e.lchmodSync=function(){});e.lchown||(e.lchown=function(e,t,n,a){a&&process.nextTick(a)},e.lchownSync=function(){});"win32"===o&&(e.rename=(t=e.rename,function(n,a,r){var i=Date.now(),o=0;t(n,a,(function s(c){if(c&&("EACCES"===c.code||"EPERM"===c.code)&&Date.now()-i<6e4)return setTimeout((function(){e.stat(a,(function(e,i){e&&"ENOENT"===e.code?t(n,a,s):r(c)}))}),o),void(o<100&&(o+=10));r&&r(c)}))}));var t;function n(t){return t?function(n,a,r){return t.call(e,n,a,(function(e){u(e)&&(e=null),r&&r.apply(this,arguments)}))}:t}function r(t){return t?function(n,a){try{return t.call(e,n,a)}catch(e){if(!u(e))throw e}}:t}function i(t){return t?function(n,a,r,i){return t.call(e,n,a,r,(function(e){u(e)&&(e=null),i&&i.apply(this,arguments)}))}:t}function s(t){return t?function(n,a,r){try{return t.call(e,n,a,r)}catch(e){if(!u(e))throw e}}:t}function c(t){return t?function(n,a,r){function i(e,t){t&&(t.uid<0&&(t.uid+=4294967296),t.gid<0&&(t.gid+=4294967296)),r&&r.apply(this,arguments)}return"function"==typeof a&&(r=a,a=null),a?t.call(e,n,a,i):t.call(e,n,i)}:t}function l(t){return t?function(n,a){var r=a?t.call(e,n,a):t.call(e,n);return r.uid<0&&(r.uid+=4294967296),r.gid<0&&(r.gid+=4294967296),r}:t}function u(e){return!e||("ENOSYS"===e.code||!(process.getuid&&0===process.getuid()||"EINVAL"!==e.code&&"EPERM"!==e.code))}e.read=function(t){function n(n,a,r,i,o,s){var c;if(s&&"function"==typeof s){var l=0;c=function(u,p,f){if(u&&"EAGAIN"===u.code&&l<10)return l++,t.call(e,n,a,r,i,o,c);s.apply(this,arguments)}}return t.call(e,n,a,r,i,o,c)}return n.__proto__=t,n}(e.read),e.readSync=(p=e.readSync,function(t,n,a,r,i){for(var o=0;;)try{return p.call(e,t,n,a,r,i)}catch(e){if("EAGAIN"===e.code&&o<10){o++;continue}throw e}});var p}},9154:(e,t,n)=>{"use strict";function a(e){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?Object(arguments[t]):{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){r(e,t,n[t])}))}return e}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function s(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function c(e,t,n){return t&&s(e.prototype,t),n&&s(e,n),e}function l(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function u(e,t){return!t||"object"!==a(t)&&"function"!=typeof t?l(e):t}function p(e){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function f(e,t){return(f=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function d(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&f(e,t)}n.r(t),n.d(t,{default:()=>Q});var h={type:"logger",log:function(e){this.output("log",e)},warn:function(e){this.output("warn",e)},error:function(e){this.output("error",e)},output:function(e,t){console&&console[e]&&console[e].apply(console,t)}},g=new(function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};o(this,e),this.init(t,n)}return c(e,[{key:"init",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.prefix=t.prefix||"i18next:",this.logger=e||h,this.options=t,this.debug=t.debug}},{key:"setDebug",value:function(e){this.debug=e}},{key:"log",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"log","",!0)}},{key:"warn",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"warn","",!0)}},{key:"error",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"error","")}},{key:"deprecate",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"warn","WARNING DEPRECATED: ",!0)}},{key:"forward",value:function(e,t,n,a){return a&&!this.debug?null:("string"==typeof e[0]&&(e[0]="".concat(n).concat(this.prefix," ").concat(e[0])),this.logger[t](e))}},{key:"create",value:function(t){return new e(this.logger,i({},{prefix:"".concat(this.prefix,":").concat(t,":")},this.options))}}]),e}()),m=function(){function e(){o(this,e),this.observers={}}return c(e,[{key:"on",value:function(e,t){var n=this;return e.split(" ").forEach((function(e){n.observers[e]=n.observers[e]||[],n.observers[e].push(t)})),this}},{key:"off",value:function(e,t){this.observers[e]&&(t?this.observers[e]=this.observers[e].filter((function(e){return e!==t})):delete this.observers[e])}},{key:"emit",value:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];if(this.observers[e]){var r=[].concat(this.observers[e]);r.forEach((function(e){e.apply(void 0,n)}))}if(this.observers["*"]){var i=[].concat(this.observers["*"]);i.forEach((function(t){t.apply(t,[e].concat(n))}))}}}]),e}();function y(){var e,t,n=new Promise((function(n,a){e=n,t=a}));return n.resolve=e,n.reject=t,n}function v(e){return null==e?"":""+e}function b(e,t,n){e.forEach((function(e){t[e]&&(n[e]=t[e])}))}function P(e,t,n){function a(e){return e&&e.indexOf("###")>-1?e.replace(/###/g,"."):e}function r(){return!e||"string"==typeof e}for(var i="string"!=typeof t?[].concat(t):t.split(".");i.length>1;){if(r())return{};var o=a(i.shift());!e[o]&&n&&(e[o]=new n),e=Object.prototype.hasOwnProperty.call(e,o)?e[o]:{}}return r()?{}:{obj:e,k:a(i.shift())}}function S(e,t,n){var a=P(e,t,Object);a.obj[a.k]=n}function T(e,t){var n=P(e,t),a=n.obj,r=n.k;if(a)return a[r]}function O(e,t,n){var a=T(e,n);return void 0!==a?a:T(t,n)}function E(e,t,n){for(var a in t)"__proto__"!==a&&"constructor"!==a&&(a in e?"string"==typeof e[a]||e[a]instanceof String||"string"==typeof t[a]||t[a]instanceof String?n&&(e[a]=t[a]):E(e[a],t[a],n):e[a]=t[a]);return e}function _(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}var C={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"};function A(e){return"string"==typeof e?e.replace(/[&<>"'\/]/g,(function(e){return C[e]})):e}var I="undefined"!=typeof window&&window.navigator&&window.navigator.userAgent&&window.navigator.userAgent.indexOf("MSIE")>-1;function R(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:".";if(e){if(e[t])return e[t];for(var a=t.split(n),r=e,i=0;i<a.length;++i){if("string"==typeof r[a[i]]&&i+1<a.length)return;if(void 0===r[a[i]]){for(var o=2,s=a.slice(i,i+o).join(n),c=r[s];void 0===c&&a.length>i+o;)o++,c=r[s=a.slice(i,i+o).join(n)];if(void 0===c)return;if("string"==typeof c)return c;if(s&&"string"==typeof c[s])return c[s];var l=a.slice(i+o).join(n);return l?R(c,l,n):void 0}r=r[a[i]]}return r}}var F=function(e){function t(e){var n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{ns:["translation"],defaultNS:"translation"};return o(this,t),n=u(this,p(t).call(this)),I&&m.call(l(n)),n.data=e||{},n.options=a,void 0===n.options.keySeparator&&(n.options.keySeparator="."),void 0===n.options.ignoreJSONStructure&&(n.options.ignoreJSONStructure=!0),n}return d(t,e),c(t,[{key:"addNamespaces",value:function(e){this.options.ns.indexOf(e)<0&&this.options.ns.push(e)}},{key:"removeNamespaces",value:function(e){var t=this.options.ns.indexOf(e);t>-1&&this.options.ns.splice(t,1)}},{key:"getResource",value:function(e,t,n){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=void 0!==a.keySeparator?a.keySeparator:this.options.keySeparator,i=void 0!==a.ignoreJSONStructure?a.ignoreJSONStructure:this.options.ignoreJSONStructure,o=[e,t];n&&"string"!=typeof n&&(o=o.concat(n)),n&&"string"==typeof n&&(o=o.concat(r?n.split(r):n)),e.indexOf(".")>-1&&(o=e.split("."));var s=T(this.data,o);return s||!i||"string"!=typeof n?s:R(this.data&&this.data[e]&&this.data[e][t],n,r)}},{key:"addResource",value:function(e,t,n,a){var r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{silent:!1},i=this.options.keySeparator;void 0===i&&(i=".");var o=[e,t];n&&(o=o.concat(i?n.split(i):n)),e.indexOf(".")>-1&&(a=t,t=(o=e.split("."))[1]),this.addNamespaces(t),S(this.data,o,a),r.silent||this.emit("added",e,t,n,a)}},{key:"addResources",value:function(e,t,n){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{silent:!1};for(var r in n)"string"!=typeof n[r]&&"[object Array]"!==Object.prototype.toString.apply(n[r])||this.addResource(e,t,r,n[r],{silent:!0});a.silent||this.emit("added",e,t,n)}},{key:"addResourceBundle",value:function(e,t,n,a,r){var o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{silent:!1},s=[e,t];e.indexOf(".")>-1&&(a=n,n=t,t=(s=e.split("."))[1]),this.addNamespaces(t);var c=T(this.data,s)||{};a?E(c,n,r):c=i({},c,n),S(this.data,s,c),o.silent||this.emit("added",e,t,n)}},{key:"removeResourceBundle",value:function(e,t){this.hasResourceBundle(e,t)&&delete this.data[e][t],this.removeNamespaces(t),this.emit("removed",e,t)}},{key:"hasResourceBundle",value:function(e,t){return void 0!==this.getResource(e,t)}},{key:"getResourceBundle",value:function(e,t){return t||(t=this.options.defaultNS),"v1"===this.options.compatibilityAPI?i({},{},this.getResource(e,t)):this.getResource(e,t)}},{key:"getDataByLanguage",value:function(e){return this.data[e]}},{key:"toJSON",value:function(){return this.data}}]),t}(m),x={processors:{},addPostProcessor:function(e){this.processors[e.name]=e},handle:function(e,t,n,a,r){var i=this;return e.forEach((function(e){i.processors[e]&&(t=i.processors[e].process(t,n,a,r))})),t}},w={},j=function(e){function t(e){var n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return o(this,t),n=u(this,p(t).call(this)),I&&m.call(l(n)),b(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],e,l(n)),n.options=a,void 0===n.options.keySeparator&&(n.options.keySeparator="."),n.logger=g.create("translator"),n}return d(t,e),c(t,[{key:"changeLanguage",value:function(e){e&&(this.language=e)}},{key:"exists",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{interpolation:{}},n=this.resolve(e,t);return n&&void 0!==n.res}},{key:"extractFromKey",value:function(e,t){var n=void 0!==t.nsSeparator?t.nsSeparator:this.options.nsSeparator;void 0===n&&(n=":");var a=void 0!==t.keySeparator?t.keySeparator:this.options.keySeparator,r=t.ns||this.options.defaultNS;if(n&&e.indexOf(n)>-1){var i=e.match(this.interpolator.nestingRegexp);if(i&&i.length>0)return{key:e,namespaces:r};var o=e.split(n);(n!==a||n===a&&this.options.ns.indexOf(o[0])>-1)&&(r=o.shift()),e=o.join(a)}return"string"==typeof r&&(r=[r]),{key:e,namespaces:r}}},{key:"translate",value:function(e,n,r){var o=this;if("object"!==a(n)&&this.options.overloadTranslationOptionHandler&&(n=this.options.overloadTranslationOptionHandler(arguments)),n||(n={}),null==e)return"";Array.isArray(e)||(e=[String(e)]);var s=void 0!==n.keySeparator?n.keySeparator:this.options.keySeparator,c=this.extractFromKey(e[e.length-1],n),l=c.key,u=c.namespaces,p=u[u.length-1],f=n.lng||this.language,d=n.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(f&&"cimode"===f.toLowerCase()){if(d){var h=n.nsSeparator||this.options.nsSeparator;return p+h+l}return l}var g=this.resolve(e,n),m=g&&g.res,y=g&&g.usedKey||l,v=g&&g.exactUsedKey||l,b=Object.prototype.toString.apply(m),P=["[object Number]","[object Function]","[object RegExp]"],S=void 0!==n.joinArrays?n.joinArrays:this.options.joinArrays,T=!this.i18nFormat||this.i18nFormat.handleAsObject,O="string"!=typeof m&&"boolean"!=typeof m&&"number"!=typeof m;if(T&&m&&O&&P.indexOf(b)<0&&("string"!=typeof S||"[object Array]"!==b)){if(!n.returnObjects&&!this.options.returnObjects)return this.options.returnedObjectHandler||this.logger.warn("accessing an object - but returnObjects options is not enabled!"),this.options.returnedObjectHandler?this.options.returnedObjectHandler(y,m,i({},n,{ns:u})):"key '".concat(l," (").concat(this.language,")' returned an object instead of string.");if(s){var E="[object Array]"===b,_=E?[]:{},C=E?v:y;for(var A in m)if(Object.prototype.hasOwnProperty.call(m,A)){var I="".concat(C).concat(s).concat(A);_[A]=this.translate(I,i({},n,{joinArrays:!1,ns:u})),_[A]===I&&(_[A]=m[A])}m=_}}else if(T&&"string"==typeof S&&"[object Array]"===b)(m=m.join(S))&&(m=this.extendTranslation(m,e,n,r));else{var R=!1,F=!1,x=void 0!==n.count&&"string"!=typeof n.count,w=t.hasDefaultValue(n),j=x?this.pluralResolver.getSuffix(f,n.count):"",N=n["defaultValue".concat(j)]||n.defaultValue;!this.isValidLookup(m)&&w&&(R=!0,m=N),this.isValidLookup(m)||(F=!0,m=l);var L=w&&N!==m&&this.options.updateMissing;if(F||R||L){if(this.logger.log(L?"updateKey":"missingKey",f,p,l,L?N:m),s){var D=this.resolve(l,i({},n,{keySeparator:!1}));D&&D.res&&this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}var V=[],M=this.languageUtils.getFallbackCodes(this.options.fallbackLng,n.lng||this.language);if("fallback"===this.options.saveMissingTo&&M&&M[0])for(var k=0;k<M.length;k++)V.push(M[k]);else"all"===this.options.saveMissingTo?V=this.languageUtils.toResolveHierarchy(n.lng||this.language):V.push(n.lng||this.language);var $=function(e,t,a){o.options.missingKeyHandler?o.options.missingKeyHandler(e,p,t,L?a:m,L,n):o.backendConnector&&o.backendConnector.saveMissing&&o.backendConnector.saveMissing(e,p,t,L?a:m,L,n),o.emit("missingKey",e,p,t,m)};this.options.saveMissing&&(this.options.saveMissingPlurals&&x?V.forEach((function(e){o.pluralResolver.getSuffixes(e).forEach((function(t){$([e],l+t,n["defaultValue".concat(t)]||N)}))})):$(V,l,N))}m=this.extendTranslation(m,e,n,g,r),F&&m===l&&this.options.appendNamespaceToMissingKey&&(m="".concat(p,":").concat(l)),F&&this.options.parseMissingKeyHandler&&(m=this.options.parseMissingKeyHandler(m))}return m}},{key:"extendTranslation",value:function(e,t,n,a,r){var o=this;if(this.i18nFormat&&this.i18nFormat.parse)e=this.i18nFormat.parse(e,n,a.usedLng,a.usedNS,a.usedKey,{resolved:a});else if(!n.skipInterpolation){n.interpolation&&this.interpolator.init(i({},n,{interpolation:i({},this.options.interpolation,n.interpolation)}));var s,c=n.interpolation&&n.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables;if(c){var l=e.match(this.interpolator.nestingRegexp);s=l&&l.length}var u=n.replace&&"string"!=typeof n.replace?n.replace:n;if(this.options.interpolation.defaultVariables&&(u=i({},this.options.interpolation.defaultVariables,u)),e=this.interpolator.interpolate(e,u,n.lng||this.language,n),c){var p=e.match(this.interpolator.nestingRegexp);s<(p&&p.length)&&(n.nest=!1)}!1!==n.nest&&(e=this.interpolator.nest(e,(function(){for(var e=arguments.length,a=new Array(e),i=0;i<e;i++)a[i]=arguments[i];return r&&r[0]===a[0]&&!n.context?(o.logger.warn("It seems you are nesting recursively key: ".concat(a[0]," in key: ").concat(t[0])),null):o.translate.apply(o,a.concat([t]))}),n)),n.interpolation&&this.interpolator.reset()}var f=n.postProcess||this.options.postProcess,d="string"==typeof f?[f]:f;return null!=e&&d&&d.length&&!1!==n.applyPostProcessor&&(e=x.handle(d,e,t,this.options&&this.options.postProcessPassResolved?i({i18nResolved:a},n):n,this)),e}},{key:"resolve",value:function(e){var t,n,a,r,i,o=this,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return"string"==typeof e&&(e=[e]),e.forEach((function(e){if(!o.isValidLookup(t)){var c=o.extractFromKey(e,s),l=c.key;n=l;var u=c.namespaces;o.options.fallbackNS&&(u=u.concat(o.options.fallbackNS));var p=void 0!==s.count&&"string"!=typeof s.count,f=void 0!==s.context&&"string"==typeof s.context&&""!==s.context,d=s.lngs?s.lngs:o.languageUtils.toResolveHierarchy(s.lng||o.language,s.fallbackLng);u.forEach((function(e){o.isValidLookup(t)||(i=e,!w["".concat(d[0],"-").concat(e)]&&o.utils&&o.utils.hasLoadedNamespace&&!o.utils.hasLoadedNamespace(i)&&(w["".concat(d[0],"-").concat(e)]=!0,o.logger.warn('key "'.concat(n,'" for languages "').concat(d.join(", "),'" won\'t get resolved as namespace "').concat(i,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),d.forEach((function(n){if(!o.isValidLookup(t)){r=n;var i,c,u=l,d=[u];if(o.i18nFormat&&o.i18nFormat.addLookupKeys)o.i18nFormat.addLookupKeys(d,l,n,e,s);else p&&(i=o.pluralResolver.getSuffix(n,s.count)),p&&f&&d.push(u+i),f&&d.push(u+="".concat(o.options.contextSeparator).concat(s.context)),p&&d.push(u+=i);for(;c=d.pop();)o.isValidLookup(t)||(a=c,t=o.getResource(n,e,c,s))}})))}))}})),{res:t,usedKey:n,exactUsedKey:a,usedLng:r,usedNS:i}}},{key:"isValidLookup",value:function(e){return!(void 0===e||!this.options.returnNull&&null===e||!this.options.returnEmptyString&&""===e)}},{key:"getResource",value:function(e,t,n){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return this.i18nFormat&&this.i18nFormat.getResource?this.i18nFormat.getResource(e,t,n,a):this.resourceStore.getResource(e,t,n,a)}}],[{key:"hasDefaultValue",value:function(e){var t="defaultValue";for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)&&t===n.substring(0,t.length)&&void 0!==e[n])return!0;return!1}}]),t}(m);function N(e){return e.charAt(0).toUpperCase()+e.slice(1)}var L=function(){function e(t){o(this,e),this.options=t,this.whitelist=this.options.supportedLngs||!1,this.supportedLngs=this.options.supportedLngs||!1,this.logger=g.create("languageUtils")}return c(e,[{key:"getScriptPartFromCode",value:function(e){if(!e||e.indexOf("-")<0)return null;var t=e.split("-");return 2===t.length?null:(t.pop(),"x"===t[t.length-1].toLowerCase()?null:this.formatLanguageCode(t.join("-")))}},{key:"getLanguagePartFromCode",value:function(e){if(!e||e.indexOf("-")<0)return e;var t=e.split("-");return this.formatLanguageCode(t[0])}},{key:"formatLanguageCode",value:function(e){if("string"==typeof e&&e.indexOf("-")>-1){var t=["hans","hant","latn","cyrl","cans","mong","arab"],n=e.split("-");return this.options.lowerCaseLng?n=n.map((function(e){return e.toLowerCase()})):2===n.length?(n[0]=n[0].toLowerCase(),n[1]=n[1].toUpperCase(),t.indexOf(n[1].toLowerCase())>-1&&(n[1]=N(n[1].toLowerCase()))):3===n.length&&(n[0]=n[0].toLowerCase(),2===n[1].length&&(n[1]=n[1].toUpperCase()),"sgn"!==n[0]&&2===n[2].length&&(n[2]=n[2].toUpperCase()),t.indexOf(n[1].toLowerCase())>-1&&(n[1]=N(n[1].toLowerCase())),t.indexOf(n[2].toLowerCase())>-1&&(n[2]=N(n[2].toLowerCase()))),n.join("-")}return this.options.cleanCode||this.options.lowerCaseLng?e.toLowerCase():e}},{key:"isWhitelisted",value:function(e){return this.logger.deprecate("languageUtils.isWhitelisted",'function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it\'s usage asap.'),this.isSupportedCode(e)}},{key:"isSupportedCode",value:function(e){return("languageOnly"===this.options.load||this.options.nonExplicitSupportedLngs)&&(e=this.getLanguagePartFromCode(e)),!this.supportedLngs||!this.supportedLngs.length||this.supportedLngs.indexOf(e)>-1}},{key:"getBestMatchFromCodes",value:function(e){var t,n=this;return e?(e.forEach((function(e){if(!t){var a=n.formatLanguageCode(e);n.options.supportedLngs&&!n.isSupportedCode(a)||(t=a)}})),!t&&this.options.supportedLngs&&e.forEach((function(e){if(!t){var a=n.getLanguagePartFromCode(e);if(n.isSupportedCode(a))return t=a;t=n.options.supportedLngs.find((function(e){if(0===e.indexOf(a))return e}))}})),t||(t=this.getFallbackCodes(this.options.fallbackLng)[0]),t):null}},{key:"getFallbackCodes",value:function(e,t){if(!e)return[];if("function"==typeof e&&(e=e(t)),"string"==typeof e&&(e=[e]),"[object Array]"===Object.prototype.toString.apply(e))return e;if(!t)return e.default||[];var n=e[t];return n||(n=e[this.getScriptPartFromCode(t)]),n||(n=e[this.formatLanguageCode(t)]),n||(n=e[this.getLanguagePartFromCode(t)]),n||(n=e.default),n||[]}},{key:"toResolveHierarchy",value:function(e,t){var n=this,a=this.getFallbackCodes(t||this.options.fallbackLng||[],e),r=[],i=function(e){e&&(n.isSupportedCode(e)?r.push(e):n.logger.warn("rejecting language code not found in supportedLngs: ".concat(e)))};return"string"==typeof e&&e.indexOf("-")>-1?("languageOnly"!==this.options.load&&i(this.formatLanguageCode(e)),"languageOnly"!==this.options.load&&"currentOnly"!==this.options.load&&i(this.getScriptPartFromCode(e)),"currentOnly"!==this.options.load&&i(this.getLanguagePartFromCode(e))):"string"==typeof e&&i(this.formatLanguageCode(e)),a.forEach((function(e){r.indexOf(e)<0&&i(n.formatLanguageCode(e))})),r}}]),e}(),D=[{lngs:["ach","ak","am","arn","br","fil","gun","ln","mfe","mg","mi","oc","pt","pt-BR","tg","tl","ti","tr","uz","wa"],nr:[1,2],fc:1},{lngs:["af","an","ast","az","bg","bn","ca","da","de","dev","el","en","eo","es","et","eu","fi","fo","fur","fy","gl","gu","ha","hi","hu","hy","ia","it","kk","kn","ku","lb","mai","ml","mn","mr","nah","nap","nb","ne","nl","nn","no","nso","pa","pap","pms","ps","pt-PT","rm","sco","se","si","so","son","sq","sv","sw","ta","te","tk","ur","yo"],nr:[1,2],fc:2},{lngs:["ay","bo","cgg","fa","ht","id","ja","jbo","ka","km","ko","ky","lo","ms","sah","su","th","tt","ug","vi","wo","zh"],nr:[1],fc:3},{lngs:["be","bs","cnr","dz","hr","ru","sr","uk"],nr:[1,2,5],fc:4},{lngs:["ar"],nr:[0,1,2,3,11,100],fc:5},{lngs:["cs","sk"],nr:[1,2,5],fc:6},{lngs:["csb","pl"],nr:[1,2,5],fc:7},{lngs:["cy"],nr:[1,2,3,8],fc:8},{lngs:["fr"],nr:[1,2],fc:9},{lngs:["ga"],nr:[1,2,3,7,11],fc:10},{lngs:["gd"],nr:[1,2,3,20],fc:11},{lngs:["is"],nr:[1,2],fc:12},{lngs:["jv"],nr:[0,1],fc:13},{lngs:["kw"],nr:[1,2,3,4],fc:14},{lngs:["lt"],nr:[1,2,10],fc:15},{lngs:["lv"],nr:[1,2,0],fc:16},{lngs:["mk"],nr:[1,2],fc:17},{lngs:["mnk"],nr:[0,1,2],fc:18},{lngs:["mt"],nr:[1,2,11,20],fc:19},{lngs:["or"],nr:[2,1],fc:2},{lngs:["ro"],nr:[1,2,20],fc:20},{lngs:["sl"],nr:[5,1,2,3],fc:21},{lngs:["he","iw"],nr:[1,2,20,21],fc:22}],V={1:function(e){return Number(e>1)},2:function(e){return Number(1!=e)},3:function(e){return 0},4:function(e){return Number(e%10==1&&e%100!=11?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2)},5:function(e){return Number(0==e?0:1==e?1:2==e?2:e%100>=3&&e%100<=10?3:e%100>=11?4:5)},6:function(e){return Number(1==e?0:e>=2&&e<=4?1:2)},7:function(e){return Number(1==e?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2)},8:function(e){return Number(1==e?0:2==e?1:8!=e&&11!=e?2:3)},9:function(e){return Number(e>=2)},10:function(e){return Number(1==e?0:2==e?1:e<7?2:e<11?3:4)},11:function(e){return Number(1==e||11==e?0:2==e||12==e?1:e>2&&e<20?2:3)},12:function(e){return Number(e%10!=1||e%100==11)},13:function(e){return Number(0!==e)},14:function(e){return Number(1==e?0:2==e?1:3==e?2:3)},15:function(e){return Number(e%10==1&&e%100!=11?0:e%10>=2&&(e%100<10||e%100>=20)?1:2)},16:function(e){return Number(e%10==1&&e%100!=11?0:0!==e?1:2)},17:function(e){return Number(1==e||e%10==1&&e%100!=11?0:1)},18:function(e){return Number(0==e?0:1==e?1:2)},19:function(e){return Number(1==e?0:0==e||e%100>1&&e%100<11?1:e%100>10&&e%100<20?2:3)},20:function(e){return Number(1==e?0:0==e||e%100>0&&e%100<20?1:2)},21:function(e){return Number(e%100==1?1:e%100==2?2:e%100==3||e%100==4?3:0)},22:function(e){return Number(1==e?0:2==e?1:(e<0||e>10)&&e%10==0?2:3)}};function M(){var e={};return D.forEach((function(t){t.lngs.forEach((function(n){e[n]={numbers:t.nr,plurals:V[t.fc]}}))})),e}var k=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};o(this,e),this.languageUtils=t,this.options=n,this.logger=g.create("pluralResolver"),this.rules=M()}return c(e,[{key:"addRule",value:function(e,t){this.rules[e]=t}},{key:"getRule",value:function(e){return this.rules[e]||this.rules[this.languageUtils.getLanguagePartFromCode(e)]}},{key:"needsPlural",value:function(e){var t=this.getRule(e);return t&&t.numbers.length>1}},{key:"getPluralFormsOfKey",value:function(e,t){return this.getSuffixes(e).map((function(e){return t+e}))}},{key:"getSuffixes",value:function(e){var t=this,n=this.getRule(e);return n?n.numbers.map((function(n){return t.getSuffix(e,n)})):[]}},{key:"getSuffix",value:function(e,t){var n=this,a=this.getRule(e);if(a){var r=a.noAbs?a.plurals(t):a.plurals(Math.abs(t)),i=a.numbers[r];this.options.simplifyPluralSuffix&&2===a.numbers.length&&1===a.numbers[0]&&(2===i?i="plural":1===i&&(i=""));var o=function(){return n.options.prepend&&i.toString()?n.options.prepend+i.toString():i.toString()};return"v1"===this.options.compatibilityJSON?1===i?"":"number"==typeof i?"_plural_".concat(i.toString()):o():"v2"===this.options.compatibilityJSON||this.options.simplifyPluralSuffix&&2===a.numbers.length&&1===a.numbers[0]?o():this.options.prepend&&r.toString()?this.options.prepend+r.toString():r.toString()}return this.logger.warn("no plural rule found for: ".concat(e)),""}}]),e}(),$=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e),this.logger=g.create("interpolator"),this.options=t,this.format=t.interpolation&&t.interpolation.format||function(e){return e},this.init(t)}return c(e,[{key:"init",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e.interpolation||(e.interpolation={escapeValue:!0});var t=e.interpolation;this.escape=void 0!==t.escape?t.escape:A,this.escapeValue=void 0===t.escapeValue||t.escapeValue,this.useRawValueToEscape=void 0!==t.useRawValueToEscape&&t.useRawValueToEscape,this.prefix=t.prefix?_(t.prefix):t.prefixEscaped||"{{",this.suffix=t.suffix?_(t.suffix):t.suffixEscaped||"}}",this.formatSeparator=t.formatSeparator?t.formatSeparator:t.formatSeparator||",",this.unescapePrefix=t.unescapeSuffix?"":t.unescapePrefix||"-",this.unescapeSuffix=this.unescapePrefix?"":t.unescapeSuffix||"",this.nestingPrefix=t.nestingPrefix?_(t.nestingPrefix):t.nestingPrefixEscaped||_("$t("),this.nestingSuffix=t.nestingSuffix?_(t.nestingSuffix):t.nestingSuffixEscaped||_(")"),this.nestingOptionsSeparator=t.nestingOptionsSeparator?t.nestingOptionsSeparator:t.nestingOptionsSeparator||",",this.maxReplaces=t.maxReplaces?t.maxReplaces:1e3,this.alwaysFormat=void 0!==t.alwaysFormat&&t.alwaysFormat,this.resetRegExp()}},{key:"reset",value:function(){this.options&&this.init(this.options)}},{key:"resetRegExp",value:function(){var e="".concat(this.prefix,"(.+?)").concat(this.suffix);this.regexp=new RegExp(e,"g");var t="".concat(this.prefix).concat(this.unescapePrefix,"(.+?)").concat(this.unescapeSuffix).concat(this.suffix);this.regexpUnescape=new RegExp(t,"g");var n="".concat(this.nestingPrefix,"(.+?)").concat(this.nestingSuffix);this.nestingRegexp=new RegExp(n,"g")}},{key:"interpolate",value:function(e,t,n,a){var r,o,s,c=this,l=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{};function u(e){return e.replace(/\$/g,"$$$$")}var p=function(e){if(e.indexOf(c.formatSeparator)<0){var r=O(t,l,e);return c.alwaysFormat?c.format(r,void 0,n,i({},a,t,{interpolationkey:e})):r}var o=e.split(c.formatSeparator),s=o.shift().trim(),u=o.join(c.formatSeparator).trim();return c.format(O(t,l,s),u,n,i({},a,t,{interpolationkey:s}))};this.resetRegExp();var f=a&&a.missingInterpolationHandler||this.options.missingInterpolationHandler,d=a&&a.interpolation&&a.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables;return[{regex:this.regexpUnescape,safeValue:function(e){return u(e)}},{regex:this.regexp,safeValue:function(e){return c.escapeValue?u(c.escape(e)):u(e)}}].forEach((function(t){for(s=0;r=t.regex.exec(e);){if(void 0===(o=p(r[1].trim())))if("function"==typeof f){var n=f(e,r,a);o="string"==typeof n?n:""}else{if(d){o=r[0];continue}c.logger.warn("missed to pass in variable ".concat(r[1]," for interpolating ").concat(e)),o=""}else"string"==typeof o||c.useRawValueToEscape||(o=v(o));var i=t.safeValue(o);if(e=e.replace(r[0],i),d?(t.regex.lastIndex+=i.length,t.regex.lastIndex-=r[0].length):t.regex.lastIndex=0,++s>=c.maxReplaces)break}})),e}},{key:"nest",value:function(e,t){var n,a,r=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},s=i({},o);function c(e,t){var n=this.nestingOptionsSeparator;if(e.indexOf(n)<0)return e;var a=e.split(new RegExp("".concat(n,"[ ]*{"))),r="{".concat(a[1]);e=a[0],r=(r=this.interpolate(r,s)).replace(/'/g,'"');try{s=JSON.parse(r),t&&(s=i({},t,s))}catch(t){return this.logger.warn("failed parsing options string in nesting for key ".concat(e),t),"".concat(e).concat(n).concat(r)}return delete s.defaultValue,e}for(s.applyPostProcessor=!1,delete s.defaultValue;n=this.nestingRegexp.exec(e);){var l=[],u=!1;if(-1!==n[0].indexOf(this.formatSeparator)&&!/{.*}/.test(n[1])){var p=n[1].split(this.formatSeparator).map((function(e){return e.trim()}));n[1]=p.shift(),l=p,u=!0}if((a=t(c.call(this,n[1].trim(),s),s))&&n[0]===e&&"string"!=typeof a)return a;"string"!=typeof a&&(a=v(a)),a||(this.logger.warn("missed to resolve ".concat(n[1]," for nesting ").concat(e)),a=""),u&&(a=l.reduce((function(e,t){return r.format(e,t,o.lng,i({},o,{interpolationkey:n[1].trim()}))}),a.trim())),e=e.replace(n[0],a),this.regexp.lastIndex=0}return e}}]),e}();var B=function(e){function t(e,n,a){var r,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return o(this,t),r=u(this,p(t).call(this)),I&&m.call(l(r)),r.backend=e,r.store=n,r.services=a,r.languageUtils=a.languageUtils,r.options=i,r.logger=g.create("backendConnector"),r.state={},r.queue=[],r.backend&&r.backend.init&&r.backend.init(a,i.backend,i),r}return d(t,e),c(t,[{key:"queueLoad",value:function(e,t,n,a){var r=this,i=[],o=[],s=[],c=[];return e.forEach((function(e){var a=!0;t.forEach((function(t){var s="".concat(e,"|").concat(t);!n.reload&&r.store.hasResourceBundle(e,t)?r.state[s]=2:r.state[s]<0||(1===r.state[s]?o.indexOf(s)<0&&o.push(s):(r.state[s]=1,a=!1,o.indexOf(s)<0&&o.push(s),i.indexOf(s)<0&&i.push(s),c.indexOf(t)<0&&c.push(t)))})),a||s.push(e)})),(i.length||o.length)&&this.queue.push({pending:o,loaded:{},errors:[],callback:a}),{toLoad:i,pending:o,toLoadLanguages:s,toLoadNamespaces:c}}},{key:"loaded",value:function(e,t,n){var a=e.split("|"),r=a[0],i=a[1];t&&this.emit("failedLoading",r,i,t),n&&this.store.addResourceBundle(r,i,n),this.state[e]=t?-1:2;var o={};this.queue.forEach((function(n){var a,s,c,l,u,p;a=n.loaded,s=i,l=P(a,[r],Object),u=l.obj,p=l.k,u[p]=u[p]||[],c&&(u[p]=u[p].concat(s)),c||u[p].push(s),function(e,t){for(var n=e.indexOf(t);-1!==n;)e.splice(n,1),n=e.indexOf(t)}(n.pending,e),t&&n.errors.push(t),0!==n.pending.length||n.done||(Object.keys(n.loaded).forEach((function(e){o[e]||(o[e]=[]),n.loaded[e].length&&n.loaded[e].forEach((function(t){o[e].indexOf(t)<0&&o[e].push(t)}))})),n.done=!0,n.errors.length?n.callback(n.errors):n.callback())})),this.emit("loaded",o),this.queue=this.queue.filter((function(e){return!e.done}))}},{key:"read",value:function(e,t,n){var a=this,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:350,o=arguments.length>5?arguments[5]:void 0;return e.length?this.backend[n](e,t,(function(s,c){s&&c&&r<5?setTimeout((function(){a.read.call(a,e,t,n,r+1,2*i,o)}),i):o(s,c)})):o(null,{})}},{key:"prepareLoading",value:function(e,t){var n=this,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3?arguments[3]:void 0;if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),r&&r();"string"==typeof e&&(e=this.languageUtils.toResolveHierarchy(e)),"string"==typeof t&&(t=[t]);var i=this.queueLoad(e,t,a,r);if(!i.toLoad.length)return i.pending.length||r(),null;i.toLoad.forEach((function(e){n.loadOne(e)}))}},{key:"load",value:function(e,t,n){this.prepareLoading(e,t,{},n)}},{key:"reload",value:function(e,t,n){this.prepareLoading(e,t,{reload:!0},n)}},{key:"loadOne",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",a=e.split("|"),r=a[0],i=a[1];this.read(r,i,"read",void 0,void 0,(function(a,o){a&&t.logger.warn("".concat(n,"loading namespace ").concat(i," for language ").concat(r," failed"),a),!a&&o&&t.logger.log("".concat(n,"loaded namespace ").concat(i," for language ").concat(r),o),t.loaded(e,a,o)}))}},{key:"saveMissing",value:function(e,t,n,a,r){var o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};this.services.utils&&this.services.utils.hasLoadedNamespace&&!this.services.utils.hasLoadedNamespace(t)?this.logger.warn('did not save key "'.concat(n,'" as the namespace "').concat(t,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"):null!=n&&""!==n&&(this.backend&&this.backend.create&&this.backend.create(e,t,n,a,null,i({},o,{isUpdate:r})),e&&e[0]&&this.store.addResource(e[0],t,n,a))}}]),t}(m);function U(){return{debug:!1,initImmediate:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,whitelist:!1,nonExplicitWhitelist:!1,supportedLngs:!1,nonExplicitSupportedLngs:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",partialBundledLanguages:!1,saveMissing:!1,updateMissing:!1,saveMissingTo:"fallback",saveMissingPlurals:!0,missingKeyHandler:!1,missingInterpolationHandler:!1,postProcess:!1,postProcessPassResolved:!1,returnNull:!0,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:!1,parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:function(e){var t={};if("object"===a(e[1])&&(t=e[1]),"string"==typeof e[1]&&(t.defaultValue=e[1]),"string"==typeof e[2]&&(t.tDescription=e[2]),"object"===a(e[2])||"object"===a(e[3])){var n=e[3]||e[2];Object.keys(n).forEach((function(e){t[e]=n[e]}))}return t},interpolation:{escapeValue:!0,format:function(e,t,n,a){return e},prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",nestingOptionsSeparator:",",maxReplaces:1e3,skipOnVariables:!1}}}function H(e){return"string"==typeof e.ns&&(e.ns=[e.ns]),"string"==typeof e.fallbackLng&&(e.fallbackLng=[e.fallbackLng]),"string"==typeof e.fallbackNS&&(e.fallbackNS=[e.fallbackNS]),e.whitelist&&(e.whitelist&&e.whitelist.indexOf("cimode")<0&&(e.whitelist=e.whitelist.concat(["cimode"])),e.supportedLngs=e.whitelist),e.nonExplicitWhitelist&&(e.nonExplicitSupportedLngs=e.nonExplicitWhitelist),e.supportedLngs&&e.supportedLngs.indexOf("cimode")<0&&(e.supportedLngs=e.supportedLngs.concat(["cimode"])),e}function K(){}const Q=new(function(e){function t(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=arguments.length>1?arguments[1]:void 0;if(o(this,t),e=u(this,p(t).call(this)),I&&m.call(l(e)),e.options=H(n),e.services={},e.logger=g,e.modules={external:[]},a&&!e.isInitialized&&!n.isClone){if(!e.options.initImmediate)return e.init(n,a),u(e,l(e));setTimeout((function(){e.init(n,a)}),0)}return e}return d(t,e),c(t,[{key:"init",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;function a(e){return e?"function"==typeof e?new e:e:null}if("function"==typeof t&&(n=t,t={}),t.whitelist&&!t.supportedLngs&&this.logger.deprecate("whitelist",'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.'),t.nonExplicitWhitelist&&!t.nonExplicitSupportedLngs&&this.logger.deprecate("whitelist",'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.'),this.options=i({},U(),this.options,H(t)),this.format=this.options.interpolation.format,n||(n=K),!this.options.isClone){this.modules.logger?g.init(a(this.modules.logger),this.options):g.init(null,this.options);var r=new L(this.options);this.store=new F(this.options.resources,this.options);var o=this.services;o.logger=g,o.resourceStore=this.store,o.languageUtils=r,o.pluralResolver=new k(r,{prepend:this.options.pluralSeparator,compatibilityJSON:this.options.compatibilityJSON,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),o.interpolator=new $(this.options),o.utils={hasLoadedNamespace:this.hasLoadedNamespace.bind(this)},o.backendConnector=new B(a(this.modules.backend),o.resourceStore,o,this.options),o.backendConnector.on("*",(function(t){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];e.emit.apply(e,[t].concat(a))})),this.modules.languageDetector&&(o.languageDetector=a(this.modules.languageDetector),o.languageDetector.init(o,this.options.detection,this.options)),this.modules.i18nFormat&&(o.i18nFormat=a(this.modules.i18nFormat),o.i18nFormat.init&&o.i18nFormat.init(this)),this.translator=new j(this.services,this.options),this.translator.on("*",(function(t){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];e.emit.apply(e,[t].concat(a))})),this.modules.external.forEach((function(t){t.init&&t.init(e)}))}if(this.options.fallbackLng&&!this.services.languageDetector&&!this.options.lng){var s=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);s.length>0&&"dev"!==s[0]&&(this.options.lng=s[0])}this.services.languageDetector||this.options.lng||this.logger.warn("init: no languageDetector is used and no lng is defined");var c=["getResource","hasResourceBundle","getResourceBundle","getDataByLanguage"];c.forEach((function(t){e[t]=function(){var n;return(n=e.store)[t].apply(n,arguments)}}));var l=["addResource","addResources","addResourceBundle","removeResourceBundle"];l.forEach((function(t){e[t]=function(){var n;return(n=e.store)[t].apply(n,arguments),e}}));var u=y(),p=function(){var t=function(t,a){e.isInitialized&&e.logger.warn("init: i18next is already initialized. You should call init just once!"),e.isInitialized=!0,e.options.isClone||e.logger.log("initialized",e.options),e.emit("initialized",e.options),u.resolve(a),n(t,a)};if(e.languages&&"v1"!==e.options.compatibilityAPI&&!e.isInitialized)return t(null,e.t.bind(e));e.changeLanguage(e.options.lng,t)};return this.options.resources||!this.options.initImmediate?p():setTimeout(p,0),u}},{key:"loadResources",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:K,a=n,r="string"==typeof e?e:this.language;if("function"==typeof e&&(a=e),!this.options.resources||this.options.partialBundledLanguages){if(r&&"cimode"===r.toLowerCase())return a();var i=[],o=function(e){e&&t.services.languageUtils.toResolveHierarchy(e).forEach((function(e){i.indexOf(e)<0&&i.push(e)}))};if(r)o(r);else{var s=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);s.forEach((function(e){return o(e)}))}this.options.preload&&this.options.preload.forEach((function(e){return o(e)})),this.services.backendConnector.load(i,this.options.ns,a)}else a(null)}},{key:"reloadResources",value:function(e,t,n){var a=y();return e||(e=this.languages),t||(t=this.options.ns),n||(n=K),this.services.backendConnector.reload(e,t,(function(e){a.resolve(),n(e)})),a}},{key:"use",value:function(e){if(!e)throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");if(!e.type)throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");return"backend"===e.type&&(this.modules.backend=e),("logger"===e.type||e.log&&e.warn&&e.error)&&(this.modules.logger=e),"languageDetector"===e.type&&(this.modules.languageDetector=e),"i18nFormat"===e.type&&(this.modules.i18nFormat=e),"postProcessor"===e.type&&x.addPostProcessor(e),"3rdParty"===e.type&&this.modules.external.push(e),this}},{key:"changeLanguage",value:function(e,t){var n=this;this.isLanguageChangingTo=e;var a=y();this.emit("languageChanging",e);var r=function(r){e||r||!n.services.languageDetector||(r=[]);var i="string"==typeof r?r:n.services.languageUtils.getBestMatchFromCodes(r);i&&(n.language||(n.language=i,n.languages=n.services.languageUtils.toResolveHierarchy(i)),n.translator.language||n.translator.changeLanguage(i),n.services.languageDetector&&n.services.languageDetector.cacheUserLanguage(i)),n.loadResources(i,(function(e){!function(e,r){r?(n.language=r,n.languages=n.services.languageUtils.toResolveHierarchy(r),n.translator.changeLanguage(r),n.isLanguageChangingTo=void 0,n.emit("languageChanged",r),n.logger.log("languageChanged",r)):n.isLanguageChangingTo=void 0,a.resolve((function(){return n.t.apply(n,arguments)})),t&&t(e,(function(){return n.t.apply(n,arguments)}))}(e,i)}))};return e||!this.services.languageDetector||this.services.languageDetector.async?!e&&this.services.languageDetector&&this.services.languageDetector.async?this.services.languageDetector.detect(r):r(e):r(this.services.languageDetector.detect()),a}},{key:"getFixedT",value:function(e,t){var n=this,r=function e(t,r){var o;if("object"!==a(r)){for(var s=arguments.length,c=new Array(s>2?s-2:0),l=2;l<s;l++)c[l-2]=arguments[l];o=n.options.overloadTranslationOptionHandler([t,r].concat(c))}else o=i({},r);return o.lng=o.lng||e.lng,o.lngs=o.lngs||e.lngs,o.ns=o.ns||e.ns,n.t(t,o)};return"string"==typeof e?r.lng=e:r.lngs=e,r.ns=t,r}},{key:"t",value:function(){var e;return this.translator&&(e=this.translator).translate.apply(e,arguments)}},{key:"exists",value:function(){var e;return this.translator&&(e=this.translator).exists.apply(e,arguments)}},{key:"setDefaultNamespace",value:function(e){this.options.defaultNS=e}},{key:"hasLoadedNamespace",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isInitialized)return this.logger.warn("hasLoadedNamespace: i18next was not initialized",this.languages),!1;if(!this.languages||!this.languages.length)return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty",this.languages),!1;var a=this.languages[0],r=!!this.options&&this.options.fallbackLng,i=this.languages[this.languages.length-1];if("cimode"===a.toLowerCase())return!0;var o=function(e,n){var a=t.services.backendConnector.state["".concat(e,"|").concat(n)];return-1===a||2===a};if(n.precheck){var s=n.precheck(this,o);if(void 0!==s)return s}return!!this.hasResourceBundle(a,e)||(!this.services.backendConnector.backend||!(!o(a,e)||r&&!o(i,e)))}},{key:"loadNamespaces",value:function(e,t){var n=this,a=y();return this.options.ns?("string"==typeof e&&(e=[e]),e.forEach((function(e){n.options.ns.indexOf(e)<0&&n.options.ns.push(e)})),this.loadResources((function(e){a.resolve(),t&&t(e)})),a):(t&&t(),Promise.resolve())}},{key:"loadLanguages",value:function(e,t){var n=y();"string"==typeof e&&(e=[e]);var a=this.options.preload||[],r=e.filter((function(e){return a.indexOf(e)<0}));return r.length?(this.options.preload=a.concat(r),this.loadResources((function(e){n.resolve(),t&&t(e)})),n):(t&&t(),Promise.resolve())}},{key:"dir",value:function(e){if(e||(e=this.languages&&this.languages.length>0?this.languages[0]:this.language),!e)return"rtl";return["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ug","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam"].indexOf(this.services.languageUtils.getLanguagePartFromCode(e))>=0?"rtl":"ltr"}},{key:"createInstance",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;return new t(e,n)}},{key:"cloneInstance",value:function(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:K,r=i({},this.options,n,{isClone:!0}),o=new t(r),s=["store","services","language"];return s.forEach((function(t){o[t]=e[t]})),o.services=i({},this.services),o.services.utils={hasLoadedNamespace:o.hasLoadedNamespace.bind(o)},o.translator=new j(o.services,o.options),o.translator.on("*",(function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];o.emit.apply(o,[e].concat(n))})),o.init(r,a),o.translator.options=o.options,o.translator.backendConnector.services.utils={hasLoadedNamespace:o.hasLoadedNamespace.bind(o)},o}},{key:"toJSON",value:function(){return{options:this.options,store:this.store,language:this.language,languages:this.languages}}}]),t}(m))},5822:(e,t,n)=>{try{var a=n(1669);if("function"!=typeof a.inherits)throw"";e.exports=a.inherits}catch(t){e.exports=n(9105)}},9105:e=>{"function"==typeof Object.create?e.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:e.exports=function(e,t){if(t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}}},1016:e=>{e.exports=function(e){if("string"!=typeof e||""===e)return!1;for(var t;t=/(\\).|([@?!+*]\(.*\))/g.exec(e);){if(t[2])return!0;e=e.slice(t.index+t[0].length)}return!1}},3490:(e,t,n)=>{var a=n(1016),r={"{":"}","(":")","[":"]"},i=/\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/,o=/\\(.)|(^!|[*?{}()[\]]|\(\?)/;e.exports=function(e,t){if("string"!=typeof e||""===e)return!1;if(a(e))return!0;var n,s=i;for(t&&!1===t.strict&&(s=o);n=s.exec(e);){if(n[2])return!0;var c=n.index+n[0].length,l=n[1],u=l?r[l]:null;if(l&&u){var p=e.indexOf(u,c);-1!==p&&(c=p+1)}e=e.slice(c)}return!1}},3253:(e,t)=>{e.exports=function(e){for(var t=0;t<e.length;)if(9==e[t]||10==e[t]||13==e[t]||32<=e[t]&&e[t]<=126)t+=1;else if(194<=e[t]&&e[t]<=223&&128<=e[t+1]&&e[t+1]<=191)t+=2;else if(224==e[t]&&160<=e[t+1]&&e[t+1]<=191&&128<=e[t+2]&&e[t+2]<=191||(225<=e[t]&&e[t]<=236||238==e[t]||239==e[t])&&128<=e[t+1]&&e[t+1]<=191&&128<=e[t+2]&&e[t+2]<=191||237==e[t]&&128<=e[t+1]&&e[t+1]<=159&&128<=e[t+2]&&e[t+2]<=191)t+=3;else{if(!(240==e[t]&&144<=e[t+1]&&e[t+1]<=191&&128<=e[t+2]&&e[t+2]<=191&&128<=e[t+3]&&e[t+3]<=191||241<=e[t]&&e[t]<=243&&128<=e[t+1]&&e[t+1]<=191&&128<=e[t+2]&&e[t+2]<=191&&128<=e[t+3]&&e[t+3]<=191||244==e[t]&&128<=e[t+1]&&e[t+1]<=143&&128<=e[t+2]&&e[t+2]<=191&&128<=e[t+3]&&e[t+3]<=191))return!1;t+=4}return!0}},5092:function(e,t,n){"use strict";var a=this&&this.__awaiter||function(e,t,n,a){return new(n||(n=Promise))((function(r,i){function o(e){try{c(a.next(e))}catch(e){i(e)}}function s(e){try{c(a.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,s)}c((a=a.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.isBinaryFileSync=t.isBinaryFile=void 0;const r=n(5747),i=n(1669),o=i.promisify(r.stat),s=i.promisify(r.open),c=i.promisify(r.close),l=512;function u(e,t){if(0===t)return!1;let n=0;const a=Math.min(t,l);if(t>=3&&239===e[0]&&187===e[1]&&191===e[2])return!1;if(t>=4&&0===e[0]&&0===e[1]&&254===e[2]&&255===e[3])return!1;if(t>=4&&255===e[0]&&254===e[1]&&0===e[2]&&0===e[3])return!1;if(t>=4&&132===e[0]&&49===e[1]&&149===e[2]&&51===e[3])return!1;if(a>=5&&"%PDF-"===e.slice(0,5).toString())return!0;if(t>=2&&254===e[0]&&255===e[1])return!1;if(t>=2&&255===e[0]&&254===e[1])return!1;for(let t=0;t<a;t++){if(0===e[t])return!0;if((e[t]<7||e[t]>14)&&(e[t]<32||e[t]>127)){if(e[t]>193&&e[t]<224&&t+1<a){if(t++,e[t]>127&&e[t]<192)continue}else if(e[t]>223&&e[t]<240&&t+2<a&&(t++,e[t]>127&&e[t]<192&&e[t+1]>127&&e[t+1]<192)){t++;continue}if(n++,t>32&&100*n/a>10)return!0}}return 100*n/a>10}function p(e){return"string"==typeof e}function f(e){if(!e.isFile())throw new Error("Path provided was not a file!")}t.isBinaryFile=function(e,t){return a(this,void 0,void 0,(function*(){if(p(e)){f(yield o(e));const t=yield s(e,"r"),n=Buffer.alloc(l);return new Promise(((e,a)=>{r.read(t,n,0,l,0,((r,i,o)=>{c(t),r?a(r):e(u(n,i))}))}))}return void 0===t&&(t=e.length),u(e,t)}))},t.isBinaryFileSync=function(e,t){if(p(e)){f(r.statSync(e));const t=r.openSync(e,"r"),n=Buffer.alloc(l),a=r.readSync(t,n,0,l,0);return r.closeSync(t),u(n,a)}return void 0===t&&(t=e.length),u(e,t)}},8125:e=>{"use strict";var t=e.exports=function(e,t,a){"function"==typeof t&&(a=t,t={}),n(t,"function"==typeof(a=t.cb||a)?a:a.pre||function(){},a.post||function(){},e,"",e)};function n(e,a,r,i,o,s,c,l,u,p){if(i&&"object"==typeof i&&!Array.isArray(i)){for(var f in a(i,o,s,c,l,u,p),i){var d=i[f];if(Array.isArray(d)){if(f in t.arrayKeywords)for(var h=0;h<d.length;h++)n(e,a,r,d[h],o+"/"+f+"/"+h,s,o,f,i,h)}else if(f in t.propsKeywords){if(d&&"object"==typeof d)for(var g in d)n(e,a,r,d[g],o+"/"+f+"/"+g.replace(/~/g,"~0").replace(/\//g,"~1"),s,o,f,i,g)}else(f in t.keywords||e.allKeys&&!(f in t.skipKeywords))&&n(e,a,r,d,o+"/"+f,s,o,f,i)}r(i,o,s,c,l,u,p)}}t.keywords={additionalItems:!0,items:!0,contains:!0,additionalProperties:!0,propertyNames:!0,not:!0},t.arrayKeywords={items:!0,allOf:!0,anyOf:!0,oneOf:!0},t.propsKeywords={definitions:!0,properties:!0,patternProperties:!0,dependencies:!0},t.skipKeywords={default:!0,enum:!0,const:!0,required:!0,maximum:!0,minimum:!0,exclusiveMaximum:!0,exclusiveMinimum:!0,multipleOf:!0,maxLength:!0,minLength:!0,pattern:!0,format:!0,maxItems:!0,minItems:!0,uniqueItems:!0,maxProperties:!0,minProperties:!0}},4366:e=>{var t="__lodash_hash_undefined__",n="[object Function]",a="[object GeneratorFunction]",r=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/,o=/^\./,s=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,c=/\\(\\)?/g,l=/^\[object .+?Constructor\]$/,u="object"==typeof global&&global&&global.Object===Object&&global,p="object"==typeof self&&self&&self.Object===Object&&self,f=u||p||Function("return this")();var d,h=Array.prototype,g=Function.prototype,m=Object.prototype,y=f["__core-js_shared__"],v=(d=/[^.]+$/.exec(y&&y.keys&&y.keys.IE_PROTO||""))?"Symbol(src)_1."+d:"",b=g.toString,P=m.hasOwnProperty,S=m.toString,T=RegExp("^"+b.call(P).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),O=f.Symbol,E=h.splice,_=V(f,"Map"),C=V(Object,"create"),A=O?O.prototype:void 0,I=A?A.toString:void 0;function R(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}function F(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}function x(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}function w(e,t){for(var n,a,r=e.length;r--;)if((n=e[r][0])===(a=t)||n!=n&&a!=a)return r;return-1}function j(e){return!(!H(e)||(t=e,v&&v in t))&&(function(e){var t=H(e)?S.call(e):"";return t==n||t==a}(e)||function(e){var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(e){}return t}(e)?T:l).test(function(e){if(null!=e){try{return b.call(e)}catch(e){}try{return e+""}catch(e){}}return""}(e));var t}function N(e,t){e=function(e,t){return 1==t.length?e:function(e,t){for(var n=0,a=(t=M(t,e)?[t]:L(t)).length;null!=e&&n<a;)e=e[$(t[n++])];return n&&n==a?e:void 0}(e,function(e,t,n){var a=-1,r=e.length;t<0&&(t=-t>r?0:r+t),(n=n>r?r:n)<0&&(n+=r),r=t>n?0:n-t>>>0,t>>>=0;for(var i=Array(r);++a<r;)i[a]=e[a+t];return i}(t,0,-1))}(e,t=M(t,e)?[t]:L(t));var n,a,r=$((a=(n=t)?n.length:0)?n[a-1]:void 0);return!(null!=e&&P.call(e,r))||delete e[r]}function L(e){return U(e)?e:k(e)}function D(e,t){var n,a,r=e.__data__;return("string"==(a=typeof(n=t))||"number"==a||"symbol"==a||"boolean"==a?"__proto__"!==n:null===n)?r["string"==typeof t?"string":"hash"]:r.map}function V(e,t){var n=function(e,t){return null==e?void 0:e[t]}(e,t);return j(n)?n:void 0}function M(e,t){if(U(e))return!1;var n=typeof e;return!("number"!=n&&"symbol"!=n&&"boolean"!=n&&null!=e&&!K(e))||(i.test(e)||!r.test(e)||null!=t&&e in Object(t))}R.prototype.clear=function(){this.__data__=C?C(null):{}},R.prototype.delete=function(e){return this.has(e)&&delete this.__data__[e]},R.prototype.get=function(e){var n=this.__data__;if(C){var a=n[e];return a===t?void 0:a}return P.call(n,e)?n[e]:void 0},R.prototype.has=function(e){var t=this.__data__;return C?void 0!==t[e]:P.call(t,e)},R.prototype.set=function(e,n){return this.__data__[e]=C&&void 0===n?t:n,this},F.prototype.clear=function(){this.__data__=[]},F.prototype.delete=function(e){var t=this.__data__,n=w(t,e);return!(n<0)&&(n==t.length-1?t.pop():E.call(t,n,1),!0)},F.prototype.get=function(e){var t=this.__data__,n=w(t,e);return n<0?void 0:t[n][1]},F.prototype.has=function(e){return w(this.__data__,e)>-1},F.prototype.set=function(e,t){var n=this.__data__,a=w(n,e);return a<0?n.push([e,t]):n[a][1]=t,this},x.prototype.clear=function(){this.__data__={hash:new R,map:new(_||F),string:new R}},x.prototype.delete=function(e){return D(this,e).delete(e)},x.prototype.get=function(e){return D(this,e).get(e)},x.prototype.has=function(e){return D(this,e).has(e)},x.prototype.set=function(e,t){return D(this,e).set(e,t),this};var k=B((function(e){var t;e=null==(t=e)?"":function(e){if("string"==typeof e)return e;if(K(e))return I?I.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}(t);var n=[];return o.test(e)&&n.push(""),e.replace(s,(function(e,t,a,r){n.push(a?r.replace(c,"$1"):t||e)})),n}));function $(e){if("string"==typeof e||K(e))return e;var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}function B(e,t){if("function"!=typeof e||t&&"function"!=typeof t)throw new TypeError("Expected a function");var n=function(){var a=arguments,r=t?t.apply(this,a):a[0],i=n.cache;if(i.has(r))return i.get(r);var o=e.apply(this,a);return n.cache=i.set(r,o),o};return n.cache=new(B.Cache||x),n}B.Cache=x;var U=Array.isArray;function H(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function K(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&"[object Symbol]"==S.call(e)}e.exports=function(e,t){return null==e||N(e,t)}},4937:(e,t,n)=>{"use strict";const a=n(5179);e.exports=function(e,t,n,r,i){n=n||{},r=r||{},this.append(e,a.render(t.toString(),n,r),i)}},9859:(e,t,n)=>{"use strict";const{EOL:a}=n(2087);e.exports=function(e,t,n){if(n={trimEnd:!0,separator:a,...n},!this.exists(e)&&n.create)return void this.write(e,t);let r=this.read(e);n.trimEnd&&(r=r.replace(/\s+$/,"")),this.write(e,r+n.separator+t)}},5755:(e,t,n)=>{"use strict";const a=n(5747).promises,r=n(5622),{clearFileState:i,isFileStateModified:o,isFileStateDeleted:s,setCommittedFile:c}=n(6268);e.exports=async function(e){const t=this.store.get(e.path);t&&t===e||this.store.add(e),o(e)?(c(e),await async function(e){const t=r.dirname(e.path);try{if(!(await a.stat(t)).isDirectory())throw new Error(`${e.path} is not a directory`)}catch(e){if("ENOENT"!==e.code)throw e;await a.mkdir(t,{recursive:!0})}const n={};e.stat&&(n.mode=e.stat.mode),await a.writeFile(e.path,e.contents,n)}(e)):s(e)&&(c(e),await async function(e){const t=a.rm||a.rmdir;await t(e.path,{recursive:!0})}(e)),i(e)}},6001:(e,t,n)=>{"use strict";const{promisify:a}=n(1669),{pipeline:r}=n(2413),i=a(r),{createPendingFilesPassthrough:o,createCommitTransform:s}=n(8206);e.exports=function(e,t,n){"function"==typeof e?(n=e,e=[],t=void 0):"function"==typeof t&&(n=t,t=void 0),t=t||this.store.stream(),e=e||[];const a=i(t,o(),...e,s(this));return n?a.then((()=>n()),n):a}},3947:(e,t,n)=>{"use strict";const a=n(2357),r=n(5747),i=n(5747).promises,o=n(5622),s=n(8613),c=n(8371),l=n(5179),u=n(1297),p=n(5696);async function f(e,t){const n=await Promise.resolve(e.call(this,t));return Buffer.isBuffer(n)?n:Buffer.from(n)}function d(e,t,n){return t?l.render(e,t,n):e}t.B=async function(e,t,n,l,f){t=o.resolve(t),n=n||{};const h=await async function(e){let t;if("string"!=typeof e)return;t=e;const n=o.resolve(t);try{if((await i.stat(n)).isFile())return n}catch(e){}}(e);if(h)return this._copySingleAsync(h,d(t,l,f),n);const g=u.globify(e),m={...n.globOptions,nodir:!0},y=s.sync(g,m).map((e=>o.resolve(e))),v=[];this.store.each((e=>{s.hasMagic(p(e.path))||0===c([e.path],g).length||y.includes(e.path)||v.push(e.path)}));let b=()=>t;if(Array.isArray(e)||!this.exists(e)||s.hasMagic(p(e))){a(!this.exists(t)||r.statSync(t).isDirectory(),"When copying multiple files, provide a directory as destination");const i=n.processDestinationPath||(e=>e),s=u.getCommonPath(e);b=e=>{const n=o.relative(s,e);return i(o.join(t,n))}}a(n.ignoreNoMatch||y.length>0||v.length>0,"Trying to copy from a source that does not exist: "+e),await Promise.all([...y.map((e=>this._copySingleAsync(e,d(b(e),l,f),n))),...v.map((e=>Promise.resolve(this._copySingle(e,d(b(e),l,f),n))))])},t.i=async function(e,t,n={}){if(!n.processFile)return this._copySingle(e,t,n);const a=await f.call(this,n.processFile,e);if(n.append){if(!this.store.existsInMemory)throw new Error("Current mem-fs is not compatible with append");if(this.store.existsInMemory(t))return void this.append(t,a,{create:!0,...n})}const r=await i.stat(e);this.write(t,a,r)}},2705:(e,t,n)=>{"use strict";const a=n(5179),r=n(5747).promises,{isBinary:i}=n(1297);e.exports=async function(e,t,n,o,s){n=n||{},o=o||{},await this.copyAsync(e,t,{processDestinationPath:e=>e.replace(/.ejs$/,""),...s,processFile:async e=>i(e,null)?r.readFile(e):a.renderFile(e,n,o),process:(e,t,a)=>this._processTpl({contents:e,filename:t,destination:a,context:n,tplSettings:o})},n,o)}},7997:(e,t,n)=>{"use strict";const a=n(5179),{isBinary:r}=n(1297);e.exports.J=function({contents:e,filename:t,context:n,tplSettings:i}){return r(t,e)?e:a.render(e.toString(),n,{filename:t,...i})},e.exports.y=function(e,t,n,a,r){n=n||{},a=a||{},this.copy(e,t,{processDestinationPath:e=>e.replace(/.ejs$/,""),...r,process:(e,t)=>this._processTpl({contents:e,filename:t,context:n,tplSettings:a})},n,a)}},749:(e,t,n)=>{"use strict";const a=n(2357),r=n(5747),i=n(5622),o=n(8613),s=n(8371),c=n(5179),l=n(1297),u=n(5696);t.J=function(e,t,n,p,f){t=i.resolve(t),n=n||{};const d=l.globify(e);let h=[];if(n.noGlob){const e=Array.isArray(d)?d:[d];h=e.filter((e=>r.existsSync(e)))}else{const e={...n.globOptions,nodir:!0};h=o.sync(d,e).map((e=>i.resolve(e)))}const g=[];this.store.each((e=>{o.hasMagic(u(e.path))||0===s([e.path],d).length||h.includes(e.path)||g.push(e.path)}));const m=h.concat(g);let y=()=>t;if(Array.isArray(e)||!this.exists(e)||o.hasMagic(u(e))){a(!this.exists(t)||r.statSync(t).isDirectory(),"When copying multiple files, provide a directory as destination");const o=n.processDestinationPath||(e=>e),s=l.getCommonPath(e);y=e=>{const n=i.relative(s,e);return o(i.join(t,n))}}a(n.ignoreNoMatch||m.length>0,"Trying to copy from a source that does not exist: "+e),m.forEach((e=>{let t=y(e);p&&(t=c.render(t,p,f)),this._copySingle(e,t,n,p,f)}))},t.W=function(e,t,n={}){a(this.exists(e),"Trying to copy from a source that does not exist: "+e);const r=this.store.get(e);let{contents:i}=r;if(n.process&&(i=function(e,t,n){const a=e(t,n);return Buffer.isBuffer(a)?a:Buffer.from(a)}(n.process,r.contents,r.path)),n.append){if(!this.store.existsInMemory)throw new Error("Current mem-fs is not compatible with append");if(this.store.existsInMemory(t))return void this.append(t,i,{create:!0,...n})}this.write(t,i,r.stat)}},7617:(e,t,n)=>{"use strict";const a=n(5622),r=n(8613),i=n(8371),o=n(1297),{setDeletedFileState:s}=n(6268);function c(e,t){const n=t.get(e);s(n),n.contents=null,t.add(n)}e.exports=function(e,t){Array.isArray(e)||(e=[e]),e=e.map((e=>a.resolve(e))),e=o.globify(e);const n=(t=t||{}).globOptions||{};r.sync(e,n).forEach((e=>{c(e,this.store)})),this.store.each((t=>{0!==i([t.path],e).length&&c(t.path,this.store)}))}},1045:(e,t,n)=>{"use strict";const a=n(5622),r=n(5696),i=n(2979),{hasClearedState:o,hasState:s,STATE:c,STATE_CLEARED:l}=n(6268);e.exports=function(e=process.cwd(),t=(e=>o(e)||s(e))){if("string"==typeof t){const e=t;t=t=>i(t.path,e)}return Object.fromEntries(this.store.all().filter((n=>t(n,e))).map((t=>{const n=r(e?a.relative(e,t.path):t.path),i={contents:t.contents?t.contents.toString():t.contents};return t[c]&&(i[c]=t[c]),t[l]&&(i[l]=t[l]),[n,i]})))}},893:e=>{"use strict";e.exports=function(e){return null!==this.store.get(e).contents}},2382:(e,t,n)=>{"use strict";const a=n(103);e.exports=function(e,t,n,r){const i=this.readJSON(e,{}),o=a({},i,t);this.writeJSON(e,o,n,r)}},1618:e=>{"use strict";e.exports=function(e,t,n){this.copy(e,t,n),this.delete(e,n)}},7253:e=>{"use strict";e.exports=function(e,t){if(!this.exists(e))return t;try{return JSON.parse(this.read(e))}catch(t){throw new Error("Could not parse JSON in file: "+e+". Detail: "+t.message)}}},4638:e=>{"use strict";e.exports=function(e,t){t=t||{raw:!1};const n=this.store.get(e);if(null===n.contents){if("defaults"in t)return t.defaults;throw new Error(e+" doesn't exist")}return t.raw?n.contents:n.contents.toString()}},9012:e=>{"use strict";e.exports=function(e,t,n,a){const r=JSON.stringify(t,n||null,a||2)+"\n";return this.write(e,r)}},8369:(e,t,n)=>{"use strict";const a=n(2357),{isFileStateModified:r,setModifiedFileState:i}=n(6268);e.exports=function(e,t,n){a("string"==typeof t||Buffer.isBuffer(t),"Expected `contents` to be a String or a Buffer");const o=this.store.get(e),s=Buffer.isBuffer(t)?t:Buffer.from(t);return r(o)&&Buffer.isBuffer(o.contents)&&s.equals(o.contents)&&(void 0===n||o.stat===n)||(i(o),o.contents=s,o.stat=n,this.store.add(o)),o.contents.toString()}},6244:(e,t,n)=>{"use strict";function a(e){this.store=e}a.prototype.read=n(4638),a.prototype.readJSON=n(7253),a.prototype.exists=n(893),a.prototype.write=n(8369),a.prototype.writeJSON=n(9012),a.prototype.extendJSON=n(2382),a.prototype.append=n(9859),a.prototype.appendTpl=n(4937),a.prototype.delete=n(7617),a.prototype.copy=n(749).J,a.prototype._copySingle=n(749).W,a.prototype.copyTpl=n(7997).y,a.prototype._processTpl=n(7997).J,a.prototype.copyAsync=n(3947).B,a.prototype._copySingleAsync=n(3947).i,a.prototype.copyTplAsync=n(2705),a.prototype.move=n(1618),a.prototype.commit=n(6001),a.prototype.commitFileAsync=n(5755),a.prototype.dump=n(1045),t.create=function(e){return new a(e)},t.State=n(6268)},6268:(e,t,n)=>{const a=n(5747),r="state",i="stateCleared",o="modified",s="deleted",c=(e,t)=>{e.state=t},l=e=>(void 0===e.isNew&&(e.isNew=!a.existsSync(e.path)),e.isNew),u=e=>e.state===o,p=e=>e.state===s,f=e=>{delete e.state};e.exports={STATE:r,STATE_CLEARED:i,STATE_MODIFIED:o,STATE_DELETED:s,isFileStateModified:u,setModifiedFileState:e=>c(e,o),isFileStateDeleted:p,setDeletedFileState:e=>c(e,s),setCommittedFile:e=>{e.committed=!0},isFileCommitted:e=>Boolean(e.committed),isFileNew:l,isFilePending:e=>u(e)||p(e)&&!l(e),resetFileState:f,clearFileState:e=>{e.state&&(e.stateCleared=e.state),f(e),delete e.isNew},hasState:e=>Boolean(e.state),hasClearedState:e=>Boolean(e.stateCleared)}},8206:(e,t,n)=>{const{createTransform:a}=n(1297),{isFilePending:r}=n(6268);e.exports={createPendingFilesPassthrough:()=>a(((e,t,n)=>{n(void 0,r(e)?e:void 0)})),createCommitTransform:e=>a(((t,n,a)=>{e.commitFileAsync(t).then((()=>a())).catch((e=>a(e)))}))}},1297:(e,t,n)=>{"use strict";const a=n(5747),r=n(5622),i=n(2169),o=n(8613),s=n(5696),{Transform:c}=n(2413),{isBinaryFileSync:l}=n(5092),{default:u}=n(3611),{default:p}=n(1672);function f(e){return null!=e&&"!"!==e.charAt(0)}t.getCommonPath=function(e){if(Array.isArray(e))return e=e.filter(f).map(this.getCommonPath.bind(this)),i(e);const t=e.indexOf("*");if(-1!==t)e=e.substring(0,t+1);else if(a.existsSync(e)&&a.statSync(e).isDirectory())return e;return r.dirname(e)},t.globify=function(e){if(Array.isArray(e))return e.reduce(((e,t)=>e.concat(this.globify(s(t)))),[]);if(e=s(e),o.hasMagic(e))return e;if(!a.existsSync(e))return[e,s(r.join(e,"**"))];const t=a.statSync(e);if(t.isFile())return e;if(t.isDirectory())return s(r.join(e,"**"));throw new Error("Only file path or directory path are supported.")},t.createTransform=function(e){return new c({objectMode:!0,transform(...t){return e.apply(this,t)}})},t.isBinary=(e,t)=>{const n=r.extname(e).replace(/^\./,"")||r.basename(e);return!!p.includes(n)||!u.includes(n)&&(a.existsSync(e)&&l(e)||t&&l(Buffer.isBuffer(t)?t:Buffer.from(t)))}},2595:e=>{"use strict";e.exports=(e,...t)=>{const n=new Set([].concat(...t));return e.filter((e=>!n.has(e)))}},9707:e=>{"use strict";e.exports=e=>null==e?[]:Array.isArray(e)?e:"string"==typeof e?[e]:"function"==typeof e[Symbol.iterator]?[...e]:[e]},1936:(e,t,n)=>{"use strict";const{promisify:a}=n(1669),r=n(5747),i=n(5622),o=n(9689),s=n(4149),c=n(9764),l=["**/node_modules/**","**/flow-typed/**","**/coverage/**","**/.git"],u=a(r.readFile),p=(e,t)=>{const n=c(i.relative(t.cwd,i.dirname(t.fileName)));return e.split(/\r?\n/).filter(Boolean).filter((e=>!e.startsWith("#"))).map((e=>t=>t.startsWith("!")?"!"+i.posix.join(e,t.slice(1)):i.posix.join(e,t))(n))},f=e=>{const t=s();for(const n of e)t.add(p(n.content,{cwd:n.cwd,fileName:n.filePath}));return t},d=(e,t)=>n=>e.ignores(c(i.relative(t,((e,t)=>{if(e=c(e),i.isAbsolute(t)){if(c(t).startsWith(e))return t;throw new Error(`Path ${t} is not in cwd ${e}`)}return i.join(e,t)})(t,n.path||n)))),h=({ignore:e=[],cwd:t=c(process.cwd())}={})=>({ignore:e,cwd:t});e.exports=async e=>{e=h(e);const t=await o("**/.gitignore",{ignore:l.concat(e.ignore),cwd:e.cwd}),n=await Promise.all(t.map((t=>(async(e,t)=>{const n=i.join(t,e);return{cwd:t,filePath:n,content:await u(n,"utf8")}})(t,e.cwd)))),a=f(n);return d(a,e.cwd)},e.exports.sync=e=>{e=h(e);const t=o.sync("**/.gitignore",{ignore:l.concat(e.ignore),cwd:e.cwd}).map((t=>((e,t)=>{const n=i.join(t,e);return{cwd:t,filePath:n,content:r.readFileSync(n,"utf8")}})(t,e.cwd))),n=f(t);return d(n,e.cwd)}},8613:(e,t,n)=>{"use strict";const a=n(5747),r=n(2245),i=n(1993),o=n(9689),s=n(4217),c=n(1936),{FilterStream:l,UniqueStream:u}=n(7005),p=()=>!1,f=e=>"!"===e[0],d=(e,t)=>{(e=>{if(!e.every((e=>"string"==typeof e)))throw new TypeError("Patterns must be a string or an array of strings")})(e=r([].concat(e))),((e={})=>{if(!e.cwd)return;let t;try{t=a.statSync(e.cwd)}catch{return}if(!t.isDirectory())throw new Error("The `cwd` option must be a path to a directory")})(t);const n=[];t={ignore:[],expandDirectories:!0,...t};for(const[a,r]of e.entries()){if(f(r))continue;const i=e.slice(a).filter((e=>f(e))).map((e=>e.slice(1))),o={...t,ignore:t.ignore.concat(i)};n.push({pattern:r,options:o})}return n},h=(e,t)=>e.options.expandDirectories?((e,t)=>{let n={};return e.options.cwd&&(n.cwd=e.options.cwd),Array.isArray(e.options.expandDirectories)?n={...n,files:e.options.expandDirectories}:"object"==typeof e.options.expandDirectories&&(n={...n,...e.options.expandDirectories}),t(e.pattern,n)})(e,t):[e.pattern],g=e=>e&&e.gitignore?c.sync({cwd:e.cwd,ignore:e.ignore}):p,m=e=>t=>{const{options:n}=e;return n.ignore&&Array.isArray(n.ignore)&&n.expandDirectories&&(n.ignore=s.sync(n.ignore)),{pattern:t,options:n}};e.exports=async(e,t)=>{const n=d(e,t),[i,l]=await Promise.all([(async()=>t&&t.gitignore?c({cwd:t.cwd,ignore:t.ignore}):p)(),(async()=>{const e=await Promise.all(n.map((async e=>{const t=await h(e,s);return Promise.all(t.map(m(e)))})));return r(...e)})()]),u=await Promise.all(l.map((e=>o(e.pattern,e.options))));return r(...u).filter((e=>{return!i((t=e,t.stats instanceof a.Stats?t.path:t));var t}))},e.exports.sync=(e,t)=>{const n=d(e,t),a=[];for(const e of n){const t=h(e,s.sync).map(m(e));a.push(...t)}const i=g(t);let c=[];for(const e of a)c=r(c,o.sync(e.pattern,e.options));return c.filter((e=>!i(e)))},e.exports.stream=(e,t)=>{const n=d(e,t),a=[];for(const e of n){const t=h(e,s.sync).map(m(e));a.push(...t)}const r=g(t),c=new l((e=>!r(e))),p=new u;return i(a.map((e=>o.stream(e.pattern,e.options)))).pipe(c).pipe(p)},e.exports.generateGlobTasks=d,e.exports.hasMagic=(e,t)=>[].concat(e).some((e=>o.isDynamicPattern(e,t))),e.exports.gitignore=c},7005:(e,t,n)=>{"use strict";const{Transform:a}=n(2413);class ObjectTransform extends a{constructor(){super({objectMode:!0})}}e.exports={FilterStream:class FilterStream extends ObjectTransform{constructor(e){super(),this._filter=e}_transform(e,t,n){this._filter(e)&&this.push(e),n()}},UniqueStream:class UniqueStream extends ObjectTransform{constructor(){super(),this._pushed=new Set}_transform(e,t,n){this._pushed.has(e)||(this.push(e),this._pushed.add(e)),n()}}}},4149:e=>{function t(e){return Array.isArray(e)?e:[e]}const n=/^\s+$/,a=/^\\!/,r=/^\\#/,i=/\r?\n/g,o=/^\.*\/|^\.+$/,s="undefined"!=typeof Symbol?Symbol.for("node-ignore"):"node-ignore",c=/([0-z])-([0-z])/g,l=[[/\\?\s+$/,e=>0===e.indexOf("\\")?" ":""],[/\\\s/g,()=>" "],[/[\\$.|*+(){^]/g,e=>`\\${e}`],[/(?!\\)\?/g,()=>"[^/]"],[/^\//,()=>"^"],[/\//g,()=>"\\/"],[/^\^*\\\*\\\*\\\//,()=>"^(?:.*\\/)?"],[/^(?=[^^])/,function(){return/\/(?!$)/.test(this)?"^":"(?:^|\\/)"}],[/\\\/\\\*\\\*(?=\\\/|$)/g,(e,t,n)=>t+6<n.length?"(?:\\/[^\\/]+)*":"\\/.+"],[/(^|[^\\]+)\\\*(?=.+)/g,(e,t)=>`${t}[^\\/]*`],[/\\\\\\(?=[$.|*+(){^])/g,()=>"\\"],[/\\\\/g,()=>"\\"],[/(\\)?\[([^\]/]*?)(\\*)($|\])/g,(e,t,n,a,r)=>"\\"===t?`\\[${n}${(e=>{const{length:t}=e;return e.slice(0,t-t%2)})(a)}${r}`:"]"===r&&a.length%2==0?`[${(e=>e.replace(c,((e,t,n)=>t.charCodeAt(0)<=n.charCodeAt(0)?e:"")))(n)}${a}]`:"[]"],[/(?:[^*])$/,e=>/\/$/.test(e)?`${e}$`:`${e}(?=$|\\/$)`],[/(\^|\\\/)?\\\*$/,(e,t)=>`${t?`${t}[^/]+`:"[^/]*"}(?=$|\\/$)`]],u=Object.create(null),p=e=>"string"==typeof e;class IgnoreRule{constructor(e,t,n,a){this.origin=e,this.pattern=t,this.negative=n,this.regex=a}}const f=(e,t)=>{const n=e;let i=!1;0===e.indexOf("!")&&(i=!0,e=e.substr(1));const o=((e,t,n)=>{const a=u[e];if(a)return a;const r=l.reduce(((t,n)=>t.replace(n[0],n[1].bind(e))),e);return u[e]=n?new RegExp(r,"i"):new RegExp(r)})(e=e.replace(a,"!").replace(r,"#"),0,t);return new IgnoreRule(n,e,i,o)},d=(e,t)=>{throw new t(e)},h=(e,t,n)=>{if(!p(e))return n(`path must be a string, but got \`${t}\``,TypeError);if(!e)return n("path must not be empty",TypeError);if(h.isNotRelative(e)){return n(`path should be a ${"`path.relative()`d"} string, but got "${t}"`,RangeError)}return!0},g=e=>o.test(e);h.isNotRelative=g,h.convert=e=>e;class Ignore{constructor({ignorecase:e=!0}={}){var t,n,a;this._rules=[],this._ignorecase=e,t=this,n=s,a=!0,Object.defineProperty(t,n,{value:a}),this._initCache()}_initCache(){this._ignoreCache=Object.create(null),this._testCache=Object.create(null)}_addPattern(e){if(e&&e[s])return this._rules=this._rules.concat(e._rules),void(this._added=!0);if((e=>e&&p(e)&&!n.test(e)&&0!==e.indexOf("#"))(e)){const t=f(e,this._ignorecase);this._added=!0,this._rules.push(t)}}add(e){return this._added=!1,t(p(e)?(e=>e.split(i))(e):e).forEach(this._addPattern,this),this._added&&this._initCache(),this}addPattern(e){return this.add(e)}_testOne(e,t){let n=!1,a=!1;return this._rules.forEach((r=>{const{negative:i}=r;if(a===i&&n!==a||i&&!n&&!a&&!t)return;r.regex.test(e)&&(n=!i,a=i)})),{ignored:n,unignored:a}}_test(e,t,n,a){const r=e&&h.convert(e);return h(r,e,d),this._t(r,t,n,a)}_t(e,t,n,a){if(e in t)return t[e];if(a||(a=e.split("/")),a.pop(),!a.length)return t[e]=this._testOne(e,n);const r=this._t(a.join("/")+"/",t,n,a);return t[e]=r.ignored?r:this._testOne(e,n)}ignores(e){return this._test(e,this._ignoreCache,!1).ignored}createFilter(){return e=>!this.ignores(e)}filter(e){return t(e).filter(this.createFilter())}test(e){return this._test(e,this._testCache,!0)}}const m=e=>new Ignore(e),y=()=>!1;if(m.isPathValid=e=>h(e&&h.convert(e),e,y),m.default=m,e.exports=m,"undefined"!=typeof process&&(process.env&&process.env.IGNORE_TEST_WIN32||"win32"===process.platform)){const e=e=>/^\\\\\?\\/.test(e)||/["<>|\u0000-\u001F]+/u.test(e)?e:e.replace(/\\/g,"/");h.convert=e;const t=/^[a-z]:\//i;h.isNotRelative=e=>t.test(e)||g(e)}},8371:(e,t,n)=>{"use strict";const a=n(2979),r=n(2245),i=n(2595),o=n(9707);e.exports=(e,t,n={})=>{if(e=o(e),t=o(t),0===e.length||0===t.length)return[];let s=[];for(const o of e)for(let e of t){let t=r;"!"===e[0]&&(e=e.slice(1),t=i),s=t(s,a.match([o],e,n))}return s}},5955:(e,t,n)=>{"use strict";var a=n(8614),r=n(5622),i=n(1669),o=n(5762),s=n(3356);const{PassThrough:c}=n(2413);t.create=function(){var e={};function t(t){var n;try{n=o.readSync(t)}catch(e){n=function(e){return new s({cwd:process.cwd(),base:process.cwd(),path:e,contents:null})}(t)}return e[t]=n,n}var n=function(){a.EventEmitter.apply(this,arguments)};return i.inherits(n,a.EventEmitter),n.prototype.get=function(n){return n=r.resolve(n),e[n]||t(n)},n.prototype.existsInMemory=function(t){return t=r.resolve(t),!!e[t]},n.prototype.add=function(t){return e[t.path]=t,this.emit("change",t.path),this},n.prototype.each=function(t){return Object.keys(e).forEach((function(n,a){t(e[n],a)})),this},n.prototype.all=function(){return Object.values(e)},n.prototype.stream=function(){const e=new c({objectMode:!0,autoDestroy:!0});return setImmediate(function(){this.each((t=>e.write(t))),e.end()}.bind(this)),e},new n}},1993:(e,t,n)=>{"use strict";const a=n(2413).PassThrough,r=Array.prototype.slice;function i(e,t){if(Array.isArray(e))for(let n=0,a=e.length;n<a;n++)e[n]=i(e[n],t);else{if(!e._readableState&&e.pipe&&(e=e.pipe(a(t))),!e._readableState||!e.pause||!e.pipe)throw new Error("Only readable stream can be merged.");e.pause()}return e}e.exports=function(){const e=[],t=r.call(arguments);let n=!1,o=t[t.length-1];o&&!Array.isArray(o)&&null==o.pipe?t.pop():o={};const s=!1!==o.end,c=!0===o.pipeError;null==o.objectMode&&(o.objectMode=!0);null==o.highWaterMark&&(o.highWaterMark=65536);const l=a(o);function u(){for(let t=0,n=arguments.length;t<n;t++)e.push(i(arguments[t],o));return p(),this}function p(){if(n)return;n=!0;let t=e.shift();if(!t)return void process.nextTick(f);Array.isArray(t)||(t=[t]);let a=t.length+1;function r(){--a>0||(n=!1,p())}function i(e){function t(){e.removeListener("merge2UnpipeEnd",t),e.removeListener("end",t),c&&e.removeListener("error",n),r()}function n(e){l.emit("error",e)}if(e._readableState.endEmitted)return r();e.on("merge2UnpipeEnd",t),e.on("end",t),c&&e.on("error",n),e.pipe(l,{end:!1}),e.resume()}for(let e=0;e<t.length;e++)i(t[e]);r()}function f(){n=!1,l.emit("queueDrain"),s&&l.end()}l.setMaxListeners(0),l.add=u,l.on("unpipe",(function(e){e.emit("merge2UnpipeEnd")})),t.length&&u.apply(null,t);return l}},2979:(e,t,n)=>{e.exports=f,f.Minimatch=d;var a={sep:"/"};try{a=n(5622)}catch(e){}var r=f.GLOBSTAR=d.GLOBSTAR={},i=n(8063),o={"!":{open:"(?:(?!(?:",close:"))[^/]*?)"},"?":{open:"(?:",close:")?"},"+":{open:"(?:",close:")+"},"*":{open:"(?:",close:")*"},"@":{open:"(?:",close:")"}},s="[^/]",c="[^/]*?",l="().*{}+?[]^$\\!".split("").reduce((function(e,t){return e[t]=!0,e}),{});var u=/\/+/;function p(e,t){e=e||{},t=t||{};var n={};return Object.keys(t).forEach((function(e){n[e]=t[e]})),Object.keys(e).forEach((function(t){n[t]=e[t]})),n}function f(e,t,n){if("string"!=typeof t)throw new TypeError("glob pattern string required");return n||(n={}),!(!n.nocomment&&"#"===t.charAt(0))&&(""===t.trim()?""===e:new d(t,n).match(e))}function d(e,t){if(!(this instanceof d))return new d(e,t);if("string"!=typeof e)throw new TypeError("glob pattern string required");t||(t={}),e=e.trim(),"/"!==a.sep&&(e=e.split(a.sep).join("/")),this.options=t,this.set=[],this.pattern=e,this.regexp=null,this.negate=!1,this.comment=!1,this.empty=!1,this.make()}function h(e,t){if(t||(t=this instanceof d?this.options:{}),void 0===(e=void 0===e?this.pattern:e))throw new TypeError("undefined pattern");return t.nobrace||!e.match(/\{.*\}/)?[e]:i(e)}f.filter=function(e,t){return t=t||{},function(n,a,r){return f(n,e,t)}},f.defaults=function(e){if(!e||!Object.keys(e).length)return f;var t=f,n=function(n,a,r){return t.minimatch(n,a,p(e,r))};return n.Minimatch=function(n,a){return new t.Minimatch(n,p(e,a))},n},d.defaults=function(e){return e&&Object.keys(e).length?f.defaults(e).Minimatch:d},d.prototype.debug=function(){},d.prototype.make=function(){if(this._made)return;var e=this.pattern,t=this.options;if(!t.nocomment&&"#"===e.charAt(0))return void(this.comment=!0);if(!e)return void(this.empty=!0);this.parseNegate();var n=this.globSet=this.braceExpand();t.debug&&(this.debug=console.error);this.debug(this.pattern,n),n=this.globParts=n.map((function(e){return e.split(u)})),this.debug(this.pattern,n),n=n.map((function(e,t,n){return e.map(this.parse,this)}),this),this.debug(this.pattern,n),n=n.filter((function(e){return-1===e.indexOf(!1)})),this.debug(this.pattern,n),this.set=n},d.prototype.parseNegate=function(){var e=this.pattern,t=!1,n=this.options,a=0;if(n.nonegate)return;for(var r=0,i=e.length;r<i&&"!"===e.charAt(r);r++)t=!t,a++;a&&(this.pattern=e.substr(a));this.negate=t},f.braceExpand=function(e,t){return h(e,t)},d.prototype.braceExpand=h,d.prototype.parse=function(e,t){if(e.length>65536)throw new TypeError("pattern is too long");var n=this.options;if(!n.noglobstar&&"**"===e)return r;if(""===e)return"";var a,i="",u=!!n.nocase,p=!1,f=[],d=[],h=!1,m=-1,y=-1,v="."===e.charAt(0)?"":n.dot?"(?!(?:^|\\/)\\.{1,2}(?:$|\\/))":"(?!\\.)",b=this;function P(){if(a){switch(a){case"*":i+=c,u=!0;break;case"?":i+=s,u=!0;break;default:i+="\\"+a}b.debug("clearStateChar %j %j",a,i),a=!1}}for(var S,T=0,O=e.length;T<O&&(S=e.charAt(T));T++)if(this.debug("%s\t%s %s %j",e,T,i,S),p&&l[S])i+="\\"+S,p=!1;else switch(S){case"/":return!1;case"\\":P(),p=!0;continue;case"?":case"*":case"+":case"@":case"!":if(this.debug("%s\t%s %s %j <-- stateChar",e,T,i,S),h){this.debug("  in class"),"!"===S&&T===y+1&&(S="^"),i+=S;continue}b.debug("call clearStateChar %j",a),P(),a=S,n.noext&&P();continue;case"(":if(h){i+="(";continue}if(!a){i+="\\(";continue}f.push({type:a,start:T-1,reStart:i.length,open:o[a].open,close:o[a].close}),i+="!"===a?"(?:(?!(?:":"(?:",this.debug("plType %j %j",a,i),a=!1;continue;case")":if(h||!f.length){i+="\\)";continue}P(),u=!0;var E=f.pop();i+=E.close,"!"===E.type&&d.push(E),E.reEnd=i.length;continue;case"|":if(h||!f.length||p){i+="\\|",p=!1;continue}P(),i+="|";continue;case"[":if(P(),h){i+="\\"+S;continue}h=!0,y=T,m=i.length,i+=S;continue;case"]":if(T===y+1||!h){i+="\\"+S,p=!1;continue}if(h){var _=e.substring(y+1,T);try{RegExp("["+_+"]")}catch(e){var C=this.parse(_,g);i=i.substr(0,m)+"\\["+C[0]+"\\]",u=u||C[1],h=!1;continue}}u=!0,h=!1,i+=S;continue;default:P(),p?p=!1:!l[S]||"^"===S&&h||(i+="\\"),i+=S}h&&(_=e.substr(y+1),C=this.parse(_,g),i=i.substr(0,m)+"\\["+C[0],u=u||C[1]);for(E=f.pop();E;E=f.pop()){var A=i.slice(E.reStart+E.open.length);this.debug("setting tail",i,E),A=A.replace(/((?:\\{2}){0,64})(\\?)\|/g,(function(e,t,n){return n||(n="\\"),t+t+n+"|"})),this.debug("tail=%j\n   %s",A,A,E,i);var I="*"===E.type?c:"?"===E.type?s:"\\"+E.type;u=!0,i=i.slice(0,E.reStart)+I+"\\("+A}P(),p&&(i+="\\\\");var R=!1;switch(i.charAt(0)){case".":case"[":case"(":R=!0}for(var F=d.length-1;F>-1;F--){var x=d[F],w=i.slice(0,x.reStart),j=i.slice(x.reStart,x.reEnd-8),N=i.slice(x.reEnd-8,x.reEnd),L=i.slice(x.reEnd);N+=L;var D=w.split("(").length-1,V=L;for(T=0;T<D;T++)V=V.replace(/\)[+*?]?/,"");var M="";""===(L=V)&&t!==g&&(M="$"),i=w+j+L+M+N}""!==i&&u&&(i="(?=.)"+i);R&&(i=v+i);if(t===g)return[i,u];if(!u)return function(e){return e.replace(/\\(.)/g,"$1")}(e);var k=n.nocase?"i":"";try{var $=new RegExp("^"+i+"$",k)}catch(e){return new RegExp("$.")}return $._glob=e,$._src=i,$};var g={};f.makeRe=function(e,t){return new d(e,t||{}).makeRe()},d.prototype.makeRe=function(){if(this.regexp||!1===this.regexp)return this.regexp;var e=this.set;if(!e.length)return this.regexp=!1,this.regexp;var t=this.options,n=t.noglobstar?c:t.dot?"(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?":"(?:(?!(?:\\/|^)\\.).)*?",a=t.nocase?"i":"",i=e.map((function(e){return e.map((function(e){return e===r?n:"string"==typeof e?function(e){return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")}(e):e._src})).join("\\/")})).join("|");i="^(?:"+i+")$",this.negate&&(i="^(?!"+i+").*$");try{this.regexp=new RegExp(i,a)}catch(e){this.regexp=!1}return this.regexp},f.match=function(e,t,n){var a=new d(t,n=n||{});return e=e.filter((function(e){return a.match(e)})),a.options.nonull&&!e.length&&e.push(t),e},d.prototype.match=function(e,t){if(this.debug("match",e,this.pattern),this.comment)return!1;if(this.empty)return""===e;if("/"===e&&t)return!0;var n=this.options;"/"!==a.sep&&(e=e.split(a.sep).join("/"));e=e.split(u),this.debug(this.pattern,"split",e);var r,i,o=this.set;for(this.debug(this.pattern,"set",o),i=e.length-1;i>=0&&!(r=e[i]);i--);for(i=0;i<o.length;i++){var s=o[i],c=e;if(n.matchBase&&1===s.length&&(c=[r]),this.matchOne(c,s,t))return!!n.flipNegate||!this.negate}return!n.flipNegate&&this.negate},d.prototype.matchOne=function(e,t,n){var a=this.options;this.debug("matchOne",{this:this,file:e,pattern:t}),this.debug("matchOne",e.length,t.length);for(var i=0,o=0,s=e.length,c=t.length;i<s&&o<c;i++,o++){this.debug("matchOne loop");var l,u=t[o],p=e[i];if(this.debug(t,u,p),!1===u)return!1;if(u===r){this.debug("GLOBSTAR",[t,u,p]);var f=i,d=o+1;if(d===c){for(this.debug("** at the end");i<s;i++)if("."===e[i]||".."===e[i]||!a.dot&&"."===e[i].charAt(0))return!1;return!0}for(;f<s;){var h=e[f];if(this.debug("\nglobstar while",e,f,t,d,h),this.matchOne(e.slice(f),t.slice(d),n))return this.debug("globstar found match!",f,s,h),!0;if("."===h||".."===h||!a.dot&&"."===h.charAt(0)){this.debug("dot detected!",e,f,t,d);break}this.debug("globstar swallow a segment, and continue"),f++}return!(!n||(this.debug("\n>>> no match, partial?",e,f,t,d),f!==s))}if("string"==typeof u?(l=a.nocase?p.toLowerCase()===u.toLowerCase():p===u,this.debug("string match",u,p,l)):(l=p.match(u),this.debug("pattern match",u,p,l)),!l)return!1}if(i===s&&o===c)return!0;if(i===s)return n;if(o===c)return i===s-1&&""===e[i];throw new Error("wtf?")}},5696:e=>{e.exports=function(e,t){if("string"!=typeof e)throw new TypeError("expected path to be a string");if("\\"===e||"/"===e)return"/";var n=e.length;if(n<=1)return e;var a="";if(n>4&&"\\"===e[3]){var r=e[2];"?"!==r&&"."!==r||"\\\\"!==e.slice(0,2)||(e=e.slice(2),a="//")}var i=e.split(/[/\\]+/);return!1!==t&&""===i[i.length-1]&&i.pop(),a+i.join("/")}},4973:(e,t,n)=>{"use strict";e.exports=n(6367)},8929:(e,t,n)=>{"use strict";const a=n(5622),r="[^\\\\/]",i="\\.",o="\\/",s="[^/]",c="(?:\\/|$)",l="(?:^|\\/)",u="\\.{1,2}(?:\\/|$)",p={DOT_LITERAL:i,PLUS_LITERAL:"\\+",QMARK_LITERAL:"\\?",SLASH_LITERAL:o,ONE_CHAR:"(?=.)",QMARK:s,END_ANCHOR:c,DOTS_SLASH:u,NO_DOT:"(?!\\.)",NO_DOTS:`(?!(?:^|\\/)${u})`,NO_DOT_SLASH:"(?!\\.{0,1}(?:\\/|$))",NO_DOTS_SLASH:`(?!${u})`,QMARK_NO_DOT:"[^.\\/]",STAR:"[^/]*?",START_ANCHOR:l},f={...p,SLASH_LITERAL:"[\\\\/]",QMARK:r,STAR:"[^\\\\/]*?",DOTS_SLASH:"\\.{1,2}(?:[\\\\/]|$)",NO_DOT:"(?!\\.)",NO_DOTS:"(?!(?:^|[\\\\/])\\.{1,2}(?:[\\\\/]|$))",NO_DOT_SLASH:"(?!\\.{0,1}(?:[\\\\/]|$))",NO_DOTS_SLASH:"(?!\\.{1,2}(?:[\\\\/]|$))",QMARK_NO_DOT:"[^.\\\\/]",START_ANCHOR:"(?:^|[\\\\/])",END_ANCHOR:"(?:[\\\\/]|$)"};e.exports={MAX_LENGTH:65536,POSIX_REGEX_SOURCE:{alnum:"a-zA-Z0-9",alpha:"a-zA-Z",ascii:"\\x00-\\x7F",blank:" \\t",cntrl:"\\x00-\\x1F\\x7F",digit:"0-9",graph:"\\x21-\\x7E",lower:"a-z",print:"\\x20-\\x7E ",punct:"\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",space:" \\t\\r\\n\\v\\f",upper:"A-Z",word:"A-Za-z0-9_",xdigit:"A-Fa-f0-9"},REGEX_BACKSLASH:/\\(?![*+?^${}(|)[\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\].,$*+?^{}()|\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\?)((\W)(\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\[.*?[^\\]\]|\\(?=.))/g,REPLACEMENTS:{"***":"*","**/**":"**","**/**/**":"**"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,SEP:a.sep,extglobChars:e=>({"!":{type:"negate",open:"(?:(?!(?:",close:`))${e.STAR})`},"?":{type:"qmark",open:"(?:",close:")?"},"+":{type:"plus",open:"(?:",close:")+"},"*":{type:"star",open:"(?:",close:")*"},"@":{type:"at",open:"(?:",close:")"}}),globChars:e=>!0===e?f:p}},7494:(e,t,n)=>{"use strict";const a=n(8929),r=n(557),{MAX_LENGTH:i,POSIX_REGEX_SOURCE:o,REGEX_NON_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_BACKREF:c,REPLACEMENTS:l}=a,u=(e,t)=>{if("function"==typeof t.expandRange)return t.expandRange(...e,t);e.sort();const n=`[${e.join("-")}]`;try{new RegExp(n)}catch(t){return e.map((e=>r.escapeRegex(e))).join("..")}return n},p=(e,t)=>`Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`,f=(e,t)=>{if("string"!=typeof e)throw new TypeError("Expected a string");e=l[e]||e;const n={...t},f="number"==typeof n.maxLength?Math.min(i,n.maxLength):i;let d=e.length;if(d>f)throw new SyntaxError(`Input length: ${d}, exceeds maximum allowed length: ${f}`);const h={type:"bos",value:"",output:n.prepend||""},g=[h],m=n.capture?"":"?:",y=r.isWindows(t),v=a.globChars(y),b=a.extglobChars(v),{DOT_LITERAL:P,PLUS_LITERAL:S,SLASH_LITERAL:T,ONE_CHAR:O,DOTS_SLASH:E,NO_DOT:_,NO_DOT_SLASH:C,NO_DOTS_SLASH:A,QMARK:I,QMARK_NO_DOT:R,STAR:F,START_ANCHOR:x}=v,w=e=>`(${m}(?:(?!${x}${e.dot?E:P}).)*?)`,j=n.dot?"":_,N=n.dot?I:R;let L=!0===n.bash?w(n):F;n.capture&&(L=`(${L})`),"boolean"==typeof n.noext&&(n.noextglob=n.noext);const D={input:e,index:-1,start:0,dot:!0===n.dot,consumed:"",output:"",prefix:"",backtrack:!1,negated:!1,brackets:0,braces:0,parens:0,quotes:0,globstar:!1,tokens:g};e=r.removePrefix(e,D),d=e.length;const V=[],M=[],k=[];let $,B=h;const U=()=>D.index===d-1,H=D.peek=(t=1)=>e[D.index+t],K=D.advance=()=>e[++D.index],Q=()=>e.slice(D.index+1),G=(e="",t=0)=>{D.consumed+=e,D.index+=t},W=e=>{D.output+=null!=e.output?e.output:e.value,G(e.value)},q=()=>{let e=1;for(;"!"===H()&&("("!==H(2)||"?"===H(3));)K(),D.start++,e++;return e%2!=0&&(D.negated=!0,D.start++,!0)},J=e=>{D[e]++,k.push(e)},X=e=>{D[e]--,k.pop()},z=e=>{if("globstar"===B.type){const t=D.braces>0&&("comma"===e.type||"brace"===e.type),n=!0===e.extglob||V.length&&("pipe"===e.type||"paren"===e.type);"slash"===e.type||"paren"===e.type||t||n||(D.output=D.output.slice(0,-B.output.length),B.type="star",B.value="*",B.output=L,D.output+=B.output)}if(V.length&&"paren"!==e.type&&!b[e.value]&&(V[V.length-1].inner+=e.value),(e.value||e.output)&&W(e),B&&"text"===B.type&&"text"===e.type)return B.value+=e.value,void(B.output=(B.output||"")+e.value);e.prev=B,g.push(e),B=e},Y=(e,t)=>{const a={...b[t],conditions:1,inner:""};a.prev=B,a.parens=D.parens,a.output=D.output;const r=(n.capture?"(":"")+a.open;J("parens"),z({type:e,value:t,output:D.output?"":O}),z({type:"paren",extglob:!0,value:K(),output:r}),V.push(a)},Z=e=>{let t=e.close+(n.capture?")":"");if("negate"===e.type){let a=L;e.inner&&e.inner.length>1&&e.inner.includes("/")&&(a=w(n)),(a!==L||U()||/^\)+$/.test(Q()))&&(t=e.close=`)$))${a}`),"bos"===e.prev.type&&U()&&(D.negatedExtglob=!0)}z({type:"paren",extglob:!0,value:$,output:t}),X("parens")};if(!1!==n.fastpaths&&!/(^[*!]|[/()[\]{}"])/.test(e)){let a=!1,i=e.replace(c,((e,t,n,r,i,o)=>"\\"===r?(a=!0,e):"?"===r?t?t+r+(i?I.repeat(i.length):""):0===o?N+(i?I.repeat(i.length):""):I.repeat(n.length):"."===r?P.repeat(n.length):"*"===r?t?t+r+(i?L:""):L:t?e:`\\${e}`));return!0===a&&(i=!0===n.unescape?i.replace(/\\/g,""):i.replace(/\\+/g,(e=>e.length%2==0?"\\\\":e?"\\":""))),i===e&&!0===n.contains?(D.output=e,D):(D.output=r.wrapOutput(i,D,t),D)}for(;!U();){if($=K(),"\0"===$)continue;if("\\"===$){const e=H();if("/"===e&&!0!==n.bash)continue;if("."===e||";"===e)continue;if(!e){$+="\\",z({type:"text",value:$});continue}const t=/^\\+/.exec(Q());let a=0;if(t&&t[0].length>2&&(a=t[0].length,D.index+=a,a%2!=0&&($+="\\")),!0===n.unescape?$=K()||"":$+=K()||"",0===D.brackets){z({type:"text",value:$});continue}}if(D.brackets>0&&("]"!==$||"["===B.value||"[^"===B.value)){if(!1!==n.posix&&":"===$){const e=B.value.slice(1);if(e.includes("[")&&(B.posix=!0,e.includes(":"))){const e=B.value.lastIndexOf("["),t=B.value.slice(0,e),n=B.value.slice(e+2),a=o[n];if(a){B.value=t+a,D.backtrack=!0,K(),h.output||1!==g.indexOf(B)||(h.output=O);continue}}}("["===$&&":"!==H()||"-"===$&&"]"===H())&&($=`\\${$}`),"]"!==$||"["!==B.value&&"[^"!==B.value||($=`\\${$}`),!0===n.posix&&"!"===$&&"["===B.value&&($="^"),B.value+=$,W({value:$});continue}if(1===D.quotes&&'"'!==$){$=r.escapeRegex($),B.value+=$,W({value:$});continue}if('"'===$){D.quotes=1===D.quotes?0:1,!0===n.keepQuotes&&z({type:"text",value:$});continue}if("("===$){J("parens"),z({type:"paren",value:$});continue}if(")"===$){if(0===D.parens&&!0===n.strictBrackets)throw new SyntaxError(p("opening","("));const e=V[V.length-1];if(e&&D.parens===e.parens+1){Z(V.pop());continue}z({type:"paren",value:$,output:D.parens?")":"\\)"}),X("parens");continue}if("["===$){if(!0!==n.nobracket&&Q().includes("]"))J("brackets");else{if(!0!==n.nobracket&&!0===n.strictBrackets)throw new SyntaxError(p("closing","]"));$=`\\${$}`}z({type:"bracket",value:$});continue}if("]"===$){if(!0===n.nobracket||B&&"bracket"===B.type&&1===B.value.length){z({type:"text",value:$,output:`\\${$}`});continue}if(0===D.brackets){if(!0===n.strictBrackets)throw new SyntaxError(p("opening","["));z({type:"text",value:$,output:`\\${$}`});continue}X("brackets");const e=B.value.slice(1);if(!0===B.posix||"^"!==e[0]||e.includes("/")||($=`/${$}`),B.value+=$,W({value:$}),!1===n.literalBrackets||r.hasRegexChars(e))continue;const t=r.escapeRegex(B.value);if(D.output=D.output.slice(0,-B.value.length),!0===n.literalBrackets){D.output+=t,B.value=t;continue}B.value=`(${m}${t}|${B.value})`,D.output+=B.value;continue}if("{"===$&&!0!==n.nobrace){J("braces");const e={type:"brace",value:$,output:"(",outputIndex:D.output.length,tokensIndex:D.tokens.length};M.push(e),z(e);continue}if("}"===$){const e=M[M.length-1];if(!0===n.nobrace||!e){z({type:"text",value:$,output:$});continue}let t=")";if(!0===e.dots){const e=g.slice(),a=[];for(let t=e.length-1;t>=0&&(g.pop(),"brace"!==e[t].type);t--)"dots"!==e[t].type&&a.unshift(e[t].value);t=u(a,n),D.backtrack=!0}if(!0!==e.comma&&!0!==e.dots){const n=D.output.slice(0,e.outputIndex),a=D.tokens.slice(e.tokensIndex);e.value=e.output="\\{",$=t="\\}",D.output=n;for(const e of a)D.output+=e.output||e.value}z({type:"brace",value:$,output:t}),X("braces"),M.pop();continue}if("|"===$){V.length>0&&V[V.length-1].conditions++,z({type:"text",value:$});continue}if(","===$){let e=$;const t=M[M.length-1];t&&"braces"===k[k.length-1]&&(t.comma=!0,e="|"),z({type:"comma",value:$,output:e});continue}if("/"===$){if("dot"===B.type&&D.index===D.start+1){D.start=D.index+1,D.consumed="",D.output="",g.pop(),B=h;continue}z({type:"slash",value:$,output:T});continue}if("."===$){if(D.braces>0&&"dot"===B.type){"."===B.value&&(B.output=P);const e=M[M.length-1];B.type="dots",B.output+=$,B.value+=$,e.dots=!0;continue}if(D.braces+D.parens===0&&"bos"!==B.type&&"slash"!==B.type){z({type:"text",value:$,output:P});continue}z({type:"dot",value:$,output:P});continue}if("?"===$){if(!(B&&"("===B.value)&&!0!==n.noextglob&&"("===H()&&"?"!==H(2)){Y("qmark",$);continue}if(B&&"paren"===B.type){const e=H();let t=$;if("<"===e&&!r.supportsLookbehinds())throw new Error("Node.js v10 or higher is required for regex lookbehinds");("("===B.value&&!/[!=<:]/.test(e)||"<"===e&&!/<([!=]|\w+>)/.test(Q()))&&(t=`\\${$}`),z({type:"text",value:$,output:t});continue}if(!0!==n.dot&&("slash"===B.type||"bos"===B.type)){z({type:"qmark",value:$,output:R});continue}z({type:"qmark",value:$,output:I});continue}if("!"===$){if(!0!==n.noextglob&&"("===H()&&("?"!==H(2)||!/[!=<:]/.test(H(3)))){Y("negate",$);continue}if(!0!==n.nonegate&&0===D.index){q();continue}}if("+"===$){if(!0!==n.noextglob&&"("===H()&&"?"!==H(2)){Y("plus",$);continue}if(B&&"("===B.value||!1===n.regex){z({type:"plus",value:$,output:S});continue}if(B&&("bracket"===B.type||"paren"===B.type||"brace"===B.type)||D.parens>0){z({type:"plus",value:$});continue}z({type:"plus",value:S});continue}if("@"===$){if(!0!==n.noextglob&&"("===H()&&"?"!==H(2)){z({type:"at",extglob:!0,value:$,output:""});continue}z({type:"text",value:$});continue}if("*"!==$){"$"!==$&&"^"!==$||($=`\\${$}`);const e=s.exec(Q());e&&($+=e[0],D.index+=e[0].length),z({type:"text",value:$});continue}if(B&&("globstar"===B.type||!0===B.star)){B.type="star",B.star=!0,B.value+=$,B.output=L,D.backtrack=!0,D.globstar=!0,G($);continue}let t=Q();if(!0!==n.noextglob&&/^\([^?]/.test(t)){Y("star",$);continue}if("star"===B.type){if(!0===n.noglobstar){G($);continue}const a=B.prev,r=a.prev,i="slash"===a.type||"bos"===a.type,o=r&&("star"===r.type||"globstar"===r.type);if(!0===n.bash&&(!i||t[0]&&"/"!==t[0])){z({type:"star",value:$,output:""});continue}const s=D.braces>0&&("comma"===a.type||"brace"===a.type),c=V.length&&("pipe"===a.type||"paren"===a.type);if(!i&&"paren"!==a.type&&!s&&!c){z({type:"star",value:$,output:""});continue}for(;"/**"===t.slice(0,3);){const n=e[D.index+4];if(n&&"/"!==n)break;t=t.slice(3),G("/**",3)}if("bos"===a.type&&U()){B.type="globstar",B.value+=$,B.output=w(n),D.output=B.output,D.globstar=!0,G($);continue}if("slash"===a.type&&"bos"!==a.prev.type&&!o&&U()){D.output=D.output.slice(0,-(a.output+B.output).length),a.output=`(?:${a.output}`,B.type="globstar",B.output=w(n)+(n.strictSlashes?")":"|$)"),B.value+=$,D.globstar=!0,D.output+=a.output+B.output,G($);continue}if("slash"===a.type&&"bos"!==a.prev.type&&"/"===t[0]){const e=void 0!==t[1]?"|$":"";D.output=D.output.slice(0,-(a.output+B.output).length),a.output=`(?:${a.output}`,B.type="globstar",B.output=`${w(n)}${T}|${T}${e})`,B.value+=$,D.output+=a.output+B.output,D.globstar=!0,G($+K()),z({type:"slash",value:"/",output:""});continue}if("bos"===a.type&&"/"===t[0]){B.type="globstar",B.value+=$,B.output=`(?:^|${T}|${w(n)}${T})`,D.output=B.output,D.globstar=!0,G($+K()),z({type:"slash",value:"/",output:""});continue}D.output=D.output.slice(0,-B.output.length),B.type="globstar",B.output=w(n),B.value+=$,D.output+=B.output,D.globstar=!0,G($);continue}const a={type:"star",value:$,output:L};!0!==n.bash?!B||"bracket"!==B.type&&"paren"!==B.type||!0!==n.regex?(D.index!==D.start&&"slash"!==B.type&&"dot"!==B.type||("dot"===B.type?(D.output+=C,B.output+=C):!0===n.dot?(D.output+=A,B.output+=A):(D.output+=j,B.output+=j),"*"!==H()&&(D.output+=O,B.output+=O)),z(a)):(a.output=$,z(a)):(a.output=".*?","bos"!==B.type&&"slash"!==B.type||(a.output=j+a.output),z(a))}for(;D.brackets>0;){if(!0===n.strictBrackets)throw new SyntaxError(p("closing","]"));D.output=r.escapeLast(D.output,"["),X("brackets")}for(;D.parens>0;){if(!0===n.strictBrackets)throw new SyntaxError(p("closing",")"));D.output=r.escapeLast(D.output,"("),X("parens")}for(;D.braces>0;){if(!0===n.strictBrackets)throw new SyntaxError(p("closing","}"));D.output=r.escapeLast(D.output,"{"),X("braces")}if(!0===n.strictSlashes||"star"!==B.type&&"bracket"!==B.type||z({type:"maybe_slash",value:"",output:`${T}?`}),!0===D.backtrack){D.output="";for(const e of D.tokens)D.output+=null!=e.output?e.output:e.value,e.suffix&&(D.output+=e.suffix)}return D};f.fastpaths=(e,t)=>{const n={...t},o="number"==typeof n.maxLength?Math.min(i,n.maxLength):i,s=e.length;if(s>o)throw new SyntaxError(`Input length: ${s}, exceeds maximum allowed length: ${o}`);e=l[e]||e;const c=r.isWindows(t),{DOT_LITERAL:u,SLASH_LITERAL:p,ONE_CHAR:f,DOTS_SLASH:d,NO_DOT:h,NO_DOTS:g,NO_DOTS_SLASH:m,STAR:y,START_ANCHOR:v}=a.globChars(c),b=n.dot?g:h,P=n.dot?m:h,S=n.capture?"":"?:";let T=!0===n.bash?".*?":y;n.capture&&(T=`(${T})`);const O=e=>!0===e.noglobstar?T:`(${S}(?:(?!${v}${e.dot?d:u}).)*?)`,E=e=>{switch(e){case"*":return`${b}${f}${T}`;case".*":return`${u}${f}${T}`;case"*.*":return`${b}${T}${u}${f}${T}`;case"*/*":return`${b}${T}${p}${f}${P}${T}`;case"**":return b+O(n);case"**/*":return`(?:${b}${O(n)}${p})?${P}${f}${T}`;case"**/*.*":return`(?:${b}${O(n)}${p})?${P}${T}${u}${f}${T}`;case"**/.*":return`(?:${b}${O(n)}${p})?${u}${f}${T}`;default:{const t=/^(.*?)\.(\w+)$/.exec(e);if(!t)return;const n=E(t[1]);if(!n)return;return n+u+t[2]}}},_=r.removePrefix(e,{negated:!1,prefix:""});let C=E(_);return C&&!0!==n.strictSlashes&&(C+=`${p}?`),C},e.exports=f},6367:(e,t,n)=>{"use strict";const a=n(5622),r=n(3803),i=n(7494),o=n(557),s=n(8929),c=(e,t,n=!1)=>{if(Array.isArray(e)){const a=e.map((e=>c(e,t,n)));return e=>{for(const t of a){const n=t(e);if(n)return n}return!1}}const a=(r=e)&&"object"==typeof r&&!Array.isArray(r)&&e.tokens&&e.input;var r;if(""===e||"string"!=typeof e&&!a)throw new TypeError("Expected pattern to be a non-empty string");const i=t||{},s=o.isWindows(t),l=a?c.compileRe(e,t):c.makeRe(e,t,!1,!0),u=l.state;delete l.state;let p=()=>!1;if(i.ignore){const e={...t,ignore:null,onMatch:null,onResult:null};p=c(i.ignore,e,n)}const f=(n,a=!1)=>{const{isMatch:r,match:o,output:f}=c.test(n,l,t,{glob:e,posix:s}),d={glob:e,state:u,regex:l,posix:s,input:n,output:f,match:o,isMatch:r};return"function"==typeof i.onResult&&i.onResult(d),!1===r?(d.isMatch=!1,!!a&&d):p(n)?("function"==typeof i.onIgnore&&i.onIgnore(d),d.isMatch=!1,!!a&&d):("function"==typeof i.onMatch&&i.onMatch(d),!a||d)};return n&&(f.state=u),f};c.test=(e,t,n,{glob:a,posix:r}={})=>{if("string"!=typeof e)throw new TypeError("Expected input to be a string");if(""===e)return{isMatch:!1,output:""};const i=n||{},s=i.format||(r?o.toPosixSlashes:null);let l=e===a,u=l&&s?s(e):e;return!1===l&&(u=s?s(e):e,l=u===a),!1!==l&&!0!==i.capture||(l=!0===i.matchBase||!0===i.basename?c.matchBase(e,t,n,r):t.exec(u)),{isMatch:Boolean(l),match:l,output:u}},c.matchBase=(e,t,n,r=o.isWindows(n))=>(t instanceof RegExp?t:c.makeRe(t,n)).test(a.basename(e)),c.isMatch=(e,t,n)=>c(t,n)(e),c.parse=(e,t)=>Array.isArray(e)?e.map((e=>c.parse(e,t))):i(e,{...t,fastpaths:!1}),c.scan=(e,t)=>r(e,t),c.compileRe=(e,t,n=!1,a=!1)=>{if(!0===n)return e.output;const r=t||{},i=r.contains?"":"^",o=r.contains?"":"$";let s=`${i}(?:${e.output})${o}`;e&&!0===e.negated&&(s=`^(?!${s}).*$`);const l=c.toRegex(s,t);return!0===a&&(l.state=e),l},c.makeRe=(e,t,n=!1,a=!1)=>{if(!e||"string"!=typeof e)throw new TypeError("Expected a non-empty string");const r=t||{};let o,s={negated:!1,fastpaths:!0},l="";return e.startsWith("./")&&(e=e.slice(2),l=s.prefix="./"),!1===r.fastpaths||"."!==e[0]&&"*"!==e[0]||(o=i.fastpaths(e,t)),void 0===o?(s=i(e,t),s.prefix=l+(s.prefix||"")):s.output=o,c.compileRe(s,t,n,a)},c.toRegex=(e,t)=>{try{const n=t||{};return new RegExp(e,n.flags||(n.nocase?"i":""))}catch(e){if(t&&!0===t.debug)throw e;return/$^/}},c.constants=s,e.exports=c},3803:(e,t,n)=>{"use strict";const a=n(557),{CHAR_ASTERISK:r,CHAR_AT:i,CHAR_BACKWARD_SLASH:o,CHAR_COMMA:s,CHAR_DOT:c,CHAR_EXCLAMATION_MARK:l,CHAR_FORWARD_SLASH:u,CHAR_LEFT_CURLY_BRACE:p,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:d,CHAR_PLUS:h,CHAR_QUESTION_MARK:g,CHAR_RIGHT_CURLY_BRACE:m,CHAR_RIGHT_PARENTHESES:y,CHAR_RIGHT_SQUARE_BRACKET:v}=n(8929),b=e=>e===u||e===o,P=e=>{!0!==e.isPrefix&&(e.depth=e.isGlobstar?1/0:1)};e.exports=(e,t)=>{const n=t||{},S=e.length-1,T=!0===n.parts||!0===n.scanToEnd,O=[],E=[],_=[];let C,A,I=e,R=-1,F=0,x=0,w=!1,j=!1,N=!1,L=!1,D=!1,V=!1,M=!1,k=!1,$=!1,B=0,U={value:"",depth:0,isGlob:!1};const H=()=>R>=S,K=()=>(C=A,I.charCodeAt(++R));for(;R<S;){let e;if(A=K(),A!==o){if(!0===V||A===p){for(B++;!0!==H()&&(A=K());)if(A!==o)if(A!==p){if(!0!==V&&A===c&&(A=K())===c){if(w=U.isBrace=!0,N=U.isGlob=!0,$=!0,!0===T)continue;break}if(!0!==V&&A===s){if(w=U.isBrace=!0,N=U.isGlob=!0,$=!0,!0===T)continue;break}if(A===m&&(B--,0===B)){V=!1,w=U.isBrace=!0,$=!0;break}}else B++;else M=U.backslashes=!0,K();if(!0===T)continue;break}if(A!==u){if(!0!==n.noext){if(!0===(A===h||A===i||A===r||A===g||A===l)&&I.charCodeAt(R+1)===f){if(N=U.isGlob=!0,L=U.isExtglob=!0,$=!0,!0===T){for(;!0!==H()&&(A=K());)if(A!==o){if(A===y){N=U.isGlob=!0,$=!0;break}}else M=U.backslashes=!0,A=K();continue}break}}if(A===r){if(C===r&&(D=U.isGlobstar=!0),N=U.isGlob=!0,$=!0,!0===T)continue;break}if(A===g){if(N=U.isGlob=!0,$=!0,!0===T)continue;break}if(A===d)for(;!0!==H()&&(e=K());)if(e!==o){if(e===v){if(j=U.isBracket=!0,N=U.isGlob=!0,$=!0,!0===T)continue;break}}else M=U.backslashes=!0,K();if(!0===n.nonegate||A!==l||R!==F){if(!0!==n.noparen&&A===f){if(N=U.isGlob=!0,!0===T){for(;!0!==H()&&(A=K());)if(A!==f){if(A===y){$=!0;break}}else M=U.backslashes=!0,A=K();continue}break}if(!0===N){if($=!0,!0===T)continue;break}}else k=U.negated=!0,F++}else{if(O.push(R),E.push(U),U={value:"",depth:0,isGlob:!1},!0===$)continue;if(C===c&&R===F+1){F+=2;continue}x=R+1}}else M=U.backslashes=!0,A=K(),A===p&&(V=!0)}!0===n.noext&&(L=!1,N=!1);let Q=I,G="",W="";F>0&&(G=I.slice(0,F),I=I.slice(F),x-=F),Q&&!0===N&&x>0?(Q=I.slice(0,x),W=I.slice(x)):!0===N?(Q="",W=I):Q=I,Q&&""!==Q&&"/"!==Q&&Q!==I&&b(Q.charCodeAt(Q.length-1))&&(Q=Q.slice(0,-1)),!0===n.unescape&&(W&&(W=a.removeBackslashes(W)),Q&&!0===M&&(Q=a.removeBackslashes(Q)));const q={prefix:G,input:e,start:F,base:Q,glob:W,isBrace:w,isBracket:j,isGlob:N,isExtglob:L,isGlobstar:D,negated:k};if(!0===n.tokens&&(q.maxDepth=0,b(A)||E.push(U),q.tokens=E),!0===n.parts||!0===n.tokens){let t;for(let a=0;a<O.length;a++){const r=t?t+1:F,i=O[a],o=e.slice(r,i);n.tokens&&(0===a&&0!==F?(E[a].isPrefix=!0,E[a].value=G):E[a].value=o,P(E[a]),q.maxDepth+=E[a].depth),0===a&&""===o||_.push(o),t=i}if(t&&t+1<e.length){const a=e.slice(t+1);_.push(a),n.tokens&&(E[E.length-1].value=a,P(E[E.length-1]),q.maxDepth+=E[E.length-1].depth)}q.slashes=O,q.parts=_}return q}},557:(e,t,n)=>{"use strict";const a=n(5622),r="win32"===process.platform,{REGEX_BACKSLASH:i,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:c}=n(8929);t.isObject=e=>null!==e&&"object"==typeof e&&!Array.isArray(e),t.hasRegexChars=e=>s.test(e),t.isRegexChar=e=>1===e.length&&t.hasRegexChars(e),t.escapeRegex=e=>e.replace(c,"\\$1"),t.toPosixSlashes=e=>e.replace(i,"/"),t.removeBackslashes=e=>e.replace(o,(e=>"\\"===e?"":e)),t.supportsLookbehinds=()=>{const e=process.version.slice(1).split(".").map(Number);return 3===e.length&&e[0]>=9||8===e[0]&&e[1]>=10},t.isWindows=e=>e&&"boolean"==typeof e.windows?e.windows:!0===r||"\\"===a.sep,t.escapeLast=(e,n,a)=>{const r=e.lastIndexOf(n,a);return-1===r?e:"\\"===e[r-1]?t.escapeLast(e,n,r-1):`${e.slice(0,r)}\\${e.slice(r)}`},t.removePrefix=(e,t={})=>{let n=e;return n.startsWith("./")&&(n=n.slice(2),t.prefix="./"),n},t.wrapOutput=(e,t={},n={})=>{let a=`${n.contains?"":"^"}(?:${e})${n.contains?"":"$"}`;return!0===t.negated&&(a=`(?:^(?!${a}).*$)`),a}},5552:e=>{"use strict";"undefined"==typeof process||!process.version||0===process.version.indexOf("v0.")||0===process.version.indexOf("v1.")&&0!==process.version.indexOf("v1.8.")?e.exports={nextTick:function(e,t,n,a){if("function"!=typeof e)throw new TypeError('"callback" argument must be a function');var r,i,o=arguments.length;switch(o){case 0:case 1:return process.nextTick(e);case 2:return process.nextTick((function(){e.call(null,t)}));case 3:return process.nextTick((function(){e.call(null,t,n)}));case 4:return process.nextTick((function(){e.call(null,t,n,a)}));default:for(r=new Array(o-1),i=0;i<r.length;)r[i++]=arguments[i];return process.nextTick((function(){e.apply(null,r)}))}}}:e.exports=process},5101:(e,t,n)=>{"use strict";var a=n(5552),r=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t};e.exports=p;var i=Object.create(n(2862));i.inherits=n(5822);var o=n(6246),s=n(609);i.inherits(p,o);for(var c=r(s.prototype),l=0;l<c.length;l++){var u=c[l];p.prototype[u]||(p.prototype[u]=s.prototype[u])}function p(e){if(!(this instanceof p))return new p(e);o.call(this,e),s.call(this,e),e&&!1===e.readable&&(this.readable=!1),e&&!1===e.writable&&(this.writable=!1),this.allowHalfOpen=!0,e&&!1===e.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",f)}function f(){this.allowHalfOpen||this._writableState.ended||a.nextTick(d,this)}function d(e){e.end()}Object.defineProperty(p.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(p.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(e){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e)}}),p.prototype._destroy=function(e,t){this.push(null),this.end(),a.nextTick(t,e)}},7153:(e,t,n)=>{"use strict";e.exports=i;var a=n(6889),r=Object.create(n(2862));function i(e){if(!(this instanceof i))return new i(e);a.call(this,e)}r.inherits=n(5822),r.inherits(i,a),i.prototype._transform=function(e,t,n){n(null,e)}},6246:(e,t,n)=>{"use strict";var a=n(5552);e.exports=v;var r,i=n(1538);v.ReadableState=y;n(8614).EventEmitter;var o=function(e,t){return e.listeners(t).length},s=n(4804),c=n(682).Buffer,l=global.Uint8Array||function(){};var u=Object.create(n(2862));u.inherits=n(5822);var p=n(1669),f=void 0;f=p&&p.debuglog?p.debuglog("stream"):function(){};var d,h=n(5335),g=n(6946);u.inherits(v,s);var m=["error","close","destroy","pause","resume"];function y(e,t){e=e||{};var a=t instanceof(r=r||n(5101));this.objectMode=!!e.objectMode,a&&(this.objectMode=this.objectMode||!!e.readableObjectMode);var i=e.highWaterMark,o=e.readableHighWaterMark,s=this.objectMode?16:16384;this.highWaterMark=i||0===i?i:a&&(o||0===o)?o:s,this.highWaterMark=Math.floor(this.highWaterMark),this.buffer=new h,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.destroyed=!1,this.defaultEncoding=e.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&(d||(d=n(8234).s),this.decoder=new d(e.encoding),this.encoding=e.encoding)}function v(e){if(r=r||n(5101),!(this instanceof v))return new v(e);this._readableState=new y(e,this),this.readable=!0,e&&("function"==typeof e.read&&(this._read=e.read),"function"==typeof e.destroy&&(this._destroy=e.destroy)),s.call(this)}function b(e,t,n,a,r){var i,o=e._readableState;null===t?(o.reading=!1,function(e,t){if(t.ended)return;if(t.decoder){var n=t.decoder.end();n&&n.length&&(t.buffer.push(n),t.length+=t.objectMode?1:n.length)}t.ended=!0,O(e)}(e,o)):(r||(i=function(e,t){var n;a=t,c.isBuffer(a)||a instanceof l||"string"==typeof t||void 0===t||e.objectMode||(n=new TypeError("Invalid non-string/buffer chunk"));var a;return n}(o,t)),i?e.emit("error",i):o.objectMode||t&&t.length>0?("string"==typeof t||o.objectMode||Object.getPrototypeOf(t)===c.prototype||(t=function(e){return c.from(e)}(t)),a?o.endEmitted?e.emit("error",new Error("stream.unshift() after end event")):P(e,o,t,!0):o.ended?e.emit("error",new Error("stream.push() after EOF")):(o.reading=!1,o.decoder&&!n?(t=o.decoder.write(t),o.objectMode||0!==t.length?P(e,o,t,!1):_(e,o)):P(e,o,t,!1))):a||(o.reading=!1));return function(e){return!e.ended&&(e.needReadable||e.length<e.highWaterMark||0===e.length)}(o)}function P(e,t,n,a){t.flowing&&0===t.length&&!t.sync?(e.emit("data",n),e.read(0)):(t.length+=t.objectMode?1:n.length,a?t.buffer.unshift(n):t.buffer.push(n),t.needReadable&&O(e)),_(e,t)}Object.defineProperty(v.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e)}}),v.prototype.destroy=g.destroy,v.prototype._undestroy=g.undestroy,v.prototype._destroy=function(e,t){this.push(null),t(e)},v.prototype.push=function(e,t){var n,a=this._readableState;return a.objectMode?n=!0:"string"==typeof e&&((t=t||a.defaultEncoding)!==a.encoding&&(e=c.from(e,t),t=""),n=!0),b(this,e,t,!1,n)},v.prototype.unshift=function(e){return b(this,e,null,!0,!1)},v.prototype.isPaused=function(){return!1===this._readableState.flowing},v.prototype.setEncoding=function(e){return d||(d=n(8234).s),this._readableState.decoder=new d(e),this._readableState.encoding=e,this};var S=8388608;function T(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!=e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=function(e){return e>=S?e=S:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function O(e){var t=e._readableState;t.needReadable=!1,t.emittedReadable||(f("emitReadable",t.flowing),t.emittedReadable=!0,t.sync?a.nextTick(E,e):E(e))}function E(e){f("emit readable"),e.emit("readable"),R(e)}function _(e,t){t.readingMore||(t.readingMore=!0,a.nextTick(C,e,t))}function C(e,t){for(var n=t.length;!t.reading&&!t.flowing&&!t.ended&&t.length<t.highWaterMark&&(f("maybeReadMore read 0"),e.read(0),n!==t.length);)n=t.length;t.readingMore=!1}function A(e){f("readable nexttick read 0"),e.read(0)}function I(e,t){t.reading||(f("resume read 0"),e.read(0)),t.resumeScheduled=!1,t.awaitDrain=0,e.emit("resume"),R(e),t.flowing&&!t.reading&&e.read(0)}function R(e){var t=e._readableState;for(f("flow",t.flowing);t.flowing&&null!==e.read(););}function F(e,t){return 0===t.length?null:(t.objectMode?n=t.buffer.shift():!e||e>=t.length?(n=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.head.data:t.buffer.concat(t.length),t.buffer.clear()):n=function(e,t,n){var a;e<t.head.data.length?(a=t.head.data.slice(0,e),t.head.data=t.head.data.slice(e)):a=e===t.head.data.length?t.shift():n?function(e,t){var n=t.head,a=1,r=n.data;e-=r.length;for(;n=n.next;){var i=n.data,o=e>i.length?i.length:e;if(o===i.length?r+=i:r+=i.slice(0,e),0===(e-=o)){o===i.length?(++a,n.next?t.head=n.next:t.head=t.tail=null):(t.head=n,n.data=i.slice(o));break}++a}return t.length-=a,r}(e,t):function(e,t){var n=c.allocUnsafe(e),a=t.head,r=1;a.data.copy(n),e-=a.data.length;for(;a=a.next;){var i=a.data,o=e>i.length?i.length:e;if(i.copy(n,n.length-e,0,o),0===(e-=o)){o===i.length?(++r,a.next?t.head=a.next:t.head=t.tail=null):(t.head=a,a.data=i.slice(o));break}++r}return t.length-=r,n}(e,t);return a}(e,t.buffer,t.decoder),n);var n}function x(e){var t=e._readableState;if(t.length>0)throw new Error('"endReadable()" called on non-empty stream');t.endEmitted||(t.ended=!0,a.nextTick(w,t,e))}function w(e,t){e.endEmitted||0!==e.length||(e.endEmitted=!0,t.readable=!1,t.emit("end"))}function j(e,t){for(var n=0,a=e.length;n<a;n++)if(e[n]===t)return n;return-1}v.prototype.read=function(e){f("read",e),e=parseInt(e,10);var t=this._readableState,n=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&(t.length>=t.highWaterMark||t.ended))return f("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?x(this):O(this),null;if(0===(e=T(e,t))&&t.ended)return 0===t.length&&x(this),null;var a,r=t.needReadable;return f("need readable",r),(0===t.length||t.length-e<t.highWaterMark)&&f("length less than watermark",r=!0),t.ended||t.reading?f("reading or ended",r=!1):r&&(f("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=T(n,t))),null===(a=e>0?F(e,t):null)?(t.needReadable=!0,e=0):t.length-=e,0===t.length&&(t.ended||(t.needReadable=!0),n!==e&&t.ended&&x(this)),null!==a&&this.emit("data",a),a},v.prototype._read=function(e){this.emit("error",new Error("_read() is not implemented"))},v.prototype.pipe=function(e,t){var n=this,r=this._readableState;switch(r.pipesCount){case 0:r.pipes=e;break;case 1:r.pipes=[r.pipes,e];break;default:r.pipes.push(e)}r.pipesCount+=1,f("pipe count=%d opts=%j",r.pipesCount,t);var s=(!t||!1!==t.end)&&e!==process.stdout&&e!==process.stderr?l:v;function c(t,a){f("onunpipe"),t===n&&a&&!1===a.hasUnpiped&&(a.hasUnpiped=!0,f("cleanup"),e.removeListener("close",m),e.removeListener("finish",y),e.removeListener("drain",u),e.removeListener("error",g),e.removeListener("unpipe",c),n.removeListener("end",l),n.removeListener("end",v),n.removeListener("data",h),p=!0,!r.awaitDrain||e._writableState&&!e._writableState.needDrain||u())}function l(){f("onend"),e.end()}r.endEmitted?a.nextTick(s):n.once("end",s),e.on("unpipe",c);var u=function(e){return function(){var t=e._readableState;f("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&o(e,"data")&&(t.flowing=!0,R(e))}}(n);e.on("drain",u);var p=!1;var d=!1;function h(t){f("ondata"),d=!1,!1!==e.write(t)||d||((1===r.pipesCount&&r.pipes===e||r.pipesCount>1&&-1!==j(r.pipes,e))&&!p&&(f("false write response, pause",n._readableState.awaitDrain),n._readableState.awaitDrain++,d=!0),n.pause())}function g(t){f("onerror",t),v(),e.removeListener("error",g),0===o(e,"error")&&e.emit("error",t)}function m(){e.removeListener("finish",y),v()}function y(){f("onfinish"),e.removeListener("close",m),v()}function v(){f("unpipe"),n.unpipe(e)}return n.on("data",h),function(e,t,n){if("function"==typeof e.prependListener)return e.prependListener(t,n);e._events&&e._events[t]?i(e._events[t])?e._events[t].unshift(n):e._events[t]=[n,e._events[t]]:e.on(t,n)}(e,"error",g),e.once("close",m),e.once("finish",y),e.emit("pipe",n),r.flowing||(f("pipe resume"),n.resume()),e},v.prototype.unpipe=function(e){var t=this._readableState,n={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes||(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this,n)),this;if(!e){var a=t.pipes,r=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var i=0;i<r;i++)a[i].emit("unpipe",this,n);return this}var o=j(t.pipes,e);return-1===o||(t.pipes.splice(o,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this,n)),this},v.prototype.on=function(e,t){var n=s.prototype.on.call(this,e,t);if("data"===e)!1!==this._readableState.flowing&&this.resume();else if("readable"===e){var r=this._readableState;r.endEmitted||r.readableListening||(r.readableListening=r.needReadable=!0,r.emittedReadable=!1,r.reading?r.length&&O(this):a.nextTick(A,this))}return n},v.prototype.addListener=v.prototype.on,v.prototype.resume=function(){var e=this._readableState;return e.flowing||(f("resume"),e.flowing=!0,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,a.nextTick(I,e,t))}(this,e)),this},v.prototype.pause=function(){return f("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(f("pause"),this._readableState.flowing=!1,this.emit("pause")),this},v.prototype.wrap=function(e){var t=this,n=this._readableState,a=!1;for(var r in e.on("end",(function(){if(f("wrapped end"),n.decoder&&!n.ended){var e=n.decoder.end();e&&e.length&&t.push(e)}t.push(null)})),e.on("data",(function(r){(f("wrapped data"),n.decoder&&(r=n.decoder.write(r)),n.objectMode&&null==r)||(n.objectMode||r&&r.length)&&(t.push(r)||(a=!0,e.pause()))})),e)void 0===this[r]&&"function"==typeof e[r]&&(this[r]=function(t){return function(){return e[t].apply(e,arguments)}}(r));for(var i=0;i<m.length;i++)e.on(m[i],this.emit.bind(this,m[i]));return this._read=function(t){f("wrapped _read",t),a&&(a=!1,e.resume())},this},Object.defineProperty(v.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),v._fromList=F},6889:(e,t,n)=>{"use strict";e.exports=o;var a=n(5101),r=Object.create(n(2862));function i(e,t){var n=this._transformState;n.transforming=!1;var a=n.writecb;if(!a)return this.emit("error",new Error("write callback called multiple times"));n.writechunk=null,n.writecb=null,null!=t&&this.push(t),a(e);var r=this._readableState;r.reading=!1,(r.needReadable||r.length<r.highWaterMark)&&this._read(r.highWaterMark)}function o(e){if(!(this instanceof o))return new o(e);a.call(this,e),this._transformState={afterTransform:i.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),this.on("prefinish",s)}function s(){var e=this;"function"==typeof this._flush?this._flush((function(t,n){c(e,t,n)})):c(this,null,null)}function c(e,t,n){if(t)return e.emit("error",t);if(null!=n&&e.push(n),e._writableState.length)throw new Error("Calling transform done when ws.length != 0");if(e._transformState.transforming)throw new Error("Calling transform done when still transforming");return e.push(null)}r.inherits=n(5822),r.inherits(o,a),o.prototype.push=function(e,t){return this._transformState.needTransform=!1,a.prototype.push.call(this,e,t)},o.prototype._transform=function(e,t,n){throw new Error("_transform() is not implemented")},o.prototype._write=function(e,t,n){var a=this._transformState;if(a.writecb=n,a.writechunk=e,a.writeencoding=t,!a.transforming){var r=this._readableState;(a.needTransform||r.needReadable||r.length<r.highWaterMark)&&this._read(r.highWaterMark)}},o.prototype._read=function(e){var t=this._transformState;null!==t.writechunk&&t.writecb&&!t.transforming?(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform)):t.needTransform=!0},o.prototype._destroy=function(e,t){var n=this;a.prototype._destroy.call(this,e,(function(e){t(e),n.emit("close")}))}},609:(e,t,n)=>{"use strict";var a=n(5552);function r(e){var t=this;this.next=null,this.entry=null,this.finish=function(){!function(e,t,n){var a=e.entry;e.entry=null;for(;a;){var r=a.callback;t.pendingcb--,r(n),a=a.next}t.corkedRequestsFree?t.corkedRequestsFree.next=e:t.corkedRequestsFree=e}(t,e)}}e.exports=m;var i,o=!process.browser&&["v0.10","v0.9."].indexOf(process.version.slice(0,5))>-1?setImmediate:a.nextTick;m.WritableState=g;var s=Object.create(n(2862));s.inherits=n(5822);var c={deprecate:n(8767)},l=n(4804),u=n(682).Buffer,p=global.Uint8Array||function(){};var f,d=n(6946);function h(){}function g(e,t){i=i||n(5101),e=e||{};var s=t instanceof i;this.objectMode=!!e.objectMode,s&&(this.objectMode=this.objectMode||!!e.writableObjectMode);var c=e.highWaterMark,l=e.writableHighWaterMark,u=this.objectMode?16:16384;this.highWaterMark=c||0===c?c:s&&(l||0===l)?l:u,this.highWaterMark=Math.floor(this.highWaterMark),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var p=!1===e.decodeStrings;this.decodeStrings=!p,this.defaultEncoding=e.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){!function(e,t){var n=e._writableState,r=n.sync,i=n.writecb;if(function(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}(n),t)!function(e,t,n,r,i){--t.pendingcb,n?(a.nextTick(i,r),a.nextTick(T,e,t),e._writableState.errorEmitted=!0,e.emit("error",r)):(i(r),e._writableState.errorEmitted=!0,e.emit("error",r),T(e,t))}(e,n,r,t,i);else{var s=P(n);s||n.corked||n.bufferProcessing||!n.bufferedRequest||b(e,n),r?o(v,e,n,s,i):v(e,n,s,i)}}(t,e)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new r(this)}function m(e){if(i=i||n(5101),!(f.call(m,this)||this instanceof i))return new m(e);this._writableState=new g(e,this),this.writable=!0,e&&("function"==typeof e.write&&(this._write=e.write),"function"==typeof e.writev&&(this._writev=e.writev),"function"==typeof e.destroy&&(this._destroy=e.destroy),"function"==typeof e.final&&(this._final=e.final)),l.call(this)}function y(e,t,n,a,r,i,o){t.writelen=a,t.writecb=o,t.writing=!0,t.sync=!0,n?e._writev(r,t.onwrite):e._write(r,i,t.onwrite),t.sync=!1}function v(e,t,n,a){n||function(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}(e,t),t.pendingcb--,a(),T(e,t)}function b(e,t){t.bufferProcessing=!0;var n=t.bufferedRequest;if(e._writev&&n&&n.next){var a=t.bufferedRequestCount,i=new Array(a),o=t.corkedRequestsFree;o.entry=n;for(var s=0,c=!0;n;)i[s]=n,n.isBuf||(c=!1),n=n.next,s+=1;i.allBuffers=c,y(e,t,!0,t.length,i,"",o.finish),t.pendingcb++,t.lastBufferedRequest=null,o.next?(t.corkedRequestsFree=o.next,o.next=null):t.corkedRequestsFree=new r(t),t.bufferedRequestCount=0}else{for(;n;){var l=n.chunk,u=n.encoding,p=n.callback;if(y(e,t,!1,t.objectMode?1:l.length,l,u,p),n=n.next,t.bufferedRequestCount--,t.writing)break}null===n&&(t.lastBufferedRequest=null)}t.bufferedRequest=n,t.bufferProcessing=!1}function P(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function S(e,t){e._final((function(n){t.pendingcb--,n&&e.emit("error",n),t.prefinished=!0,e.emit("prefinish"),T(e,t)}))}function T(e,t){var n=P(t);return n&&(!function(e,t){t.prefinished||t.finalCalled||("function"==typeof e._final?(t.pendingcb++,t.finalCalled=!0,a.nextTick(S,e,t)):(t.prefinished=!0,e.emit("prefinish")))}(e,t),0===t.pendingcb&&(t.finished=!0,e.emit("finish"))),n}s.inherits(m,l),g.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(g.prototype,"buffer",{get:c.deprecate((function(){return this.getBuffer()}),"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(e){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(f=Function.prototype[Symbol.hasInstance],Object.defineProperty(m,Symbol.hasInstance,{value:function(e){return!!f.call(this,e)||this===m&&(e&&e._writableState instanceof g)}})):f=function(e){return e instanceof this},m.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},m.prototype.write=function(e,t,n){var r,i=this._writableState,o=!1,s=!i.objectMode&&(r=e,u.isBuffer(r)||r instanceof p);return s&&!u.isBuffer(e)&&(e=function(e){return u.from(e)}(e)),"function"==typeof t&&(n=t,t=null),s?t="buffer":t||(t=i.defaultEncoding),"function"!=typeof n&&(n=h),i.ended?function(e,t){var n=new Error("write after end");e.emit("error",n),a.nextTick(t,n)}(this,n):(s||function(e,t,n,r){var i=!0,o=!1;return null===n?o=new TypeError("May not write null values to stream"):"string"==typeof n||void 0===n||t.objectMode||(o=new TypeError("Invalid non-string/buffer chunk")),o&&(e.emit("error",o),a.nextTick(r,o),i=!1),i}(this,i,e,n))&&(i.pendingcb++,o=function(e,t,n,a,r,i){if(!n){var o=function(e,t,n){e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=u.from(t,n));return t}(t,a,r);a!==o&&(n=!0,r="buffer",a=o)}var s=t.objectMode?1:a.length;t.length+=s;var c=t.length<t.highWaterMark;c||(t.needDrain=!0);if(t.writing||t.corked){var l=t.lastBufferedRequest;t.lastBufferedRequest={chunk:a,encoding:r,isBuf:n,callback:i,next:null},l?l.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1}else y(e,t,!1,s,a,r,i);return c}(this,i,s,e,t,n)),o},m.prototype.cork=function(){this._writableState.corked++},m.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.finished||e.bufferProcessing||!e.bufferedRequest||b(this,e))},m.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new TypeError("Unknown encoding: "+e);return this._writableState.defaultEncoding=e,this},Object.defineProperty(m.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),m.prototype._write=function(e,t,n){n(new Error("_write() is not implemented"))},m.prototype._writev=null,m.prototype.end=function(e,t,n){var r=this._writableState;"function"==typeof e?(n=e,e=null,t=null):"function"==typeof t&&(n=t,t=null),null!=e&&this.write(e,t),r.corked&&(r.corked=1,this.uncork()),r.ending||r.finished||function(e,t,n){t.ending=!0,T(e,t),n&&(t.finished?a.nextTick(n):e.once("finish",n));t.ended=!0,e.writable=!1}(this,r,n)},Object.defineProperty(m.prototype,"destroyed",{get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e)}}),m.prototype.destroy=d.destroy,m.prototype._undestroy=d.undestroy,m.prototype._destroy=function(e,t){this.end(),t(e)}},5335:(e,t,n)=>{"use strict";var a=n(682).Buffer,r=n(1669);e.exports=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.head=null,this.tail=null,this.length=0}return e.prototype.push=function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length},e.prototype.unshift=function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length},e.prototype.shift=function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}},e.prototype.clear=function(){this.head=this.tail=null,this.length=0},e.prototype.join=function(e){if(0===this.length)return"";for(var t=this.head,n=""+t.data;t=t.next;)n+=e+t.data;return n},e.prototype.concat=function(e){if(0===this.length)return a.alloc(0);if(1===this.length)return this.head.data;for(var t,n,r,i=a.allocUnsafe(e>>>0),o=this.head,s=0;o;)t=o.data,n=i,r=s,t.copy(n,r),s+=o.data.length,o=o.next;return i},e}(),r&&r.inspect&&r.inspect.custom&&(e.exports.prototype[r.inspect.custom]=function(){var e=r.inspect({length:this.length});return this.constructor.name+" "+e})},6946:(e,t,n)=>{"use strict";var a=n(5552);function r(e,t){e.emit("error",t)}e.exports={destroy:function(e,t){var n=this,i=this._readableState&&this._readableState.destroyed,o=this._writableState&&this._writableState.destroyed;return i||o?(t?t(e):!e||this._writableState&&this._writableState.errorEmitted||a.nextTick(r,this,e),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(e||null,(function(e){!t&&e?(a.nextTick(r,n,e),n._writableState&&(n._writableState.errorEmitted=!0)):t&&t(e)})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)}}},4804:(e,t,n)=>{e.exports=n(2413)},1538:e=>{var t={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==t.call(e)}},682:(e,t,n)=>{var a=n(4293),r=a.Buffer;function i(e,t){for(var n in e)t[n]=e[n]}function o(e,t,n){return r(e,t,n)}r.from&&r.alloc&&r.allocUnsafe&&r.allocUnsafeSlow?e.exports=a:(i(a,t),t.Buffer=o),i(r,o),o.from=function(e,t,n){if("number"==typeof e)throw new TypeError("Argument must not be a number");return r(e,t,n)},o.alloc=function(e,t,n){if("number"!=typeof e)throw new TypeError("Argument must be a number");var a=r(e);return void 0!==t?"string"==typeof n?a.fill(t,n):a.fill(t):a.fill(0),a},o.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return r(e)},o.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return a.SlowBuffer(e)}},8234:(e,t,n)=>{"use strict";var a=n(682).Buffer,r=a.isEncoding||function(e){switch((e=""+e)&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function i(e){var t;switch(this.encoding=function(e){var t=function(e){if(!e)return"utf8";for(var t;;)switch(e){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return e;default:if(t)return;e=(""+e).toLowerCase(),t=!0}}(e);if("string"!=typeof t&&(a.isEncoding===r||!r(e)))throw new Error("Unknown encoding: "+e);return t||e}(e),this.encoding){case"utf16le":this.text=c,this.end=l,t=4;break;case"utf8":this.fillLast=s,t=4;break;case"base64":this.text=u,this.end=p,t=3;break;default:return this.write=f,void(this.end=d)}this.lastNeed=0,this.lastTotal=0,this.lastChar=a.allocUnsafe(t)}function o(e){return e<=127?0:e>>5==6?2:e>>4==14?3:e>>3==30?4:e>>6==2?-1:-2}function s(e){var t=this.lastTotal-this.lastNeed,n=function(e,t,n){if(128!=(192&t[0]))return e.lastNeed=0,"";if(e.lastNeed>1&&t.length>1){if(128!=(192&t[1]))return e.lastNeed=1,"";if(e.lastNeed>2&&t.length>2&&128!=(192&t[2]))return e.lastNeed=2,""}}(this,e);return void 0!==n?n:this.lastNeed<=e.length?(e.copy(this.lastChar,t,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(e.copy(this.lastChar,t,0,e.length),void(this.lastNeed-=e.length))}function c(e,t){if((e.length-t)%2==0){var n=e.toString("utf16le",t);if(n){var a=n.charCodeAt(n.length-1);if(a>=55296&&a<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1],n.slice(0,-1)}return n}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=e[e.length-1],e.toString("utf16le",t,e.length-1)}function l(e){var t=e&&e.length?this.write(e):"";if(this.lastNeed){var n=this.lastTotal-this.lastNeed;return t+this.lastChar.toString("utf16le",0,n)}return t}function u(e,t){var n=(e.length-t)%3;return 0===n?e.toString("base64",t):(this.lastNeed=3-n,this.lastTotal=3,1===n?this.lastChar[0]=e[e.length-1]:(this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1]),e.toString("base64",t,e.length-n))}function p(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+this.lastChar.toString("base64",0,3-this.lastNeed):t}function f(e){return e.toString(this.encoding)}function d(e){return e&&e.length?this.write(e):""}t.s=i,i.prototype.write=function(e){if(0===e.length)return"";var t,n;if(this.lastNeed){if(void 0===(t=this.fillLast(e)))return"";n=this.lastNeed,this.lastNeed=0}else n=0;return n<e.length?t?t+this.text(e,n):this.text(e,n):t||""},i.prototype.end=function(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+"":t},i.prototype.text=function(e,t){var n=function(e,t,n){var a=t.length-1;if(a<n)return 0;var r=o(t[a]);if(r>=0)return r>0&&(e.lastNeed=r-1),r;if(--a<n||-2===r)return 0;if((r=o(t[a]))>=0)return r>0&&(e.lastNeed=r-2),r;if(--a<n||-2===r)return 0;if((r=o(t[a]))>=0)return r>0&&(2===r?r=0:e.lastNeed=r-3),r;return 0}(this,e,t);if(!this.lastNeed)return e.toString("utf8",t);this.lastTotal=n;var a=e.length-(n-this.lastNeed);return e.copy(this.lastChar,0,a),e.toString("utf8",t,a)},i.prototype.fillLast=function(e){if(this.lastNeed<=e.length)return e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length),this.lastNeed-=e.length}},8295:(e,t,n)=>{var a=n(2413);"disable"===process.env.READABLE_STREAM&&a?(e.exports=a,(t=e.exports=a.Readable).Readable=a.Readable,t.Writable=a.Writable,t.Duplex=a.Duplex,t.Transform=a.Transform,t.PassThrough=a.PassThrough,t.Stream=a):((t=e.exports=n(6246)).Stream=a||t,t.Readable=t,t.Writable=n(609),t.Duplex=n(5101),t.Transform=n(6889),t.PassThrough=n(7153))},2775:()=>{var e;!function(e){!function(t){var n="object"==typeof global?global:"object"==typeof self?self:"object"==typeof this?this:Function("return this;")(),a=r(e);function r(e,t){return function(n,a){"function"!=typeof e[n]&&Object.defineProperty(e,n,{configurable:!0,writable:!0,value:a}),t&&t(n,a)}}void 0===n.Reflect?n.Reflect=e:a=r(n.Reflect,a),function(e){var t=Object.prototype.hasOwnProperty,n="function"==typeof Symbol,a=n&&void 0!==Symbol.toPrimitive?Symbol.toPrimitive:"@@toPrimitive",r=n&&void 0!==Symbol.iterator?Symbol.iterator:"@@iterator",i="function"==typeof Object.create,o={__proto__:[]}instanceof Array,s=!i&&!o,c={create:i?function(){return ae(Object.create(null))}:o?function(){return ae({__proto__:null})}:function(){return ae({})},has:s?function(e,n){return t.call(e,n)}:function(e,t){return t in e},get:s?function(e,n){return t.call(e,n)?e[n]:void 0}:function(e,t){return e[t]}},l=Object.getPrototypeOf(Function),u="object"==typeof process&&process.env&&"true"===process.env.REFLECT_METADATA_USE_MAP_POLYFILL,p=u||"function"!=typeof Map||"function"!=typeof Map.prototype.entries?ee():Map,f=u||"function"!=typeof Set||"function"!=typeof Set.prototype.entries?te():Set,d=new(u||"function"!=typeof WeakMap?ne():WeakMap);function h(e,t,n,a){if(L(n)){if(!K(e))throw new TypeError;if(!G(t))throw new TypeError;return E(e,t)}if(!K(e))throw new TypeError;if(!M(t))throw new TypeError;if(!M(a)&&!L(a)&&!D(a))throw new TypeError;return D(a)&&(a=void 0),_(e,t,n=H(n),a)}function g(e,t){function n(n,a){if(!M(n))throw new TypeError;if(!L(a)&&!W(a))throw new TypeError;x(e,t,n,a)}return n}function m(e,t,n,a){if(!M(n))throw new TypeError;return L(a)||(a=H(a)),x(e,t,n,a)}function y(e,t,n){if(!M(t))throw new TypeError;return L(n)||(n=H(n)),A(e,t,n)}function v(e,t,n){if(!M(t))throw new TypeError;return L(n)||(n=H(n)),I(e,t,n)}function b(e,t,n){if(!M(t))throw new TypeError;return L(n)||(n=H(n)),R(e,t,n)}function P(e,t,n){if(!M(t))throw new TypeError;return L(n)||(n=H(n)),F(e,t,n)}function S(e,t){if(!M(e))throw new TypeError;return L(t)||(t=H(t)),w(e,t)}function T(e,t){if(!M(e))throw new TypeError;return L(t)||(t=H(t)),j(e,t)}function O(e,t,n){if(!M(t))throw new TypeError;L(n)||(n=H(n));var a=C(t,n,!1);if(L(a))return!1;if(!a.delete(e))return!1;if(a.size>0)return!0;var r=d.get(t);return r.delete(n),r.size>0||d.delete(t),!0}function E(e,t){for(var n=e.length-1;n>=0;--n){var a=(0,e[n])(t);if(!L(a)&&!D(a)){if(!G(a))throw new TypeError;t=a}}return t}function _(e,t,n,a){for(var r=e.length-1;r>=0;--r){var i=(0,e[r])(t,n,a);if(!L(i)&&!D(i)){if(!M(i))throw new TypeError;a=i}}return a}function C(e,t,n){var a=d.get(e);if(L(a)){if(!n)return;a=new p,d.set(e,a)}var r=a.get(t);if(L(r)){if(!n)return;r=new p,a.set(t,r)}return r}function A(e,t,n){if(I(e,t,n))return!0;var a=Z(t);return!D(a)&&A(e,a,n)}function I(e,t,n){var a=C(t,n,!1);return!L(a)&&B(a.has(e))}function R(e,t,n){if(I(e,t,n))return F(e,t,n);var a=Z(t);return D(a)?void 0:R(e,a,n)}function F(e,t,n){var a=C(t,n,!1);if(!L(a))return a.get(e)}function x(e,t,n,a){C(n,a,!0).set(e,t)}function w(e,t){var n=j(e,t),a=Z(e);if(null===a)return n;var r=w(a,t);if(r.length<=0)return n;if(n.length<=0)return r;for(var i=new f,o=[],s=0,c=n;s<c.length;s++){var l=c[s];i.has(l)||(i.add(l),o.push(l))}for(var u=0,p=r;u<p.length;u++){l=p[u];i.has(l)||(i.add(l),o.push(l))}return o}function j(e,t){var n=[],a=C(e,t,!1);if(L(a))return n;for(var r=J(a.keys()),i=0;;){var o=z(r);if(!o)return n.length=i,n;var s=X(o);try{n[i]=s}catch(e){try{Y(r)}finally{throw e}}i++}}function N(e){if(null===e)return 1;switch(typeof e){case"undefined":return 0;case"boolean":return 2;case"string":return 3;case"symbol":return 4;case"number":return 5;case"object":return null===e?1:6;default:return 6}}function L(e){return void 0===e}function D(e){return null===e}function V(e){return"symbol"==typeof e}function M(e){return"object"==typeof e?null!==e:"function"==typeof e}function k(e,t){switch(N(e)){case 0:case 1:case 2:case 3:case 4:case 5:return e}var n=3===t?"string":5===t?"number":"default",r=q(e,a);if(void 0!==r){var i=r.call(e,n);if(M(i))throw new TypeError;return i}return $(e,"default"===n?"number":n)}function $(e,t){if("string"===t){var n=e.toString;if(Q(n))if(!M(r=n.call(e)))return r;if(Q(a=e.valueOf))if(!M(r=a.call(e)))return r}else{var a;if(Q(a=e.valueOf))if(!M(r=a.call(e)))return r;var r,i=e.toString;if(Q(i))if(!M(r=i.call(e)))return r}throw new TypeError}function B(e){return!!e}function U(e){return""+e}function H(e){var t=k(e,3);return V(t)?t:U(t)}function K(e){return Array.isArray?Array.isArray(e):e instanceof Object?e instanceof Array:"[object Array]"===Object.prototype.toString.call(e)}function Q(e){return"function"==typeof e}function G(e){return"function"==typeof e}function W(e){switch(N(e)){case 3:case 4:return!0;default:return!1}}function q(e,t){var n=e[t];if(null!=n){if(!Q(n))throw new TypeError;return n}}function J(e){var t=q(e,r);if(!Q(t))throw new TypeError;var n=t.call(e);if(!M(n))throw new TypeError;return n}function X(e){return e.value}function z(e){var t=e.next();return!t.done&&t}function Y(e){var t=e.return;t&&t.call(e)}function Z(e){var t=Object.getPrototypeOf(e);if("function"!=typeof e||e===l)return t;if(t!==l)return t;var n=e.prototype,a=n&&Object.getPrototypeOf(n);if(null==a||a===Object.prototype)return t;var r=a.constructor;return"function"!=typeof r||r===e?t:r}function ee(){var e={},t=[],n=function(){function e(e,t,n){this._index=0,this._keys=e,this._values=t,this._selector=n}return e.prototype["@@iterator"]=function(){return this},e.prototype[r]=function(){return this},e.prototype.next=function(){var e=this._index;if(e>=0&&e<this._keys.length){var n=this._selector(this._keys[e],this._values[e]);return e+1>=this._keys.length?(this._index=-1,this._keys=t,this._values=t):this._index++,{value:n,done:!1}}return{value:void 0,done:!0}},e.prototype.throw=function(e){throw this._index>=0&&(this._index=-1,this._keys=t,this._values=t),e},e.prototype.return=function(e){return this._index>=0&&(this._index=-1,this._keys=t,this._values=t),{value:e,done:!0}},e}();return function(){function t(){this._keys=[],this._values=[],this._cacheKey=e,this._cacheIndex=-2}return Object.defineProperty(t.prototype,"size",{get:function(){return this._keys.length},enumerable:!0,configurable:!0}),t.prototype.has=function(e){return this._find(e,!1)>=0},t.prototype.get=function(e){var t=this._find(e,!1);return t>=0?this._values[t]:void 0},t.prototype.set=function(e,t){var n=this._find(e,!0);return this._values[n]=t,this},t.prototype.delete=function(t){var n=this._find(t,!1);if(n>=0){for(var a=this._keys.length,r=n+1;r<a;r++)this._keys[r-1]=this._keys[r],this._values[r-1]=this._values[r];return this._keys.length--,this._values.length--,t===this._cacheKey&&(this._cacheKey=e,this._cacheIndex=-2),!0}return!1},t.prototype.clear=function(){this._keys.length=0,this._values.length=0,this._cacheKey=e,this._cacheIndex=-2},t.prototype.keys=function(){return new n(this._keys,this._values,a)},t.prototype.values=function(){return new n(this._keys,this._values,i)},t.prototype.entries=function(){return new n(this._keys,this._values,o)},t.prototype["@@iterator"]=function(){return this.entries()},t.prototype[r]=function(){return this.entries()},t.prototype._find=function(e,t){return this._cacheKey!==e&&(this._cacheIndex=this._keys.indexOf(this._cacheKey=e)),this._cacheIndex<0&&t&&(this._cacheIndex=this._keys.length,this._keys.push(e),this._values.push(void 0)),this._cacheIndex},t}();function a(e,t){return e}function i(e,t){return t}function o(e,t){return[e,t]}}function te(){return function(){function e(){this._map=new p}return Object.defineProperty(e.prototype,"size",{get:function(){return this._map.size},enumerable:!0,configurable:!0}),e.prototype.has=function(e){return this._map.has(e)},e.prototype.add=function(e){return this._map.set(e,e),this},e.prototype.delete=function(e){return this._map.delete(e)},e.prototype.clear=function(){this._map.clear()},e.prototype.keys=function(){return this._map.keys()},e.prototype.values=function(){return this._map.values()},e.prototype.entries=function(){return this._map.entries()},e.prototype["@@iterator"]=function(){return this.keys()},e.prototype[r]=function(){return this.keys()},e}()}function ne(){var e=16,n=c.create(),a=r();return function(){function e(){this._key=r()}return e.prototype.has=function(e){var t=i(e,!1);return void 0!==t&&c.has(t,this._key)},e.prototype.get=function(e){var t=i(e,!1);return void 0!==t?c.get(t,this._key):void 0},e.prototype.set=function(e,t){return i(e,!0)[this._key]=t,this},e.prototype.delete=function(e){var t=i(e,!1);return void 0!==t&&delete t[this._key]},e.prototype.clear=function(){this._key=r()},e}();function r(){var e;do{e="@@WeakMap@@"+l()}while(c.has(n,e));return n[e]=!0,e}function i(e,n){if(!t.call(e,a)){if(!n)return;Object.defineProperty(e,a,{value:c.create()})}return e[a]}function o(e,t){for(var n=0;n<t;++n)e[n]=255*Math.random()|0;return e}function s(e){return"function"==typeof Uint8Array?"undefined"!=typeof crypto?crypto.getRandomValues(new Uint8Array(e)):"undefined"!=typeof msCrypto?msCrypto.getRandomValues(new Uint8Array(e)):o(new Uint8Array(e),e):o(new Array(e),e)}function l(){var t=s(e);t[6]=79&t[6]|64,t[8]=191&t[8]|128;for(var n="",a=0;a<e;++a){var r=t[a];4!==a&&6!==a&&8!==a||(n+="-"),r<16&&(n+="0"),n+=r.toString(16).toLowerCase()}return n}}function ae(e){return e.__=void 0,delete e.__,e}e("decorate",h),e("metadata",g),e("defineMetadata",m),e("hasMetadata",y),e("hasOwnMetadata",v),e("getMetadata",b),e("getOwnMetadata",P),e("getMetadataKeys",S),e("getOwnMetadataKeys",T),e("deleteMetadata",O)}(a)}()}(e||(e={}))},9948:e=>{var t="win32"===process.platform;function n(e,n){var a=e[n];return n>0&&("/"===a||t&&"\\"===a)}e.exports=function(e){var t=e.length-1;if(t<2)return e;for(;n(e,t);)t--;return e.substr(0,t+1)}},7174:e=>{"use strict";e.exports=function(e){var t=new e,n=t;return{get:function(){var a=t;return a.next?t=a.next:(t=new e,n=t),a.next=null,a},release:function(e){n.next=e,n=e}}}},1670:e=>{e.exports=function(e,t){var n,a,r,i=!0;Array.isArray(e)?(n=[],a=e.length):(r=Object.keys(e),n={},a=r.length);function o(e){function a(){t&&t(e,n),t=null}i?process.nextTick(a):a()}function s(e,t,r){n[e]=r,(0==--a||t)&&o(t)}a?r?r.forEach((function(t){e[t]((function(e,n){s(t,e,n)}))})):e.forEach((function(e,t){e((function(e,n){s(t,e,n)}))})):o(null);i=!1}},9871:(e,t,n)=>{!function(e){e.parser=function(e,t){return new r(e,t)},e.SAXParser=r,e.SAXStream=o,e.createStream=function(e,t){return new o(e,t)},e.MAX_BUFFER_LENGTH=65536;var t,a=["comment","sgmlDecl","textNode","tagName","doctype","procInstName","procInstBody","entity","attribName","attribValue","cdata","script"];function r(t,n){if(!(this instanceof r))return new r(t,n);var i=this;!function(e){for(var t=0,n=a.length;t<n;t++)e[a[t]]=""}(i),i.q=i.c="",i.bufferCheckPosition=e.MAX_BUFFER_LENGTH,i.opt=n||{},i.opt.lowercase=i.opt.lowercase||i.opt.lowercasetags,i.looseCase=i.opt.lowercase?"toLowerCase":"toUpperCase",i.tags=[],i.closed=i.closedRoot=i.sawRoot=!1,i.tag=i.error=null,i.strict=!!t,i.noscript=!(!t&&!i.opt.noscript),i.state=T.BEGIN,i.strictEntities=i.opt.strictEntities,i.ENTITIES=i.strictEntities?Object.create(e.XML_ENTITIES):Object.create(e.ENTITIES),i.attribList=[],i.opt.xmlns&&(i.ns=Object.create(l)),i.trackPosition=!1!==i.opt.position,i.trackPosition&&(i.position=i.line=i.column=0),E(i,"onready")}e.EVENTS=["text","processinginstruction","sgmldeclaration","doctype","comment","opentagstart","attribute","opentag","closetag","opencdata","cdata","closecdata","error","end","ready","script","opennamespace","closenamespace"],Object.create||(Object.create=function(e){function t(){}return t.prototype=e,new t}),Object.keys||(Object.keys=function(e){var t=[];for(var n in e)e.hasOwnProperty(n)&&t.push(n);return t}),r.prototype={end:function(){R(this)},write:function(t){var n=this;if(this.error)throw this.error;if(n.closed)return I(n,"Cannot write after close. Assign an onready handler.");if(null===t)return R(n);"object"==typeof t&&(t=t.toString());var r=0,i="";for(;i=M(t,r++),n.c=i,i;)switch(n.trackPosition&&(n.position++,"\n"===i?(n.line++,n.column=0):n.column++),n.state){case T.BEGIN:if(n.state=T.BEGIN_WHITESPACE,"\ufeff"===i)continue;V(n,i);continue;case T.BEGIN_WHITESPACE:V(n,i);continue;case T.TEXT:if(n.sawRoot&&!n.closedRoot){for(var o=r-1;i&&"<"!==i&&"&"!==i;)(i=M(t,r++))&&n.trackPosition&&(n.position++,"\n"===i?(n.line++,n.column=0):n.column++);n.textNode+=t.substring(o,r-1)}"<"!==i||n.sawRoot&&n.closedRoot&&!n.strict?(h(i)||n.sawRoot&&!n.closedRoot||F(n,"Text data outside of root node."),"&"===i?n.state=T.TEXT_ENTITY:n.textNode+=i):(n.state=T.OPEN_WAKA,n.startTagPosition=n.position);continue;case T.SCRIPT:"<"===i?n.state=T.SCRIPT_ENDING:n.script+=i;continue;case T.SCRIPT_ENDING:"/"===i?n.state=T.CLOSE_TAG:(n.script+="<"+i,n.state=T.SCRIPT);continue;case T.OPEN_WAKA:if("!"===i)n.state=T.SGML_DECL,n.sgmlDecl="";else if(h(i));else if(y(u,i))n.state=T.OPEN_TAG,n.tagName=i;else if("/"===i)n.state=T.CLOSE_TAG,n.tagName="";else if("?"===i)n.state=T.PROC_INST,n.procInstName=n.procInstBody="";else{if(F(n,"Unencoded <"),n.startTagPosition+1<n.position){var s=n.position-n.startTagPosition;i=new Array(s).join(" ")+i}n.textNode+="<"+i,n.state=T.TEXT}continue;case T.SGML_DECL:"[CDATA["===(n.sgmlDecl+i).toUpperCase()?(_(n,"onopencdata"),n.state=T.CDATA,n.sgmlDecl="",n.cdata=""):n.sgmlDecl+i==="--"?(n.state=T.COMMENT,n.comment="",n.sgmlDecl=""):"DOCTYPE"===(n.sgmlDecl+i).toUpperCase()?(n.state=T.DOCTYPE,(n.doctype||n.sawRoot)&&F(n,"Inappropriately located doctype declaration"),n.doctype="",n.sgmlDecl=""):">"===i?(_(n,"onsgmldeclaration",n.sgmlDecl),n.sgmlDecl="",n.state=T.TEXT):g(i)?(n.state=T.SGML_DECL_QUOTED,n.sgmlDecl+=i):n.sgmlDecl+=i;continue;case T.SGML_DECL_QUOTED:i===n.q&&(n.state=T.SGML_DECL,n.q=""),n.sgmlDecl+=i;continue;case T.DOCTYPE:">"===i?(n.state=T.TEXT,_(n,"ondoctype",n.doctype),n.doctype=!0):(n.doctype+=i,"["===i?n.state=T.DOCTYPE_DTD:g(i)&&(n.state=T.DOCTYPE_QUOTED,n.q=i));continue;case T.DOCTYPE_QUOTED:n.doctype+=i,i===n.q&&(n.q="",n.state=T.DOCTYPE);continue;case T.DOCTYPE_DTD:n.doctype+=i,"]"===i?n.state=T.DOCTYPE:g(i)&&(n.state=T.DOCTYPE_DTD_QUOTED,n.q=i);continue;case T.DOCTYPE_DTD_QUOTED:n.doctype+=i,i===n.q&&(n.state=T.DOCTYPE_DTD,n.q="");continue;case T.COMMENT:"-"===i?n.state=T.COMMENT_ENDING:n.comment+=i;continue;case T.COMMENT_ENDING:"-"===i?(n.state=T.COMMENT_ENDED,n.comment=A(n.opt,n.comment),n.comment&&_(n,"oncomment",n.comment),n.comment=""):(n.comment+="-"+i,n.state=T.COMMENT);continue;case T.COMMENT_ENDED:">"!==i?(F(n,"Malformed comment"),n.comment+="--"+i,n.state=T.COMMENT):n.state=T.TEXT;continue;case T.CDATA:"]"===i?n.state=T.CDATA_ENDING:n.cdata+=i;continue;case T.CDATA_ENDING:"]"===i?n.state=T.CDATA_ENDING_2:(n.cdata+="]"+i,n.state=T.CDATA);continue;case T.CDATA_ENDING_2:">"===i?(n.cdata&&_(n,"oncdata",n.cdata),_(n,"onclosecdata"),n.cdata="",n.state=T.TEXT):"]"===i?n.cdata+="]":(n.cdata+="]]"+i,n.state=T.CDATA);continue;case T.PROC_INST:"?"===i?n.state=T.PROC_INST_ENDING:h(i)?n.state=T.PROC_INST_BODY:n.procInstName+=i;continue;case T.PROC_INST_BODY:if(!n.procInstBody&&h(i))continue;"?"===i?n.state=T.PROC_INST_ENDING:n.procInstBody+=i;continue;case T.PROC_INST_ENDING:">"===i?(_(n,"onprocessinginstruction",{name:n.procInstName,body:n.procInstBody}),n.procInstName=n.procInstBody="",n.state=T.TEXT):(n.procInstBody+="?"+i,n.state=T.PROC_INST_BODY);continue;case T.OPEN_TAG:y(p,i)?n.tagName+=i:(x(n),">"===i?N(n):"/"===i?n.state=T.OPEN_TAG_SLASH:(h(i)||F(n,"Invalid character in tag name"),n.state=T.ATTRIB));continue;case T.OPEN_TAG_SLASH:">"===i?(N(n,!0),L(n)):(F(n,"Forward-slash in opening tag not followed by >"),n.state=T.ATTRIB);continue;case T.ATTRIB:if(h(i))continue;">"===i?N(n):"/"===i?n.state=T.OPEN_TAG_SLASH:y(u,i)?(n.attribName=i,n.attribValue="",n.state=T.ATTRIB_NAME):F(n,"Invalid attribute name");continue;case T.ATTRIB_NAME:"="===i?n.state=T.ATTRIB_VALUE:">"===i?(F(n,"Attribute without value"),n.attribValue=n.attribName,j(n),N(n)):h(i)?n.state=T.ATTRIB_NAME_SAW_WHITE:y(p,i)?n.attribName+=i:F(n,"Invalid attribute name");continue;case T.ATTRIB_NAME_SAW_WHITE:if("="===i)n.state=T.ATTRIB_VALUE;else{if(h(i))continue;F(n,"Attribute without value"),n.tag.attributes[n.attribName]="",n.attribValue="",_(n,"onattribute",{name:n.attribName,value:""}),n.attribName="",">"===i?N(n):y(u,i)?(n.attribName=i,n.state=T.ATTRIB_NAME):(F(n,"Invalid attribute name"),n.state=T.ATTRIB)}continue;case T.ATTRIB_VALUE:if(h(i))continue;g(i)?(n.q=i,n.state=T.ATTRIB_VALUE_QUOTED):(F(n,"Unquoted attribute value"),n.state=T.ATTRIB_VALUE_UNQUOTED,n.attribValue=i);continue;case T.ATTRIB_VALUE_QUOTED:if(i!==n.q){"&"===i?n.state=T.ATTRIB_VALUE_ENTITY_Q:n.attribValue+=i;continue}j(n),n.q="",n.state=T.ATTRIB_VALUE_CLOSED;continue;case T.ATTRIB_VALUE_CLOSED:h(i)?n.state=T.ATTRIB:">"===i?N(n):"/"===i?n.state=T.OPEN_TAG_SLASH:y(u,i)?(F(n,"No whitespace between attributes"),n.attribName=i,n.attribValue="",n.state=T.ATTRIB_NAME):F(n,"Invalid attribute name");continue;case T.ATTRIB_VALUE_UNQUOTED:if(!m(i)){"&"===i?n.state=T.ATTRIB_VALUE_ENTITY_U:n.attribValue+=i;continue}j(n),">"===i?N(n):n.state=T.ATTRIB;continue;case T.CLOSE_TAG:if(n.tagName)">"===i?L(n):y(p,i)?n.tagName+=i:n.script?(n.script+="</"+n.tagName,n.tagName="",n.state=T.SCRIPT):(h(i)||F(n,"Invalid tagname in closing tag"),n.state=T.CLOSE_TAG_SAW_WHITE);else{if(h(i))continue;v(u,i)?n.script?(n.script+="</"+i,n.state=T.SCRIPT):F(n,"Invalid tagname in closing tag."):n.tagName=i}continue;case T.CLOSE_TAG_SAW_WHITE:if(h(i))continue;">"===i?L(n):F(n,"Invalid characters in closing tag");continue;case T.TEXT_ENTITY:case T.ATTRIB_VALUE_ENTITY_Q:case T.ATTRIB_VALUE_ENTITY_U:var c,l;switch(n.state){case T.TEXT_ENTITY:c=T.TEXT,l="textNode";break;case T.ATTRIB_VALUE_ENTITY_Q:c=T.ATTRIB_VALUE_QUOTED,l="attribValue";break;case T.ATTRIB_VALUE_ENTITY_U:c=T.ATTRIB_VALUE_UNQUOTED,l="attribValue"}";"===i?(n[l]+=D(n),n.entity="",n.state=c):y(n.entity.length?d:f,i)?n.entity+=i:(F(n,"Invalid character in entity name"),n[l]+="&"+n.entity+i,n.entity="",n.state=c);continue;default:throw new Error(n,"Unknown state: "+n.state)}n.position>=n.bufferCheckPosition&&function(t){for(var n=Math.max(e.MAX_BUFFER_LENGTH,10),r=0,i=0,o=a.length;i<o;i++){var s=t[a[i]].length;if(s>n)switch(a[i]){case"textNode":C(t);break;case"cdata":_(t,"oncdata",t.cdata),t.cdata="";break;case"script":_(t,"onscript",t.script),t.script="";break;default:I(t,"Max buffer length exceeded: "+a[i])}r=Math.max(r,s)}var c=e.MAX_BUFFER_LENGTH-r;t.bufferCheckPosition=c+t.position}(n);return n},resume:function(){return this.error=null,this},close:function(){return this.write(null)},flush:function(){var e;C(e=this),""!==e.cdata&&(_(e,"oncdata",e.cdata),e.cdata=""),""!==e.script&&(_(e,"onscript",e.script),e.script="")}};try{t=n(2413).Stream}catch(e){t=function(){}}var i=e.EVENTS.filter((function(e){return"error"!==e&&"end"!==e}));function o(e,n){if(!(this instanceof o))return new o(e,n);t.apply(this),this._parser=new r(e,n),this.writable=!0,this.readable=!0;var a=this;this._parser.onend=function(){a.emit("end")},this._parser.onerror=function(e){a.emit("error",e),a._parser.error=null},this._decoder=null,i.forEach((function(e){Object.defineProperty(a,"on"+e,{get:function(){return a._parser["on"+e]},set:function(t){if(!t)return a.removeAllListeners(e),a._parser["on"+e]=t,t;a.on(e,t)},enumerable:!0,configurable:!1})}))}o.prototype=Object.create(t.prototype,{constructor:{value:o}}),o.prototype.write=function(e){if("function"==typeof Buffer&&"function"==typeof Buffer.isBuffer&&Buffer.isBuffer(e)){if(!this._decoder){var t=n(4304).StringDecoder;this._decoder=new t("utf8")}e=this._decoder.write(e)}return this._parser.write(e.toString()),this.emit("data",e),!0},o.prototype.end=function(e){return e&&e.length&&this.write(e),this._parser.end(),!0},o.prototype.on=function(e,n){var a=this;return a._parser["on"+e]||-1===i.indexOf(e)||(a._parser["on"+e]=function(){var t=1===arguments.length?[arguments[0]]:Array.apply(null,arguments);t.splice(0,0,e),a.emit.apply(a,t)}),t.prototype.on.call(a,e,n)};var s="http://www.w3.org/XML/1998/namespace",c="http://www.w3.org/2000/xmlns/",l={xml:s,xmlns:c},u=/[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,p=/[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/,f=/[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,d=/[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;function h(e){return" "===e||"\n"===e||"\r"===e||"\t"===e}function g(e){return'"'===e||"'"===e}function m(e){return">"===e||h(e)}function y(e,t){return e.test(t)}function v(e,t){return!y(e,t)}var b,P,S,T=0;for(var O in e.STATE={BEGIN:T++,BEGIN_WHITESPACE:T++,TEXT:T++,TEXT_ENTITY:T++,OPEN_WAKA:T++,SGML_DECL:T++,SGML_DECL_QUOTED:T++,DOCTYPE:T++,DOCTYPE_QUOTED:T++,DOCTYPE_DTD:T++,DOCTYPE_DTD_QUOTED:T++,COMMENT_STARTING:T++,COMMENT:T++,COMMENT_ENDING:T++,COMMENT_ENDED:T++,CDATA:T++,CDATA_ENDING:T++,CDATA_ENDING_2:T++,PROC_INST:T++,PROC_INST_BODY:T++,PROC_INST_ENDING:T++,OPEN_TAG:T++,OPEN_TAG_SLASH:T++,ATTRIB:T++,ATTRIB_NAME:T++,ATTRIB_NAME_SAW_WHITE:T++,ATTRIB_VALUE:T++,ATTRIB_VALUE_QUOTED:T++,ATTRIB_VALUE_CLOSED:T++,ATTRIB_VALUE_UNQUOTED:T++,ATTRIB_VALUE_ENTITY_Q:T++,ATTRIB_VALUE_ENTITY_U:T++,CLOSE_TAG:T++,CLOSE_TAG_SAW_WHITE:T++,SCRIPT:T++,SCRIPT_ENDING:T++},e.XML_ENTITIES={amp:"&",gt:">",lt:"<",quot:'"',apos:"'"},e.ENTITIES={amp:"&",gt:">",lt:"<",quot:'"',apos:"'",AElig:198,Aacute:193,Acirc:194,Agrave:192,Aring:197,Atilde:195,Auml:196,Ccedil:199,ETH:208,Eacute:201,Ecirc:202,Egrave:200,Euml:203,Iacute:205,Icirc:206,Igrave:204,Iuml:207,Ntilde:209,Oacute:211,Ocirc:212,Ograve:210,Oslash:216,Otilde:213,Ouml:214,THORN:222,Uacute:218,Ucirc:219,Ugrave:217,Uuml:220,Yacute:221,aacute:225,acirc:226,aelig:230,agrave:224,aring:229,atilde:227,auml:228,ccedil:231,eacute:233,ecirc:234,egrave:232,eth:240,euml:235,iacute:237,icirc:238,igrave:236,iuml:239,ntilde:241,oacute:243,ocirc:244,ograve:242,oslash:248,otilde:245,ouml:246,szlig:223,thorn:254,uacute:250,ucirc:251,ugrave:249,uuml:252,yacute:253,yuml:255,copy:169,reg:174,nbsp:160,iexcl:161,cent:162,pound:163,curren:164,yen:165,brvbar:166,sect:167,uml:168,ordf:170,laquo:171,not:172,shy:173,macr:175,deg:176,plusmn:177,sup1:185,sup2:178,sup3:179,acute:180,micro:181,para:182,middot:183,cedil:184,ordm:186,raquo:187,frac14:188,frac12:189,frac34:190,iquest:191,times:215,divide:247,OElig:338,oelig:339,Scaron:352,scaron:353,Yuml:376,fnof:402,circ:710,tilde:732,Alpha:913,Beta:914,Gamma:915,Delta:916,Epsilon:917,Zeta:918,Eta:919,Theta:920,Iota:921,Kappa:922,Lambda:923,Mu:924,Nu:925,Xi:926,Omicron:927,Pi:928,Rho:929,Sigma:931,Tau:932,Upsilon:933,Phi:934,Chi:935,Psi:936,Omega:937,alpha:945,beta:946,gamma:947,delta:948,epsilon:949,zeta:950,eta:951,theta:952,iota:953,kappa:954,lambda:955,mu:956,nu:957,xi:958,omicron:959,pi:960,rho:961,sigmaf:962,sigma:963,tau:964,upsilon:965,phi:966,chi:967,psi:968,omega:969,thetasym:977,upsih:978,piv:982,ensp:8194,emsp:8195,thinsp:8201,zwnj:8204,zwj:8205,lrm:8206,rlm:8207,ndash:8211,mdash:8212,lsquo:8216,rsquo:8217,sbquo:8218,ldquo:8220,rdquo:8221,bdquo:8222,dagger:8224,Dagger:8225,bull:8226,hellip:8230,permil:8240,prime:8242,Prime:8243,lsaquo:8249,rsaquo:8250,oline:8254,frasl:8260,euro:8364,image:8465,weierp:8472,real:8476,trade:8482,alefsym:8501,larr:8592,uarr:8593,rarr:8594,darr:8595,harr:8596,crarr:8629,lArr:8656,uArr:8657,rArr:8658,dArr:8659,hArr:8660,forall:8704,part:8706,exist:8707,empty:8709,nabla:8711,isin:8712,notin:8713,ni:8715,prod:8719,sum:8721,minus:8722,lowast:8727,radic:8730,prop:8733,infin:8734,ang:8736,and:8743,or:8744,cap:8745,cup:8746,int:8747,there4:8756,sim:8764,cong:8773,asymp:8776,ne:8800,equiv:8801,le:8804,ge:8805,sub:8834,sup:8835,nsub:8836,sube:8838,supe:8839,oplus:8853,otimes:8855,perp:8869,sdot:8901,lceil:8968,rceil:8969,lfloor:8970,rfloor:8971,lang:9001,rang:9002,loz:9674,spades:9824,clubs:9827,hearts:9829,diams:9830},Object.keys(e.ENTITIES).forEach((function(t){var n=e.ENTITIES[t],a="number"==typeof n?String.fromCharCode(n):n;e.ENTITIES[t]=a})),e.STATE)e.STATE[e.STATE[O]]=O;function E(e,t,n){e[t]&&e[t](n)}function _(e,t,n){e.textNode&&C(e),E(e,t,n)}function C(e){e.textNode=A(e.opt,e.textNode),e.textNode&&E(e,"ontext",e.textNode),e.textNode=""}function A(e,t){return e.trim&&(t=t.trim()),e.normalize&&(t=t.replace(/\s+/g," ")),t}function I(e,t){return C(e),e.trackPosition&&(t+="\nLine: "+e.line+"\nColumn: "+e.column+"\nChar: "+e.c),t=new Error(t),e.error=t,E(e,"onerror",t),e}function R(e){return e.sawRoot&&!e.closedRoot&&F(e,"Unclosed root tag"),e.state!==T.BEGIN&&e.state!==T.BEGIN_WHITESPACE&&e.state!==T.TEXT&&I(e,"Unexpected end"),C(e),e.c="",e.closed=!0,E(e,"onend"),r.call(e,e.strict,e.opt),e}function F(e,t){if("object"!=typeof e||!(e instanceof r))throw new Error("bad call to strictFail");e.strict&&I(e,t)}function x(e){e.strict||(e.tagName=e.tagName[e.looseCase]());var t=e.tags[e.tags.length-1]||e,n=e.tag={name:e.tagName,attributes:{}};e.opt.xmlns&&(n.ns=t.ns),e.attribList.length=0,_(e,"onopentagstart",n)}function w(e,t){var n=e.indexOf(":")<0?["",e]:e.split(":"),a=n[0],r=n[1];return t&&"xmlns"===e&&(a="xmlns",r=""),{prefix:a,local:r}}function j(e){if(e.strict||(e.attribName=e.attribName[e.looseCase]()),-1!==e.attribList.indexOf(e.attribName)||e.tag.attributes.hasOwnProperty(e.attribName))e.attribName=e.attribValue="";else{if(e.opt.xmlns){var t=w(e.attribName,!0),n=t.prefix,a=t.local;if("xmlns"===n)if("xml"===a&&e.attribValue!==s)F(e,"xml: prefix must be bound to "+s+"\nActual: "+e.attribValue);else if("xmlns"===a&&e.attribValue!==c)F(e,"xmlns: prefix must be bound to "+c+"\nActual: "+e.attribValue);else{var r=e.tag,i=e.tags[e.tags.length-1]||e;r.ns===i.ns&&(r.ns=Object.create(i.ns)),r.ns[a]=e.attribValue}e.attribList.push([e.attribName,e.attribValue])}else e.tag.attributes[e.attribName]=e.attribValue,_(e,"onattribute",{name:e.attribName,value:e.attribValue});e.attribName=e.attribValue=""}}function N(e,t){if(e.opt.xmlns){var n=e.tag,a=w(e.tagName);n.prefix=a.prefix,n.local=a.local,n.uri=n.ns[a.prefix]||"",n.prefix&&!n.uri&&(F(e,"Unbound namespace prefix: "+JSON.stringify(e.tagName)),n.uri=a.prefix);var r=e.tags[e.tags.length-1]||e;n.ns&&r.ns!==n.ns&&Object.keys(n.ns).forEach((function(t){_(e,"onopennamespace",{prefix:t,uri:n.ns[t]})}));for(var i=0,o=e.attribList.length;i<o;i++){var s=e.attribList[i],c=s[0],l=s[1],u=w(c,!0),p=u.prefix,f=u.local,d=""===p?"":n.ns[p]||"",h={name:c,value:l,prefix:p,local:f,uri:d};p&&"xmlns"!==p&&!d&&(F(e,"Unbound namespace prefix: "+JSON.stringify(p)),h.uri=p),e.tag.attributes[c]=h,_(e,"onattribute",h)}e.attribList.length=0}e.tag.isSelfClosing=!!t,e.sawRoot=!0,e.tags.push(e.tag),_(e,"onopentag",e.tag),t||(e.noscript||"script"!==e.tagName.toLowerCase()?e.state=T.TEXT:e.state=T.SCRIPT,e.tag=null,e.tagName=""),e.attribName=e.attribValue="",e.attribList.length=0}function L(e){if(!e.tagName)return F(e,"Weird empty close tag."),e.textNode+="</>",void(e.state=T.TEXT);if(e.script){if("script"!==e.tagName)return e.script+="</"+e.tagName+">",e.tagName="",void(e.state=T.SCRIPT);_(e,"onscript",e.script),e.script=""}var t=e.tags.length,n=e.tagName;e.strict||(n=n[e.looseCase]());for(var a=n;t--;){if(e.tags[t].name===a)break;F(e,"Unexpected close tag")}if(t<0)return F(e,"Unmatched closing tag: "+e.tagName),e.textNode+="</"+e.tagName+">",void(e.state=T.TEXT);e.tagName=n;for(var r=e.tags.length;r-- >t;){var i=e.tag=e.tags.pop();e.tagName=e.tag.name,_(e,"onclosetag",e.tagName);var o={};for(var s in i.ns)o[s]=i.ns[s];var c=e.tags[e.tags.length-1]||e;e.opt.xmlns&&i.ns!==c.ns&&Object.keys(i.ns).forEach((function(t){var n=i.ns[t];_(e,"onclosenamespace",{prefix:t,uri:n})}))}0===t&&(e.closedRoot=!0),e.tagName=e.attribValue=e.attribName="",e.attribList.length=0,e.state=T.TEXT}function D(e){var t,n=e.entity,a=n.toLowerCase(),r="";return e.ENTITIES[n]?e.ENTITIES[n]:e.ENTITIES[a]?e.ENTITIES[a]:("#"===(n=a).charAt(0)&&("x"===n.charAt(1)?(n=n.slice(2),r=(t=parseInt(n,16)).toString(16)):(n=n.slice(1),r=(t=parseInt(n,10)).toString(10))),n=n.replace(/^0+/,""),isNaN(t)||r.toLowerCase()!==n?(F(e,"Invalid character entity"),"&"+e.entity+";"):String.fromCodePoint(t))}function V(e,t){"<"===t?(e.state=T.OPEN_WAKA,e.startTagPosition=e.position):h(t)||(F(e,"Non-whitespace before first tag."),e.textNode=t,e.state=T.TEXT)}function M(e,t){var n="";return t<e.length&&(n=e.charAt(t)),n}T=e.STATE,String.fromCodePoint||(b=String.fromCharCode,P=Math.floor,S=function(){var e,t,n=16384,a=[],r=-1,i=arguments.length;if(!i)return"";for(var o="";++r<i;){var s=Number(arguments[r]);if(!isFinite(s)||s<0||s>1114111||P(s)!==s)throw RangeError("Invalid code point: "+s);s<=65535?a.push(s):(e=55296+((s-=65536)>>10),t=s%1024+56320,a.push(e,t)),(r+1===i||a.length>n)&&(o+=b.apply(null,a),a.length=0)}return o},Object.defineProperty?Object.defineProperty(String,"fromCodePoint",{value:S,configurable:!0,writable:!0}):String.fromCodePoint=S)}(t)},9764:e=>{"use strict";e.exports=e=>{const t=/^\\\\\?\\/.test(e),n=/[^\u0000-\u0080]+/.test(e);return t||n?e:e.replace(/\\/g,"/")}},6627:(e,t,n)=>{"use strict";const a=n(3253);e.exports=e=>{if(!Buffer.isBuffer(e))throw new TypeError("Expected a Buffer, got "+typeof e);return 239===e[0]&&187===e[1]&&191===e[2]&&a(e)?e.slice(3):e}},8525:(e,t,n)=>{"use strict";var a=n(2937),r=n(6635);e.exports=function(){return a({chunkLength:3},(function(e,t,n,a){e?a(e):a(null,r(t))}))}},6635:(e,t,n)=>{"use strict";var a=n(3253);e.exports=function(e){return"string"==typeof e&&65279===e.charCodeAt(0)?e.slice(1):Buffer.isBuffer(e)&&a(e)&&239===e[0]&&187===e[1]&&191===e[2]?e.slice(3):e}},3611:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=["Makefile","Rakefile","ada","adb","ads","applescript","as","ascx","asm","asmx","asp","aspx","atom","bas","bash","bashrc","bat","bbcolors","bdsgroup","bdsproj","bib","bowerrc","c","cbl","cc","cfc","cfg","cfm","cfml","cgi","clj","cls","cmake","cmd","cnf","cob","coffee","coffeekup","conf","cpp","cpt","cpy","crt","cs","csh","cson","csr","css","csslintrc","csv","ctl","curlrc","cxx","dart","dfm","diff","dof","dpk","dproj","dtd","eco","editorconfig","ejs","el","emacs","eml","ent","erb","erl","eslintignore","eslintrc","ex","exs","f","f03","f77","f90","f95","fish","for","fpp","frm","ftn","gemrc","gitattributes","gitconfig","gitignore","gitkeep","gitmodules","go","gpp","gradle","groovy","groupproj","grunit","gtmpl","gvimrc","h","haml","hbs","hgignore","hh","hpp","hrl","hs","hta","htaccess","htc","htm","html","htpasswd","hxx","iced","inc","ini","ino","int","irbrc","itcl","itermcolors","itk","jade","java","jhtm","jhtml","js","jscsrc","jshintignore","jshintrc","json","json5","jsonld","jsp","jspx","jsx","ksh","less","lhs","lisp","log","ls","lsp","lua","m","mak","map","markdown","master","md","mdown","mdwn","mdx","metadata","mht","mhtml","mjs","mk","mkd","mkdn","mkdown","ml","mli","mm","mxml","nfm","nfo","njk","noon","npmignore","npmrc","nvmrc","ops","pas","pasm","patch","pbxproj","pch","pem","pg","php","php3","php4","php5","phpt","phtml","pir","pl","pm","pmc","pod","pot","properties","props","pt","pug","py","r","rake","rb","rdoc","rdoc_options","resx","rhtml","rjs","rlib","rmd","ron","rs","rss","rst","rtf","rvmrc","rxml","s","sass","scala","scm","scss","seestyle","sh","shtml","sls","spec","sql","sqlite","ss","sss","st","strings","sty","styl","stylus","sub","sublime-build","sublime-commands","sublime-completions","sublime-keymap","sublime-macro","sublime-menu","sublime-project","sublime-settings","sublime-workspace","sv","svc","svg","t","tcl","tcsh","terminal","tex","text","textile","tg","tmLanguage","tmTheme","tmpl","tpl","ts","tsv","tsx","tt","tt2","ttml","txt","v","vb","vbs","vh","vhd","vhdl","vim","viminfo","vimrc","vue","webapp","wxml","wxss","x-php","xht","xhtml","xml","xs","xsd","xsl","xslt","yaml","yml","zsh","zshrc"]},5858:function(e,t){!function(e){"use strict";function t(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];if(t.length>1){t[0]=t[0].slice(0,-1);for(var a=t.length-1,r=1;r<a;++r)t[r]=t[r].slice(1,-1);return t[a]=t[a].slice(1),t.join("")}return t[0]}function n(e){return"(?:"+e+")"}function a(e){return void 0===e?"undefined":null===e?"null":Object.prototype.toString.call(e).split(" ").pop().split("]").shift().toLowerCase()}function r(e){return e.toUpperCase()}function i(e){return null!=e?e instanceof Array?e:"number"!=typeof e.length||e.split||e.setInterval||e.call?[e]:Array.prototype.slice.call(e):[]}function o(e,t){var n=e;if(t)for(var a in t)n[a]=t[a];return n}function s(e){var a="[A-Za-z]",r="[0-9]",i=t(r,"[A-Fa-f]"),o=n(n("%[EFef]"+i+"%"+i+i+"%"+i+i)+"|"+n("%[89A-Fa-f]"+i+"%"+i+i)+"|"+n("%"+i+i)),s="[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",c=t("[\\:\\/\\?\\#\\[\\]\\@]",s),l=e?"[\\uE000-\\uF8FF]":"[]",u=t(a,r,"[\\-\\.\\_\\~]",e?"[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]":"[]"),p=n(a+t(a,r,"[\\+\\-\\.]")+"*"),f=n(n(o+"|"+t(u,s,"[\\:]"))+"*"),d=(n(n("25[0-5]")+"|"+n("2[0-4]"+r)+"|"+n("1"+r+r)+"|"+n("[1-9]"+r)+"|"+r),n(n("25[0-5]")+"|"+n("2[0-4]"+r)+"|"+n("1"+r+r)+"|"+n("0?[1-9]"+r)+"|0?0?"+r)),h=n(d+"\\."+d+"\\."+d+"\\."+d),g=n(i+"{1,4}"),m=n(n(g+"\\:"+g)+"|"+h),y=n(n(g+"\\:")+"{6}"+m),v=n("\\:\\:"+n(g+"\\:")+"{5}"+m),b=n(n(g)+"?\\:\\:"+n(g+"\\:")+"{4}"+m),P=n(n(n(g+"\\:")+"{0,1}"+g)+"?\\:\\:"+n(g+"\\:")+"{3}"+m),S=n(n(n(g+"\\:")+"{0,2}"+g)+"?\\:\\:"+n(g+"\\:")+"{2}"+m),T=n(n(n(g+"\\:")+"{0,3}"+g)+"?\\:\\:"+g+"\\:"+m),O=n(n(n(g+"\\:")+"{0,4}"+g)+"?\\:\\:"+m),E=n(n(n(g+"\\:")+"{0,5}"+g)+"?\\:\\:"+g),_=n(n(n(g+"\\:")+"{0,6}"+g)+"?\\:\\:"),C=n([y,v,b,P,S,T,O,E,_].join("|")),A=n(n(u+"|"+o)+"+"),I=(n(C+"\\%25"+A),n(C+n("\\%25|\\%(?!"+i+"{2})")+A)),R=n("[vV]"+i+"+\\."+t(u,s,"[\\:]")+"+"),F=n("\\["+n(I+"|"+C+"|"+R)+"\\]"),x=n(n(o+"|"+t(u,s))+"*"),w=n(F+"|"+h+"(?!"+x+")|"+x),j=n(r+"*"),N=n(n(f+"@")+"?"+w+n("\\:"+j)+"?"),L=n(o+"|"+t(u,s,"[\\:\\@]")),D=n(L+"*"),V=n(L+"+"),M=n(n(o+"|"+t(u,s,"[\\@]"))+"+"),k=n(n("\\/"+D)+"*"),$=n("\\/"+n(V+k)+"?"),B=n(M+k),U=n(V+k),H="(?!"+L+")",K=(n(k+"|"+$+"|"+B+"|"+U+"|"+H),n(n(L+"|"+t("[\\/\\?]",l))+"*")),Q=n(n(L+"|[\\/\\?]")+"*"),G=n(n("\\/\\/"+N+k)+"|"+$+"|"+U+"|"+H),W=n(p+"\\:"+G+n("\\?"+K)+"?"+n("\\#"+Q)+"?"),q=n(n("\\/\\/"+N+k)+"|"+$+"|"+B+"|"+H),J=n(q+n("\\?"+K)+"?"+n("\\#"+Q)+"?");return n(W+"|"+J),n(p+"\\:"+G+n("\\?"+K)+"?"),n(n("\\/\\/("+n("("+f+")@")+"?("+w+")"+n("\\:("+j+")")+"?)")+"?("+k+"|"+$+"|"+U+"|"+H+")"),n("\\?("+K+")"),n("\\#("+Q+")"),n(n("\\/\\/("+n("("+f+")@")+"?("+w+")"+n("\\:("+j+")")+"?)")+"?("+k+"|"+$+"|"+B+"|"+H+")"),n("\\?("+K+")"),n("\\#("+Q+")"),n(n("\\/\\/("+n("("+f+")@")+"?("+w+")"+n("\\:("+j+")")+"?)")+"?("+k+"|"+$+"|"+U+"|"+H+")"),n("\\?("+K+")"),n("\\#("+Q+")"),n("("+f+")@"),n("\\:("+j+")"),{NOT_SCHEME:new RegExp(t("[^]",a,r,"[\\+\\-\\.]"),"g"),NOT_USERINFO:new RegExp(t("[^\\%\\:]",u,s),"g"),NOT_HOST:new RegExp(t("[^\\%\\[\\]\\:]",u,s),"g"),NOT_PATH:new RegExp(t("[^\\%\\/\\:\\@]",u,s),"g"),NOT_PATH_NOSCHEME:new RegExp(t("[^\\%\\/\\@]",u,s),"g"),NOT_QUERY:new RegExp(t("[^\\%]",u,s,"[\\:\\@\\/\\?]",l),"g"),NOT_FRAGMENT:new RegExp(t("[^\\%]",u,s,"[\\:\\@\\/\\?]"),"g"),ESCAPE:new RegExp(t("[^]",u,s),"g"),UNRESERVED:new RegExp(u,"g"),OTHER_CHARS:new RegExp(t("[^\\%]",u,c),"g"),PCT_ENCODED:new RegExp(o,"g"),IPV4ADDRESS:new RegExp("^("+h+")$"),IPV6ADDRESS:new RegExp("^\\[?("+C+")"+n(n("\\%25|\\%(?!"+i+"{2})")+"("+A+")")+"?\\]?$")}}var c=s(!1),l=s(!0),u=function(){function e(e,t){var n=[],a=!0,r=!1,i=void 0;try{for(var o,s=e[Symbol.iterator]();!(a=(o=s.next()).done)&&(n.push(o.value),!t||n.length!==t);a=!0);}catch(e){r=!0,i=e}finally{try{!a&&s.return&&s.return()}finally{if(r)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),p=function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)},f=2147483647,d=36,h=1,g=26,m=38,y=700,v=72,b=128,P="-",S=/^xn--/,T=/[^\0-\x7E]/,O=/[\x2E\u3002\uFF0E\uFF61]/g,E={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},_=d-h,C=Math.floor,A=String.fromCharCode;function I(e){throw new RangeError(E[e])}function R(e,t){for(var n=[],a=e.length;a--;)n[a]=t(e[a]);return n}function F(e,t){var n=e.split("@"),a="";return n.length>1&&(a=n[0]+"@",e=n[1]),a+R((e=e.replace(O,".")).split("."),t).join(".")}function x(e){for(var t=[],n=0,a=e.length;n<a;){var r=e.charCodeAt(n++);if(r>=55296&&r<=56319&&n<a){var i=e.charCodeAt(n++);56320==(64512&i)?t.push(((1023&r)<<10)+(1023&i)+65536):(t.push(r),n--)}else t.push(r)}return t}var w=function(e){return e-48<10?e-22:e-65<26?e-65:e-97<26?e-97:d},j=function(e,t){return e+22+75*(e<26)-((0!=t)<<5)},N=function(e,t,n){var a=0;for(e=n?C(e/y):e>>1,e+=C(e/t);e>_*g>>1;a+=d)e=C(e/_);return C(a+(_+1)*e/(e+m))},L=function(e){var t=[],n=e.length,a=0,r=b,i=v,o=e.lastIndexOf(P);o<0&&(o=0);for(var s=0;s<o;++s)e.charCodeAt(s)>=128&&I("not-basic"),t.push(e.charCodeAt(s));for(var c=o>0?o+1:0;c<n;){for(var l=a,u=1,p=d;;p+=d){c>=n&&I("invalid-input");var m=w(e.charCodeAt(c++));(m>=d||m>C((f-a)/u))&&I("overflow"),a+=m*u;var y=p<=i?h:p>=i+g?g:p-i;if(m<y)break;var S=d-y;u>C(f/S)&&I("overflow"),u*=S}var T=t.length+1;i=N(a-l,T,0==l),C(a/T)>f-r&&I("overflow"),r+=C(a/T),a%=T,t.splice(a++,0,r)}return String.fromCodePoint.apply(String,t)},D=function(e){var t=[],n=(e=x(e)).length,a=b,r=0,i=v,o=!0,s=!1,c=void 0;try{for(var l,u=e[Symbol.iterator]();!(o=(l=u.next()).done);o=!0){var p=l.value;p<128&&t.push(A(p))}}catch(e){s=!0,c=e}finally{try{!o&&u.return&&u.return()}finally{if(s)throw c}}var m=t.length,y=m;for(m&&t.push(P);y<n;){var S=f,T=!0,O=!1,E=void 0;try{for(var _,R=e[Symbol.iterator]();!(T=(_=R.next()).done);T=!0){var F=_.value;F>=a&&F<S&&(S=F)}}catch(e){O=!0,E=e}finally{try{!T&&R.return&&R.return()}finally{if(O)throw E}}var w=y+1;S-a>C((f-r)/w)&&I("overflow"),r+=(S-a)*w,a=S;var L=!0,D=!1,V=void 0;try{for(var M,k=e[Symbol.iterator]();!(L=(M=k.next()).done);L=!0){var $=M.value;if($<a&&++r>f&&I("overflow"),$==a){for(var B=r,U=d;;U+=d){var H=U<=i?h:U>=i+g?g:U-i;if(B<H)break;var K=B-H,Q=d-H;t.push(A(j(H+K%Q,0))),B=C(K/Q)}t.push(A(j(B,0))),i=N(r,w,y==m),r=0,++y}}}catch(e){D=!0,V=e}finally{try{!L&&k.return&&k.return()}finally{if(D)throw V}}++r,++a}return t.join("")},V=function(e){return F(e,(function(e){return S.test(e)?L(e.slice(4).toLowerCase()):e}))},M=function(e){return F(e,(function(e){return T.test(e)?"xn--"+D(e):e}))},k={version:"2.1.0",ucs2:{decode:x,encode:function(e){return String.fromCodePoint.apply(String,p(e))}},decode:L,encode:D,toASCII:M,toUnicode:V},$={};function B(e){var t=e.charCodeAt(0);return t<16?"%0"+t.toString(16).toUpperCase():t<128?"%"+t.toString(16).toUpperCase():t<2048?"%"+(t>>6|192).toString(16).toUpperCase()+"%"+(63&t|128).toString(16).toUpperCase():"%"+(t>>12|224).toString(16).toUpperCase()+"%"+(t>>6&63|128).toString(16).toUpperCase()+"%"+(63&t|128).toString(16).toUpperCase()}function U(e){for(var t="",n=0,a=e.length;n<a;){var r=parseInt(e.substr(n+1,2),16);if(r<128)t+=String.fromCharCode(r),n+=3;else if(r>=194&&r<224){if(a-n>=6){var i=parseInt(e.substr(n+4,2),16);t+=String.fromCharCode((31&r)<<6|63&i)}else t+=e.substr(n,6);n+=6}else if(r>=224){if(a-n>=9){var o=parseInt(e.substr(n+4,2),16),s=parseInt(e.substr(n+7,2),16);t+=String.fromCharCode((15&r)<<12|(63&o)<<6|63&s)}else t+=e.substr(n,9);n+=9}else t+=e.substr(n,3),n+=3}return t}function H(e,t){function n(e){var n=U(e);return n.match(t.UNRESERVED)?n:e}return e.scheme&&(e.scheme=String(e.scheme).replace(t.PCT_ENCODED,n).toLowerCase().replace(t.NOT_SCHEME,"")),void 0!==e.userinfo&&(e.userinfo=String(e.userinfo).replace(t.PCT_ENCODED,n).replace(t.NOT_USERINFO,B).replace(t.PCT_ENCODED,r)),void 0!==e.host&&(e.host=String(e.host).replace(t.PCT_ENCODED,n).toLowerCase().replace(t.NOT_HOST,B).replace(t.PCT_ENCODED,r)),void 0!==e.path&&(e.path=String(e.path).replace(t.PCT_ENCODED,n).replace(e.scheme?t.NOT_PATH:t.NOT_PATH_NOSCHEME,B).replace(t.PCT_ENCODED,r)),void 0!==e.query&&(e.query=String(e.query).replace(t.PCT_ENCODED,n).replace(t.NOT_QUERY,B).replace(t.PCT_ENCODED,r)),void 0!==e.fragment&&(e.fragment=String(e.fragment).replace(t.PCT_ENCODED,n).replace(t.NOT_FRAGMENT,B).replace(t.PCT_ENCODED,r)),e}function K(e){return e.replace(/^0*(.*)/,"$1")||"0"}function Q(e,t){var n=e.match(t.IPV4ADDRESS)||[],a=u(n,2)[1];return a?a.split(".").map(K).join("."):e}function G(e,t){var n=e.match(t.IPV6ADDRESS)||[],a=u(n,3),r=a[1],i=a[2];if(r){for(var o=r.toLowerCase().split("::").reverse(),s=u(o,2),c=s[0],l=s[1],p=l?l.split(":").map(K):[],f=c.split(":").map(K),d=t.IPV4ADDRESS.test(f[f.length-1]),h=d?7:8,g=f.length-h,m=Array(h),y=0;y<h;++y)m[y]=p[y]||f[g+y]||"";d&&(m[h-1]=Q(m[h-1],t));var v=m.reduce((function(e,t,n){if(!t||"0"===t){var a=e[e.length-1];a&&a.index+a.length===n?a.length++:e.push({index:n,length:1})}return e}),[]).sort((function(e,t){return t.length-e.length}))[0],b=void 0;if(v&&v.length>1){var P=m.slice(0,v.index),S=m.slice(v.index+v.length);b=P.join(":")+"::"+S.join(":")}else b=m.join(":");return i&&(b+="%"+i),b}return e}var W=/^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,q=void 0==="".match(/(){0}/)[1];function J(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n={},a=!1!==t.iri?l:c;"suffix"===t.reference&&(e=(t.scheme?t.scheme+":":"")+"//"+e);var r=e.match(W);if(r){q?(n.scheme=r[1],n.userinfo=r[3],n.host=r[4],n.port=parseInt(r[5],10),n.path=r[6]||"",n.query=r[7],n.fragment=r[8],isNaN(n.port)&&(n.port=r[5])):(n.scheme=r[1]||void 0,n.userinfo=-1!==e.indexOf("@")?r[3]:void 0,n.host=-1!==e.indexOf("//")?r[4]:void 0,n.port=parseInt(r[5],10),n.path=r[6]||"",n.query=-1!==e.indexOf("?")?r[7]:void 0,n.fragment=-1!==e.indexOf("#")?r[8]:void 0,isNaN(n.port)&&(n.port=e.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)?r[4]:void 0)),n.host&&(n.host=G(Q(n.host,a),a)),void 0!==n.scheme||void 0!==n.userinfo||void 0!==n.host||void 0!==n.port||n.path||void 0!==n.query?void 0===n.scheme?n.reference="relative":void 0===n.fragment?n.reference="absolute":n.reference="uri":n.reference="same-document",t.reference&&"suffix"!==t.reference&&t.reference!==n.reference&&(n.error=n.error||"URI is not a "+t.reference+" reference.");var i=$[(t.scheme||n.scheme||"").toLowerCase()];if(t.unicodeSupport||i&&i.unicodeSupport)H(n,a);else{if(n.host&&(t.domainHost||i&&i.domainHost))try{n.host=k.toASCII(n.host.replace(a.PCT_ENCODED,U).toLowerCase())}catch(e){n.error=n.error||"Host's domain name can not be converted to ASCII via punycode: "+e}H(n,c)}i&&i.parse&&i.parse(n,t)}else n.error=n.error||"URI can not be parsed.";return n}function X(e,t){var n=!1!==t.iri?l:c,a=[];return void 0!==e.userinfo&&(a.push(e.userinfo),a.push("@")),void 0!==e.host&&a.push(G(Q(String(e.host),n),n).replace(n.IPV6ADDRESS,(function(e,t,n){return"["+t+(n?"%25"+n:"")+"]"}))),"number"==typeof e.port&&(a.push(":"),a.push(e.port.toString(10))),a.length?a.join(""):void 0}var z=/^\.\.?\//,Y=/^\/\.(\/|$)/,Z=/^\/\.\.(\/|$)/,ee=/^\/?(?:.|\n)*?(?=\/|$)/;function te(e){for(var t=[];e.length;)if(e.match(z))e=e.replace(z,"");else if(e.match(Y))e=e.replace(Y,"/");else if(e.match(Z))e=e.replace(Z,"/"),t.pop();else if("."===e||".."===e)e="";else{var n=e.match(ee);if(!n)throw new Error("Unexpected dot segment condition");var a=n[0];e=e.slice(a.length),t.push(a)}return t.join("")}function ne(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=t.iri?l:c,a=[],r=$[(t.scheme||e.scheme||"").toLowerCase()];if(r&&r.serialize&&r.serialize(e,t),e.host)if(n.IPV6ADDRESS.test(e.host));else if(t.domainHost||r&&r.domainHost)try{e.host=t.iri?k.toUnicode(e.host):k.toASCII(e.host.replace(n.PCT_ENCODED,U).toLowerCase())}catch(n){e.error=e.error||"Host's domain name can not be converted to "+(t.iri?"Unicode":"ASCII")+" via punycode: "+n}H(e,n),"suffix"!==t.reference&&e.scheme&&(a.push(e.scheme),a.push(":"));var i=X(e,t);if(void 0!==i&&("suffix"!==t.reference&&a.push("//"),a.push(i),e.path&&"/"!==e.path.charAt(0)&&a.push("/")),void 0!==e.path){var o=e.path;t.absolutePath||r&&r.absolutePath||(o=te(o)),void 0===i&&(o=o.replace(/^\/\//,"/%2F")),a.push(o)}return void 0!==e.query&&(a.push("?"),a.push(e.query)),void 0!==e.fragment&&(a.push("#"),a.push(e.fragment)),a.join("")}function ae(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a={};return arguments[3]||(e=J(ne(e,n),n),t=J(ne(t,n),n)),!(n=n||{}).tolerant&&t.scheme?(a.scheme=t.scheme,a.userinfo=t.userinfo,a.host=t.host,a.port=t.port,a.path=te(t.path||""),a.query=t.query):(void 0!==t.userinfo||void 0!==t.host||void 0!==t.port?(a.userinfo=t.userinfo,a.host=t.host,a.port=t.port,a.path=te(t.path||""),a.query=t.query):(t.path?("/"===t.path.charAt(0)?a.path=te(t.path):(void 0===e.userinfo&&void 0===e.host&&void 0===e.port||e.path?e.path?a.path=e.path.slice(0,e.path.lastIndexOf("/")+1)+t.path:a.path=t.path:a.path="/"+t.path,a.path=te(a.path)),a.query=t.query):(a.path=e.path,void 0!==t.query?a.query=t.query:a.query=e.query),a.userinfo=e.userinfo,a.host=e.host,a.port=e.port),a.scheme=e.scheme),a.fragment=t.fragment,a}function re(e,t,n){var a=o({scheme:"null"},n);return ne(ae(J(e,a),J(t,a),a,!0),a)}function ie(e,t){return"string"==typeof e?e=ne(J(e,t),t):"object"===a(e)&&(e=J(ne(e,t),t)),e}function oe(e,t,n){return"string"==typeof e?e=ne(J(e,n),n):"object"===a(e)&&(e=ne(e,n)),"string"==typeof t?t=ne(J(t,n),n):"object"===a(t)&&(t=ne(t,n)),e===t}function se(e,t){return e&&e.toString().replace(t&&t.iri?l.ESCAPE:c.ESCAPE,B)}function ce(e,t){return e&&e.toString().replace(t&&t.iri?l.PCT_ENCODED:c.PCT_ENCODED,U)}var le={scheme:"http",domainHost:!0,parse:function(e,t){return e.host||(e.error=e.error||"HTTP URIs must have a host."),e},serialize:function(e,t){return e.port!==("https"!==String(e.scheme).toLowerCase()?80:443)&&""!==e.port||(e.port=void 0),e.path||(e.path="/"),e}},ue={scheme:"https",domainHost:le.domainHost,parse:le.parse,serialize:le.serialize},pe={},fe="[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]",de="[0-9A-Fa-f]",he=n(n("%[EFef]"+de+"%"+de+de+"%"+de+de)+"|"+n("%[89A-Fa-f]"+de+"%"+de+de)+"|"+n("%"+de+de)),ge="[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]",me=t("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]",'[\\"\\\\]'),ye="[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]",ve=new RegExp(fe,"g"),be=new RegExp(he,"g"),Pe=new RegExp(t("[^]",ge,"[\\.]",'[\\"]',me),"g"),Se=new RegExp(t("[^]",fe,ye),"g"),Te=Se;function Oe(e){var t=U(e);return t.match(ve)?t:e}var Ee={scheme:"mailto",parse:function(e,t){var n=e,a=n.to=n.path?n.path.split(","):[];if(n.path=void 0,n.query){for(var r=!1,i={},o=n.query.split("&"),s=0,c=o.length;s<c;++s){var l=o[s].split("=");switch(l[0]){case"to":for(var u=l[1].split(","),p=0,f=u.length;p<f;++p)a.push(u[p]);break;case"subject":n.subject=ce(l[1],t);break;case"body":n.body=ce(l[1],t);break;default:r=!0,i[ce(l[0],t)]=ce(l[1],t)}}r&&(n.headers=i)}n.query=void 0;for(var d=0,h=a.length;d<h;++d){var g=a[d].split("@");if(g[0]=ce(g[0]),t.unicodeSupport)g[1]=ce(g[1],t).toLowerCase();else try{g[1]=k.toASCII(ce(g[1],t).toLowerCase())}catch(e){n.error=n.error||"Email address's domain name can not be converted to ASCII via punycode: "+e}a[d]=g.join("@")}return n},serialize:function(e,t){var n=e,a=i(e.to);if(a){for(var o=0,s=a.length;o<s;++o){var c=String(a[o]),l=c.lastIndexOf("@"),u=c.slice(0,l).replace(be,Oe).replace(be,r).replace(Pe,B),p=c.slice(l+1);try{p=t.iri?k.toUnicode(p):k.toASCII(ce(p,t).toLowerCase())}catch(e){n.error=n.error||"Email address's domain name can not be converted to "+(t.iri?"Unicode":"ASCII")+" via punycode: "+e}a[o]=u+"@"+p}n.path=a.join(",")}var f=e.headers=e.headers||{};e.subject&&(f.subject=e.subject),e.body&&(f.body=e.body);var d=[];for(var h in f)f[h]!==pe[h]&&d.push(h.replace(be,Oe).replace(be,r).replace(Se,B)+"="+f[h].replace(be,Oe).replace(be,r).replace(Te,B));return d.length&&(n.query=d.join("&")),n}},_e=/^([^\:]+)\:(.*)/,Ce={scheme:"urn",parse:function(e,t){var n=e.path&&e.path.match(_e),a=e;if(n){var r=t.scheme||a.scheme||"urn",i=n[1].toLowerCase(),o=n[2],s=r+":"+(t.nid||i),c=$[s];a.nid=i,a.nss=o,a.path=void 0,c&&(a=c.parse(a,t))}else a.error=a.error||"URN can not be parsed.";return a},serialize:function(e,t){var n=t.scheme||e.scheme||"urn",a=e.nid,r=n+":"+(t.nid||a),i=$[r];i&&(e=i.serialize(e,t));var o=e,s=e.nss;return o.path=(a||t.nid)+":"+s,o}},Ae=/^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,Ie={scheme:"urn:uuid",parse:function(e,t){var n=e;return n.uuid=n.nss,n.nss=void 0,t.tolerant||n.uuid&&n.uuid.match(Ae)||(n.error=n.error||"UUID is not valid."),n},serialize:function(e,t){var n=e;return n.nss=(e.uuid||"").toLowerCase(),n}};$[le.scheme]=le,$[ue.scheme]=ue,$[Ee.scheme]=Ee,$[Ce.scheme]=Ce,$[Ie.scheme]=Ie,e.SCHEMES=$,e.pctEncChar=B,e.pctDecChars=U,e.parse=J,e.removeDotSegments=te,e.serialize=ne,e.resolveComponents=ae,e.resolve=re,e.normalize=ie,e.equal=oe,e.escapeComponent=se,e.unescapeComponent=ce,Object.defineProperty(e,"__esModule",{value:!0})}(t)},8767:(e,t,n)=>{e.exports=n(1669).deprecate},5762:(e,t,n)=>{"use strict";const a=n(5622),r=n(2159),i=n(6627),o=n(8525),s=n(3356),c=n(9417)(r);t.read=(e,t)=>{const n=(t=t||{}).cwd||process.cwd(),l=t.base||n;return e=a.resolve(n,e),c.stat(e).then((a=>{const u=new s({cwd:n,base:l,path:e,stat:a});return!1===t.read?u:!1===t.buffer?(u.contents=r.createReadStream(e).pipe(o()),u):c.readFile(e).then((e=>(u.contents=i(e),u)))}))},t.readSync=(e,t)=>{const n=(t=t||{}).cwd||process.cwd(),c=t.base||n;let l;return e=a.resolve(n,e),!1!==t.read&&(l=!1===t.buffer?r.createReadStream(e).pipe(o()):i(r.readFileSync(e))),new s({cwd:n,base:c,path:e,stat:r.statSync(e),contents:l})}},9417:e=>{"use strict";var t=function(e,t,n){return function(){for(var a=this,r=new Array(arguments.length),i=0;i<arguments.length;i++)r[i]=arguments[i];return new t((function(t,i){r.push((function(e,a){if(e)i(e);else if(n.multiArgs){for(var r=new Array(arguments.length-1),o=1;o<arguments.length;o++)r[o-1]=arguments[o];t(r)}else t(a)})),e.apply(a,r)}))}},n=e.exports=function(e,n,a){"function"!=typeof n&&(a=n,n=Promise),(a=a||{}).exclude=a.exclude||[/.+Sync$/];var r="function"==typeof e?function(){return a.excludeMain?e.apply(this,arguments):t(e,n,a).apply(this,arguments)}:{};return Object.keys(e).reduce((function(r,i){var o=e[i];return r[i]="function"==typeof o&&function(e){var t=function(t){return"string"==typeof t?e===t:t.test(e)};return a.include?a.include.some(t):!a.exclude.some(t)}(i)?t(o,n,a):o,r}),r)};n.all=n},3356:(e,t,n)=>{"use strict";var a=n(5622),r=n(1669),i=n(4293).Buffer.isBuffer,o=n(2278),s=n(2059),c=n(6972),l=n(4736),u=n(9111),p=n(9948),f=n(9783),d=n(4886),h=n(1380),g=["_contents","_symlink","contents","stat","history","path","_base","base","_cwd","cwd"];function m(e){var t=this;e||(e={}),this.stat=e.stat||null,this.contents=e.contents||null;var n=Array.prototype.slice.call(e.history||[]);e.path&&n.push(e.path),this.history=[],n.forEach((function(e){t.path=e})),this.cwd=e.cwd||process.cwd(),this.base=e.base,this._isVinyl=!0,this._symlink=null,Object.keys(e).forEach((function(n){t.constructor.isCustomProp(n)&&(t[n]=e[n])}))}m.prototype.isBuffer=function(){return i(this.contents)},m.prototype.isStream=function(){return f(this.contents)},m.prototype.isNull=function(){return null===this.contents},m.prototype.isDirectory=function(){return!!this.isNull()&&(!(!this.stat||"function"!=typeof this.stat.isDirectory)&&this.stat.isDirectory())},m.prototype.isSymbolic=function(){return!!this.isNull()&&(!(!this.stat||"function"!=typeof this.stat.isSymbolicLink)&&this.stat.isSymbolicLink())},m.prototype.clone=function(e){var t,n=this;"boolean"==typeof e?e={deep:e,contents:!0}:e?(e.deep=!0===e.deep,e.contents=!1!==e.contents):e={deep:!0,contents:!0},this.isStream()?t=this.contents.clone():this.isBuffer()&&(t=e.contents?u(this.contents):this.contents);var a=new this.constructor({cwd:this.cwd,base:this.base,stat:this.stat?l(this.stat):null,history:this.history.slice(),contents:t});return this.isSymbolic()&&(a.symlink=this.symlink),Object.keys(this).forEach((function(t){n.constructor.isCustomProp(t)&&(a[t]=e.deep?o(n[t],!0):n[t])})),a},m.prototype.inspect=function(){var e=[],t=this.path?this.relative:null;return t&&e.push('"'+t+'"'),this.isBuffer()&&e.push(this.contents.inspect()),this.isStream()&&e.push(h(this.contents)),"<File "+e.join(" ")+">"},r.inspect.custom&&(m.prototype[r.inspect.custom]=m.prototype.inspect),m.isCustomProp=function(e){return-1===g.indexOf(e)},m.isVinyl=function(e){return e&&!0===e._isVinyl||!1},Object.defineProperty(m.prototype,"contents",{get:function(){return this._contents},set:function(e){if(!i(e)&&!f(e)&&null!==e)throw new Error("File.contents can only be a Buffer, a Stream, or null.");f(e)&&!s.isCloneable(e)&&(e=s(e)),this._contents=e}}),Object.defineProperty(m.prototype,"cwd",{get:function(){return this._cwd},set:function(e){if(!e||"string"!=typeof e)throw new Error("cwd must be a non-empty string.");this._cwd=p(d(e))}}),Object.defineProperty(m.prototype,"base",{get:function(){return this._base||this._cwd},set:function(e){if(null!=e){if("string"!=typeof e||!e)throw new Error("base must be a non-empty string, or null/undefined.");(e=p(d(e)))!==this._cwd?this._base=e:delete this._base}else delete this._base}}),Object.defineProperty(m.prototype,"relative",{get:function(){if(!this.path)throw new Error("No path specified! Can not get relative.");return a.relative(this.base,this.path)},set:function(){throw new Error("File.relative is generated from the base and path attributes. Do not modify it.")}}),Object.defineProperty(m.prototype,"dirname",{get:function(){if(!this.path)throw new Error("No path specified! Can not get dirname.");return a.dirname(this.path)},set:function(e){if(!this.path)throw new Error("No path specified! Can not set dirname.");this.path=a.join(e,this.basename)}}),Object.defineProperty(m.prototype,"basename",{get:function(){if(!this.path)throw new Error("No path specified! Can not get basename.");return a.basename(this.path)},set:function(e){if(!this.path)throw new Error("No path specified! Can not set basename.");this.path=a.join(this.dirname,e)}}),Object.defineProperty(m.prototype,"stem",{get:function(){if(!this.path)throw new Error("No path specified! Can not get stem.");return a.basename(this.path,this.extname)},set:function(e){if(!this.path)throw new Error("No path specified! Can not set stem.");this.path=a.join(this.dirname,e+this.extname)}}),Object.defineProperty(m.prototype,"extname",{get:function(){if(!this.path)throw new Error("No path specified! Can not get extname.");return a.extname(this.path)},set:function(e){if(!this.path)throw new Error("No path specified! Can not set extname.");this.path=c(this.path,e)}}),Object.defineProperty(m.prototype,"path",{get:function(){return this.history[this.history.length-1]},set:function(e){if("string"!=typeof e)throw new Error("path should be a string.");(e=p(d(e)))&&e!==this.path&&this.history.push(e)}}),Object.defineProperty(m.prototype,"symlink",{get:function(){return this._symlink},set:function(e){if("string"!=typeof e)throw new Error("symlink should be a string");this._symlink=p(d(e))}}),e.exports=m},1380:e=>{"use strict";e.exports=function(e){var t=e.constructor.name;return"Stream"===t&&(t=""),"<"+t+"Stream>"}},9783:e=>{"use strict";e.exports=function(e){return!!e&&"function"==typeof e.pipe}},4886:(e,t,n)=>{"use strict";var a=n(5622);e.exports=function(e){return""===e?e:a.normalize(e)}},2278:e=>{var t=function(){"use strict";function e(e,t){return null!=t&&e instanceof t}var t,n,a;try{t=Map}catch(e){t=function(){}}try{n=Set}catch(e){n=function(){}}try{a=Promise}catch(e){a=function(){}}function r(i,s,c,l,u){"object"==typeof s&&(c=s.depth,l=s.prototype,u=s.includeNonEnumerable,s=s.circular);var p=[],f=[],d="undefined"!=typeof Buffer;return void 0===s&&(s=!0),void 0===c&&(c=1/0),function i(c,h){if(null===c)return null;if(0===h)return c;var g,m;if("object"!=typeof c)return c;if(e(c,t))g=new t;else if(e(c,n))g=new n;else if(e(c,a))g=new a((function(e,t){c.then((function(t){e(i(t,h-1))}),(function(e){t(i(e,h-1))}))}));else if(r.__isArray(c))g=[];else if(r.__isRegExp(c))g=new RegExp(c.source,o(c)),c.lastIndex&&(g.lastIndex=c.lastIndex);else if(r.__isDate(c))g=new Date(c.getTime());else{if(d&&Buffer.isBuffer(c))return g=Buffer.allocUnsafe?Buffer.allocUnsafe(c.length):new Buffer(c.length),c.copy(g),g;e(c,Error)?g=Object.create(c):void 0===l?(m=Object.getPrototypeOf(c),g=Object.create(m)):(g=Object.create(l),m=l)}if(s){var y=p.indexOf(c);if(-1!=y)return f[y];p.push(c),f.push(g)}for(var v in e(c,t)&&c.forEach((function(e,t){var n=i(t,h-1),a=i(e,h-1);g.set(n,a)})),e(c,n)&&c.forEach((function(e){var t=i(e,h-1);g.add(t)})),c){var b;m&&(b=Object.getOwnPropertyDescriptor(m,v)),b&&null==b.set||(g[v]=i(c[v],h-1))}if(Object.getOwnPropertySymbols){var P=Object.getOwnPropertySymbols(c);for(v=0;v<P.length;v++){var S=P[v];(!(O=Object.getOwnPropertyDescriptor(c,S))||O.enumerable||u)&&(g[S]=i(c[S],h-1),O.enumerable||Object.defineProperty(g,S,{enumerable:!1}))}}if(u){var T=Object.getOwnPropertyNames(c);for(v=0;v<T.length;v++){var O,E=T[v];(O=Object.getOwnPropertyDescriptor(c,E))&&O.enumerable||(g[E]=i(c[E],h-1),Object.defineProperty(g,E,{enumerable:!1}))}}return g}(i,c)}function i(e){return Object.prototype.toString.call(e)}function o(e){var t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),t}return r.clonePrototype=function(e){if(null===e)return null;var t=function(){};return t.prototype=e,new t},r.__objToStr=i,r.__isDate=function(e){return"object"==typeof e&&"[object Date]"===i(e)},r.__isArray=function(e){return"object"==typeof e&&"[object Array]"===i(e)},r.__isRegExp=function(e){return"object"==typeof e&&"[object RegExp]"===i(e)},r.__getRegExpFlags=o,r}();e.exports&&(e.exports=t)},6972:(e,t,n)=>{"use strict";var a=n(5622);e.exports=function(e,t){if("string"!=typeof e)return e;if(0===e.length)return e;var n,r=a.basename(e,a.extname(e))+t,i=a.join(a.dirname(e),r);return(n=e.slice(0,2))==="."+a.sep||"./"===n?"."+a.sep+i:i}},7725:e=>{e.exports={isArray:function(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)}}},4139:(e,t,n)=>{var a=n(5707),r=n(4096),i=n(2160),o=n(1473);e.exports={xml2js:a,xml2json:r,js2xml:i,json2xml:o}},2160:(e,t,n)=>{var a,r,i=n(4314),o=n(7725).isArray;function s(e,t,n){return(!n&&e.spaces?"\n":"")+Array(t+1).join(e.spaces)}function c(e,t,n){if(t.ignoreAttributes)return"";"attributesFn"in t&&(e=t.attributesFn(e,r,a));var i,o,c,l,u=[];for(i in e)e.hasOwnProperty(i)&&null!==e[i]&&void 0!==e[i]&&(l=t.noQuotesForNativeAttributes&&"string"!=typeof e[i]?"":'"',o=(o=""+e[i]).replace(/"/g,"&quot;"),c="attributeNameFn"in t?t.attributeNameFn(i,o,r,a):i,u.push(t.spaces&&t.indentAttributes?s(t,n+1,!1):" "),u.push(c+"="+l+("attributeValueFn"in t?t.attributeValueFn(o,i,r,a):o)+l));return e&&Object.keys(e).length&&t.spaces&&t.indentAttributes&&u.push(s(t,n,!1)),u.join("")}function l(e,t,n){return a=e,r="xml",t.ignoreDeclaration?"":"<?xml"+c(e[t.attributesKey],t,n)+"?>"}function u(e,t,n){if(t.ignoreInstruction)return"";var i;for(i in e)if(e.hasOwnProperty(i))break;var o="instructionNameFn"in t?t.instructionNameFn(i,e[i],r,a):i;if("object"==typeof e[i])return a=e,r=o,"<?"+o+c(e[i][t.attributesKey],t,n)+"?>";var s=e[i]?e[i]:"";return"instructionFn"in t&&(s=t.instructionFn(s,i,r,a)),"<?"+o+(s?" "+s:"")+"?>"}function p(e,t){return t.ignoreComment?"":"\x3c!--"+("commentFn"in t?t.commentFn(e,r,a):e)+"--\x3e"}function f(e,t){return t.ignoreCdata?"":"<![CDATA["+("cdataFn"in t?t.cdataFn(e,r,a):e.replace("]]>","]]]]><![CDATA[>"))+"]]>"}function d(e,t){return t.ignoreDoctype?"":"<!DOCTYPE "+("doctypeFn"in t?t.doctypeFn(e,r,a):e)+">"}function h(e,t){return t.ignoreText?"":(e=(e=(e=""+e).replace(/&amp;/g,"&")).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"),"textFn"in t?t.textFn(e,r,a):e)}function g(e,t,n,i){return e.reduce((function(e,o){var l=s(t,n,i&&!e);switch(o.type){case"element":return e+l+function(e,t,n){a=e,r=e.name;var i=[],o="elementNameFn"in t?t.elementNameFn(e.name,e):e.name;i.push("<"+o),e[t.attributesKey]&&i.push(c(e[t.attributesKey],t,n));var s=e[t.elementsKey]&&e[t.elementsKey].length||e[t.attributesKey]&&"preserve"===e[t.attributesKey]["xml:space"];return s||(s="fullTagEmptyElementFn"in t?t.fullTagEmptyElementFn(e.name,e):t.fullTagEmptyElement),s?(i.push(">"),e[t.elementsKey]&&e[t.elementsKey].length&&(i.push(g(e[t.elementsKey],t,n+1)),a=e,r=e.name),i.push(t.spaces&&function(e,t){var n;if(e.elements&&e.elements.length)for(n=0;n<e.elements.length;++n)switch(e.elements[n][t.typeKey]){case"text":if(t.indentText)return!0;break;case"cdata":if(t.indentCdata)return!0;break;case"instruction":if(t.indentInstruction)return!0;break;case"doctype":case"comment":case"element":default:return!0}return!1}(e,t)?"\n"+Array(n+1).join(t.spaces):""),i.push("</"+o+">")):i.push("/>"),i.join("")}(o,t,n);case"comment":return e+l+p(o[t.commentKey],t);case"doctype":return e+l+d(o[t.doctypeKey],t);case"cdata":return e+(t.indentCdata?l:"")+f(o[t.cdataKey],t);case"text":return e+(t.indentText?l:"")+h(o[t.textKey],t);case"instruction":var m={};return m[o[t.nameKey]]=o[t.attributesKey]?o:o[t.instructionKey],e+(t.indentInstruction?l:"")+u(m,t,n)}}),"")}function m(e,t,n){var a;for(a in e)if(e.hasOwnProperty(a))switch(a){case t.parentKey:case t.attributesKey:break;case t.textKey:if(t.indentText||n)return!0;break;case t.cdataKey:if(t.indentCdata||n)return!0;break;case t.instructionKey:if(t.indentInstruction||n)return!0;break;case t.doctypeKey:case t.commentKey:default:return!0}return!1}function y(e,t,n,i,o){a=e,r=t;var l="elementNameFn"in n?n.elementNameFn(t,e):t;if(null==e||""===e)return"fullTagEmptyElementFn"in n&&n.fullTagEmptyElementFn(t,e)||n.fullTagEmptyElement?"<"+l+"></"+l+">":"<"+l+"/>";var u=[];if(t){if(u.push("<"+l),"object"!=typeof e)return u.push(">"+h(e,n)+"</"+l+">"),u.join("");e[n.attributesKey]&&u.push(c(e[n.attributesKey],n,i));var p=m(e,n,!0)||e[n.attributesKey]&&"preserve"===e[n.attributesKey]["xml:space"];if(p||(p="fullTagEmptyElementFn"in n?n.fullTagEmptyElementFn(t,e):n.fullTagEmptyElement),!p)return u.push("/>"),u.join("");u.push(">")}return u.push(v(e,n,i+1,!1)),a=e,r=t,t&&u.push((o?s(n,i,!1):"")+"</"+l+">"),u.join("")}function v(e,t,n,a){var r,i,c,g=[];for(i in e)if(e.hasOwnProperty(i))for(c=o(e[i])?e[i]:[e[i]],r=0;r<c.length;++r){switch(i){case t.declarationKey:g.push(l(c[r],t,n));break;case t.instructionKey:g.push((t.indentInstruction?s(t,n,a):"")+u(c[r],t,n));break;case t.attributesKey:case t.parentKey:break;case t.textKey:g.push((t.indentText?s(t,n,a):"")+h(c[r],t));break;case t.cdataKey:g.push((t.indentCdata?s(t,n,a):"")+f(c[r],t));break;case t.doctypeKey:g.push(s(t,n,a)+d(c[r],t));break;case t.commentKey:g.push(s(t,n,a)+p(c[r],t));break;default:g.push(s(t,n,a)+y(c[r],i,t,n,m(c[r],t)))}a=a&&!g.length}return g.join("")}e.exports=function(e,t){t=function(e){var t=i.copyOptions(e);return i.ensureFlagExists("ignoreDeclaration",t),i.ensureFlagExists("ignoreInstruction",t),i.ensureFlagExists("ignoreAttributes",t),i.ensureFlagExists("ignoreText",t),i.ensureFlagExists("ignoreComment",t),i.ensureFlagExists("ignoreCdata",t),i.ensureFlagExists("ignoreDoctype",t),i.ensureFlagExists("compact",t),i.ensureFlagExists("indentText",t),i.ensureFlagExists("indentCdata",t),i.ensureFlagExists("indentAttributes",t),i.ensureFlagExists("indentInstruction",t),i.ensureFlagExists("fullTagEmptyElement",t),i.ensureFlagExists("noQuotesForNativeAttributes",t),i.ensureSpacesExists(t),"number"==typeof t.spaces&&(t.spaces=Array(t.spaces+1).join(" ")),i.ensureKeyExists("declaration",t),i.ensureKeyExists("instruction",t),i.ensureKeyExists("attributes",t),i.ensureKeyExists("text",t),i.ensureKeyExists("comment",t),i.ensureKeyExists("cdata",t),i.ensureKeyExists("doctype",t),i.ensureKeyExists("type",t),i.ensureKeyExists("name",t),i.ensureKeyExists("elements",t),i.checkFnExists("doctype",t),i.checkFnExists("instruction",t),i.checkFnExists("cdata",t),i.checkFnExists("comment",t),i.checkFnExists("text",t),i.checkFnExists("instructionName",t),i.checkFnExists("elementName",t),i.checkFnExists("attributeName",t),i.checkFnExists("attributeValue",t),i.checkFnExists("attributes",t),i.checkFnExists("fullTagEmptyElement",t),t}(t);var n=[];return a=e,r="_root_",t.compact?n.push(v(e,t,0,!0)):(e[t.declarationKey]&&n.push(l(e[t.declarationKey],t,0)),e[t.elementsKey]&&e[t.elementsKey].length&&n.push(g(e[t.elementsKey],t,0,!n.length))),n.join("")}},1473:(e,t,n)=>{var a=n(2160);e.exports=function(e,t){e instanceof Buffer&&(e=e.toString());var n=null;if("string"==typeof e)try{n=JSON.parse(e)}catch(e){throw new Error("The JSON structure is invalid")}else n=e;return a(n,t)}},4314:(e,t,n)=>{var a=n(7725).isArray;e.exports={copyOptions:function(e){var t,n={};for(t in e)e.hasOwnProperty(t)&&(n[t]=e[t]);return n},ensureFlagExists:function(e,t){e in t&&"boolean"==typeof t[e]||(t[e]=!1)},ensureSpacesExists:function(e){(!("spaces"in e)||"number"!=typeof e.spaces&&"string"!=typeof e.spaces)&&(e.spaces=0)},ensureAlwaysArrayExists:function(e){"alwaysArray"in e&&("boolean"==typeof e.alwaysArray||a(e.alwaysArray))||(e.alwaysArray=!1)},ensureKeyExists:function(e,t){e+"Key"in t&&"string"==typeof t[e+"Key"]||(t[e+"Key"]=t.compact?"_"+e:e)},checkFnExists:function(e,t){return e+"Fn"in t}}},5707:(e,t,n)=>{var a,r,i=n(9871),o=n(4314),s=n(7725).isArray;function c(e){var t=Number(e);if(!isNaN(t))return t;var n=e.toLowerCase();return"true"===n||"false"!==n&&e}function l(e,t){var n;if(a.compact){if(!r[a[e+"Key"]]&&(s(a.alwaysArray)?-1!==a.alwaysArray.indexOf(a[e+"Key"]):a.alwaysArray)&&(r[a[e+"Key"]]=[]),r[a[e+"Key"]]&&!s(r[a[e+"Key"]])&&(r[a[e+"Key"]]=[r[a[e+"Key"]]]),e+"Fn"in a&&"string"==typeof t&&(t=a[e+"Fn"](t,r)),"instruction"===e&&("instructionFn"in a||"instructionNameFn"in a))for(n in t)if(t.hasOwnProperty(n))if("instructionFn"in a)t[n]=a.instructionFn(t[n],n,r);else{var i=t[n];delete t[n],t[a.instructionNameFn(n,i,r)]=i}s(r[a[e+"Key"]])?r[a[e+"Key"]].push(t):r[a[e+"Key"]]=t}else{r[a.elementsKey]||(r[a.elementsKey]=[]);var o={};if(o[a.typeKey]=e,"instruction"===e){for(n in t)if(t.hasOwnProperty(n))break;o[a.nameKey]="instructionNameFn"in a?a.instructionNameFn(n,t,r):n,a.instructionHasAttributes?(o[a.attributesKey]=t[n][a.attributesKey],"instructionFn"in a&&(o[a.attributesKey]=a.instructionFn(o[a.attributesKey],n,r))):("instructionFn"in a&&(t[n]=a.instructionFn(t[n],n,r)),o[a.instructionKey]=t[n])}else e+"Fn"in a&&(t=a[e+"Fn"](t,r)),o[a[e+"Key"]]=t;a.addParent&&(o[a.parentKey]=r),r[a.elementsKey].push(o)}}function u(e){var t;if("attributesFn"in a&&e&&(e=a.attributesFn(e,r)),(a.trim||"attributeValueFn"in a||"attributeNameFn"in a||a.nativeTypeAttributes)&&e)for(t in e)if(e.hasOwnProperty(t)&&(a.trim&&(e[t]=e[t].trim()),a.nativeTypeAttributes&&(e[t]=c(e[t])),"attributeValueFn"in a&&(e[t]=a.attributeValueFn(e[t],t,r)),"attributeNameFn"in a)){var n=e[t];delete e[t],e[a.attributeNameFn(t,e[t],r)]=n}return e}function p(e){var t={};if(e.body&&("xml"===e.name.toLowerCase()||a.instructionHasAttributes)){for(var n,i=/([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;null!==(n=i.exec(e.body));)t[n[1]]=n[2]||n[3]||n[4];t=u(t)}if("xml"===e.name.toLowerCase()){if(a.ignoreDeclaration)return;r[a.declarationKey]={},Object.keys(t).length&&(r[a.declarationKey][a.attributesKey]=t),a.addParent&&(r[a.declarationKey][a.parentKey]=r)}else{if(a.ignoreInstruction)return;a.trim&&(e.body=e.body.trim());var o={};a.instructionHasAttributes&&Object.keys(t).length?(o[e.name]={},o[e.name][a.attributesKey]=t):o[e.name]=e.body,l("instruction",o)}}function f(e,t){var n;if("object"==typeof e&&(t=e.attributes,e=e.name),t=u(t),"elementNameFn"in a&&(e=a.elementNameFn(e,r)),a.compact){var i;if(n={},!a.ignoreAttributes&&t&&Object.keys(t).length)for(i in n[a.attributesKey]={},t)t.hasOwnProperty(i)&&(n[a.attributesKey][i]=t[i]);!(e in r)&&(s(a.alwaysArray)?-1!==a.alwaysArray.indexOf(e):a.alwaysArray)&&(r[e]=[]),r[e]&&!s(r[e])&&(r[e]=[r[e]]),s(r[e])?r[e].push(n):r[e]=n}else r[a.elementsKey]||(r[a.elementsKey]=[]),(n={})[a.typeKey]="element",n[a.nameKey]=e,!a.ignoreAttributes&&t&&Object.keys(t).length&&(n[a.attributesKey]=t),a.alwaysChildren&&(n[a.elementsKey]=[]),r[a.elementsKey].push(n);n[a.parentKey]=r,r=n}function d(e){a.ignoreText||(e.trim()||a.captureSpacesBetweenElements)&&(a.trim&&(e=e.trim()),a.nativeType&&(e=c(e)),a.sanitize&&(e=e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")),l("text",e))}function h(e){a.ignoreComment||(a.trim&&(e=e.trim()),l("comment",e))}function g(e){var t=r[a.parentKey];a.addParent||delete r[a.parentKey],r=t}function m(e){a.ignoreCdata||(a.trim&&(e=e.trim()),l("cdata",e))}function y(e){a.ignoreDoctype||(e=e.replace(/^ /,""),a.trim&&(e=e.trim()),l("doctype",e))}function v(e){e.note=e}e.exports=function(e,t){var n=i.parser(!0,{}),s={};if(r=s,a=function(e){return a=o.copyOptions(e),o.ensureFlagExists("ignoreDeclaration",a),o.ensureFlagExists("ignoreInstruction",a),o.ensureFlagExists("ignoreAttributes",a),o.ensureFlagExists("ignoreText",a),o.ensureFlagExists("ignoreComment",a),o.ensureFlagExists("ignoreCdata",a),o.ensureFlagExists("ignoreDoctype",a),o.ensureFlagExists("compact",a),o.ensureFlagExists("alwaysChildren",a),o.ensureFlagExists("addParent",a),o.ensureFlagExists("trim",a),o.ensureFlagExists("nativeType",a),o.ensureFlagExists("nativeTypeAttributes",a),o.ensureFlagExists("sanitize",a),o.ensureFlagExists("instructionHasAttributes",a),o.ensureFlagExists("captureSpacesBetweenElements",a),o.ensureAlwaysArrayExists(a),o.ensureKeyExists("declaration",a),o.ensureKeyExists("instruction",a),o.ensureKeyExists("attributes",a),o.ensureKeyExists("text",a),o.ensureKeyExists("comment",a),o.ensureKeyExists("cdata",a),o.ensureKeyExists("doctype",a),o.ensureKeyExists("type",a),o.ensureKeyExists("name",a),o.ensureKeyExists("elements",a),o.ensureKeyExists("parent",a),o.checkFnExists("doctype",a),o.checkFnExists("instruction",a),o.checkFnExists("cdata",a),o.checkFnExists("comment",a),o.checkFnExists("text",a),o.checkFnExists("instructionName",a),o.checkFnExists("elementName",a),o.checkFnExists("attributeName",a),o.checkFnExists("attributeValue",a),o.checkFnExists("attributes",a),a}(t),n.opt={strictEntities:!0},n.onopentag=f,n.ontext=d,n.oncomment=h,n.onclosetag=g,n.onerror=v,n.oncdata=m,n.ondoctype=y,n.onprocessinginstruction=p,n.write(e).close(),s[a.elementsKey]){var c=s[a.elementsKey];delete s[a.elementsKey],s[a.elementsKey]=c,delete s.text}return s}},4096:(e,t,n)=>{var a=n(4314),r=n(5707);e.exports=function(e,t){var n,i,o;return n=function(e){var t=a.copyOptions(e);return a.ensureSpacesExists(t),t}(t),i=r(e,n),o="compact"in n&&n.compact?"_parent":"parent",("addParent"in n&&n.addParent?JSON.stringify(i,(function(e,t){return e===o?"_":t}),n.spaces):JSON.stringify(i,null,n.spaces)).replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}},1097:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(4681),r=n(3435),i=n(6272),o=n(1918),s=n(6882),c=n(7505),l=n(4330),u=n(1271),p=n(3517),f=n(5008);var d=n(3435);t.getGenericSchema=d.getGenericSchema,t.generateSchema=function(e){let t;if(e[a.FioriElementsVersion.v2]){const n=e[a.FioriElementsVersion.v2];if(n[r.SchemaType.ListReport]){const{genericSchema:e,entitySet:a,annotations:i,manifest:s,fragments:c,logger:l}=n[r.SchemaType.ListReport];t=o.generateListReportInterfaceV2(e,a,i,s,c,l)}else if(n[r.SchemaType.ObjectPage]){const{genericSchema:e,entitySet:a,annotations:i,manifest:s,fragments:c,logger:l}=n[r.SchemaType.ObjectPage];t=o.generateObjectPageInterfaceV2(e,a,i,s,c,l)}else if(n[r.SchemaType.OverviewPage]){const{genericSchema:e,manifest:a}=n[r.SchemaType.OverviewPage];t=o.generateOVPInterfaceV2(e,a)}else if(n[r.SchemaType.AnalyticalListPage]){const{genericSchema:e,entitySet:a,annotations:i,manifest:s,fragments:c,logger:l}=n[r.SchemaType.AnalyticalListPage];t=o.generateAnalyticalListPageInterfaceV2(e,a,i,s,c,l)}}else if(e[a.FioriElementsVersion.v4]){const n=e[a.FioriElementsVersion.v4];if(n[r.SchemaType.ListReport]){const{genericSchema:e,entitySet:a,annotations:i,logger:o}=n[r.SchemaType.ListReport];t=s.generateListReportInterfaceV4(e,a,i,o)}else if(n[r.SchemaType.ObjectPage]){const{genericSchema:e,entitySet:a,annotations:i,manifest:o,logger:c}=n[r.SchemaType.ObjectPage];t=s.generateObjectPageInterfaceV4(e,a,i,o,c)}else if(n[r.SchemaType.AnalyticalListPage]){const{genericSchema:e,entitySet:a,annotations:i,logger:o}=n[r.SchemaType.AnalyticalListPage];t=s.generateListReportInterfaceV4(e,a,i,o)}}return t},t.exportConfig=function(e){let t;const n={ui5Version:e.ui5Version,layer:e.layer};if(e[a.FioriElementsVersion.v2]){const r=e[a.FioriElementsVersion.v2];t=c.exportPageV2(r,n)}else if(e[a.FioriElementsVersion.v4]){const r=e[a.FioriElementsVersion.v4];t=u.exportPageV4(r,n)}return t},t.importConfig=function(e){let t;if(e[a.FioriElementsVersion.v2]){const n=e[a.FioriElementsVersion.v2];n[r.SchemaType.ListReport]?t=l.createListReportConfig(n[r.SchemaType.ListReport]):n[r.SchemaType.ObjectPage]?t=l.createObjectPageConfigV2(n[r.SchemaType.ObjectPage]):n[r.SchemaType.OverviewPage]?t=l.createOverviewPageConfig(n[r.SchemaType.OverviewPage]):n[r.SchemaType.AnalyticalListPage]&&(t=l.createAnalyticalListPageConfig(n[r.SchemaType.AnalyticalListPage]))}else if(e[a.FioriElementsVersion.v4]){const n=e[a.FioriElementsVersion.v4];n[r.SchemaType.ListReport]?t=p.createListReportConfig(n[r.SchemaType.ListReport]):n[r.SchemaType.ObjectPage]?t=p.createObjectPageConfigV4(n[r.SchemaType.ObjectPage]):n[r.SchemaType.AnalyticalListPage]&&(t=p.createAnalyticalListPageConfig(n[r.SchemaType.AnalyticalListPage]))}return t},t.importProject=async function(e){return await f.importProjectSchemaAndConfig(e)},t.importProjectSchema=async function(e){return await f.importProjectSchema(e)},t.getApiVersion=function(){return{version:"2"}},t.generateCustomExtension=function(e){const t=i.FPMWriterMap.get(e.customExtension);return t&&"function"==typeof t?t(e.basePath,e.data,e.fsEditor):void 0}},6272:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});n(3435),n(4681);const a=n(8861);var r;!function(e){e.CustomPage="CustomPage",e.CustomColumn="CustomColumn"}(r=t.CustomExtensionType||(t.CustomExtensionType={})),t.FPMWriterMap=new Map([[r.CustomPage,a.generateCustomPage],[r.CustomColumn,a.generateCustomColumn]])},5921:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.Error="error",e.Warning="warning",e.Info="info"}(t.LogSeverity||(t.LogSeverity={})),t.LogSeverityLabel={error:"Error",warning:"Warning",info:"Information"},t.log=(e,n,...a)=>{e?e[n.severity](n.message,n.location,...a):n.location?n.location.range?console.log(`${t.LogSeverityLabel[n.severity]}: ${n.message}, location: ${n.location.path}, ${n.location.range}`,...a):console.log(`${t.LogSeverityLabel[n.severity]}: ${n.message}, location: ${n.location.path}`,...a):console.log(`${t.LogSeverityLabel[n.severity]}: ${n.message}`,...a)}},2449:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=a(n(9154)),i=a(n(2892)),o=n(1997);t.initI18n=function(e="en"){r.default.init({resources:{en:{translation:i.default}},lng:e,fallbackLng:"en",joinArrays:"\n\n"}),o.initI18n(r.default)}},4027:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(6971)),a(n(8517)),a(n(1097)),a(n(6272)),a(n(3435)),a(n(5921)),a(n(2735))},2735:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5622),r=n(5747),i=async e=>new Promise(((t,n)=>{r.readFile(e,{encoding:"utf8"},((e,a)=>{e?n(e):t(a)}))}));t.readDirectory=async e=>new Promise(((t,n)=>{r.readdir(e,{encoding:"utf8"},((e,a)=>{e?n(e):t(a)}))})),t.isDirectory=async e=>new Promise((t=>{r.stat(e,((e,n)=>{t(!e&&n.isDirectory())}))}));const o=async e=>new Promise((t=>{r.exists(e,(e=>{t(e)}))})),s=async e=>await(async e=>JSON.parse(await i(e)))(a.join(e,"manifest.json"));t.getProject=async e=>{const n=a.basename(e),r=a.join(e,"webapp"),c=await s(r);return{root:e,name:n,manifest:c,annotations:await(async(e,t)=>{const n=[],r=e["sap.app"].dataSources;if(r.mainService&&r.mainService.settings&&r.mainService.settings.localUri){const e=a.join(t,r.mainService.settings.localUri);n.push({dataSourceUri:e,fileContent:await i(e)})}if(r&&r.mainService&&r.mainService.settings&&r.mainService.settings.annotations)for(const e of r.mainService.settings.annotations){const o=a.join(t,r[e].settings.localUri);n.push({dataSourceUri:o,fileContent:await i(o)})}if(0===n.length)for(const e in r){const o=r[e];if("ODataAnnotation"===o.type&&o.settings&&o.settings.localUri){const e=a.join(t,o.settings.localUri);n.push({dataSourceUri:e,fileContent:await i(e)})}}return n})(c,r),changes:await(async e=>{const n=[],r=a.join(e,"changes");if(!await o(r))return n;const s=await t.readDirectory(r);for(const t of s)n.push(await i(a.join(e,"changes",t)));return n})(r),fragments:await(async e=>{const n=[],r=a.join(e,"ext","fragments");if(!await o(r))return n;const s=await t.readDirectory(r);for(const e of s){const t=a.join(r,e),o=await i(t);n.push({dataSourceUri:t,fileContent:o})}return n})(r)}}},6971:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(4681)),a(n(3404)),a(n(3435)),a(n(6904))},4681:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.ObjectPage="ObjectPage",e.ListReport="ListReport",e.OverviewPage="OverviewPage",e.CustomPage="CustomPage",e.AnalyticalListPage="AnalyticalListPage"}(n=t.PageType||(t.PageType={})),function(e){e.ObjectPage="ObjectPage",e.ListReport="ListReport",e.CustomPage="CustomPage",e.AnalyticalListPage="AnalyticalListPage"}(t.PageTypeV4||(t.PageTypeV4={})),function(e){e.v2="v2",e.v4="v4"}(t.FioriElementsVersion||(t.FioriElementsVersion={})),function(e){e.v2="v2",e.v4="v4"}(t.OdataVersion||(t.OdataVersion={})),t.PAGETYPE_VIEW_EXTENSION_TEMPLATE_MAP=new Map([[n.ListReport,"sap.suite.ui.generic.template.ListReport.view.ListReport"],[n.AnalyticalListPage,"sap.suite.ui.generic.template.AnalyticalListPage.view.AnalyticalListPage"],[n.ObjectPage,"sap.suite.ui.generic.template.ObjectPage.view.Details"]])},6904:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.OneColumn="OneColumn",e.TwoColumnsBeginExpanded="TwoColumnsBeginExpanded",e.TwoColumnsMidExpanded="TwoColumnsMidExpanded",e.MidColumnFullScreen="MidColumnFullScreen",e.ThreeColumnsMidExpanded="ThreeColumnsMidExpanded",e.ThreeColumnsEndExpanded="ThreeColumnsEndExpanded",e.ThreeColumnsMidExpandedEndHidden="ThreeColumnsMidExpandedEndHidden",e.ThreeColumnsBeginExpandedEndHidden="ThreeColumnsBeginExpandedEndHidden",e.EndColumnFullScreen="EndColumnFullScreen"}(t.FlexibleColumnLayoutType||(t.FlexibleColumnLayoutType={})),function(e){e.Vendor="VENDOR",e.Customer="CUSTOMER_BASE"}(t.FlexChangeLayer||(t.FlexChangeLayer={}))},6442:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.OData="OData",e.ODataAnnotation="ODataAnnotation"}(t.DataSourceType||(t.DataSourceType={})),function(e){e.ui="sap.ui",e.app="sap.app",e.generic="sap.ui.generic.app",e.ovp="sap.ovp",e.ui5="sap.ui5"}(n=t.ManifestSection||(t.ManifestSection={})),t.GENERICAPPSETTINGS=`${n.generic}/settings`},3404:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(6442)),a(n(5281))},5281:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FIORI_FCL_ROOT_VIEW_NAME="sap.fe.templates.RootContainer.view.Fcl",t.FIORI_FCL_ROOT_ID="appRootView",function(e){e.XML="XML",e.HTML="HTML",e.JS="JS",e.JSON="JSON"}(t.ViewTypes||(t.ViewTypes={})),t.SAPUI5_VIEW_CLASS="sap.ui.core.mvc.View",t.SAPUI5_FRAGMENT_CLASS="sap.ui.core.Fragment"},3435:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5747),r=n(5622);var i;!function(e){e.Application="Application",e.ObjectPage="ObjectPage",e.ListReport="ListReport",e.OverviewPage="OverviewPage",e.AnalyticalListPage="AnalyticalListPage"}(i=t.SchemaType||(t.SchemaType={}));t.getGenericSchema=async(e,t)=>{try{const n=((e,t)=>{const n=t===i.Application?i.Application+e.toUpperCase()+".json":t+"Config.json";return r.join(__dirname,"schemas",e,n)})(e,t);return await(async e=>new Promise(((t,n)=>{a.readFile(e,{encoding:"utf8"},((e,a)=>{e?n(e):t(JSON.parse(a))}))})))(n)}catch(n){throw new Error(`No schema available for type: ${t}, version: ${e}. Error was ${n.message}`)}}},3846:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.Top="Top",e.Middle="Middle",e.Bottom="Bottom"}(t.TableColumnVerticalAlignment||(t.TableColumnVerticalAlignment={}))},2387:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.bar="bar",e.column="column",e.line="line",e.combination="combination",e.pie="pie",e.donut="donut",e.scatter="scatter",e.bubble="bubble",e.heatmap="heatmap",e.bullet="bullet",e.verticalBullet="vertical_bullet",e.stackedBar="stacked_bar",e.stackedColumn="stacked_column",e.stackedCombination="stacked_combination",e.horizontalStackedCombination="horizontal_stacked_combination",e.dualBar="dual_bar",e.dualColumn="dual_column",e.dualLine="dual_line",e.dualStackedBar="dual_stacked_bar",e.dualStackedColumn="dual_stacked_column",e.dualCombination="dual_combination",e.dualStackedCombination="dual_stacked_combination",e.dualHorizontalCombination="dual_horizontal_combination",e.dualHorizontalStackedCombination="dual_horizontal_stacked_combination",e.hundredStackedBar="100_stacked_bar",e.hundredStackedColumn="100_stacked_column",e.hundredDualStackedBar="100_dual_stacked_bar",e.hundredDualStackedColumn="100_dual_stacked_column",e.waterfall="waterfall",e.horizontalWaterfall="horizontal_waterfall"}(t.ChartType||(t.ChartType={}))},6745:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.cardBubble="cardBubble",e.cardchartsline="cardchartsline",e.cardchartsdonut="cardchartsdonut"}(t.ChartCardType||(t.ChartCardType={})),function(e){e.analytical="sap.ovp.cards.charts.analytical",e.analyticalv4="sap.ovp.cards.v4.charts.analytical",e.list="sap.ovp.cards.list",e.listv4="sap.ovp.cards.v4.list",e.linklist="sap.ovp.cards.linklist",e.linklistv4="sap.ovp.cards.v4.linklist",e.table="sap.ovp.cards.table",e.tablev4="sap.ovp.cards.v4.table",e.stack="sap.ovp.cards.stack"}(t.CardTemplateType||(t.CardTemplateType={})),t.cardTemplateTypeMap={"sap.ovp.cards.charts.analytical":"AnalyticalCard","sap.ovp.cards.v4.charts.analytical":"AnalyticalCard","sap.ovp.cards.list":"ListCard","sap.ovp.cards.v4.list":"ListCard","sap.ovp.cards.linklist":"LinklistCard","sap.ovp.cards.v4.linklist":"LinklistCard","sap.ovp.cards.table":"TableCard","sap.ovp.cards.v4.table":"TableCard","sap.ovp.cards.stack":"StackCard"},function(e){e.analyticalCardSettings="analyticalCardSettings",e.analyticalCardSettingsv4="analyticalCardSettingsv4",e.listCardSettings="listCardSettings",e.listCardSettingsv4="listCardSettingsv4",e.stackCardSettings="stackCardSettings",e.linkListCardSettings="linkListCardSettings",e.tableCardSettings="tableCardSettings",e.tableCardSettingsv4="tableCardSettingsv4"}(t.CardSettingsType||(t.CardSettingsType={})),function(e){e.average="average",e.max="max",e.min="min",e.sum="sum",e.count="$count"}(t.MeasureAggregateValues||(t.MeasureAggregateValues={})),function(e){e.standard="standard",e.bar="bar",e.carousel="carousel"}(t.ListFlavorType||(t.ListFlavorType={})),function(e){e.extended="extended",e.condensed="condensed"}(t.ListTypeType||(t.ListTypeType={})),function(e){e.ascending="ascending",e.descending="descending"}(t.SortOrderType||(t.SortOrderType={})),function(e){e.standard="standard",e.carousel="carousel"}(t.LinkListFlavorType||(t.LinkListFlavorType={}))},2922:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.DATERANGE="DATERANGE",e.DATE="DATE",e.FROM="FROM",e.TO="TO",e.DAYS="DAYS",e.LASTDAYS="LASTDAYS",e.LASTWEEKS="LASTWEEKS",e.WEEK="WEEK",e.LASTMONTHS="LASTMONTHS",e.MONTH="MONTH",e.QUARTER="QUARTER",e.LASTQUARTERS="LASTQUARTERS",e.LASTYEARS="LASTYEARS",e.LASTYEAR="LASTYEAR",e.YEAR="YEAR",e.NEXTDAYS="NEXTDAYS",e.NEXTWEEKS="NEXTWEEKS",e.NEXTMONTHS="NEXTMONTHS",e.NEXTQUARTERS="NEXTQUARTERS",e.NEXTYEARS="NEXTYEARS",e.NEXT="NEXT",e.SPECIFICMONTH="SPECIFICMONTH",e.YESTERDAY="YESTERDAY",e.YEARTODATE="YEARTODATE",e.TODAY="TODAY",e.TOMORROW="TOMORROW",e.THISWEEK="THISWEEK",e.LASTWEEK="LASTWEEK",e.LAST2WEEKS="LAST2WEEKS",e.LAST3WEEKS="LAST3WEEKS",e.LAST4WEEKS="LAST4WEEKS",e.LAST5WEEKS="LAST5WEEKS",e.NEXTWEEK="NEXTWEEK",e.NEXT2WEEKS="NEXT2WEEKS",e.NEXT3WEEKS="NEXT3WEEKS",e.NEXT4WEEKS="NEXT4WEEKS",e.NEXT5WEEKS="NEXT5WEEKS",e.THISMONTH="THISMONTH",e.LASTMONTH="LASTMONTH",e.NEXTMONTH="NEXTMONTH",e.THISQUARTER="THISQUARTER",e.LASTQUARTER="LASTQUARTER",e.NEXTQUARTER="NEXTQUARTER",e.QUARTER1="QUARTER1",e.QUARTER2="QUARTER2",e.QUARTER3="QUARTER3",e.QUARTER4="QUARTER4",e.TODAYFROMTO="TODAYFROMTO"}(t.DateRangeType||(t.DateRangeType={}))},7876:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.AfterFacet="AfterFacet",e.BeforeFacet="BeforeFacet",e.ReplaceFacet="ReplaceFacet"}(t.SectionPosition||(t.SectionPosition={})),function(e){e.XML="XML"}(t.ExtensionFragmentTypes||(t.ExtensionFragmentTypes={}))},9649:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.inline="inline"}(t.CreateMode||(t.CreateMode={}))},2906:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.XML="XML"}(t.customColumnViewTypes||(t.customColumnViewTypes={})),function(e){e.ResponsiveTable="ResponsiveTable",e.GridTable="GridTable",e.AnalyticalTable="AnalyticalTable",e.TreeTable="TreeTable"}(t.TableTypeV2||(t.TableTypeV2={})),function(e){e.ResponsiveTableColumnsExtension="ResponsiveTableColumnsExtension",e.AnalyticalTableColumnsExtension="AnalyticalTableColumnsExtension",e.TreeTableColumnsExtension="TreeTableColumnsExtension",e.GridTableColumnsExtension="GridTableColumnsExtension"}(t.TableColumnExtensionTypeV2||(t.TableColumnExtensionTypeV2={})),function(e){e.extension="extension"}(t.Strategy||(t.Strategy={})),function(e){e.charttable="charttable",e.chart="chart",e.table="table"}(t.DefaultContentView||(t.DefaultContentView={})),function(e){e.visual="visual",e.compact="compact"}(t.DefaultFilterMode||(t.DefaultFilterMode={})),function(e){e.always="always",e.never="never",e.ifAnyFilterExist="ifAnyFilterExist"}(t.LoadDataOnAppLaunchSettings||(t.LoadDataOnAppLaunchSettings={}))},6402:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(2922)),a(n(2906)),a(n(7876)),a(n(6745)),a(n(9649)),a(n(2387))},390:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(3800)),a(n(6402)),a(n(9809)),a(n(3846))},2505:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.fixed="fixed",e.resizable="resizable"}(t.ContainerLayoutType||(t.ContainerLayoutType={}))},3800:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}(n(2505))},9809:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}(n(7900))},7900:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(4867)),a(n(1374))},1374:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});n(5877);t.SAPUI5_VIEW_EXTENSION="sap.ui.viewExtensions",t.SAPUI5_CONTROLLER_EXTENSION="sap.ui.controllerExtensions",t.SAPUI5_VIEW_EXTENSION_OBJECT_PAGE="sap.suite.ui.generic.template.ObjectPage.view.Details",t.SAPUI5_VIEW_EXTENSION_LIST_REPORT="sap.suite.ui.generic.template.ListReport.view.ListReport",t.SAPUI5_VIEW_EXTENSION_ANALYTICAL_LIST_PAGE="sap.suite.ui.generic.template.AnalyticalListPage.view.AnalyticalListPage"},4867:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FE_TEMPLATE_V2="sap.suite.ui.generic.template",t.FE_TEMPLATE_V2_OBJECT_PAGE="sap.suite.ui.generic.template.ObjectPage",t.FE_TEMPLATE_V2_LIST_REPORT="sap.suite.ui.generic.template.ListReport",t.FE_TEMPLATE_V2_ALP="sap.suite.ui.generic.template.AnalyticalListPage"},9734:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e["not-adaptable-visibility"]="not-adaptable-visibility"}(t.DesigntimeValues||(t.DesigntimeValues={}))},8554:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.Tabs="Tabs",e.Page="Page"}(t.SectionLayoutType||(t.SectionLayoutType={}))},4685:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.After="After",e.Before="Before"}(t.SectionPosition||(t.SectionPosition={})),function(e){e.XML="XML"}(t.CustomSectionViewTypesV4||(t.CustomSectionViewTypesV4={}))},7093:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.Multi="Multi",e.None="None",e.Single="Single",e.Auto="Auto"}(t.SelectionMode||(t.SelectionMode={})),function(e){e.ResponsiveTable="ResponsiveTable",e.GridTable="GridTable",e.AnalyticalTable="AnalyticalTable"}(t.TableTypeV4||(t.TableTypeV4={})),function(e){e.NewPage="NewPage",e.Inline="Inline",e.CreationRow="CreationRow"}(t.TableCreationModeType||(t.TableCreationModeType={})),function(e){e.Disabled="Disabled",e.Enabled="Enabled",e.Auto="Auto"}(t.InitialLoadType||(t.InitialLoadType={}))},8452:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.single="single",e.multi="multi"}(t.SelectType||(t.SelectType={}))},1709:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(7093)),a(n(8452)),a(n(9734)),a(n(8554)),a(n(4685))},5877:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(2616)),a(n(1709)),a(n(5113))},5759:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.None="None",e.Control="Control",e.Page="Page"}(t.VariantManagementTypeListReport||(t.VariantManagementTypeListReport={}))},8999:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.None="None",e.Control="Control"}(t.VariantManagementTypeObjectPage||(t.VariantManagementTypeObjectPage={}))},2616:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(8999)),a(n(5759))},5113:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}(n(6568))},5817:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.After="After",e.Before="Before",e.End="End"}(t.Placement||(t.Placement={})),function(e){e.Default="Default",e.Adaptation="Adaptation",e.Hidden="Hidden"}(t.Availability||(t.Availability={}))},6568:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(8778)),a(n(8741)),a(n(3404)),a(n(5817))},8741:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FIORI_FCL_ROUTER_CLASS="sap.f.routing.Router",function(e){e.BeginColumnPages="beginColumnPages",e.MidColumnPages="midColumnPages",e.EndColumnPages="endColumnPages"}(t.FlexibleColumnLayoutAggregations||(t.FlexibleColumnLayoutAggregations={})),t.SAPUI5_DEPENDENCY_LIB_SAP_F="sap.f"},8778:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FE_TEMPLATE_V4="sap.fe.templates",t.FE_TEMPLATE_V4_CUSTOM_PAGE="sap.fe.core.fpm",t.FE_TEMPLATE_V4_OBJECT_PAGE="sap.fe.templates.ObjectPage",t.FE_TEMPLATE_V4_LIST_REPORT="sap.fe.templates.ListReport",t.FE_TEMPLATE_V4_ALP="sap.fe.templates.AnalyticalListPage",t.SAPUI5_FRAGMENT_TYPE_V4="XMLFragment",function(e){e.AfterFacet="AfterFacet",e.BeforeFacet="BeforeFacet"}(t.SectionPositionV4||(t.SectionPositionV4={}))},4093:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(6971),r=n(8517),i=n(9081),o=n(3435);t.AppProvider=class AppProvider{constructor(e,t,n,r,s,c,l){this.unhandledControllers=[];const u=i.getSchemaFilePath(o.SchemaType.Application);this.app=Object.assign({$schema:u.path,id:e["sap.app"].id,pages:r,home:n,target:{fioriElements:s,odata:s===a.FioriElementsVersion.v2?a.OdataVersion.v2:a.OdataVersion.v4}},c&&{settings:c}),this.schemas=t,this.logger=l}createConfigFiles(){const e={},t={};let n;for(const t in this.app.pages)if(n=this.app.pages[t],n.config){const a=i.getSchemaFilePath(n.pageType,n.entitySet),o=n.config;if(this.schemas[a.filename])o.$schema=a.path;else{const e=i.getSchemaFilePath(n.pageType);o.$schema=e.path}e[`${r.DirName.Pages}/${t}.json`]=o}const a=JSON.parse(JSON.stringify(this.app));for(const e in a.pages)delete a.pages[e].config;return t[r.FileName.App]=a,{appConfig:t,pageConfigs:e}}}},3265:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(8517),r=n(9081);function i(e){return e.replace(/[^-A-Za-z0-9_.:]/g,(function(e){const t=e.charCodeAt(0).toString(16);return":"+(1===t.length?"0":"")+t}))}var o;t.buildControlIdFromParent=(e,t)=>e+t.join("::"),t.buildControlIdForPage=(e,t,n)=>e+t.join("::")+n[0],t.convertSectionId=(e,t)=>{let n;const r=a.FacetTitlePrefix;return n=void 0!==t?t.split(r)[1]:e.replace(new RegExp("/@","g"),"::").replace(/@com.sap/g,"com.sap"),n},t.escapeId=i,function(e){e.Editable="{ui>/editable}",e.NotEditable="{= !${ui>/editable}}"}(o=t.BindingValue||(t.BindingValue={})),t.buildColumnControlId=(e,n,r,o,s)=>{let c,l="listReport";const u=[...r];n=n.map((function(e){if("sections"===e)for(let e=0;e<u.length;e++){if("sections"===u[e]&&(c=u[e+1],-1!==c.indexOf("LineItem")))return u[e+1]=t.convertSectionId(c,s)+"::Table",u[e+1]}return e})),"sections"===u[0]&&(l=u[1].replace(/::com.sap.vocabularies/g,a.VOCWITHSLASH).replace(/::@com.sap.vocabularies/g,a.VOCWITHSLASH));const p=u[u.length-1].replace(/::com.sap.vocabularies/g,a.VOCWITHSLASH).replace(/::@com.sap.vocabularies/g,a.VOCWITHSLASH).replace("sTarget/@","sTarget::@");let f;const d=p.indexOf(":::");return f=p.startsWith("DataField")&&d>-1?e+"template:::TableColumn:::"+p.substr(0,d)+":::sSmartTableId::"+l.replace("::Table",":3a:3aTable")+":::"+p.substr(d+3):e+n.join("::")+"-"+p,i(f)};const s=(e,t,n,i)=>{const o=t&&t.properties;if(o[n].pattern)return;const s=o[n];let c=s;const l=s.$ref?e.definitions[s.$ref.split(r.DEFINITION_LINK_PREFIX)[1]]:s,u=s.description?s.description:l.description,p=function(e){let t=a.BindingPropertyRegexAsString;if(e.enum){let n;e.enum.forEach((e=>{e.toString().startsWith("{")||(n=n?n+"|"+e.toString():e.toString())})),t=`^(${n})$|${t}`}return e.type&&"boolean"===e.type&&(t=`^(false|true)$|${t}`),t}(l);l.type&&"boolean"===l.type&&(c={enum:[!1,!0]}),i&&c.enum&&i.forEach((e=>{-1===c.enum.indexOf(e)&&c.enum.push(e)})),o[n]={pattern:p,anyOf:[c,{type:"string"}]},u&&(o[n].description=u,delete s.description)};t.addPatternForBindingChangeOfEnumLR=(e,t,n)=>{s(e,t,n)},t.addPatternForBindingChangeOfEnumOP=(e,t,n)=>{const a=Object.values(o);s(e,t,n,a)}},2762:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),n(2775),t.reflectMetadataKey=Symbol("specificationMetadataKey"),t.syncRule=e=>Reflect.metadata(t.reflectMetadataKey,e),t.getReflectMetadata=function(e,n){if(e)return Reflect.getMetadata(t.reflectMetadataKey,e,n)},t.pageLayoutInformation=e=>t=>{t.prototype.pageLayoutInformation=e};const a=Symbol("childId");t.childId=e=>Reflect.metadata(a,e),t.getChildId=(e,t)=>Reflect.getMetadata(a,e,t),t.getPageLayoutInformation=e=>Object.getPrototypeOf(e).pageLayoutInformation,t.validityMetadataKey=Symbol("validityMetadataKey"),t.validity=e=>Reflect.metadata(t.validityMetadataKey,e),t.getTextForDeprecated=function(e,t){let n=e+" is deprecated";return t&&t.deprecated&&(n=t.deprecated.since?n+" since "+t.deprecated.since:n,n=t.deprecated.text?n+". "+t.deprecated.text:n),n}},6785:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.MetadataFactory=class MetadataFactory{constructor(e,t,n){this.controls=e,this.pages=t,this.pageTypes=n}createInstance(e,t,n,a){let r=this.controls[a]?this.controls[a]:this.controls[t];r||(r=this.pageTypes[e][a]?this.pageTypes[e][a]:this.pageTypes[e][t]);return r?Object.assign(new r,n):n}createPageInstance(e,t){const n=this.pages[e];return n?Object.assign(new n,t):null}}},4792:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(1684);t.exportToFlexChange=function(e,t){return a.createChangeString(e,t)}},5599:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(3265)),a(n(2762)),a(n(4792))},1684:function(e,t,n){"use strict";var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});const r=a(n(2281)).default.change,i={isCustomer:!1,sapui5Version:" ",creatingTool:"SAPFioriTools",type:"propertyChange"};t.createChangeString=function(e,t){let n="";try{for(const t in i)void 0===e[t]&&(e[t]=i[t]);n=r.createChangeString(e,t)}catch(e){console.error("Error while create flex change.",e)}return n},t.parseChangeString=function(e){try{return r.parse(e)}catch(e){return!1}},t.fillFlexChangeContent=function(e,t,n,a,r){const i=!n.layer||"CUSTOMER_BASE"===n.layer,o={controlId:r,controlType:t.flex.controlType(),content:{property:a},sapui5Version:n.ui5Version,isCustomer:i};return void 0!==e[a]?t.flex.exportFlexValue?t.flex.exportFlexValue(o,e,a):e[a].toString().startsWith("{")?(o.content.newBinding=e[a],o.type="propertyBindingChange"):o.content.newValue=e[a]:o.content.newValue=null,o}},3917:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(7898)),a(n(9152))},7898:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(1162),r=n(6971),i=n(5008);function o(e,t,n,o,s,c,l,u=!0){var p,f,d,h,g;const m=a.getStableIdPartFromDataField(n),y=l===r.FioriElementsVersion.v2&&m&&m.includes("::")?m.split("::").splice(1).join("::"):m,v=l===r.FioriElementsVersion.v2&&m&&m.includes("::")?m.split("::")[0].replace("DataField","Field"):void 0,b=l===r.FioriElementsVersion.v2?`${v}<${o}::${y}>`:`${o}::${y}`,P=i.prepareRef(`${e}Fields<${o}>`),S=i.prepareRef(`${e}Actions<${o}>`);if(n&&n.$Type){if("com.sap.vocabularies.UI.v1.DataFieldForAction"===n.$Type||"com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation"===n.$Type?u&&e===i.SectionType.Section&&(t.definitions[S].properties[y]={$ref:i.DEFINITION_LINK_PREFIX+b,propertyIndex:parseInt(s)}):t.definitions[P].properties[y]={$ref:i.DEFINITION_LINK_PREFIX+b,propertyIndex:parseInt(s)},t.definitions[b]={type:"object",isViewNode:!0,properties:{},description:i.getDatafieldDescription(n,c.entityType),additionalProperties:!1,annotationType:n.$Type},l===r.FioriElementsVersion.v4&&t.definitions.Field)switch(n.$Type){case"com.sap.vocabularies.UI.v1.DataField":case"com.sap.vocabularies.UI.v1.DataFieldForAnnotation":case"com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath":case"com.sap.vocabularies.UI.v1.DataFieldWithUrl":t.definitions[b].properties=t.definitions.Field.properties}else if(l===r.FioriElementsVersion.v2&&t.definitions.Field)switch(n.$Type){case"com.sap.vocabularies.UI.v1.DataField":case"com.sap.vocabularies.UI.v1.DataFieldForAnnotation":case"com.sap.vocabularies.UI.v1.DataFieldWithUrl":t.definitions[b].properties=t.definitions.Field.properties}"com.sap.vocabularies.UI.v1.DataFieldForAction"===n.$Type&&(null===(p=t.definitions)||void 0===p?void 0:p.FormAction)&&(t.definitions[b].properties=t.definitions.FormAction.properties),(null===(d=null===(f=n.Value)||void 0===f?void 0:f.$target)||void 0===d?void 0:d.type)&&(t.definitions[b].dataType=null===(g=null===(h=n.Value)||void 0===h?void 0:h.$target)||void 0===g?void 0:g.type.replace("Edm.","")),t.definitions[b].annotationPath=`/${c.entityType.fullyQualifiedName}/${n.fullyQualifiedName.split(c.entityType.fullyQualifiedName)[1]}`}}function s(e,t){let n,a,r=e.lastIndexOf("/");if(-1===r&&(r=e.lastIndexOf(".")),r>-1)n=e.substr(r+1),a=e.substr(0,r)+"::"+n;else{n=e;const r=t.fullyQualifiedName.split(t.name)[0];a=r.substr(0,r.length-1)+"::"+n}return{actionName:n,actionId:a}}t.handleForm=function(e,t,n,a,r,s=!0){var c;if(!t.target)return;const l=function(e){let t;return t=e.target&&e.target.qualifier&&e.entityType?`${e.entityType.name}::${e.base}::${e.target.qualifier}`:e.entityType?`${e.entityType.name}::${e.base}`:e.ID,t}(t),u=i.prepareRef(`${e}Form<${l}>`),p=i.prepareRef(`${e}Fields<${l}>`),f=i.prepareRef(`${e}Actions<${l}>`);if(n.properties.form={$ref:i.DEFINITION_LINK_PREFIX+u},e===i.SectionType.Section&&s?(a.definitions[u]={type:"object",properties:{actions:{$ref:i.DEFINITION_LINK_PREFIX+f},fields:{$ref:i.DEFINITION_LINK_PREFIX+p}},isViewNode:!0,description:"Form",additionalProperties:!1},a.definitions[f]={type:"object",properties:{},isViewNode:!0,description:"Actions",additionalProperties:!1}):a.definitions[u]={type:"object",properties:{fields:{$ref:i.DEFINITION_LINK_PREFIX+p}},isViewNode:!0,description:"Form",additionalProperties:!1},(null===(c=t.entityType)||void 0===c?void 0:c.name)&&(a.definitions[u].annotationPath=i.createAnnotationPath(t.entityType.fullyQualifiedName,t.target.term,t.target.qualifier)),a.definitions[p]={type:"object",properties:{},isViewNode:!0,description:"Fields",additionalProperties:!1},t.base===i.FacetBase.Identification)for(const n in t.target){const i=t.target[n];i&&o(e,a,i,l,n,t,r,s)}else for(const n in t.target.Data){o(e,a,t.target.Data[n],l,n,t,r)}},t.replaceAlias=function(e,t){const n=e.indexOf(".")>-1?e.split(".")[0]:void 0;let a=e;if(n){const r=t.references.find((e=>e.alias===n));r&&(a=e.replace(n,r.namespace))}return a},t.getActionNameAndId=s,t.addFooterActions=function(e,t,n){e.definitions.ObjectPageFooter=JSON.parse(JSON.stringify(e.definitions["ObjectPageFooter<GenericFooterActions>"])),e.properties.footer={$ref:`${i.DEFINITION_LINK_PREFIX}ObjectPageFooter`},e.definitions.ObjectPageFooter.properties.actions={$ref:`${i.DEFINITION_LINK_PREFIX}FooterActions`};const a=e.definitions.FooterActions={type:"object",properties:{},description:"Actions",additionalProperties:!1,isViewNode:!0},r=i.findAlias(i.UIVOCABULARY,n),o=r&&t.annotations&&t.annotations[r]&&t.annotations[r].Identification;if(o){const n=o.fullyQualifiedName.replace("@com.sap.vocabularies.UI.v1.Identification","/@com.sap.vocabularies.UI.v1.Identification");a.annotationPath=`/${n}`,o.forEach(((r,o)=>{if(r.Determining&&"com.sap.vocabularies.UI.v1.DataFieldForAction"===r.$Type){const{actionName:c,actionId:l}=s(r.Action,t),u=r.Label||c,p=i.prepareRef(`FooterAction<${l}>`);e.definitions[p]={isViewNode:!0,type:"object",properties:{},description:u,annotationPath:`/${n}/${o}`},a.properties[l]={$ref:`${i.DEFINITION_LINK_PREFIX}${p}`}}}))}else a.annotationPath=`/${t.fullyQualifiedName}/@com.sap.vocabularies.UI.v1.Identification`;delete e.definitions.GenericFooterActions,delete e.definitions.FooterAction,delete e.definitions["ObjectPageFooter<GenericFooterActions>"]},t.addHeaderActions=function(e,t,n,a){e.definitions.ObjectPageHeader.properties.actions={$ref:`${i.DEFINITION_LINK_PREFIX}HeaderActions`};const r=e.definitions.HeaderActions={type:"object",properties:{},description:"Actions",additionalProperties:!1,isViewNode:!0},o=i.findAlias(i.UIVOCABULARY,n),s=o&&t.annotations&&t.annotations[o]&&t.annotations[o].Identification;s?(r.annotationPath="/"+s.fullyQualifiedName.replace("@com.sap.vocabularies.UI.v1.Identification","/@com.sap.vocabularies.UI.v1.Identification"),s.forEach(a(t,e,s,r,n))):r.annotationPath=`/${t.fullyQualifiedName}/@com.sap.vocabularies.UI.v1.Identification`,delete e.definitions.GenericActions,delete e.definitions["ObjectPageHeader<GenericActions>"]},t.addCommonHeaderSchema=function(e,t){e.properties.header={$ref:i.DEFINITION_LINK_PREFIX+"ObjectPageHeader"},e.definitions.ObjectPageHeader=JSON.parse(JSON.stringify(e.definitions["ObjectPageHeader<GenericActions>"])),e.definitions.ObjectPageHeader.annotationPath=`/${t.fullyQualifiedName}/@com.sap.vocabularies.UI.v1.HeaderInfo`}},9152:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5008);function r(e,t,n){const a=e.annotations.UI;if(!a)return;const r=n.enum?n.enum:[];for(const e in a){const n=a[e];if(t.indexOf(n.term)>-1){const e=n.qualifier?`${n.term}#${n.qualifier}`:`${n.term}`;-1===r.indexOf(e)&&r.push(e)}}r.length>0&&(n.enum=r)}t.addEnumForValidAnnotations=r,t.addEnumForSingleTabVariant=function(e,t,n){r(e,["com.sap.vocabularies.UI.v1.SelectionVariant","com.sap.vocabularies.UI.v1.SelectionPresentationVariant"],t.definitions[n].properties.annotationPath)},t.addEnumForMultiTabVariant=function(e,t,n){const a=t.definitions[n].properties.annotationPath,i=["com.sap.vocabularies.UI.v1.SelectionVariant","com.sap.vocabularies.UI.v1.SelectionPresentationVariant","com.sap.vocabularies.UI.v1.PresentationVariant"];e.entitySets&&e.entitySets.forEach((e=>{r(e.entityType,i,a)}))},t.addEnumForVariantEntitySet=function(e,t,n){const a=t.definitions[n].properties.entitySet;if(e.entitySets){const t=[];e.entitySets.forEach((e=>{t.push(e.name)})),t.length>0&&(a.enum=t)}},t.addEnumForFilterBarAnnotationPath=function(e,t,n){r(e,["com.sap.vocabularies.UI.v1.SelectionVariant"],t.definitions[n].properties.annotationPath)},t.addDefinitionForRelatedFacetKeys=function(e,t,n,r){const i=n.map((e=>{const t=r.find((t=>!!e[t])),n=e[t];return Object.assign(Object.assign({const:n},e.label&&{description:e.label}),e.custom&&{custom:e.custom})}));if(i.length){e.definitions.RelatedFacetKeys={type:"string",oneOf:i};for(const n of t){const t=e.definitions[n],r=t.properties.relatedFacet;t.properties.relatedFacet={anyOf:[{$ref:a.DEFINITION_LINK_PREFIX+"RelatedFacetKeys"},r]}}}},t.addCommonLineItemDefinitions=function(e,t,n,r){let i;e.definitions[r]={type:"object",properties:{},additionalProperties:!1,isViewNode:!0,description:"Columns"};const o="LineItems"===r?"ToolBar":"ObjectPageToolBar",s=`${o}<${r}>`;e.definitions[s]=JSON.parse(JSON.stringify(e.definitions[`${o}`]));const c=`Actions<${a.prepareRef(r)}>`;e.definitions[s].properties.actions.$ref=a.DEFINITION_LINK_PREFIX+c;const l="LineItems"===r?"Actions":"ObjectPageToolBarActions",u=e.definitions[c]=JSON.parse(JSON.stringify(e.definitions[l]));return u.properties={},u.additionalProperties=!1,t&&(i=a.createAnnotationPath(n.fullyQualifiedName,t.term,t.qualifier),e.definitions[r].annotationPath=e.definitions[s].annotationPath=i),{actions:u,lineItemPath:i}},t.addFieldsType=function(e,t,n=""){const r=[],i={},o=`FieldPath${a.prepareRef(n)}`;for(const e of t.entityProperties){const t=e.name;r.push(t),i[t]={$ref:a.DEFINITION_LINK_PREFIX+o}}e.definitions[t.name]={enum:r},e.definitions[o].properties.path={$ref:a.DEFINITION_LINK_PREFIX+t.name};const s=`CreationFieldKeys${a.prepareRef(n)}`;e.definitions[s]={type:"object",properties:i,additionalProperties:!1},e.definitions[`Fields4Dialog${n}`].properties.fields.$ref=a.DEFINITION_LINK_PREFIX+s}},3436:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5008),r=n(5921);t.importProperty=function(e,t,n,a,r){const i=e.manifest.key||n,o=e.manifest.import;if(o&&"function"==typeof o){const e=o(t,r);void 0!==e&&(a[n]=e)}else void 0!==t[i]&&(a[n]=t[i])},t.checkDeprecatedProperties=function(e,t,n,i){if(t&&e)for(const o in t){const t=e[o];t&&(r.log(i,{severity:"warning",message:a.getTextForDeprecated(o,t),location:{path:"webapp/manifest.json/",range:n.split("/")}}),delete e[o])}},t.getSectionTitle=function e(t,n){if(!t.$ref||t.title)return t.title&&t.title.startsWith(a.FacetTitlePrefix)?t.title.split(a.FacetTitlePrefix)[1]:t.title?t.title:void 0;e(n.definitions[t.$ref.split(a.DEFINITION_LINK_PREFIX)[1]],n)}},7108:function(e,t,n){"use strict";var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t},r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=n(6971),o=n(3435),s=a(n(4867)),c=a(n(8778)),l=n(1918),u=n(3073),p=n(4370),f=n(6882),d=n(8083),h=n(8517),g=n(9081),m=r(n(9154)),y=n(5921),v=n(2449);function b(e){const t={Facets:[],LineItems:[]},n=null==e?void 0:e.entityTypes;if(n){const a=g.findAlias(h.UIVOCABULARY,e);for(const e of n){if(!e.annotations||!e.annotations[a])continue;const n=e.name||e.fullyQualifiedName.split(".").pop(),{LineItem:r,Facets:i}=e.annotations[a];r&&!r.qualifier&&r.find((e=>"com.sap.vocabularies.UI.v1.DataField"===e.$Type||"com.sap.vocabularies.UI.v1.DataFieldForAnnotation"===e.$Type))&&t.LineItems.push(n),i&&!i.qualifier&&t.Facets.push(n)}}return t}function P(e,t){return t&&t.entitySets&&t.entitySets.find((t=>t.name===e))}function S(e,t,n){const a=u.getPages(e.manifest[i.ManifestSection.generic].pages,s.FE_TEMPLATE_V2_OBJECT_PAGE);for(const r in a){const o=a[r].entitySet,s=P(o,null==e?void 0:e.serviceAVT),c=s&&s.entityType&&s.entityType.name,u=g.getSchemaFilePath(i.SchemaType.ObjectPage,(null==s?void 0:s.name)||o),p=g.getSchemaFilePath(i.SchemaType.ObjectPage);n[u.filename]=l.generateObjectPageSchemaV2(e,t[p.filename],c)}}function T(e,t,n){var a;const r=d.getPages(e.manifest,c.FE_TEMPLATE_V4_OBJECT_PAGE);for(const o in r){const s=r[o].options.settings.entitySet,c=P(s,null==e?void 0:e.serviceAVT);c||y.log(e.logger,{severity:"error",message:m.default.t("ENTITYSETNOTFOUND",{entitySet:s}),location:{path:h.METADATAPATH}});const l=c&&(null==c?void 0:c.entityType)&&(null===(a=null==c?void 0:c.entityType)||void 0===a?void 0:a.name),u=g.getSchemaFilePath(i.SchemaType.ObjectPage,(null==c?void 0:c.name)||s),p=g.getSchemaFilePath(i.SchemaType.ObjectPage);n[u.filename]=f.generateObjectPageSchemaV4(e,t[p.filename],l)}}async function O(e,t,n){const a=await async function(e,t){const n={};let a=[];switch(a=[i.SchemaType.Application],e){case g.TemplateType.ListReportObjectPageV2:case g.TemplateType.ListReportObjectPageV4:a.push(i.SchemaType.ListReport,i.SchemaType.ObjectPage);break;case g.TemplateType.AnalyticalListPageV2:case g.TemplateType.AnalyticalListPageV4:a.push(i.SchemaType.AnalyticalListPage,i.SchemaType.ObjectPage);break;case g.TemplateType.OverviewPageV2:a.push(i.SchemaType.OverviewPage)}for(const e of a)n[g.getSchemaFilePath(e).filename]=await o.getGenericSchema(t,e);return n}(n,e.fioriElementsVersion);return e.fioriElementsVersion===i.FioriElementsVersion.v4?function(e,t,n,a){const r={};if(n)if(a===g.TemplateType.ListReportObjectPageV4){const n=d.getPages(e.manifest,c.FE_TEMPLATE_V4_LIST_REPORT);for(const a in n){const o=n[a].options.settings.entitySet,s=P(o,null==e?void 0:e.serviceAVT),c=s&&s.entityType&&s.entityType.name,l=g.getSchemaFilePath(i.SchemaType.ListReport,(null==s?void 0:s.name)||o),u=g.getSchemaFilePath(i.SchemaType.ListReport);r[l.filename]=f.generateListReportSchemaV4(t[u.filename],c,null==e?void 0:e.serviceAVT,e.logger)}T(e,t,r)}else if(a===g.TemplateType.AnalyticalListPageV4){const n=d.getPages(e.manifest,c.FE_TEMPLATE_V4_ALP);for(const a in n){const o=n[a].options.settings.entitySet,s=P(o,null==e?void 0:e.serviceAVT),c=s&&s.entityType&&s.entityType.name,l=g.getSchemaFilePath(i.SchemaType.AnalyticalListPage,(null==s?void 0:s.name)||o),u=g.getSchemaFilePath(i.SchemaType.AnalyticalListPage);r[l.filename]=f.generateListReportSchemaV4(t[u.filename],c,null==e?void 0:e.serviceAVT,e.logger)}T(e,t,r)}return Object.assign(Object.assign({},t),r)}(e,a,t,n):function(e,t,n,a){var r;const o={};if(a===g.TemplateType.ListReportObjectPageV2&&n){const n=u.getPages(e.manifest[i.ManifestSection.generic].pages,s.FE_TEMPLATE_V2_LIST_REPORT);for(const a in n){const r=n[a].entitySet,s=P(r,null==e?void 0:e.serviceAVT),c=s&&s.entityType&&s.entityType.name,u=g.getSchemaFilePath(i.SchemaType.ListReport,(null==s?void 0:s.name)||r),p=g.getSchemaFilePath(i.SchemaType.ListReport);o[u.filename]=l.generateListReportSchemaV2(e,t[p.filename],c)}S(e,t,o)}else if(a===g.TemplateType.AnalyticalListPageV2&&n){const n=u.getPages(e.manifest[i.ManifestSection.generic].pages,s.FE_TEMPLATE_V2_ALP);for(const a in n){const s=n[a].entitySet,c=P(s,null==e?void 0:e.serviceAVT),u=null===(r=null==c?void 0:c.entityType)||void 0===r?void 0:r.name,p=g.getSchemaFilePath(i.SchemaType.AnalyticalListPage,(null==c?void 0:c.name)||s),f=g.getSchemaFilePath(i.SchemaType.AnalyticalListPage);o[p.filename]=l.generateAnalyticalListReportSchemaV2(e,t[f.filename],u)}S(e,t,o)}else if(a===g.TemplateType.OverviewPageV2){const n=g.getSchemaFilePath(i.SchemaType.OverviewPage),a=g.getSchemaFilePath(i.SchemaType.OverviewPage);o[n.filename]=l.generateOVPInterfaceV2(t[a.filename],e.manifest)}return Object.assign(Object.assign({},t),o)}(e,a,t,n)}function E(e,t){let n=[];for(const t of Object.keys(e).sort()){let a;a=t===i.SchemaType.Application?`${h.DirName.Schemas}/${h.FileName.App[0].toUpperCase()}${h.FileName.App.slice(1)}`:`${h.DirName.Schemas}/${t}.json`,n.push({dataSourceUri:a,fileContent:JSON.stringify(e[t],null,4)})}return t&&(n=n.concat(t)),n}t.getEntitySetByEntitySetName=P,t.importProjectSchema=async function(e){v.initI18n();let t=[];const n=g.getVersionFromManifest(e.manifest),a=g.parseAndMergeAndConvert(e.annotations,e.logger),r=b(a),i=g.getTemplateTypeFromManifest(e.manifest,n,e.logger),o={manifest:e.manifest,serviceAVT:a,fragments:e.fragments,fioriElementsVersion:n,logger:e.logger};if(i){t=E(await O(o,r,i))}return t},t.importProjectSchemaAndConfig=async function(e){v.initI18n();let t=[],n=[];const{manifest:a,annotations:r,flex:i,fragments:o,logger:s}=e,c=g.getVersionFromManifest(a),l=g.parseAndMergeAndConvert(r,s),f={manifest:e.manifest,serviceAVT:l,fragments:e.fragments,fioriElementsVersion:c,logger:e.logger},h=b(l),m=g.getTemplateTypeFromManifest(a,c,s);if(m){const e=await O(f,h,m);n=function(e,t,n,a,r){let i;const o=[];switch(a){case g.TemplateType.ListReportObjectPageV2:case g.TemplateType.AnalyticalListPageV2:i=new u.V2AppProvider(e,t,n,r);break;case g.TemplateType.AnalyticalListPageV4:case g.TemplateType.ListReportObjectPageV4:i=new d.V4AppProvider(e,n);break;case g.TemplateType.OverviewPageV2:i=new p.V2OvpProvider(e,n)}if(i){const{appConfig:e,pageConfigs:t}=i.createConfigFiles();for(const t in e)o.push({dataSourceUri:t,fileContent:JSON.stringify(e[t],null,4)});for(const e in t)o.push({dataSourceUri:e,fileContent:JSON.stringify(t[e],null,4)})}return o}(a,i,e,m,o),t=E(e,n)}return t}},5008:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(9081)),a(n(8517)),a(n(5599)),a(n(1684)),a(n(3436)),a(n(3917));var r=n(7108);t.importProjectSchemaAndConfig=r.importProjectSchemaAndConfig,t.importProjectSchema=r.importProjectSchema},8517:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.flex="flex",e.manifest="manifest"}(t.ExportArtifacts||(t.ExportArtifacts={})),function(e){e.Schemas=".schemas",e.Pages="pages"}(t.DirName||(t.DirName={})),function(e){e.App="app.json"}(t.FileName||(t.FileName={})),t.FacetTitlePrefix="Facet ID: ",function(e){e.Section="Section",e.HeaderSection="HeaderSection"}(t.SectionType||(t.SectionType={})),function(e){e.Manifest="Manifest",e.FlexChange="FlexChange",e.Annotation="Annotation"}(t.ArtifactType||(t.ArtifactType={})),function(e){e.Table="sap.m.Table",e.TableColumn="sap.m.Column",e.SmartTable="sap.ui.comp.smarttable.SmartTable",e.SmartFilterBar="sap.ui.comp.smartfilterbar.SmartFilterBar",e.SmartChart="sap.ui.comp.smartchart.SmartChart",e.SmartGroup="sap.ui.comp.smartform.SmartGroup",e.Button="sap.m.Button",e.ToolbarButton="sap.m.OverflowToolbarButton",e.Avatar="sap.f.Avatar",e.ObjectPageDynamicHeaderTitle="sap.uxap.ObjectPageDynamicHeaderTitle",e.ObjectPageGridProperties="sap.ui.layout.GridData",e.ObjectPageHeader="sap.uxap.ObjectPageHeader",e.ObjectPageLayout="sap.uxap.ObjectPageLayout",e.HeaderAction="sap.uxap.ObjectPageHeaderActionButton",e.DynamicPage="sap.f.DynamicPage",e.Form="sap.ui.layout.form",e.Chart="sap.suite.ui.microchart",e.Section="sap.uxap.ObjectPageSection",e.SubSection="sap.uxap.ObjectPageSubSection"}(t.ControlType||(t.ControlType={})),function(e){e.LineItem="LineItem",e.CollectionFacet="CollectionFacet",e.Chart="Chart",e.Form="Form",e.Identification="Identification",e.DataPoint="DataPoint",e.Address="Address",e.Contact="Contact",e.Unknown=""}(t.FacetBase||(t.FacetBase={})),t.BindingPropertyRegexAsString="^{[A-Za-z0-9{}&$!@#? _|,<>'()[\\]\\/:=.]+}$",function(e){e.ResponsiveTableColumnsExtension="ResponsiveTableColumnsExtension",e.AnalyticalTableColumnsExtension="AnalyticalTableColumnsExtension",e.TreeTableColumnsExtension="TreeTableColumnsExtension",e.GridTableColumnsExtension="GridTableColumnsExtension",e.ResponsiveTableCellsExtension="ResponsiveTableCellsExtension"}(t.ViewTemplateType||(t.ViewTemplateType={})),t.METADATAPATH="webapp/localService/metadata.xml",t.MANIFESTPATH="webapp/manifest.json",t.VOCWITHSLASH="/@com.sap.vocabularies",t.VOCWITHCOLONS="::@com.sap.vocabularies",t.UIVOCABULARY="com.sap.vocabularies.UI.v1",t.QUICKVARPATH="/quickVariantSelection",t.QUICKVARPATHX="/quickVariantSelectionX",t.DATESETTINGSPATH="/filterSettings/dateSettings",t.TOOLBAR="ToolBar<LineItems>",t.FRAGMENTNAMEPART=".fragment."},9081:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(8517),i=n(4350),o=n(1014),s=n(6971),c=n(3435),l=a(n(9154)),u=n(390),p=n(5877),f=n(5921),d=a(n(4225));var h;function g(e,t,n){var a,r,i,o;if(null===(a=null==e?void 0:e.Common)||void 0===a?void 0:a.Label)if("string"==typeof e.Common.Label)n=e.Common.Label;else if("Path"===e.Common.Label.type){const a=t.resolvePath(e.Common.Label.path);a.value?n=a.value:"string"==typeof(null===(r=a.Common)||void 0===r?void 0:r.Label)&&(n=a.annotations.Common.Label)}else"string"==typeof(null===(o=null===(i=e.Common)||void 0===i?void 0:i.Label)||void 0===o?void 0:o.toString())&&(n=e.Common.Label.toString());return n}function m(e,t){var n,a;let r,i;return e.Value?"string"==typeof e.Value?i=t.entityProperties.find((t=>t.name===e.Value)):(i=t.resolvePath(e.Value.path),i||(i=e.Value.$target)):e.Target&&e.Target.$target&&e.Target.$target.Value&&(i=e.Target.$target.Value.$target),(null===(a=null===(n=null==i?void 0:i.annotations)||void 0===n?void 0:n.Common)||void 0===a?void 0:a.Label)&&(r=g(i.annotations,t,r)),r}function y(e,t,n){const a=m(e,t);return n||a||(e.Value.$target?e.Value.$target.name:e.Value.value||e.Value.path)}function v(e){if(e){const t=`${u.FE_TEMPLATE_V2}.`;return e.split(t)[1]}}function b(e){if(e){const t=`${p.FE_TEMPLATE_V4}.`;return e.split(t)[1]}}function P(e,t){let n=t.references.find((t=>t.namespace===e));return n||(n=t.references.find((t=>t.alias===e))),n||(n=t.references.find((t=>t.alias.toUpperCase()===e.split("SAP__")[e.split("SAP__").length-1].toUpperCase()))),null==n?void 0:n.alias}function S(e,n,a,r,i=s.FioriElementsVersion.v2,o=!1){var c;const u=e.fullyQualifiedName.substr(e.fullyQualifiedName.lastIndexOf("@"));let p=e.ID?e.ID.toString():u,d=n;if("com.sap.vocabularies.UI.v1.CollectionFacet"!==e.$Type&&"Target"in e){const u=t.getAnnotationPropertyValue(e.Target);if(!u)return void f.log(r,{severity:"error",message:l.default.t("NOTARGET",{target:e.Target})});const h=u.split("/"),g=h.length>1?h[0]:"";g&&(d=null===(c=n.resolvePath(g))||void 0===c?void 0:c.targetType),function(e,t,n){const a=(t[1]||t[0]).split("#")[0];if(a.includes(".LineItem")){const t=e.split("::");t[t.length-1]=(n?"":"@")+"com.sap.vocabularies.UI.v1.LineItem",e=t.join("::")}else e=a.replace("@UI",(n?"":"@")+"com.sap.vocabularies.UI.v1")}(p,h,o);const m=function(e,t,n){var a;const r=e[e.length-1],i=r.substring(r.lastIndexOf(".")+1,r.length),o=P(r.substring(0,r.lastIndexOf(".")).replace("@",""),n);return null===(a=null==t?void 0:t.annotations[o])||void 0===a?void 0:a[i]}(h,d,a);if(!m)return;{const e=i===s.FioriElementsVersion.v2?"::":"#";p=function(e,t=!1){return`${t?"":"@"}${e.qualifier?e.term+"#"+e.qualifier:e.term}`}(m,o).replace("#",e)}if(g){p=`${g}${i===s.FioriElementsVersion.v2?"::":"/"}${p}`}}return p=p.replace(/\//gi,"::"),p?Object.assign(Object.assign(Object.assign({key:p},e.Label&&{label:e.Label.toString()}),e.ID&&{ID:e.ID.toString()}),{entityType:d}):void 0}function T(e,t,n,a,i,o=s.FioriElementsVersion.v2,c){var u;const p=S(e,a,t,c,o,!1);if(p)switch(e.$Type){case"com.sap.vocabularies.UI.v1.ReferenceFacet":!function(e,t,n,a,i,o=s.FioriElementsVersion.v2,c){var u,p,d,h,g,m;const y=P(r.UIVOCABULARY,i);let v=e?e.key:"";const b=e.entityType;let S,T;if(v.includes("com.sap.vocabularies.UI.v1.Chart")||v.includes(y+".Chart"))n[v]={base:r.FacetBase.Chart},n[v].entityType=b;else if(v.includes("com.sap.vocabularies.UI.v1.Identification")||v.includes(y+".Identification"))S=v.split(".")[v.split(".").length-1],T=b.annotations[y][S],n[v]={base:r.FacetBase.Identification},n[v].entityType=b,n[v].target=T;else if(a&&(v.includes("com.sap.vocabularies.UI.v1.LineItem")||v.includes(y+".LineItem"))){if(!v.includes("com.sap.vocabularies.UI.v1.LineItem")&&v.includes(".LineItem")){const e=v.split("::");e[e.length-1]="@com.sap.vocabularies.UI.v1.LineItem",v=e.join("::")}n[v]={base:r.FacetBase.LineItem},n[v].target=null===(u=null==t?void 0:t.Target)||void 0===u?void 0:u.$target,n[v].entityType=b}else v.includes("com.sap.vocabularies.UI.v1.FieldGroup")||v.includes(y+".FieldGroup")?(n[v]={base:r.FacetBase.Form},n[v].target=null===(p=null==t?void 0:t.Target)||void 0===p?void 0:p.$target,n[v].entityType=b):v.includes("com.sap.vocabularies.UI.v1.DataPoint")||v.includes(y+".DataPoint")?(n[v]={base:r.FacetBase.DataPoint},n[v].target=null===(d=null==t?void 0:t.Target)||void 0===d?void 0:d.$target,n[v].entityType=b,n[v].Label=null===(h=null==t?void 0:t.Target)||void 0===h?void 0:h.$target.Title):v.includes("com.sap.vocabularies.Communication.v1.Contact")||v.includes(y+".Contact")?(n[v]={base:r.FacetBase.Contact},n[v].target=null===(g=null==t?void 0:t.Target)||void 0===g?void 0:g.$target,n[v].entityType=b):v.includes("com.sap.vocabularies.Communication.v1.Address")||v.includes(y+".Address")?(n[v]={base:r.FacetBase.Address},n[v].target=null===(m=null==t?void 0:t.Target)||void 0===m?void 0:m.$target,n[v].entityType=b):n[v]={base:r.FacetBase.Unknown};n[v]&&(n[v].annotationPath=`/${t.fullyQualifiedName.replace("@com.sap.vocabularies",r.VOCWITHSLASH)}`,t.Label&&(n[v].Label=t.Label),t.ID?n[v].ID=t.ID:o===s.FioriElementsVersion.v4&&f.log(c,{severity:"error",message:l.default.t("NOID4SECTION",{facet:t.fullyQualifiedName})}),e&&e.entityType&&(n[v].entityType=e.entityType))}(p,e,i,a,t,o,c);break;case"com.sap.vocabularies.UI.v1.CollectionFacet":{const s=`/${a.fullyQualifiedName}/${e.fullyQualifiedName.split(a.fullyQualifiedName)[1]}`,l=i[p.key]={base:r.FacetBase.CollectionFacet,facets:{},ID:p.ID,annotationPath:s,Label:p.label};null===(u=e.Facets)||void 0===u||u.forEach((e=>{T(e,t,n,a,l.facets,o,c)}));break}}}function O(e,t){let n;if(e[p.ManifestSection.generic]){const a=e[p.ManifestSection.generic].pages;if(!a)return void f.log(t,{severity:"error",message:l.default.t("NOPAGES",{appId:e["sap.app"].id}),location:{path:r.MANIFESTPATH,range:[p.ManifestSection.generic]}});for(const e in a){const t=a[e];if(v(t.component.name)===s.PageType.AnalyticalListPage){n=h.AnalyticalListPageV2;break}if(v(t.component.name)===s.PageType.ListReport){n=h.ListReportObjectPageV2;break}}}else n||f.log(t,{severity:"error",message:l.default.t("NOTEMPLATE",{section:p.ManifestSection.generic}),location:{path:r.MANIFESTPATH,range:[p.ManifestSection.generic]}});return n}function E(e,t){let n;const a=e[p.ManifestSection.ui5].routing&&e[p.ManifestSection.ui5].routing.targets;if(a){for(const e in a){const t=b(a[e].name);if(t===s.PageTypeV4.AnalyticalListPage){n=h.AnalyticalListPageV4;break}if(t===s.PageTypeV4.ListReport||t===s.PageTypeV4.ObjectPage){n=h.ListReportObjectPageV4;break}}return n||f.log(t,{severity:"error",message:l.default.t("NOTEMPLATE",{section:p.ManifestSection.ui5}),location:{path:r.MANIFESTPATH,range:[p.ManifestSection.ui5,"routing","targets"]}}),n}f.log(t,{severity:"error",message:l.default.t("NOPAGES",{appId:e["sap.app"].id}),location:{path:r.MANIFESTPATH,range:[p.ManifestSection.ui5,"routing"]}})}function _(e,t,n){(null==e?void 0:e.ID)?t.title=r.FacetTitlePrefix+e.ID:t.title=n.substr(n.lastIndexOf(".")+1),(null==e?void 0:e.Label)?t.description=e.Label:(null==e?void 0:e.ID)?t.description=e.ID:t.description=n.substr(n.lastIndexOf(".")+1)}!function(e){e.ListReportObjectPageV2="ListReportObjectPageV2",e.ListReportObjectPageV4="ListReportObjectPageV4",e.OverviewPageV2="OverviewPageV2",e.AnalyticalListPageV2="AnalyticalListPageV2",e.AnalyticalListPageV4="AnalyticalListPageV4"}(h=t.TemplateType||(t.TemplateType={})),t.DEFINITION_LINK_PREFIX="#/definitions/",t.createAnnotationPath=(e,t,n)=>{let a=`/${e}/@${t}`;return n&&(a+=`#${n}`),a},t.parseAndMergeAndConvert=function(e,t){const n=[];let a;try{if(e&&e.forEach((function(e){n.push(o.parseEDMX(e.fileContent,e.dataSourceUri))})),n.length>0&&(a=i.convertTypes(o.merge(n))),t&&(null==a?void 0:a.diagnostics))for(const e of a.diagnostics)f.log(t,{severity:"error",message:e.message});return a}catch(e){f.log(t,{severity:"error",message:l.default.t("ANNOERR")},...e)}},t.getAnnotationPropertyValue=e=>(null==e?void 0:e.value)||(null==e?void 0:e.path),t.evaluateCommonLabel=g,t.getLabelForPropertyPath=function(e,t){let n=e.value;return e.$target&&(n=g(e.$target.annotations,t,n)),n},t.getLabelForDataField=m,t.getDatafieldDescription=function(e,t){let n,a,r="";const i=function(e,t){var n,a;if("string"==typeof e)return e;if("object"==typeof e&&e.path){const r=t.resolvePath(e.path);if(!r||0===r.length)return;{const i=r[0];if(null===(a=null===(n=null==i?void 0:i.annotations)||void 0===n?void 0:n.Common)||void 0===a?void 0:a.Label){const n=e;return g(i.annotations,t,n)}}}}(e.Label,t);switch(e.$Type){case"com.sap.vocabularies.UI.v1.DataField":a=e,r=y(a,t,i);break;case"com.sap.vocabularies.UI.v1.DataFieldWithUrl":a=e,n=m(e,t),r=i||n||("string"==typeof a.Value?a.Value:a.Value.path);break;case"com.sap.vocabularies.UI.v1.DataFieldForAnnotation":a=e,n=m(e,t),r=i||n||a.Target.$target.Title||a.Target.value;break;case"com.sap.vocabularies.UI.v1.DataFieldForAction":case"com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation":a=e,r=i?"string"==typeof i?i:a.Action:e.Action;break;case"com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation":a=e,n=m(e,t),r=n||a.Value.path;break;case"com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath":a=e,r=y(a,t,i)}return r},t.getPageTypeV2=v,t.getPageTypeV4=b,t.findAlias=P,t.getSectionFacet=S,t.getManifestSectionByPathV4=(e,t,n,a)=>{let r=e;return t.split("/").forEach((function(e){a&&a===e&&(e=n),r[e]||(r[e]={}),r=r[e]})),r},t.getSchemaKeyOfLineItemRecord=function(e){let n,a,r;switch(e.$Type){case"com.sap.vocabularies.UI.v1.DataField":n=t.getAnnotationPropertyValue(e.Value);break;case"com.sap.vocabularies.UI.v1.DataFieldWithUrl":n="string"==typeof e.Value?e.Value:t.getAnnotationPropertyValue(e.Value);break;case"com.sap.vocabularies.UI.v1.DataFieldForAnnotation":a=e.Target.value,a&&(n="DataFieldForAnnotation:::sTarget::"+a.replace("@UI","@com.sap.vocabularies.UI.v1").replace("@Communication","@com.sap.vocabularies.Communication.v1").replace("@Contact","@com.sap.vocabularies.Contact.v1"));break;case"com.sap.vocabularies.UI.v1.DataFieldForAction":e.Inline&&(n="DataFieldForAction:::sAction::"+e.Action);break;case"com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation":r=t.getAnnotationPropertyValue(e.Value),n="DataFieldWithIntentBasedNavigation:::sProperty::"+r+":::sSemanticObject::"+e.SemanticObject+":::sAction::"+e.Action;break;case"com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation":e.Inline&&(n="DataFieldForIntentBasedNavigation:::sSemanticObject::"+e.SemanticObject+":::sAction::"+e.Action);break;case"com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath":r=t.getAnnotationPropertyValue(e.Value),a=t.getAnnotationPropertyValue(e.Target),n="DataFieldWithNavigationPath:::sProperty::"+r+":::sTarget::"+a}return n},t.getObjectPageHeaderFacets=function(e,t,n=s.FioriElementsVersion.v2,a){const i={};if(!e||!e.annotations)return;const o=P(r.UIVOCABULARY,t),c=o&&e.annotations[o]&&e.annotations[o].HeaderFacets;if(c){const r=e.fullyQualifiedName.lastIndexOf("."),o=e.fullyQualifiedName.substr(0,r);c.forEach((r=>{T(r,t,o,e,i,n,a)}))}return i},t.getObjectPageFacets=function(e,t,n=s.FioriElementsVersion.v2,a){const i={};if(!e||!e.annotations)return;const o=P(r.UIVOCABULARY,t),c=o&&e.annotations[o]&&e.annotations[o].Facets;if(c){const r=e.fullyQualifiedName.lastIndexOf("."),o=e.fullyQualifiedName.substr(0,r);c.forEach((r=>{T(r,t,o,e,i,n,a)}))}return i},t.getVersionFromManifest=function(e){return e[p.ManifestSection.generic]||e[p.ManifestSection.ovp]?s.FioriElementsVersion.v2:s.FioriElementsVersion.v4},t.determineV2Template=O,t.determineV4Template=E,t.getTemplateTypeFromManifest=function(e,t,n){let a;return e[p.ManifestSection.ovp]?a=h.OverviewPageV2:t===s.FioriElementsVersion.v2?a=O(e,n):t===s.FioriElementsVersion.v4?a=E(e,n):a||f.log(n,{severity:"error",message:l.default.t("NOFE"),location:{path:r.MANIFESTPATH}}),a},t.addSectionTitleAndDescription=_,t.createSectionWithoutProperties=function(e,t){if(!e)return;const n={type:"object",properties:{},additionalProperties:!1,annotationPath:e.annotationPath,isViewNode:!0};return _(e,n,t),n},t.getObjectPageFacetSection=function(e,t,n,a=s.FioriElementsVersion.v2,i=!1){const o=P(r.UIVOCABULARY,t);let c=[];if(e){const r=o&&e.annotations&&e.annotations[o]&&e.annotations[o].Facets;return r&&(c=r.reduce((function(r,o){if(i&&!o.ID&&(!("Target"in o)||!o.Target))return r;const s=S(o,e,t,n,a,!0);return s&&r.push(s),r}),c)),c}},t.deleteEmptyStructure=(e,n,a,r)=>{let i=e;const o=n.split("/");o.forEach((function(n){if(n===r&&(n=a),i[n])return 0===Object.keys(i[n]).length?(delete i[n],o.pop(),void t.deleteEmptyStructure(e,o.join("/"),a,r)):void(i=i&&i[n])}))};const C=e=>`${e}`;function A(e,n,a,r,i,o,s){let c;if("array"===r.type)return c=A(e,n,a,r.items,i,o,s),c;const l=function(e,n,a){const r=[];if(e.$ref)r.push(e.$ref.split(t.DEFINITION_LINK_PREFIX)[1]);else if(e.anyOf&&(n&&e.anyOf.forEach((e=>{if(e.$ref){const i=e.$ref.split(t.DEFINITION_LINK_PREFIX)[1];if(a.definitions[i]){const t=a.definitions[i].controlProperty;e.$ref.includes(n[t])&&r.push(i)}}})),0===r.length))return;return r}(r,a,e);return l?(c=function(e,t,n,a,r,i,o,s){var c,l,u;let p={configObject:void 0,targetDefinition:{},title:""};if(e.length){const s=e[e.length-1];if(p.targetDefinition=t.definitions[s],(null===(c=null==p?void 0:p.targetDefinition)||void 0===c?void 0:c.$ref)||"array"===(null===(l=null==p?void 0:p.targetDefinition)||void 0===l?void 0:l.type))return p=A(t,n,a,p.targetDefinition,r,i,o),p;e.length>1&&e.forEach((e=>{""!==e&&(p.targetDefinition.properties=Object.assign(Object.assign({},p.targetDefinition.properties),t.definitions[e].properties))})),p.title=(null===(u=null==p?void 0:p.targetDefinition)||void 0===u?void 0:u.title)?p.targetDefinition.title:n;const f=null==s?void 0:s.split("<")[0],d=a||{};p.configObject=i.createInstance(o,f,d,p.targetDefinition.controlProperty)}else p.targetDefinition=s,p.title=p.targetDefinition.title?p.targetDefinition.title:r,p.configObject=a;return p}(l,e,n,a,i,o,s,r),c):void 0}t.getSchemaFilePath=(e,t)=>{const n={filename:"",path:""};switch(e){case c.SchemaType.Application:n.filename="App",n.path=`./${r.DirName.Schemas}/${n.filename}`;break;case c.SchemaType.ListReport:case c.SchemaType.ObjectPage:n.filename=t?`${e}_${t}`:C(e),n.path=`../${r.DirName.Schemas}/${n.filename}`;break;default:n.filename=C(e),n.path=`../${r.DirName.Schemas}/${n.filename}`}return n.path+=".json",n},t.generatePageId=function(e,t,n,a){if(e===s.PageType.CustomPage){const e=a&&a.split(".");return e&&e[e.length-1]+"Page"}const r=[];return r.push(e),t&&r.push(t),n&&r.push(n),r.join("_")},t.getNextTargetDefinition=A,t.prepareRef=function(e){return e.replace("#","::").replace(/\//g,"::")},t.arrayCombineMerge=(e,t,n)=>{const a=e.slice();return t.forEach(((t,r)=>{void 0===a[r]?a[r]=n.cloneUnlessOtherwiseSpecified(t,n):n.isMergeableObject(t)?a[r]=d.default(e[r],t,n):-1===e.indexOf(t)&&a.push(t)})),a}},1997:function(e,t,n){"use strict";var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});const r=a(n(6354));t.initI18n=function(e){e.addResourceBundle(e.language,"translation",r)}},6088:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5599),i=n(390),o=n(6971),s=n(8517);t.getAppSettingPathV2=e=>`${o.ManifestSection.generic}/pages/${e[0]}/component/settings`,t.getTableSettingPathV2=e=>t.getAppSettingPathV2(e)+"/tableSettings",t.getChartSettingPathV2=e=>t.getAppSettingPathV2(e)+"/chartSettings",t.getDataLoadSettingPathV2=e=>t.getAppSettingPathV2(e)+"/dataLoadSettings",t.getCreationFieldsPathV2=(e,n,a)=>`${t.getTableSettingPathV2(e)}/createWithParameterDialog/fields/${a}`,t.getOVPsettingPath=()=>o.ManifestSection.ovp,t.getCardSettingsPath=e=>{const t=[o.ManifestSection.ovp+"/cards"];return e.forEach((e=>{e in i.CardSettingsType?t.push("settings"):t.push(e)})),t.pop(),t.join("/")},t.getGlobalSettingsPath=e=>{const t=[o.ManifestSection.ovp];return e.forEach((e=>{t.push(e)})),t.pop(),t.join("/")},t.getKPISettingsPath=(e,t,n)=>`${o.ManifestSection.generic}/pages/${e[0]}/component/settings/keyPerformanceIndicators/${n}`,t.getAppRootSettingOBJPath=e=>{const t=[o.ManifestSection.generic];return e.forEach((e=>{t.push("pages/"+e)})),t.join("/")},t.getAppSettingOBJPathV2=e=>{const n=[];return n.push(t.getAppRootSettingOBJPath(e)),n.push("component/settings"),n.join("/")},t.getAppSettingOBJsectionPathV2=(e,n,a)=>{const r=[];r.push(t.getAppRootSettingOBJPath(e));const i=a.replace(s.VOCWITHCOLONS,"::com.sap.vocabularies");return r.push("component/settings/sections/"+i),r.join("/")},t.getTableSettingsOBJsectionPathV2=(e,n,a)=>t.getAppSettingOBJsectionPathV2(e,{},a)+"/tableSettings",t.getChartSettingsOBJsectionPathV2=(e,n,a)=>t.getAppSettingOBJsectionPathV2(e,{},a)+"/chartSettings",t.getViewExtensionsPath=()=>`sap.ui5/extends/extensions/${i.SAPUI5_VIEW_EXTENSION}/${i.SAPUI5_VIEW_EXTENSION_OBJECT_PAGE}`,t.getObjectPageCustomSectionPath=(e,n,a,...r)=>{const i="|",o=a.split(i),s=e[e.length-1].split(i);let c="";4===o.length?c=[o[2],o[3]].join(i):3===o.length&&(c=o[2]);const l=[o[0],s[s.length-1],c].join(i);return r.unshift(l),t.getViewExtensionsPath()+"/"+r.join("/")};class ApplicationV2{}a([r.childId("settings")],ApplicationV2.prototype,"settings",void 0),t.ApplicationV2=ApplicationV2;class AppSettings{}a([r.syncRule({manifest:{path:()=>"sap.app"}})],AppSettings.prototype,"title",void 0),a([r.syncRule({manifest:{path:()=>"sap.app"}})],AppSettings.prototype,"description",void 0),a([r.syncRule({manifest:{path:()=>o.GENERICAPPSETTINGS}}),r.validity({since:"1.50.0"})],AppSettings.prototype,"flexibleColumnLayout",void 0),a([r.syncRule({manifest:{path:()=>o.GENERICAPPSETTINGS}}),r.validity({since:"1.46.0"})],AppSettings.prototype,"forceGlobalRefresh",void 0),a([r.syncRule({manifest:{path:()=>o.GENERICAPPSETTINGS}}),r.validity({since:"1.74.0"})],AppSettings.prototype,"tableColumnVerticalAlignment",void 0),a([r.syncRule({manifest:{path:()=>"sap.ui5"}}),r.validity({since:"1.56.0"})],AppSettings.prototype,"flexEnabled",void 0),t.AppSettings=AppSettings},8722:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5599),i=n(2762),o=n(8517),s=n(6088);t.getSmartChartControlId=e=>e+"chart";class ChartSettings{}a([i.syncRule({flex:{controlId:t.getSmartChartControlId,controlType:()=>o.ControlType.SmartChart,createFlexChange:r.exportToFlexChange}})],ChartSettings.prototype,"showLegendButton",void 0),a([i.syncRule({flex:{controlId:t.getSmartChartControlId,controlType:()=>o.ControlType.SmartChart,createFlexChange:r.exportToFlexChange}})],ChartSettings.prototype,"showDownloadButton",void 0),a([i.syncRule({flex:{controlId:t.getSmartChartControlId,controlType:()=>o.ControlType.SmartChart,createFlexChange:r.exportToFlexChange}})],ChartSettings.prototype,"showChartTypeSelectionButton",void 0),a([i.syncRule({flex:{controlId:t.getSmartChartControlId,controlType:()=>o.ControlType.SmartChart,exportFlexValue:(e,t,n)=>{e.content.newValue=t[n].join()},importFlexValue:(e,t,n)=>{e.content.newValue=e.content.newValue,t[n]=e.content.newValue.split(",")},createFlexChange:r.exportToFlexChange}})],ChartSettings.prototype,"ignoredChartTypes",void 0),a([i.syncRule({manifest:{path:e=>s.getChartSettingPathV2(e)}}),i.validity({since:"1.81.0"})],ChartSettings.prototype,"showDataLabel",void 0),t.ChartSettings=ChartSettings},8378:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(6088);class KPISettings{}a([r.syncRule({manifest:{path:(e,t,n)=>i.getKPISettingsPath(e,void 0,n)}})],KPISettings.prototype,"model",void 0),a([r.syncRule({manifest:{path:(e,t,n)=>i.getKPISettingsPath(e,void 0,n)}})],KPISettings.prototype,"entitySet",void 0),a([r.syncRule({manifest:{path:(e,t,n)=>i.getKPISettingsPath(e,void 0,n)}})],KPISettings.prototype,"qualifier",void 0),a([r.syncRule({manifest:{path:(e,t,n)=>i.getKPISettingsPath(e,void 0,n)}})],KPISettings.prototype,"filterable",void 0),a([r.syncRule({manifest:{path:(e,t,n)=>i.getKPISettingsPath(e,void 0,n)}})],KPISettings.prototype,"detailNavigation",void 0),a([r.syncRule({manifest:{path:(e,t,n)=>i.getKPISettingsPath(e,void 0,n)}})],KPISettings.prototype,"groupId",void 0),t.KPISettings=KPISettings},5682:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(6088);class CommonCardSettings{}a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CommonCardSettings.prototype,"entitySet",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CommonCardSettings.prototype,"title",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CommonCardSettings.prototype,"subTitle",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CommonCardSettings.prototype,"identificationAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CommonCardSettings.prototype,"selectionAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CommonCardSettings.prototype,"presentationAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CommonCardSettings.prototype,"defaultSpan",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CommonCardSettings.prototype,"requireAppAuthorization",void 0),t.CommonCardSettings=CommonCardSettings;class CustomCard extends CommonCardSettings{}a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"model",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"template",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"settings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"entitySet",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"itemText",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"valueSelectionInfo",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"staticContent",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"listFlavor",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"listType",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"sortBy",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"sortOrder",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"annotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"chartAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"dataPointAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"kpiAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"selectionPresentationAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"dynamicSubtitleAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"ignoreSapText",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"objectStreamCardsSettings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"enableLocaleCurrencyFormatting",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"navigation",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"showFilterInHeader",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"showSortingInHeader",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"imageSupported",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"showLineItemDetail",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"showLabelText",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"customParams",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"chartProperties",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],CustomCard.prototype,"colorPalette",void 0),t.CustomCard=CustomCard;class ListCard extends CommonCardSettings{}a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"model",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"template",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"settings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"listCardSettings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"tabs",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"listFlavor",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"listType",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"annotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"valueSelectionInfo",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"sortBy",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"sortOrder",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"addODataSelect",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],ListCard.prototype,"dataPointAnnotationPath",void 0),t.ListCard=ListCard;class AnalyticalCard extends CommonCardSettings{}a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],AnalyticalCard.prototype,"model",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],AnalyticalCard.prototype,"template",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],AnalyticalCard.prototype,"settings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],AnalyticalCard.prototype,"analyticalCardSettings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],AnalyticalCard.prototype,"chartAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],AnalyticalCard.prototype,"dataPointAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],AnalyticalCard.prototype,"valueSelectionInfo",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],AnalyticalCard.prototype,"tabs",void 0),t.AnalyticalCard=AnalyticalCard;class StackCard extends CommonCardSettings{}a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],StackCard.prototype,"model",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],StackCard.prototype,"template",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],StackCard.prototype,"settings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],StackCard.prototype,"stackCardSettings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],StackCard.prototype,"itemText",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],StackCard.prototype,"objectStreamCardsNavigationProperty",void 0),t.StackCard=StackCard;class LinklistCard{}a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"model",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"template",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"settings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"linkListCardSettings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"entitySet",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"title",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"subTitle",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"targetUri",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"listFlavor",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"sortBy",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"sortOrder",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"headerAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"identificationAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"defaultSpan",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"staticContent",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"requireAppAuthorization",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],LinklistCard.prototype,"annotationPath",void 0),t.LinklistCard=LinklistCard;class TableCard extends CommonCardSettings{}a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"model",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"template",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"disableTableCardFlexibility",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"settings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"tableCardSettings",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"annotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"listFlavor",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"listType",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"dataPointAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"selectionPresentationAnnotationPath",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"valueSelectionInfo",void 0),a([r.syncRule({manifest:{path:e=>i.getCardSettingsPath(e)}})],TableCard.prototype,"tabs",void 0),t.TableCard=TableCard},651:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5599),i=n(5008);class Field{}a([r.syncRule({flex:{controlId:(e,t,n)=>{const a=n.filter((e=>!t.includes(e)))[0].replace("@com.sap","com.sap"),i=n.slice(-1)[0],o=[a,i.includes("::")?i.split("Field::")[1]:i,"GroupElement"];return r.buildControlIdFromParent(e,o)},controlType:()=>i.ControlType.SmartGroup,createFlexChange:r.exportToFlexChange},generate:i.addPatternForBindingChangeOfEnumOP})],Field.prototype,"visible",void 0),t.Field=Field},296:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(5599),o=n(6088),s=n(5008),c=n(6971);function l(e){if(!e||!e.dateSettings)return;const t=JSON.parse(JSON.stringify(e.dateSettings));if("string"==typeof e.dateSettings.selectedValues&&(t.selectedValues=e.dateSettings.selectedValues.split(",")),e.dateSettings.fields)for(const n in e.dateSettings.fields){t.fields[n]=e.dateSettings.fields[n];const a=e.dateSettings.fields[n].selectedValues;"string"==typeof a&&(t.fields[n].selectedValues=a.split(","));for(const a in e.dateSettings.fields[n].filter){const r=e.dateSettings.fields[n].filter[a];t.fields[n].filter[a]=r,r.equals&&"string"==typeof r.equals&&(t.fields[n].filter[a].equals=r.equals.split(","))}}return t}function u(e,t,n){if(e[n]=JSON.parse(JSON.stringify(t[n])),"selectedValues"===n&&(e[n]=t[n].join()),"fields"===n)for(const a in t[n]){const r=t[n][a];if(r.selectedValues&&(e[n][a].selectedValues=r.selectedValues.join()),r.filter)for(const t in r.filter){const i=r.filter[t];i.equals&&Array.isArray(i.equals)&&(e[n][a].filter[t].equals=i.equals.join())}}}t.importDateSettings=l,t.exportDateSettings=u;class DateRange{}a([r.syncRule({manifest:{path:(e,t)=>t===c.PageType.OverviewPage?o.getOVPsettingPath()+s.DATESETTINGSPATH:o.getAppSettingPathV2(e)+s.DATESETTINGSPATH}}),r.validity({since:"1.77.0"})],DateRange.prototype,"useDateRange",void 0),a([r.syncRule({manifest:{path:e=>o.getAppSettingPathV2(e)+s.DATESETTINGSPATH,import:l,export:u}}),r.validity({since:"1.77.0"})],DateRange.prototype,"selectedValues",void 0),a([r.syncRule({manifest:{path:e=>o.getAppSettingPathV2(e)+s.DATESETTINGSPATH}}),r.validity({since:"1.77.0"})],DateRange.prototype,"exclude",void 0),a([r.syncRule({manifest:{path:e=>o.getAppSettingPathV2(e)+s.DATESETTINGSPATH,import:l,export:u}}),r.validity({since:"1.77.0"})],DateRange.prototype,"fields",void 0),t.DateRange=DateRange;class CommonFilterBar{}a([r.syncRule({manifest:{path:e=>o.getAppSettingPathV2(e)}}),r.validity({since:"1.38.0"})],CommonFilterBar.prototype,"smartVariantManagement",void 0),a([r.syncRule({flex:{controlId:i.buildControlIdFromParent,controlType:()=>s.ControlType.SmartFilterBar,createFlexChange:i.exportToFlexChange}}),r.validity({since:"1.40.0"})],CommonFilterBar.prototype,"liveMode",void 0),a([r.syncRule({manifest:{path:e=>o.getAppSettingPathV2(e)}}),r.validity({since:"1.48.0"})],CommonFilterBar.prototype,"variantManagementHidden",void 0),a([r.syncRule({manifest:{path:e=>o.getAppSettingPathV2(e)}}),r.validity({since:"1.52.0"})],CommonFilterBar.prototype,"subTitleIfVariantMgmtHidden",void 0),a([r.syncRule({manifest:{path:e=>o.getAppSettingPathV2(e)+"/filterSettings",import:l}}),r.validity({since:"1.77.0"})],CommonFilterBar.prototype,"dateSettings",void 0),a([r.syncRule({flex:{controlId:i.buildControlIdFromParent,controlType:()=>s.ControlType.SmartFilterBar,createFlexChange:i.exportToFlexChange}}),r.validity({since:"1.28.0"})],CommonFilterBar.prototype,"showClearOnFB",void 0),a([r.syncRule({flex:{controlId:i.buildControlIdFromParent,controlType:()=>s.ControlType.SmartFilterBar,createFlexChange:i.exportToFlexChange}}),r.validity({since:"1.38.0"})],CommonFilterBar.prototype,"showFilterConfiguration",void 0),a([r.syncRule({flex:{controlId:i.buildControlIdFromParent,controlType:()=>s.ControlType.SmartFilterBar,createFlexChange:i.exportToFlexChange}}),r.validity({since:"1.28.0"})],CommonFilterBar.prototype,"showRestoreOnFB",void 0),t.CommonFilterBar=CommonFilterBar;class AnalyticalListPageFilterBar extends CommonFilterBar{}a([r.syncRule({manifest:{path:e=>o.getAppSettingPathV2(e)}})],AnalyticalListPageFilterBar.prototype,"showGoButtonOnFilterBar",void 0),t.AnalyticalListPageFilterBar=AnalyticalListPageFilterBar;class ListReportFilterBar extends CommonFilterBar{}a([r.syncRule({manifest:{path:e=>o.getAppSettingPathV2(e)}}),r.validity({since:"1.86.0"})],ListReportFilterBar.prototype,"annotationPath",void 0),t.ListReportFilterBar=ListReportFilterBar},4834:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5599),i=n(8517),o=n(5008),s={controlId:(e,t,n,a)=>{if(a()===i.ControlType.Button){return`${e}action::${n[n.length-1]}::${n[1].replace("@","")}::FormAction`}return r.buildControlIdFromParent(e,t)},controlType:()=>i.ControlType.Button,createFlexChange:r.exportToFlexChange};class FormAction{}a([r.syncRule({flex:s,generate:o.addPatternForBindingChangeOfEnumOP})],FormAction.prototype,"visible",void 0),a([r.syncRule({flex:s})],FormAction.prototype,"tooltip",void 0),a([r.syncRule({flex:s})],FormAction.prototype,"icon",void 0),a([r.syncRule({flex:s})],FormAction.prototype,"activeIcon",void 0),a([r.syncRule({flex:s})],FormAction.prototype,"type",void 0),t.FormAction=FormAction;class FieldForAction{}a([r.syncRule({flex:s,generate:o.addPatternForBindingChangeOfEnumOP})],FieldForAction.prototype,"visible",void 0),a([r.syncRule({flex:s})],FieldForAction.prototype,"tooltip",void 0),a([r.syncRule({flex:s})],FieldForAction.prototype,"icon",void 0),a([r.syncRule({flex:s})],FieldForAction.prototype,"activeIcon",void 0),a([r.syncRule({flex:s}),r.validity({since:"1.73.0"})],FieldForAction.prototype,"type",void 0),t.FieldForAction=FieldForAction},8049:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(8517),i=n(4139),o=n(4667),s=a(n(9154)),c=n(5921),l=n(390),u=n(1350),p=n(5622);t.FRAGMENT_DEFINITION="core:FragmentDefinition";const f=new Map([[r.ViewTemplateType.AnalyticalTableColumnsExtension,"table:AnalyticalColumn"],[r.ViewTemplateType.ResponsiveTableColumnsExtension,"Column"],[r.ViewTemplateType.TreeTableColumnsExtension,"table:Column"],[r.ViewTemplateType.GridTableColumnsExtension,"table:Column"]]),d=new Map([[l.FE_TEMPLATE_V2_LIST_REPORT,l.SAPUI5_VIEW_EXTENSION_LIST_REPORT],[l.FE_TEMPLATE_V2_ALP,l.SAPUI5_VIEW_EXTENSION_ANALYTICAL_LIST_PAGE],[l.FE_TEMPLATE_V2_OBJECT_PAGE,l.SAPUI5_VIEW_EXTENSION_OBJECT_PAGE]]),h={type:"element",name:"Text",attributes:{text:"Placeholder"}},g=JSON.stringify(h);function m(e){const t=f.keys();for(const n of t){const t=f.get(n);if(e[t])return t}}function y(e){return e[m(e)]}function v(e,t){let n=!1;const a=e.customData||e["table:customData"];if(!a)return!1;let r=a["core:CustomData"]._attributes.value;const i=JSON.parse(r.substr(1,r.length)),o=t.findIndex((e=>e.columnKey===i.columnKey));return!(o<0)&&(n=!0,r='\\{"columnKey": "'+t[o].columnKey+'"',void 0!==t[o].columnIndex&&(r+=', "columnIndex": "'+t[o].columnIndex.toString()+'"'),t[o].leadingProperty&&(r+=', "leadingProperty": "'+t[o].leadingProperty+'"'),r+="}",a["core:CustomData"]._attributes.value=r,e.Text||e.Label||(e.Text={_attributes:{}}),e.Text?e.Text._attributes.text=t[o].text:e.Label&&(e.Label._attributes.text=t[o].text),e._attributes||(e._attributes={}),e._attributes.id=t[o].id,t.splice(o,1),true)}t.getTagNameFromFragmentJSON=m,t.getRootCustomColumnFromFragmentJSON=y,t.deleteColumnFromFragment=function(e,n,a,o){if(o){let s=e[n].fragmentName.substr(a.length+1),c=e.type?e.type.toLowerCase():"xml",l=s.split("."),u=l[l.length-1]+r.FRAGMENTNAMEPART+c;for(let e=0;e<o.length;e++){const n=o[e],a=n.dataSourceUri.split(p.sep);if(a[a.length-1]===u){const e=JSON.parse(i.xml2json(n.fileContent,{compact:!0})),a=m(e[t.FRAGMENT_DEFINITION]);a&&(delete e[t.FRAGMENT_DEFINITION][a],n.fileContent=i.json2xml(JSON.stringify(e),{compact:!0,spaces:4}));break}}const f=e[n.replace(r.ViewTemplateType.ResponsiveTableColumnsExtension,r.ViewTemplateType.ResponsiveTableCellsExtension)];if(f){c=f.type?f.type.toLowerCase():"xml",s=f.fragmentName.substr(a.length+1),l=s.split("."),u=l[l.length-1]+r.FRAGMENTNAMEPART+c;for(let e=0;e<o.length;e++){const t=o[e];if(t.dataSourceUri.endsWith(u)){const e=JSON.parse(i.xml2json(t.fileContent)),n=e.elements[0].elements&&e.elements[0].elements.filter((e=>"element"===e.type));if(n)for(let e=0;e<n.length;e++)JSON.stringify(n[e])===g&&n.splice(e,1);break}}}}},t.exportToFragment=function(e,n,a,l,d,b){var P;const S=e.fragments,T=e.manifest;let O,E;const _=u.getManifestSectionByPathV2(T,n),C=_.type?_.type.toLowerCase():"xml";_.type=C.toUpperCase();for(let e=0;e<a.length;e++)a[e].fragmentName?(_.fragmentName=a[e].fragmentName,_.className=a[e].className,E=(null===(P=a[e].fragmentName)||void 0===P?void 0:P.replace(l,"<root>/webapp").replace(/[.]/g,p.sep))+r.FRAGMENTNAMEPART+C):c.log(b,{severity:"error",message:s.default.t("NOFRAGMENT",{columnKey:a[e].columnKey})});if(n.indexOf(r.ViewTemplateType.ResponsiveTableColumnsExtension)>-1){const e=n.replace(r.ViewTemplateType.ResponsiveTableColumnsExtension,r.ViewTemplateType.ResponsiveTableCellsExtension),t=u.getManifestSectionByPathV2(T,e),i=a.reduce(((e,t)=>t.cellsFragmentName?t:e));i&&i.cellsFragmentName?(t.fragmentName=O=i.cellsFragmentName,t.className=a[0].className,t.type=C.toUpperCase()):u.deleteManifestSectionByPathV2(T,e)}const A=JSON.parse(JSON.stringify(a));let I=_.fragmentName,R=!1,F=!1;const x=I.substr(l.length+1),w=x.split(".");I=w[w.length-1]+r.FRAGMENTNAMEPART+C;const j=null==O?void 0:O.split("."),N=j?j[j.length-1]:null,L=N?N+r.FRAGMENTNAMEPART+C:null;if(S){for(let e=0;e<S.length;e++){const n=S[e];if(n.dataSourceUri.endsWith(I)){let e={};if(R=!0,n.fileContent&&0!==n.fileContent.length){const a=JSON.parse(i.xml2json(n.fileContent,{compact:!0}));if(e=y(a[t.FRAGMENT_DEFINITION]),e)if(Array.isArray(e))for(let t=0;t<e.length;t++){v(e[t],A)||e.splice(t,1)}else{if(!v(e,A)){const n=m(a[t.FRAGMENT_DEFINITION]);n&&(delete a[t.FRAGMENT_DEFINITION][n],e=void 0)}}for(let t=0;t<A.length;t++)if(A[t].fragmentName.endsWith(x)){const n=o.getSingleColumnContent(A[t],d);if(n){const t=y(JSON.parse(i.xml2json(n,{compact:!0})));Array.isArray(e)?e.push(t):e=e?[e,t]:[t]}}const r=f.get(d);a[t.FRAGMENT_DEFINITION][r]=e,n.fileContent=i.json2xml(JSON.stringify(a),{compact:!0,spaces:4})}else n.fileContent=o.getColumnFragmentContent(A,d);break}}F=!O||function(e,t,n){let a=!1;for(let r=0;r<e.length;r++){const s=e[r],c=s.dataSourceUri.split(p.sep);if(c[c.length-1]===t){if(a=!0,s.fileContent&&0!==Object.keys(s.fileContent).length){const e=JSON.parse(i.xml2json(s.fileContent)),t=e.elements[0].elements&&e.elements[0].elements.filter((e=>"element"===e.type));if(!t||Object.keys(t).length!==Object.keys(n).length){if(!t||Object.keys(t).length<Object.keys(n).length){const a=t?Object.keys(t).length:0;e.elements[0].elements||(e.elements[0].elements=[]);for(let t=a;t<Object.keys(n).length;t++)e.elements[0].elements.push(h)}else if(Object.keys(t).length>Object.keys(n).length){let a=Object.keys(t).length-Object.keys(n).length;for(let t=0;t<Object.keys(e.elements[0].elements).length&&(JSON.stringify(e.elements[0].elements[t])!==g||(e.elements[0].elements.splice(t,1),a-=1,0!==a));t++);}s.fileContent=i.json2xml(JSON.stringify(e),{spaces:4})}}else s.fileContent=o.getResponsiveTableCellsFragment(n);break}}return a}(S,L,a)}if(!R){const t={fileContent:o.getColumnFragmentContent(A,d),dataSourceUri:E};e.fragments.push(t)}if(!F){const t={fileContent:o.getResponsiveTableCellsFragment(a),dataSourceUri:E.replace(I,L)};e.fragments.push(t)}},t.getCustomColumnPath=(e,t,n,a)=>{const r=d.get(e.component.name);if(!a){let t=e.component.settings&&e.component.settings.tableSettings&&e.component.settings.tableSettings.type;t||(t="ResponsiveTable"),"sap.suite.ui.generic.template.AnalyticalListPage.view.AnalyticalListPage"===r&&(t="AnalyticalTable"),a=t+"ColumnsExtension"}let i=`${a}|${t}`;n&&(i+="|"+n);return{path:"sap.ui5/extends/extensions/sap.ui.viewExtensions/"+r+"/"+i,viewTemplateType:a}}},919:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(6088),i=n(2762);class ObjectPageChart{}a([i.syncRule({manifest:{path:r.getChartSettingsOBJsectionPathV2}}),i.validity({since:"1.78.0"})],ObjectPageChart.prototype,"variantManagement",void 0),t.ObjectPageChart=ObjectPageChart;class GlobalChartSettings{}a([i.syncRule({manifest:{path:e=>r.getAppSettingOBJPathV2(e)+"/chartSettings"}}),i.validity({since:"1.78.0"})],GlobalChartSettings.prototype,"variantManagement",void 0),t.GlobalChartSettings=GlobalChartSettings},708:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(6971),i=n(2762),o=n(6088);class BaseCustomSection{}a([i.syncRule({manifest:{path:o.getObjectPageCustomSectionPath,export:!1,import:(e,t)=>t.split("|")[2]}}),i.validity({since:"1.52.0"})],BaseCustomSection.prototype,"relatedFacet",void 0),a([i.syncRule({manifest:{path:o.getObjectPageCustomSectionPath,export:!1,import:(e,t)=>t.split("|")[0]}}),i.validity({since:"1.52.0"})],BaseCustomSection.prototype,"relativePosition",void 0),a([i.syncRule({manifest:{path:(e,t,n)=>o.getObjectPageCustomSectionPath(e,{},n,r.ManifestSection.generic)}}),i.validity({since:"1.52.0"})],BaseCustomSection.prototype,"title",void 0),a([i.syncRule({manifest:{path:o.getObjectPageCustomSectionPath}}),i.validity({since:"1.52.0"})],BaseCustomSection.prototype,"className",void 0),t.BaseCustomSection=BaseCustomSection;class ObjectPageCustomSectionFragment extends BaseCustomSection{}a([i.syncRule({manifest:{path:o.getObjectPageCustomSectionPath}}),i.validity({since:"1.52.0"})],ObjectPageCustomSectionFragment.prototype,"fragmentName",void 0),a([i.syncRule({manifest:{path:o.getObjectPageCustomSectionPath}}),i.validity({since:"1.52.0"})],ObjectPageCustomSectionFragment.prototype,"type",void 0),t.ObjectPageCustomSectionFragment=ObjectPageCustomSectionFragment;class ObjectPageCustomSectionView extends BaseCustomSection{}a([i.syncRule({manifest:{path:o.getObjectPageCustomSectionPath}}),i.validity({since:"1.52.0"})],ObjectPageCustomSectionView.prototype,"viewName",void 0),a([i.syncRule({manifest:{path:o.getObjectPageCustomSectionPath}}),i.validity({since:"1.52.0"})],ObjectPageCustomSectionView.prototype,"type",void 0),t.ObjectPageCustomSectionView=ObjectPageCustomSectionView},3284:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5599),i=n(6088),o=n(5008);class ObjectPageHeader{}a([r.syncRule({manifest:{path:e=>i.getAppSettingOBJPathV2(e)}}),r.validity({since:"1.46.0"})],ObjectPageHeader.prototype,"showRelatedApps",void 0),a([r.syncRule({manifest:{path:e=>i.getAppSettingOBJPathV2(e)}}),r.validity({since:"1.46.0"})],ObjectPageHeader.prototype,"editableHeaderContent",void 0),a([r.syncRule({manifest:{path:e=>i.getAppSettingOBJPathV2(e)}}),r.validity({since:"1.48.0"})],ObjectPageHeader.prototype,"simpleHeaderFacets",void 0),a([r.syncRule({flex:{controlId:(e,t)=>{const n=t.slice(0);return n[t.length-1]="objectImage",r.buildControlIdFromParent(e,n)},controlType:()=>o.ControlType.Avatar,createFlexChange:r.exportToFlexChange},generate:o.addPatternForBindingChangeOfEnumOP})],ObjectPageHeader.prototype,"displayShape",void 0),t.ObjectPageHeader=ObjectPageHeader},338:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5599),i=n(8517),o=n(5008),s=(e,t,n,a)=>{if(a()===i.ControlType.Button||a()===i.ControlType.HeaderAction){return e+"action::"+n[2]}return r.buildControlIdFromParent(e,t)};class HeaderAction{}a([r.syncRule({flex:{controlId:s,controlType:()=>i.ControlType.HeaderAction,createFlexChange:r.exportToFlexChange},generate:o.addPatternForBindingChangeOfEnumOP})],HeaderAction.prototype,"visible",void 0),a([r.syncRule({flex:{controlId:s,controlType:()=>i.ControlType.HeaderAction,createFlexChange:r.exportToFlexChange}})],HeaderAction.prototype,"tooltip",void 0),a([r.syncRule({flex:{controlId:s,controlType:()=>i.ControlType.HeaderAction,createFlexChange:r.exportToFlexChange}})],HeaderAction.prototype,"icon",void 0),a([r.syncRule({flex:{controlId:s,controlType:()=>i.ControlType.HeaderAction,createFlexChange:r.exportToFlexChange}})],HeaderAction.prototype,"activeIcon",void 0),a([r.syncRule({flex:{controlId:s,controlType:()=>i.ControlType.HeaderAction,createFlexChange:r.exportToFlexChange}}),r.validity({since:"1.73.0"})],HeaderAction.prototype,"type",void 0),t.HeaderAction=HeaderAction},8763:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(5599),o=n(8517),s=(e,t)=>{const n=t.slice(0);return n[t.length-1]="objectPage",i.buildControlIdFromParent(e,n)};class ObjectPageLayout{}a([r.syncRule({flex:{controlId:s,controlType:()=>o.ControlType.ObjectPageLayout,createFlexChange:i.exportToFlexChange}})],ObjectPageLayout.prototype,"showHeaderContent",void 0),a([r.syncRule({flex:{controlId:s,controlType:()=>o.ControlType.ObjectPageLayout,createFlexChange:i.exportToFlexChange}})],ObjectPageLayout.prototype,"showAnchorBar",void 0),a([r.syncRule({flex:{controlId:s,controlType:()=>o.ControlType.ObjectPageLayout,createFlexChange:i.exportToFlexChange}})],ObjectPageLayout.prototype,"useIconTabBar",void 0),a([r.syncRule({flex:{controlId:s,controlType:()=>o.ControlType.ObjectPageLayout,createFlexChange:i.exportToFlexChange}}),r.validity({since:"1.34.0"})],ObjectPageLayout.prototype,"alwaysShowContentHeader",void 0),t.ObjectPageLayout=ObjectPageLayout},4245:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(5008);t.FacetTitlePrefix="Facet ID: ",t.getTableSectionControlId=(e,n,a,r,o)=>{const s=[o.replace(t.FacetTitlePrefix,""),"Table"];return i.buildControlIdFromParent(e,s)},t.getFormSectionControlId=(e,n,a,r,o)=>{const s=[o.replace(t.FacetTitlePrefix,""),"FormGroup"];return i.buildControlIdFromParent(e,s)},t.getChartSectionControlId=(e,n,a,r,o)=>{const s=[o.replace(t.FacetTitlePrefix,""),"Chart"];return i.buildControlIdFromParent(e,s)},t.getSectionControlId=(e,n,a,r,o)=>{let s=o.replace(t.FacetTitlePrefix,"");s.includes("::")&&(s=a[a.length-1].replace("@",""));const c=[s,"Section"];return i.buildControlIdFromParent(e,c)},t.getSubSectionControlId=(e,n,a,r,o)=>{const s=[o.replace(t.FacetTitlePrefix,""),"SubSection"];return i.buildControlIdFromParent(e,s)};class ObjectPageSectionV2{}a([r.syncRule({flex:{controlId:t.getSectionControlId,controlType:()=>i.ControlType.Section,createFlexChange:i.exportToFlexChange},generate:i.addPatternForBindingChangeOfEnumOP})],ObjectPageSectionV2.prototype,"visible",void 0),t.ObjectPageSectionV2=ObjectPageSectionV2;class ObjectPageSectionFormV2{}a([r.syncRule({flex:{controlId:t.getSectionControlId,controlType:()=>i.ControlType.Section,createFlexChange:i.exportToFlexChange},generate:i.addPatternForBindingChangeOfEnumOP})],ObjectPageSectionFormV2.prototype,"visible",void 0),t.ObjectPageSectionFormV2=ObjectPageSectionFormV2;class ObjectPageSectionChartV2{}a([r.syncRule({flex:{controlId:t.getSectionControlId,controlType:()=>i.ControlType.Section,createFlexChange:i.exportToFlexChange},generate:i.addPatternForBindingChangeOfEnumOP})],ObjectPageSectionChartV2.prototype,"visible",void 0),t.ObjectPageSectionChartV2=ObjectPageSectionChartV2;class ObjectPageSectionTableV2{}a([r.syncRule({flex:{controlId:t.getSectionControlId,controlType:()=>i.ControlType.Section,createFlexChange:i.exportToFlexChange},generate:i.addPatternForBindingChangeOfEnumOP})],ObjectPageSectionTableV2.prototype,"visible",void 0),t.ObjectPageSectionTableV2=ObjectPageSectionTableV2;class ObjectPageSubSectionV2{}a([r.syncRule({flex:{controlId:t.getSubSectionControlId,controlType:()=>i.ControlType.SubSection,createFlexChange:i.exportToFlexChange},generate:i.addPatternForBindingChangeOfEnumOP})],ObjectPageSubSectionV2.prototype,"visible",void 0),t.ObjectPageSubSectionV2=ObjectPageSubSectionV2;class ObjectPageSubSectionFormV2{}a([r.syncRule({flex:{controlId:t.getFormSectionControlId,controlType:()=>i.ControlType.SmartGroup,createFlexChange:i.exportToFlexChange},generate:i.addPatternForBindingChangeOfEnumOP})],ObjectPageSubSectionFormV2.prototype,"visible",void 0),t.ObjectPageSubSectionFormV2=ObjectPageSubSectionFormV2;class ObjectPageSubSectionChartV2{}a([r.syncRule({flex:{controlId:t.getChartSectionControlId,controlType:()=>i.ControlType.SmartChart,createFlexChange:i.exportToFlexChange},generate:i.addPatternForBindingChangeOfEnumOP})],ObjectPageSubSectionChartV2.prototype,"visible",void 0),t.ObjectPageSubSectionChartV2=ObjectPageSubSectionChartV2;class ObjectPageSubSectionTableV2{}a([r.syncRule({flex:{controlId:t.getTableSectionControlId,controlType:()=>i.ControlType.SmartTable,createFlexChange:i.exportToFlexChange},generate:i.addPatternForBindingChangeOfEnumOP})],ObjectPageSubSectionTableV2.prototype,"visible",void 0),t.ObjectPageSubSectionTableV2=ObjectPageSubSectionTableV2},2269:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5599),i=n(6088),o=n(5008),s=n(6138),c=(e,t,n,a,i)=>{const o=n.slice(1,2);let s;return"sap.ui.comp.smarttable.SmartTable"===a()?s="Table":"sap.m.Table"===a()&&(s="responsiveTable"),o.push(s),o[0]=r.convertSectionId(o[0],i),r.buildControlIdFromParent(e,o)};class QuickVariantSelectionOP{}a([r.syncRule({manifest:{path:(e,t,n)=>i.getAppSettingOBJsectionPathV2(e,t,n)+o.QUICKVARPATH}}),r.validity({since:"1.48.0"})],QuickVariantSelectionOP.prototype,"showCounts",void 0),a([r.syncRule({manifest:{path:(e,t,n)=>i.getAppSettingOBJsectionPathV2(e,t,n)+o.QUICKVARPATH}}),r.validity({since:"1.48.0"})],QuickVariantSelectionOP.prototype,"variants",void 0),t.QuickVariantSelectionOP=QuickVariantSelectionOP;class FieldPathOP{}a([r.syncRule({manifest:{path:(e,t,n,a)=>i.getTableSettingsOBJsectionPathV2(e,t,n)+`/createWithParameterDialog/fields/${a}`}}),r.validity({since:"1.77.0"})],FieldPathOP.prototype,"path",void 0),t.FieldPathOP=FieldPathOP;class Fields4DialogOP{}a([r.syncRule({manifest:{path:(e,t,n)=>i.getTableSettingsOBJsectionPathV2(e,t,n)+"/createWithParameterDialog"}}),r.validity({since:"1.77.0"})],Fields4DialogOP.prototype,"fields",void 0),t.Fields4DialogOP=Fields4DialogOP;class ObjectPageCommonTableSettings{constructor(){this.getDeprecated=()=>({tableType:{since:"1.50.0",deprecated:{since:"1.70.0",text:"Use tableSettings.type instead"}}})}}a([r.syncRule({manifest:{key:"createWithParameterDialog",path:i.getTableSettingsOBJsectionPathV2,import:function(e){let t;return e.createWithParameterDialog&&(t=JSON.parse(JSON.stringify(e.createWithParameterDialog))),t},export:s.exportCreateParameters}}),r.validity({since:"1.77.0"})],ObjectPageCommonTableSettings.prototype,"createWithParameterDialog",void 0),a([r.syncRule({flex:{controlId:c,controlType:()=>o.ControlType.SmartTable,createFlexChange:r.exportToFlexChange}}),r.validity({since:"1.28.0"})],ObjectPageCommonTableSettings.prototype,"editable",void 0),a([r.syncRule({manifest:{path:i.getTableSettingsOBJsectionPathV2}}),r.validity({since:"1.54.0"})],ObjectPageCommonTableSettings.prototype,"multiSelect",void 0),a([r.syncRule({manifest:{path:i.getTableSettingsOBJsectionPathV2}}),r.validity({since:"1.70.0"})],ObjectPageCommonTableSettings.prototype,"selectAll",void 0),a([r.syncRule({manifest:{path:i.getTableSettingsOBJsectionPathV2}}),r.validity({since:"1.70.0"})],ObjectPageCommonTableSettings.prototype,"selectionLimit",void 0),a([r.syncRule({manifest:{path:i.getAppSettingOBJsectionPathV2}}),r.validity({since:"1.63.0"})],ObjectPageCommonTableSettings.prototype,"quickVariantSelection",void 0),a([r.syncRule({flex:{controlId:c,controlType:()=>o.ControlType.SmartTable,createFlexChange:r.exportToFlexChange}}),r.validity({since:"1.26.0"})],ObjectPageCommonTableSettings.prototype,"useExportToExcel",void 0),a([r.syncRule({manifest:{path:i.getAppSettingOBJsectionPathV2}}),r.validity({since:"1.48.5"})],ObjectPageCommonTableSettings.prototype,"createMode",void 0),a([r.syncRule({manifest:{path:i.getAppSettingOBJsectionPathV2}}),r.validity({since:"1.61.0"})],ObjectPageCommonTableSettings.prototype,"disableDefaultInlineCreateSort",void 0),a([r.syncRule({manifest:{path:i.getTableSettingsOBJsectionPathV2}}),r.validity({since:"1.78.0"})],ObjectPageCommonTableSettings.prototype,"variantManagement",void 0),t.ObjectPageCommonTableSettings=ObjectPageCommonTableSettings;class ObjectPageResponsiveTable extends ObjectPageCommonTableSettings{}a([r.syncRule({manifest:{path:i.getTableSettingsOBJsectionPathV2}})],ObjectPageResponsiveTable.prototype,"type",void 0),a([r.syncRule({flex:{controlId:c,controlType:()=>o.ControlType.Table,createFlexChange:r.exportToFlexChange}})],ObjectPageResponsiveTable.prototype,"includeItemInSelection",void 0),a([r.syncRule({flex:{controlId:c,controlType:()=>o.ControlType.Table,createFlexChange:r.exportToFlexChange},generate:o.addPatternForBindingChangeOfEnumOP}),r.validity({since:"1.52.0"})],ObjectPageResponsiveTable.prototype,"popinLayout",void 0),a([r.syncRule({manifest:{path:i.getTableSettingsOBJsectionPathV2}}),r.validity({since:"1.77.0"})],ObjectPageResponsiveTable.prototype,"inlineDelete",void 0),a([r.syncRule({flex:{controlId:c,controlType:()=>o.ControlType.Table,createFlexChange:r.exportToFlexChange}}),r.validity({since:"1.16.0"})],ObjectPageResponsiveTable.prototype,"growingThreshold",void 0),t.ObjectPageResponsiveTable=ObjectPageResponsiveTable;class ObjectPageAnalyticalTable extends ObjectPageCommonTableSettings{}a([r.syncRule({manifest:{path:i.getTableSettingsOBJsectionPathV2}})],ObjectPageAnalyticalTable.prototype,"type",void 0),a([r.syncRule({manifest:{path:i.getAppSettingOBJsectionPathV2}}),r.validity({since:"1.67.0"})],ObjectPageAnalyticalTable.prototype,"condensedTableLayout",void 0),t.ObjectPageAnalyticalTable=ObjectPageAnalyticalTable;class ObjectPageGridTable extends ObjectPageCommonTableSettings{}a([r.syncRule({manifest:{path:i.getTableSettingsOBJsectionPathV2}})],ObjectPageGridTable.prototype,"type",void 0),a([r.syncRule({manifest:{path:i.getAppSettingOBJsectionPathV2}}),r.validity({since:"1.67.0"})],ObjectPageGridTable.prototype,"condensedTableLayout",void 0),t.ObjectPageGridTable=ObjectPageGridTable;class ObjectPageTreeTable extends ObjectPageCommonTableSettings{}a([r.syncRule({manifest:{path:i.getTableSettingsOBJsectionPathV2}})],ObjectPageTreeTable.prototype,"type",void 0),a([r.syncRule({manifest:{path:i.getAppSettingOBJsectionPathV2}}),r.validity({since:"1.67.0"})],ObjectPageTreeTable.prototype,"condensedTableLayout",void 0),t.ObjectPageTreeTable=ObjectPageTreeTable},6138:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(6971),i=n(390),o=n(5008),s=n(5599),c=n(6088);function l(e){if(!e.createWithParameterDialog)return;let t={};return e.createWithParameterDialog&&(t=JSON.parse(JSON.stringify(e.createWithParameterDialog))),t}function u(e,t){t.createWithParameterDialog?e.createWithParameterDialog=JSON.parse(JSON.stringify(t.createWithParameterDialog)):delete e.createWithParameterDialog}t.getSmartTableControlId=(e,t,n,a)=>"sap.m.Table"===a()?e+"responsiveTable":"sap.ui.comp.smarttable.SmartTable"===a()&&e.includes("AnalyticalListPage")?e+"table":s.buildControlIdFromParent(e,t),t.importCreateParameters=l,t.exportCreateParameters=u;class CreateWithFilters{}function p(e){return e.type?e.type:i.TableTypeV2.ResponsiveTable}function f(e,t){t.type&&(e.type||t.type!==i.TableTypeV2.ResponsiveTable)?e.type=t.type:delete e.type}a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)+"/createWithFilters"}})],CreateWithFilters.prototype,"strategy",void 0),t.CreateWithFilters=CreateWithFilters,t.exportType=f;class DataLoadSettings{}a([s.syncRule({manifest:{path:e=>c.getDataLoadSettingPathV2(e)}}),s.validity({since:"1.75.2"})],DataLoadSettings.prototype,"loadDataOnAppLaunch",void 0),t.DataLoadSettings=DataLoadSettings;class FieldPath{}a([s.syncRule({manifest:{path:(e,t,n)=>c.getCreationFieldsPathV2(e,t,n)}}),s.validity({since:"1.77.0"})],FieldPath.prototype,"path",void 0),t.FieldPath=FieldPath;class Fields4Dialog{}a([s.syncRule({manifest:{path:e=>c.getTableSettingPathV2(e)+"/createWithParameterDialog"}}),s.validity({since:"1.77.0"})],Fields4Dialog.prototype,"fields",void 0),t.Fields4Dialog=Fields4Dialog;class QuickVariantSelection{}a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)+o.QUICKVARPATH}}),s.validity({since:"1.48.0"})],QuickVariantSelection.prototype,"showCounts",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)+o.QUICKVARPATH}}),s.validity({since:"1.48.0"})],QuickVariantSelection.prototype,"variants",void 0),t.QuickVariantSelection=QuickVariantSelection;class QuickVariantSelectionX{}a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)+o.QUICKVARPATHX}}),s.validity({since:"1.48.0"})],QuickVariantSelectionX.prototype,"showCounts",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)+o.QUICKVARPATHX}}),s.validity({since:"1.48.0"})],QuickVariantSelectionX.prototype,"enableAutoBinding",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)+o.QUICKVARPATHX,export:(e,t)=>{if(t.variants)for(const n in t.variants){const a=t.variants[n],r=["type","multiSelect","selectAll","selectionLimit","inlineDelete"];for(const e in a)-1!==r.indexOf(e)&&(a.tableSettings||(a.tableSettings={}),a.tableSettings[e]=a[e],delete a[e]);e.variants?e.variants[n]=a:e.variants={[n]:a}}}}}),s.validity({since:"1.48.0"})],QuickVariantSelectionX.prototype,"variants",void 0),t.QuickVariantSelectionX=QuickVariantSelectionX;class CommonTableSettings{constructor(){this.getDeprecated=()=>({tableType:{since:"1.50.0",deprecated:{since:"1.70.0",text:"Use tableSettings.type instead"}},enableAutoBinding:{since:"1.40.0",deprecated:{since:"1.75.2",text:"Use tableSettings.loadDataOnAppLaunch instead"}}})}}a([s.syncRule({manifest:{key:"createWithParameterDialog",path:e=>c.getTableSettingPathV2(e),import:l,export:u}}),s.validity({since:"1.77.0"})],CommonTableSettings.prototype,"createWithParameterDialog",void 0),a([s.syncRule({flex:{controlId:s.buildControlIdFromParent,controlType:()=>o.ControlType.SmartTable,createFlexChange:s.exportToFlexChange}}),s.validity({since:"1.38.0"})],CommonTableSettings.prototype,"showTablePersonalisation",void 0),a([s.syncRule({flex:{controlId:t.getSmartTableControlId,controlType:()=>o.ControlType.SmartTable,createFlexChange:s.exportToFlexChange}}),s.validity({since:"1.26.0"})],CommonTableSettings.prototype,"useExportToExcel",void 0),a([s.syncRule({flex:{controlId:t.getSmartTableControlId,controlType:()=>o.ControlType.SmartTable,createFlexChange:s.exportToFlexChange}})],CommonTableSettings.prototype,"fitContainer",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.48.0"})],CommonTableSettings.prototype,"quickVariantSelection",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.48.0"})],CommonTableSettings.prototype,"quickVariantSelectionX",void 0),a([s.syncRule({manifest:{path:e=>c.getTableSettingPathV2(e)}}),s.validity({since:"1.38.0"})],CommonTableSettings.prototype,"multiSelect",void 0),a([s.syncRule({manifest:{path:e=>c.getTableSettingPathV2(e)}}),s.validity({since:"1.70.0"})],CommonTableSettings.prototype,"selectAll",void 0),a([s.syncRule({manifest:{path:e=>c.getTableSettingPathV2(e)}}),s.validity({since:"1.70.0"})],CommonTableSettings.prototype,"selectionLimit",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.75.2"})],CommonTableSettings.prototype,"dataLoadSettings",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.42.0"})],CommonTableSettings.prototype,"condensedTableLayout",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.56.0"})],CommonTableSettings.prototype,"enableTableFilterInPageVariant",void 0),t.CommonTableSettings=CommonTableSettings;class ResponsiveTable extends CommonTableSettings{}a([s.syncRule({manifest:{path:e=>c.getTableSettingPathV2(e),import:p,export:f}}),s.validity({since:"1.50.0"})],ResponsiveTable.prototype,"type",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.54.0"})],ResponsiveTable.prototype,"createWithFilters",void 0),a([s.syncRule({flex:{controlId:t.getSmartTableControlId,controlType:()=>o.ControlType.Table,createFlexChange:s.exportToFlexChange},generate:o.addPatternForBindingChangeOfEnumLR}),s.validity({since:"1.52.0"})],ResponsiveTable.prototype,"popinLayout",void 0),a([s.syncRule({flex:{controlId:t.getSmartTableControlId,controlType:()=>o.ControlType.Table,createFlexChange:s.exportToFlexChange}})],ResponsiveTable.prototype,"includeItemInSelection",void 0),a([s.syncRule({manifest:{path:e=>c.getTableSettingPathV2(e)}}),s.validity({since:"1.77.0"})],ResponsiveTable.prototype,"inlineDelete",void 0),a([s.syncRule({manifest:{path:()=>r.GENERICAPPSETTINGS}}),s.validity({since:"1.63.0"})],ResponsiveTable.prototype,"showDraftToggle",void 0),a([s.syncRule({flex:{controlId:t.getSmartTableControlId,controlType:()=>o.ControlType.Table,createFlexChange:s.exportToFlexChange}}),s.validity({since:"1.16.0"})],ResponsiveTable.prototype,"growingThreshold",void 0),t.ResponsiveTable=ResponsiveTable;class TreeTable extends CommonTableSettings{}a([s.syncRule({manifest:{path:e=>c.getTableSettingPathV2(e),import:p,export:f}}),s.validity({since:"1.50.0"})],TreeTable.prototype,"type",void 0),a([s.syncRule({manifest:{path:()=>r.GENERICAPPSETTINGS}}),s.validity({since:"1.63.0"})],TreeTable.prototype,"showDraftToggle",void 0),t.TreeTable=TreeTable;class AnalyticalTable extends CommonTableSettings{}a([s.syncRule({manifest:{path:e=>c.getTableSettingPathV2(e),import:p,export:f}}),s.validity({since:"1.50.0"})],AnalyticalTable.prototype,"type",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}})],AnalyticalTable.prototype,"qualifier",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.38.0"}),s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}})],AnalyticalTable.prototype,"defaultContentView",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}})],AnalyticalTable.prototype,"defaultFilterMode",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.60.0"})],AnalyticalTable.prototype,"contentTitle",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}})],AnalyticalTable.prototype,"autoHide",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.60.0"})],AnalyticalTable.prototype,"filterDefaultsFromSelectionVariant",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.78.0"})],AnalyticalTable.prototype,"allFiltersAsInParameters",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.54.0"})],AnalyticalTable.prototype,"createWithFilters",void 0),a([s.syncRule({manifest:{path:()=>r.GENERICAPPSETTINGS}}),s.validity({since:"1.63.0"})],AnalyticalTable.prototype,"showDraftToggle",void 0),t.AnalyticalTable=AnalyticalTable;class TableALP extends CommonTableSettings{}a([s.syncRule({manifest:{path:e=>c.getTableSettingPathV2(e),import:p,export:f}}),s.validity({since:"1.50.0"})],TableALP.prototype,"type",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}})],TableALP.prototype,"qualifier",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.38.0"}),s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}})],TableALP.prototype,"defaultContentView",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}})],TableALP.prototype,"defaultFilterMode",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.60.0"})],TableALP.prototype,"contentTitle",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}})],TableALP.prototype,"autoHide",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.60.0"})],TableALP.prototype,"filterDefaultsFromSelectionVariant",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.78.0"})],TableALP.prototype,"allFiltersAsInParameters",void 0),t.TableALP=TableALP;class ALPResponsiveTable extends TableALP{}a([s.syncRule({flex:{controlId:t.getSmartTableControlId,controlType:()=>o.ControlType.Table,createFlexChange:s.exportToFlexChange}}),s.validity({since:"1.16.0"})],ALPResponsiveTable.prototype,"growingThreshold",void 0),t.ALPResponsiveTable=ALPResponsiveTable;t.ALPGridTable=class ALPGridTable extends TableALP{};t.ALPAnalyticalTable=class ALPAnalyticalTable extends TableALP{};class GridTable extends CommonTableSettings{}a([s.syncRule({manifest:{path:e=>c.getTableSettingPathV2(e),import:p,export:f}}),s.validity({since:"1.50.0"})],GridTable.prototype,"type",void 0),a([s.syncRule({manifest:{path:e=>c.getAppSettingPathV2(e)}}),s.validity({since:"1.54.0"})],GridTable.prototype,"createWithFilters",void 0),a([s.syncRule({manifest:{path:()=>r.GENERICAPPSETTINGS}}),s.validity({since:"1.63.0"})],GridTable.prototype,"showDraftToggle",void 0),t.GridTable=GridTable},8210:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(8517),i=n(5599),o=n(5008);class TableColumn{}a([i.syncRule({flex:{controlId:i.buildColumnControlId,controlType:()=>r.ControlType.TableColumn,createFlexChange:i.exportToFlexChange}})],TableColumn.prototype,"width",void 0),a([i.syncRule({flex:{controlId:i.buildColumnControlId,controlType:()=>r.ControlType.TableColumn,createFlexChange:i.exportToFlexChange},generate:o.addPatternForBindingChangeOfEnumLR})],TableColumn.prototype,"hAlign",void 0),t.TableColumn=TableColumn;t.TableCustomColumn=class TableCustomColumn{}},7040:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(296)),a(n(6138)),a(n(8210)),a(n(8049)),a(n(3284)),a(n(338)),a(n(8763)),a(n(2269)),a(n(651)),a(n(4834)),a(n(5682)),a(n(708)),a(n(919)),a(n(8722)),a(n(8378)),a(n(4245))},2432:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=a(n(4225)),i=n(7040),o=n(5008),s=n(3374),c=n(6088),l=n(1350),u=n(1403);function p(e,t){if(e.includes(t)){const n=t.split("|");return 3===n.length?n.push("1"):n[3]=(parseInt(n[3])+1).toString(),p(e,n.join("|"))}return t}function f(e,t,n,a,r,i){a&&(a.properties?y(e,t,n,a.properties,r,i):a.additionalProperties&&y(e,t,n,a.additionalProperties,r,i))}function d(e,t,n,a){return e.createInstance(s.PageType.OverviewPage,a,n,t)}function h(e,t,n,a,r,i,s){e.pop();let c=a;for(const l in t.anyOf)if(t.anyOf[l].$ref){const u=t.anyOf[l].$ref.split(o.DEFINITION_LINK_PREFIX),p=n.definitions[u[u.length-1]],h=e[1];c=d(i,h,a=r[h],"CustomCard"),f(c,s,n,p,i,[...e])}else"object"==typeof t.anyOf[l]&&y(r,s,n,t.anyOf[l].properties,i,[...e,"anyOfObject"]);return c}function g(e,t,n,a,i,c,u){const p=e.manifest.path([...t,n]),f=l.getManifestSectionByPathV2(a.manifest,p);if(n in s.CardSettingsType||"settings"===n)f.settings=r.default(f.settings||{},i||{},{arrayMerge:o.arrayCombineMerge});else if(void 0!==i){const t=e.manifest.export;!1!==t&&(t&&"function"==typeof t?t(f,c,n):"object"!=typeof i||u.includes(n)?f[n]=i:f[n]=r.default(f[n]||{},i||{},{arrayMerge:o.arrayCombineMerge}))}else void 0!==f[n]&&delete f[n]}function m(e,t,n,a){Object.keys(e).forEach((r=>{const i=e[r].template;let o;var c,l;o=Object.values(s.CardTemplateType).includes(i)?Object.keys(t.definitions).filter((n=>{var a,i,o;return(null===(o=null===(i=null===(a=t.definitions[n].properties)||void 0===a?void 0:a.template)||void 0===i?void 0:i.enum)||void 0===o?void 0:o.indexOf(e[r].template))>-1})):["CustomCard"],e[r]=d(n,o[0],e[r],"CustomCard"),c=r,(l=a.manifest[s.ManifestSection.ovp]).cards||(l.cards={}),c in l.cards||(l.cards[c]={}),f(e[r],a,t,t.definitions[o[0]],n,[r])})),Object.keys(a.manifest[s.ManifestSection.ovp].cards).forEach((t=>{e[t]||delete a.manifest[s.ManifestSection.ovp].cards[t]}))}function y(e,t,n,a,r,i){let s,c=!1,l=!1;const u=["colorPalette","tabs"];for(const p in a){s=e[p];let v=o.getReflectMetadata(e,p);if("anyOfObject"===i[i.length-1]&&(c=!0,i.pop()),c&&(s=e[i[i.length-1]][p],v=o.getReflectMetadata(e,i[i.length-1])),"objectProperties"===i[i.length-1]&&(l=!0,i.pop()),l&&(s=e[i[i.length-1]][p],v=o.getReflectMetadata(e,i[i.length-1])),"anyOf"===i[i.length-1]&&(s=h(i,a,n,s,e,r,t)),(null==v?void 0:v.manifest)&&g(v,i,p,t,s,e,u),s&&"object"==typeof s&&a[p])if("cards"===p)m(s,n,r,t);else if(a[p].$ref){const e=a[p].$ref.split(o.DEFINITION_LINK_PREFIX),c=n.definitions[e[e.length-1]];s=d(r,p,s,"settings"===p?"CustomCard":""),f(s,t,n,c,r,[...i,p])}else a[p].anyOf?y(e,t,n,a[p],r,[...i,p,"anyOf"]):void 0!==a[p].properties&&y(e,t,n,a[p].properties,r,[...i,p,"objectProperties"])}}function v(e,t,n,a,r,i,s){let c=a.indexOf("subsections");for(;c>-1;)a.splice(c-1,2),c=a.indexOf("subsections");if(t.flex)!function(e,t,n,a,r,i,s){let c;c=0===t.length?["page"]:t;const l=n.flex.controlId(e.baseId,a,c,n.flex.controlType,r),u=o.fillFlexChangeContent(i,n,e.ui5Version,s,l),p=n.flex.createFlexChange(u,e.exportResults.manifest);e.exportResults.flexChanges.find((e=>{let t=!1,n=JSON.parse(e);n={content:n.content,selector:n.selector};let a=JSON.parse(p);return a={content:a.content,selector:a.selector},JSON.stringify(n)===JSON.stringify(a)&&(t=!0),t}))||e.exportResults.flexChanges.push(p)}(e,a,t,r,i,n,s);else if(t.manifest){const r=function(){let r;return"sections"===a[0]?"custom"===a[1]?r=t.manifest.path(e.pageKeys,{},a[2]):(r=t.manifest.path(e.pageKeys,{},a[1],a[a.length-1]),r=r.replace("/@","::").replace(/VOCWITHCOLONS/g,"::com.sap.vocabularies")):r="table"===a[0]?"columns"===a[1]&&"custom"===a[2]?t.manifest.path(e.pageKeys,e.exportResults.manifest,n.tabKey):t.manifest.path(e.pageKeys,{},a[a.length-1]):"keyPerformanceIndicators"===a[0]?t.manifest.path(e.pageKeys,e.exportResults.manifest,i):t.manifest.path(e.pageKeys),r}();!function(e,t,n,a,r){const i=l.getManifestSectionByPathV2(e.exportResults.manifest,t),s=n.manifest.key||a;if(void 0!==r[a])if("array"!==e.propertyDefinition.type&&e.nextDefinition&&"object"===e.nextDefinition.targetDefinition.type&&e.nextDefinition.targetDefinition.properties)"array"!==e.propertyDefinition.type&&void 0===i[s]&&(i[s]={});else{const e=n.manifest.export;!1!==e&&(e&&"function"==typeof e?e(i,r,a,s):i[s]=r[a])}else Object.prototype.hasOwnProperty.call(i,s)&&delete i[s];o.deleteEmptyStructure(e.exportResults.manifest,t)}(e,r,t,s,n)}}function b(e,t,n,a,r,s,c){const u=e.substr(0,e.lastIndexOf("/")),p=l.getManifestSectionByPathV2(t.manifest,u),f=e.substr(e.lastIndexOf("/")+1);for(const e in p)if(e.startsWith(f)){const l=e.split("|"),u=l[1],f=l[2];if(u===n){const n=null==a?void 0:a.filter((e=>(e.tabKey===f||void 0===f&&""===e.tabKey||f&&r===f)&&e.extensionType===s));if((!n||0===n.length)&&(i.deleteColumnFromFragment(p,e,c,t.fragments),delete p[e],e.startsWith(o.ViewTemplateType.ResponsiveTableColumnsExtension))){const n=e.replace(o.ViewTemplateType.ResponsiveTableColumnsExtension,o.ViewTemplateType.ResponsiveTableCellsExtension);i.deleteColumnFromFragment(p,n,c,t.fragments),delete p[n]}}}}function P(e,t,n,a){const r=a?a.key:void 0,o=(a?a.target:void 0)||e.v2Page.entitySet;for(const n in s.TableColumnExtensionTypeV2){const{path:a}=i.getCustomColumnPath(e.v2Page,o,r,n);a&&b(a,e.exportResults,o,t,r,n,e.appId)}const c={};if(t){for(let a=0;a<t.length;a++){const s=t[a];if(!(s.className&&s.fragmentName&&s.columnKey&&s.extensionType))continue;if(n.properties.fragmentName.pattern){if(!1===new RegExp(n.properties.fragmentName.pattern).test(s.fragmentName))continue}const{path:l,viewTemplateType:u}=i.getCustomColumnPath(e.v2Page,o,s.tabKey||r,s.extensionType);c[l]||(c[l]={viewTemplateType:u,columns:[]}),c[l].columns.push(s)}for(const t in c)i.exportToFragment(e.exportResults,t,c[t].columns,e.appId,c[t].viewTemplateType,e.logger)}}function S(e,t,n,a,r,i){const s=[],f=n.split("|")[1];if(!t)return;for(const e of t){const t=p(s,[e.relativePosition,f,e.relatedFacet].join("|"));s.push(t)}for(let n=0;n<s.length;n++){const c=i.anyOf.find((e=>e.$ref.includes(t[n].constructor.name))).$ref.split(o.DEFINITION_LINK_PREFIX),l=e.appSchema.definitions[c[c.length-1]];_(e,t[n],a,[...r,s[n]],l)}const d=l.getManifestSectionByPathV2(e.exportResults.manifest,c.getViewExtensionsPath());for(const e in d)u.isAssociatedCustomSection(e,f)&&!s.includes(e)&&delete d[e]}function T(e,t){let n;for(let t=e.length-1;t>=0;t--)if("table"===e[t]){n=e[t-1];break}return o.convertSectionId(n,t)}function O(e,t,n,a,r,i,s){Object.keys(e).forEach((c=>{const l=o.getNextTargetDefinition(t.appSchema,n,e[c],a.additionalProperties,r,t.factory,t.pageType);_(t,l.configObject,i,[...s,r],l.targetDefinition,c)}))}function E(e,t,n,a,r,i){let o;const s=u.getTargetFromCustomColumnRef(e.$ref);s&&(o={target:s,key:T(t,n)}),P(a,null==r?void 0:r.custom,i.targetDefinition,o)}function _(e,t,n,a,r,i){let s;if(r&&r.properties)for(const c in r.properties){s=t&&t[c];const l=t&&o.getChildId(t,c),u=l?[...n,l]:n,p=o.getReflectMetadata(t,c),f=e.propertyDefinition=r.properties[c];let d=e.nextDefinition=o.getNextTargetDefinition(e.appSchema,i,s,f,c,e.factory,e.pageType);if(p&&v(e,p,t,[...a],u,i,c),s&&f.additionalProperties&&O(s,e,i,f,c,u,a),void 0!==s&&"object"!=typeof s||!f){if(f&&f.$ref===o.DEFINITION_LINK_PREFIX+"TableCustomColumns"){P(e,[],e.appSchema.definitions.TableCustomColumn);continue}}else{if("array"===f.type&&("sections"===a[0]||"subsections"===a[0])&&"custom"===c){S(e,t[c],e.pageKeys[e.pageKeys.length-1],u,[...a,c],f.items);continue}if(d&&"custom"===c){E(f,a,i,e,t,d);continue}d?_(e,d.configObject,u,[...a,c],d.targetDefinition,d.title):f.anyOf&&f.anyOf.forEach((t=>{d=o.getNextTargetDefinition(e.appSchema,i,s,t,c,e.factory,e.pageType),d&&_(e,d.configObject,u,[...a,c],d.targetDefinition,d.title)}))}}}t.transferManifestEntriesOVP=f,t.assignReflectMetadataRules=d,t.transferManifestEntriesAndFlexChange=_},7505:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=a(n(9154)),i=a(n(4366)),o=a(n(1199)),s=n(4027),c=n(3374),l=n(5008),u=n(6088),p=n(1350),f=n(4330),d=n(7072),h=n(2432),g=n(5921),m=e=>({flexChanges:[],manifest:{[s.ManifestSection.generic]:{pages:{}}},fragments:e||[]});function y(e,t){const n=e.page.config,a=e.page.entitySet,r=m(e.fragments),i=new d.MetadataInstanceFactoryV2,o=i.createPageInstance(s.PageType.ObjectPage,n);if(r.manifest=JSON.parse(JSON.stringify(e.manifest)),n){const u=l.getPageLayoutInformation(o),p=`${e.appId}::${u.id}::${a}--`,d=[],g=f.findObjectPageV2(e.manifest[s.ManifestSection.generic].pages,a,d);if(!g)return r;if(n.sections&&function(e,t,n){function a(e,t,n){if(e&&"custom"===t&&Array.isArray(e))for(const t in e)e[t].className===c.SAPUI5_FRAGMENT_CLASS?e[t]=n.createInstance(s.PageType.ObjectPage,"ObjectPageCustomSectionFragment",e[t]):e[t]=n.createInstance(s.PageType.ObjectPage,"ObjectPageCustomSectionView",e[t])}function r(e,t){if(e.subsections){let n;for(const i in e.subsections)n=e.subsections[i],a(n,i,t),r(n,t)}}let i;for(const o in e.sections)i=t.sections[o],a(i,o,n),r(i,n)}(n,o,i),0!==Object.keys(n).length){const n={v2Page:g,exportResults:r,appId:e.appId,baseId:p,appSchema:e.jsonSchema,ui5Version:t,factory:i,pageKeys:d,pageType:s.PageType.ObjectPage,logger:e.logger};h.transferManifestEntriesAndFlexChange(n,o,[],[],e.jsonSchema)}}return r}t.exportPageV2=function(e,t){if(e[s.SchemaType.ListReport])return function(e,t){const n=e.page.config,a=e.page.entitySet,i=m(e.fragments),o=new d.MetadataInstanceFactoryV2,c=o.createPageInstance(s.PageType.ListReport,n),u=l.getPageLayoutInformation(c),p=`${e.appId}::${u.id}::${a}--`,y=[],v=f.findListReportPageV2(e.manifest[s.ManifestSection.generic].pages,y);if(v){if(v.component.settings||(v.component.settings={}),i.manifest=JSON.parse(JSON.stringify(e.manifest)),n&&0!==Object.keys(n).length){const n={v2Page:v,exportResults:i,appId:e.appId,baseId:p,appSchema:e.jsonSchema,ui5Version:t,factory:o,pageKeys:y,pageType:s.PageType.ListReport,logger:e.logger};h.transferManifestEntriesAndFlexChange(n,c,[],[],e.jsonSchema)}return i}g.log(e.logger,{severity:"error",message:r.default.t("NOLR"),location:{path:l.MANIFESTPATH,range:[s.ManifestSection.generic]}})}(e[s.SchemaType.ListReport],t);if(e[s.SchemaType.ObjectPage])return y(e[s.SchemaType.ObjectPage],t);if(e[s.SchemaType.OverviewPage])return(e=>{const t=m();t.manifest=JSON.parse(JSON.stringify(e.manifest));const n=new d.MetadataInstanceFactoryV2,a=n.createPageInstance(s.PageType.OverviewPage,e.page.config),r=new o.default({allErrors:!0}).compile(e.jsonSchema);if(!r(a))for(const e of r.errors){const t=e.params.additionalProperty;"additionalProperties"!==e.keyword||Object.values(c.CardSettingsType).includes(e.params.additionalProperty)||"settings"===t||i.default(a,`${e.dataPath.slice(1)}.${t}`)}return e.page.config&&0!==Object.keys(e.page.config).length&&h.transferManifestEntriesOVP(a,t,e.jsonSchema,e.jsonSchema,n,[]),t})(e[s.SchemaType.OverviewPage]);if(e[s.SchemaType.Application]){const{application:t,manifest:n,jsonSchema:a}=e[s.SchemaType.Application];return((e,t,n)=>{const a=m();a.manifest=JSON.parse(JSON.stringify(t));const r=Object.assign(new u.ApplicationV2,e);r.settings=Object.assign(new u.AppSettings,e.settings);for(const t in n.definitions.AppSettings.properties){const n=l.getReflectMetadata(r.settings,t);if(n&&n.manifest){const r=n.manifest.path(),i=p.getManifestSectionByPathV2(a.manifest,r);e.settings&&void 0!==e.settings[t]?i[t]=e.settings[t]:delete i[t]}}const i=a.manifest[s.ManifestSection.generic]&&a.manifest[s.ManifestSection.generic].pages;return i&&e.pages&&p.transformPageToNewManifestV2(e.home,e.pages,Object.values(i)[0]),a})(t,n,a)}return e[s.SchemaType.AnalyticalListPage]?function(e,t){const n=e.page.config,a=e.page.entitySet,i=m(e.fragments);i.flexChanges=[],i.manifest=JSON.parse(JSON.stringify(e.manifest));const o=new d.MetadataInstanceFactoryV2,c=o.createPageInstance(s.PageType.AnalyticalListPage,n),u=l.getPageLayoutInformation(c),p=`${e.appId}::${u.id}::${a}--`,y=[],v=f.findAnalyticalListPage(e.manifest[s.ManifestSection.generic].pages,y);if(v){if(v.component.settings||(v.component.settings={}),i.manifest=JSON.parse(JSON.stringify(e.manifest)),n&&0!==Object.keys(n).length){const n={v2Page:v,exportResults:i,appId:e.appId,baseId:p,appSchema:e.jsonSchema,ui5Version:t,factory:o,pageKeys:y,pageType:s.PageType.AnalyticalListPage,logger:e.logger};h.transferManifestEntriesAndFlexChange(n,c,[],[],e.jsonSchema)}return i}g.log(e.logger,{severity:"error",message:r.default.t("NOALP"),location:{path:l.MANIFESTPATH,range:[s.ManifestSection.generic]}})}(e[s.SchemaType.AnalyticalListPage],t):void 0}},7072:function(e,t,n){"use strict";var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});const r=n(390),i=a(n(7040)),o=a(n(2486)),s=n(6785),c=n(6971),l={Table:i.ResponsiveTable,ResponsiveTableWithMultiSelect:i.ResponsiveTable,ResponsiveTableWithInlineDelete:i.ResponsiveTable},u={[r.CardSettingsType.listCardSettings]:i.ListCard,[r.CardSettingsType.listCardSettingsv4]:i.ListCard,[r.CardSettingsType.analyticalCardSettings]:i.AnalyticalCard,[r.CardSettingsType.analyticalCardSettingsv4]:i.AnalyticalCard,[r.CardSettingsType.stackCardSettings]:i.StackCard,[r.CardSettingsType.linkListCardSettings]:i.LinklistCard,[r.CardSettingsType.tableCardSettings]:i.TableCard,[r.CardSettingsType.tableCardSettingsv4]:i.TableCard},p={[c.SAPUI5_VIEW_CLASS]:i.ObjectPageCustomSectionView,[c.SAPUI5_FRAGMENT_CLASS]:i.ObjectPageCustomSectionFragment,Table:i.ObjectPageResponsiveTable,ObjectPageResponsiveTableWithMultiSelect:i.ObjectPageResponsiveTable,ObjectPageResponsiveTableWithInlineDelete:i.ObjectPageResponsiveTable},f={[c.PageType.AnalyticalListPage]:{},[c.PageType.ListReport]:l,[c.PageType.ObjectPage]:p,[c.PageType.OverviewPage]:u};class MetadataInstanceFactoryV2 extends s.MetadataFactory{constructor(){super(i,o,f)}}t.MetadataInstanceFactoryV2=MetadataInstanceFactoryV2},1350:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(6971);function r(e){return{component:{name:"sap.suite.ui.generic.template."+e}}}function i(e,t,n){if(e)for(const a in e){const r=e[a];if(r.entitySet===t&&r.navigationProperty===n)return r}}t.getManifestSectionByPathV2=(e,t)=>{let n=e;return t.split("/").forEach((function(e){n[e]||(n[e]={}),n=n&&n[e]})),n||{}},t.deleteManifestSectionByPathV2=(e,t)=>{let n=e;for(let e=0;e<t.split("/").length;e++){const a=t.split("/")[e];e===t.split("/").length-1?delete n[a]:n=n&&n[a]}},t.transformPageToNewManifestV2=function e(t,n,o){const s=n[t];if(s&&(s.entitySet&&(o.entitySet=s.entitySet),s.pageType===a.PageType.ListReport&&(o.component.list=!0),s.navigationProperty&&(o.navigationProperty=s.navigationProperty),s.defaultLayoutType?o.defaultLayoutType=s.defaultLayoutType:"defaultLayoutType"in o&&delete o.defaultLayoutType,s.navigation)){for(const t in s.navigation)if(n[t]&&(o.pages&&!Object.values(o.pages)[0]&&(o.pages[`${n[t].pageType}|${n[t].entitySet}`]=r(n[t].pageType)),o.pages||(o.pages={[`${n[t].pageType}|${n[t].entitySet}`]:r(n[t].pageType)}),!Array.isArray(o.pages))){let a=i(o.pages,n[t].entitySet,n[t].navigationProperty);a||(o.pages[`${n[t].pageType}|${n[t].entitySet}`]=a=r(n[t].pageType)),e(t,n,a)}Array.isArray(o.pages)||(o.pages&&Object.keys(o.pages).forEach((e=>{const t=o.pages[e];if("sap.suite.ui.generic.template.ObjectPage"===t.component.name){const a=t.navigationProperty?`ObjectPage_${t.entitySet}_${t.navigationProperty}`:`ObjectPage_${t.entitySet}`;n[a]||delete o.pages[e]}})),s.pageType!==a.PageType.ListReport&&s.pageType!==a.PageType.AnalyticalListPage||0!==Object.keys(s.navigation).length||delete o.pages)}}},3318:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(390),i=n(2762),o=n(2762),s=n(5599),c=n(8517);let l=class AnalyticalListPage{};a([o.syncRule({flex:{controlId:s.buildControlIdForPage,controlType:()=>c.ControlType.DynamicPage,createFlexChange:s.exportToFlexChange}})],l.prototype,"fitContent",void 0),a([i.childId("table")],l.prototype,"table",void 0),a([i.childId("template::SmartFilterBar")],l.prototype,"filterBar",void 0),a([i.childId("analyticalListPageChart")],l.prototype,"chart",void 0),l=a([i.pageLayoutInformation({id:"sap.suite.ui.generic.template.AnalyticalListPage.view.AnalyticalListPage",pageId:r.FE_TEMPLATE_V2_ALP})],l),t.AnalyticalListPage=l},5972:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(390),i=n(2762),o=n(2762),s=n(5599),c=n(8517);let l=class ListReport{};a([o.syncRule({flex:{controlId:s.buildControlIdForPage,controlType:()=>c.ControlType.DynamicPage,createFlexChange:s.exportToFlexChange}})],l.prototype,"fitContent",void 0),a([i.childId("listReportFilter")],l.prototype,"filterBar",void 0),a([i.childId("listReport")],l.prototype,"table",void 0),l=a([i.pageLayoutInformation({id:r.SAPUI5_VIEW_EXTENSION_LIST_REPORT,pageId:r.FE_TEMPLATE_V2_LIST_REPORT})],l),t.ListReport=l},650:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(6088),o=n(390);let s=class ObjectPage{};a([r.syncRule({manifest:{path:e=>i.getAppSettingOBJPathV2(e)}}),r.validity({since:"1.52.0"})],s.prototype,"showConfirmationOnDraftActivate",void 0),a([r.syncRule({manifest:{path:e=>i.getAppSettingOBJPathV2(e)}}),r.validity({since:"1.52.1"})],s.prototype,"hideChevronForUnauthorizedExtNav",void 0),a([r.syncRule({manifest:{path:e=>i.getAppSettingOBJPathV2(e)}}),r.validity({since:"1.48.0"})],s.prototype,"allowDeepLinking",void 0),a([r.syncRule({manifest:{path:e=>i.getAppSettingOBJPathV2(e)}}),r.validity({since:"1.52.0"})],s.prototype,"navToListOnSave",void 0),a([r.childId("header")],s.prototype,"header",void 0),a([r.childId("sections")],s.prototype,"sections",void 0),a([r.childId("layout")],s.prototype,"layout",void 0),a([r.syncRule({manifest:{path:e=>i.getAppRootSettingOBJPath(e)}}),r.validity({since:"1.77.0"})],s.prototype,"defaultLayoutTypeIfExternalNavigation",void 0),a([r.syncRule({manifest:{path:e=>i.getAppSettingOBJPathV2(e),import:e=>{if("chartSettings"in e)return e.chartSettings},key:"chartSettings"}}),r.validity({since:"1.78.0"})],s.prototype,"globalChartSettings",void 0),s=a([r.pageLayoutInformation({id:o.SAPUI5_VIEW_EXTENSION_OBJECT_PAGE,pageId:o.FE_TEMPLATE_V2_OBJECT_PAGE})],s),t.ObjectPage=s},8607:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(6088),o=n(296);function s(e){const t={};return t.dateSettings=o.importDateSettings(e.filterSettings),t}function c(e,t){e.filterSettings||(e.filterSettings={});const n="dateSettings";if(void 0===t.filterSettings[n])delete e.filterSettings[n];else if(e.filterSettings[n]=JSON.parse(JSON.stringify(t.filterSettings[n])),t.filterSettings[n].selectedValues&&(e.filterSettings[n].selectedValues=t.filterSettings[n].selectedValues.join()),t.filterSettings[n].fields)for(const a in t.filterSettings[n].fields){const r=t.filterSettings[n].fields[a];if(r.selectedValues&&(e.filterSettings[n].fields[a].selectedValues=r.selectedValues.join()),r.filter)for(const t in r.filter){const i=r.filter[t];i.equals&&Array.isArray(i.equals)&&(e.filterSettings[n].fields[a].filter[t].equals=i.equals.join())}}}t.importFilterSettings=s,t.exportFilterSettings=c;let l=class OverviewPage{};a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"globalFilterModel",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"globalFilterEntityType",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"globalFilterEntitySet",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"containerLayout",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"smartVariantRequired",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"showDateInRelativeFormat",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"enableLiveFilter",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"imageSupported",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"considerAnalyticalParameters",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"refreshIntervalInMinutes",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"useDateRangeType",void 0),a([r.syncRule({manifest:{path:e=>i.getGlobalSettingsPath(e)}}),r.validity({since:"1.80.0"})],l.prototype,"chartSettings",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath(),import:s,export:c}}),r.validity({since:"1.80.0"})],l.prototype,"filterSettings",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"showBasicSearch",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"disableErrorPage",void 0),a([r.syncRule({manifest:{path:()=>i.getOVPsettingPath()}})],l.prototype,"bHeaderExpanded",void 0),l=a([r.pageLayoutInformation({id:"sap.suite.ui.generic.template.OverviewPage.view.Details",pageId:"sap.suite.ui.generic.template.OverviewPage"})],l),t.OverviewPage=l},2486:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(3318)),a(n(5972)),a(n(650)),a(n(8607))},4667:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5622),r=n(5179),i=n(5747),o=a.join(__dirname,"templates");var s;!function(e){e.XML="xml",e.HTML="html",e.JS="js",e.JSON="json"}(t.ViewTypes||(t.ViewTypes={})),function(e){e.Sapux="src",e.Schemas=".schemas",e.Pages="pages",e.Webapp="webapp",e.Temp=".tmp",e.Changes="changes",e.LocalService="localService",e.Controller="controller",e.View="view",e.Fragment="fragment",e.Ext="ext",e.VSCode=".vscode"}(s=t.DirName||(t.DirName={}));const c=(e,t)=>{const n=i.readFileSync(e,"utf8");return r.render(n,t)},l=e=>e.replace(/[^\w\s-]/gi,"");t.getControllerContent=(e,t,n=!1,r=!1)=>{const i={name:t+"."+l(e),newControllerRouting:r};return c(a.join(o,n?"controllerFcl.js":"controller.js"),i)},t.getViewContent=(e,t,n,r=!1,i=!0)=>{const s=l(e),u={name:s,controllerName:"",page:i};return r&&(u.controllerName=t+".controller."+s),c(a.join(o,"view."+n),u)},t.getFragmentContent=(e,t,n,r=!1)=>{const i=l(e),u={name:i,handler:""};return r&&(u.handler=`${t.replace(/\./g,"/")}/${s.Fragment}/${i}`),c(a.join(o,"fragment."+n),u)},t.getSingleColumnContent=(e,t)=>{const n={id:e.id,text:e.text,columnKey:e.columnKey,columnIndex:void 0!==e.columnIndex?e.columnIndex.toString():void 0,leadingProperty:e.leadingProperty};return c(a.join(o,t+".xml"),n)},t.getColumnFragmentContent=(e,n)=>{let a="";if(a='<core:FragmentDefinition xmlns:core="sap.ui.core" xmlns:table="sap.ui.table" xmlns="sap.m">',e)for(let r=0;r<e.length;r++){const i=e[r];a=a+"\n"+t.getSingleColumnContent(i,n)}return a+"\n</core:FragmentDefinition>"},t.getResponsiveTableCellsFragment=e=>{let t='<core:FragmentDefinition xmlns:core="sap.ui.core" xmlns="sap.m">';if(e)for(let n=0;n<e.length;n++)t+='\n<Text text="Placeholder"></Text>';return t+"\n</core:FragmentDefinition>"},t.getFragmentJsContent=()=>c(a.join(o,"fragment.js"),{})},3026:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(468),i=n(4330),o=n(5008),s=a(n(9154)),c=n(2449),l=n(5921),u=n(3374),p=n(6083);t.generateAnalyticalListReportSchemaV2=function(e,t,n){var a,f,d;c.initI18n();const h=JSON.parse(JSON.stringify(t));h.properties.table.anyOf[0].$ref=o.DEFINITION_LINK_PREFIX+"ALPResponsiveTable<LineItems>";const g=JSON.parse(JSON.stringify(h.definitions.ALPResponsiveTable));g.properties.columns.$ref=o.DEFINITION_LINK_PREFIX+"LineItems",g.properties.toolBar.$ref=o.DEFINITION_LINK_PREFIX+o.TOOLBAR,h.definitions["ALPResponsiveTable<LineItems>"]=g,h.properties.table.anyOf[1].$ref=o.DEFINITION_LINK_PREFIX+"ALPGridTable<LineItems>";const m=JSON.parse(JSON.stringify(h.definitions.ALPGridTable));m.properties.columns.$ref=o.DEFINITION_LINK_PREFIX+"LineItems",m.properties.toolBar.$ref=o.DEFINITION_LINK_PREFIX+o.TOOLBAR,h.definitions["ALPGridTable<LineItems>"]=m,h.properties.table.anyOf[2].$ref=o.DEFINITION_LINK_PREFIX+"ALPAnalyticalTable<LineItems>";const y=JSON.parse(JSON.stringify(h.definitions.ALPAnalyticalTable));y.properties.columns.$ref=o.DEFINITION_LINK_PREFIX+"LineItems",y.properties.toolBar.$ref=o.DEFINITION_LINK_PREFIX+o.TOOLBAR,h.definitions["ALPAnalyticalTable<LineItems>"]=y,r.removeElementsFromEnum(h.definitions.TableColumnExtensionTypeV2.enum,[u.TableColumnExtensionTypeV2.TreeTableColumnsExtension]);const v=null===(a=null==e?void 0:e.serviceAVT.entityTypes)||void 0===a?void 0:a.find((e=>e.name===n));if(v){const t=null===(d=null===(f=null==v?void 0:v.annotations)||void 0===f?void 0:f.UI)||void 0===d?void 0:d.LineItem;r.addLineItemsType(h,t,v),o.addFieldsType(h,v);const n=[],a=i.findAnalyticalListPage(e.manifest[u.ManifestSection.generic].pages,n);if(!a)return void l.log(e.logger,{severity:"error",message:s.default.t("NOALP"),location:{path:u.MANIFESTPATH,range:[u.ManifestSection.generic]}});r.addListReportColumnExtensions(h,v,a,e.manifest,e.fragments),p.addEnumForVariantPaths(v,h,e.serviceAVT),delete h.definitions.ALPGridTable,delete h.definitions.ALPResponsiveTable,delete h.definitions.ALPAnalyticalTable,delete h.definitions.GenericColumns,delete h.definitions.ToolBar,delete h.definitions.Actions}else l.log(e.logger,{severity:"error",message:s.default.t("NOENTITYTYPE",{entityType:n}),location:{path:o.METADATAPATH}});return h}},220:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(9081),r=n(8289),i=n(6083),o=n(3026),s=n(1353),c=n(4027);t.generateObjectPageInterfaceV2=function(e,t,n,i,o,s){const l=a.parseAndMergeAndConvert(n,s),u={fioriElementsVersion:c.FioriElementsVersion.v2,manifest:i,fragments:o,serviceAVT:l,logger:s};return r.generateObjectPageSchemaV2(u,e,t)},t.generateListReportInterfaceV2=function(e,t,n,r,o,s){const l=a.parseAndMergeAndConvert(n,s),u={fioriElementsVersion:c.FioriElementsVersion.v2,manifest:r,fragments:o,serviceAVT:l,logger:s};return i.generateListReportSchemaV2(u,e,t)},t.generateOVPInterfaceV2=function(e,t){return s.generateOverviewPageSchemaV2(e,t)},t.generateAnalyticalListPageInterfaceV2=function(e,t,n,r,i,s){const l=a.parseAndMergeAndConvert(n,s),u={fioriElementsVersion:c.FioriElementsVersion.v2,manifest:r,fragments:i,serviceAVT:l,logger:s};return o.generateAnalyticalListReportSchemaV2(u,e,t)}},1918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=n(220);t.generateAnalyticalListPageInterfaceV2=a.generateAnalyticalListPageInterfaceV2,t.generateListReportInterfaceV2=a.generateListReportInterfaceV2,t.generateObjectPageInterfaceV2=a.generateObjectPageInterfaceV2,t.generateOVPInterfaceV2=a.generateOVPInterfaceV2;var r=n(8289);t.generateObjectPageSchemaV2=r.generateObjectPageSchemaV2;var i=n(6083);t.generateListReportSchemaV2=i.generateListReportSchemaV2;var o=n(3026);t.generateAnalyticalListReportSchemaV2=o.generateAnalyticalListReportSchemaV2},6083:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(468),i=n(4330),o=n(5008),s=a(n(9154)),c=n(2449),l=n(3374),u=n(5921),p=n(1205);function f(e,t,n){o.addEnumForSingleTabVariant(e,t,"QuickVariant"),o.addEnumForMultiTabVariant(n,t,"QuickVariantX"),o.addEnumForVariantEntitySet(n,t,"QuickVariantX")}t.addEnumForVariantPaths=f,t.generateListReportSchemaV2=function(e,t,n){c.initI18n();const a=JSON.parse(JSON.stringify(t));a.properties.table.anyOf[0].$ref=o.DEFINITION_LINK_PREFIX+p.MULTISELECTTABLE,a.properties.table.anyOf[1].$ref=o.DEFINITION_LINK_PREFIX+p.INLINEDELETETABLE,a.properties.table.anyOf[2].$ref=o.DEFINITION_LINK_PREFIX+p.TREETABLE,a.properties.table.anyOf[3].$ref=o.DEFINITION_LINK_PREFIX+p.ANALYTICALTABLE,a.properties.table.anyOf[4].$ref=o.DEFINITION_LINK_PREFIX+p.GRIDTABLE;const d=JSON.parse(JSON.stringify(t.definitions.ResponsiveTableWithMultiSelect)),h=JSON.parse(JSON.stringify(t.definitions.ResponsiveTableWithInlineDelete)),g=JSON.parse(JSON.stringify(t.definitions.TreeTable)),m=JSON.parse(JSON.stringify(t.definitions.AnalyticalTable)),y=JSON.parse(JSON.stringify(t.definitions.GridTable)),v={$ref:o.DEFINITION_LINK_PREFIX+"LineItems"};d.properties.columns=v,h.properties.columns=v,g.properties.columns=v,m.properties.columns=v,y.properties.columns=v;const b=o.DEFINITION_LINK_PREFIX+o.TOOLBAR;a.definitions[p.MULTISELECTTABLE]=d,a.definitions[p.MULTISELECTTABLE].properties.toolBar.$ref=b,a.definitions[p.INLINEDELETETABLE]=h,a.definitions[p.INLINEDELETETABLE].properties.toolBar.$ref=b,a.definitions[p.TREETABLE]=g,a.definitions[p.TREETABLE].properties.toolBar.$ref=b,a.definitions[p.ANALYTICALTABLE]=m,a.definitions[p.ANALYTICALTABLE].properties.toolBar.$ref=b,a.definitions[p.GRIDTABLE]=y,a.definitions[p.GRIDTABLE].properties.toolBar.$ref=b;const P=null==e?void 0:e.serviceAVT.entityTypes.find((e=>e.name===n));if(P){const t=P.annotations&&P.annotations.UI&&P.annotations.UI.LineItem;r.addLineItemsType(a,t,P),o.addFieldsType(a,P);const n=[],c=i.findListReportPageV2(e.manifest[l.ManifestSection.generic].pages,n);if(!c)return void u.log(e.logger,{severity:"error",message:s.default.t("NOALP"),location:{path:l.MANIFESTPATH,range:[l.ManifestSection.generic]}});r.addListReportColumnExtensions(a,P,c,e.manifest,e.fragments),f(P,a,e.serviceAVT),o.addEnumForFilterBarAnnotationPath(P,a,"ListReportFilterBar"),delete a.definitions.ResponsiveTableWithMultiSelect,delete a.definitions.ResponsiveTableWithInlineDelete,delete a.definitions.TreeTable,delete a.definitions.AnalyticalTable,delete a.definitions.GridTable,delete a.definitions.GenericColumns,delete a.definitions.ToolBar,delete a.definitions.Actions}else u.log(e.logger,{severity:"error",message:s.default.t("NOENTITYTYPE",{entityType:n}),location:{path:o.METADATAPATH}});return a}},8289:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5008),i=n(468),o=n(4330),s=n(3374),c=n(5921),l=n(6971),u=a(n(9154)),p=n(2449),f=n(1205);function d(e,t,n,a){let i;switch(a){case f.SectionTypeV2.Section:case f.SectionTypeV2.SectionForm:case f.SectionTypeV2.SectionChart:case f.SectionTypeV2.SectionTable:i=s.ControlType.Section;break;case f.SectionTypeV2.SubSection:i=s.ControlType.SubSection;break;case f.SectionTypeV2.SubSectionForm:i=s.ControlType.SmartGroup;break;case f.SectionTypeV2.SubSectionChart:i=s.ControlType.SmartChart;break;case f.SectionTypeV2.SubSectionTable:i=s.ControlType.SmartTable}void 0!==i&&(r.addPatternForBindingChangeOfEnumOP(e,t,n),t.properties[n].artifactType="FlexChange",t.properties[n].controlType=i)}function h(e,t,n,a,i){return(o,s)=>{if(!o.Determining&&"com.sap.vocabularies.UI.v1.DataFieldForAction"===o.$Type){const c=r.replaceAlias(o.Action,i),{actionName:l,actionId:u}=r.getActionNameAndId(c,e),p=o.Label||l,f=`HeaderAction<${r.prepareRef(u)}>`;t.definitions[f]=JSON.parse(JSON.stringify(t.definitions.HeaderAction));const d=n.fullyQualifiedName.replace("@com.sap.vocabularies.UI.v1.Identification","/@com.sap.vocabularies.UI.v1.Identification");t.definitions[f].annotationPath=`/${d}/${s}`,t.definitions[f].description=p,a.properties[u]={$ref:`${r.DEFINITION_LINK_PREFIX}${f}`}}}}function g(e,t,n,a){const i=r.prepareRef(`${e}<${t}>`);a.definitions[i]=JSON.parse(JSON.stringify(a.definitions[e])),a.definitions[i].properties.columns.$ref=r.DEFINITION_LINK_PREFIX+t,a.definitions[i].properties.toolBar.$ref=`${r.DEFINITION_LINK_PREFIX}ObjectPageToolBar<${t}>`,a.definitions[i].annotationPath=n.annotationPath,void 0!==n.ID&&(a.definitions[i].title=r.FacetTitlePrefix+n.ID),a.definitions[i].description="Table",a.definitions[i].properties.quickVariantSelection.$ref=`${r.DEFINITION_LINK_PREFIX}QuickVariantSelectionOP<${t}>`,a.definitions[`QuickVariantSelectionOP<${t}>`]=JSON.parse(JSON.stringify(a.definitions.QuickVariantSelectionOP)),a.definitions[`QuickVariant<${t}>`]=JSON.parse(JSON.stringify(a.definitions.QuickVariant)),a.definitions[`QuickVariantSelectionOP<${t}>`].properties.variants.patternProperties["^[0-9]+$"].$ref=`QuickVariant<${t}>`,r.addEnumForSingleTabVariant(n.entityType,a,`QuickVariant<${t}>`)}function m(e,t,n,a,s,c){var u;if("LineItem"!==a.base||!t)return;const p=t.split("::")[0],h=`${c}<${t}>`;n.definitions[h]=r.createSectionWithoutProperties(a,t);const m=n.definitions[h];a.ID||(null===(u=a.target)||void 0===u?void 0:u.qualifier)?(m.properties=JSON.parse(JSON.stringify(n.definitions[f.SectionTypeV2.SectionTable].properties)),m.properties.visible&&d(n,m,"visible",c)):m.properties.table=JSON.parse(JSON.stringify(n.definitions[f.SectionTypeV2.SectionTable].properties.table)),m.properties.table.anyOf=[{$ref:`${r.DEFINITION_LINK_PREFIX}ObjectPageResponsiveTableWithMultiSelect<${t}>`},{$ref:`${r.DEFINITION_LINK_PREFIX}ObjectPageResponsiveTableWithInlineDelete<${t}>`},{$ref:`${r.DEFINITION_LINK_PREFIX}ObjectPageAnalyticalTable<${t}>`},{$ref:`${r.DEFINITION_LINK_PREFIX}ObjectPageGridTable<${t}>`},{$ref:`${r.DEFINITION_LINK_PREFIX}ObjectPageTreeTable<${t}>`}],m.annotationPath=a.annotationPath,r.addSectionTitleAndDescription(a,m,t);const y=a.entityType?null==e?void 0:e.serviceAVT.entitySets.find((e=>e.entityType.name===a.entityType.name||e.name===a.entityType.name)):void 0;let v;g("ObjectPageResponsiveTableWithMultiSelect",t,a,n),g("ObjectPageResponsiveTableWithInlineDelete",t,a,n),g("ObjectPageGridTable",t,a,n),g("ObjectPageTreeTable",t,a,n),g("ObjectPageAnalyticalTable",t,a,n),y&&(v=function(e,t,n,a,r,s){const c=`${i.CUSTOM_COLUMNS_DEFINITION}<${n}>`;if(e.definitions[c])return i.CUSTOM_COLUMNS_DEFINITION;const u=`${i.CUSTOM_COLUMN_DEFINITION}<${n}>`,p=JSON.parse(JSON.stringify(e.definitions.TableCustomColumn));e.definitions[u]=p;const f=r.entityTypes.find((e=>e.name===a)),d=o.findObjectPageV2(t[l.ManifestSection.generic].pages,n,[]);return i.addListReportColumnExtensions(e,f,d,t,s,c,u),c}(n,e.manifest,y.name,a.entityType.name,null==e?void 0:e.serviceAVT,e.fragments));for(const e in s)"LineItem"===s[e].base&&e.includes(p)&&i.addLineItemsType(n,s[e].target,s[e].entityType,t,v)}function y(e,t,n,a,i,o=!1){var c;const u=t[n];switch(u.base){case s.FacetBase.CollectionFacet:{const t="Subsections"===(null==a?void 0:a.description)?f.SectionTypeV2.SubSection:f.SectionTypeV2.Section,s=n.replace("@com.sap.vocabularies.UI.v1.Facets",u.base);o=!0;const c=`${t}<${s}>`;a.properties[s]={$ref:`${r.DEFINITION_LINK_PREFIX}${c}`},function(e,t,n,a){const i=`${a}<${e.replace("@com.sap.vocabularies.UI.v1.Facets",n.base)}>`;t.definitions[i]=r.createSectionWithoutProperties(n,e);const o=t.definitions[i];n.ID&&(o.properties=JSON.parse(JSON.stringify(t.definitions[f.SectionTypeV2.SubSection].properties)),o.properties.visible&&d(t,o,"visible",a)),o.properties.subsections={type:"object",description:"Subsections",properties:{},additionalProperties:!1,isViewNode:!0}}(n,i,u,t);const l=i.definitions[c].properties.subsections;for(const t in u.facets)y(e,u.facets,t,l,i,o);break}case s.FacetBase.LineItem:{const s=o?f.SectionTypeV2.SubSectionTable:f.SectionTypeV2.SectionTable;a.properties[n]={$ref:`${r.DEFINITION_LINK_PREFIX}${s}<${n}>`},m(e,n,i,u,t,s);const c="OP";r.addFieldsType(i,u.entityType,c);break}case s.FacetBase.Chart:{const e=o?f.SectionTypeV2.SubSectionChart:f.SectionTypeV2.SectionChart,t=`${e}<${n}>`;a.properties[n]={$ref:`${r.DEFINITION_LINK_PREFIX}${t}`},i.definitions[t]=r.createSectionWithoutProperties(u,n);const s=i.definitions[t];u.ID&&(s.properties=JSON.parse(JSON.stringify(i.definitions[f.SectionTypeV2.SectionChart].properties)),s.properties.visible&&d(i,s,"visible",e));break}case s.FacetBase.Form:case s.FacetBase.Identification:{const e=o?f.SectionTypeV2.SubSectionForm:f.SectionTypeV2.SectionForm,t=`${e}<${n}>`;a.properties[n]={$ref:`${r.DEFINITION_LINK_PREFIX}${t}`},i.definitions[t]=r.createSectionWithoutProperties(u,n);const p=i.definitions[t];((null==u?void 0:u.ID)||(null===(c=u.target)||void 0===c?void 0:c.qualifier))&&(p.properties=JSON.parse(JSON.stringify(i.definitions[f.SectionTypeV2.SectionForm].properties)),p.properties.visible&&d(i,p,"visible",e)),(null==u?void 0:u.ID)&&(p.title=r.FacetTitlePrefix+u.ID),(null==u?void 0:u.Label)&&(p.description=u.Label);let h=!0;p.annotationPath=u.annotationPath,p.isViewNode=!0,p.description||(u.base===s.FacetBase.Form?p.description="Form":"Identification"===u.base&&(p.description="Identification",h=!1)),r.handleForm(s.SectionType.Section,u,p,i,l.FioriElementsVersion.v2,h);break}default:a.properties[n]=r.createSectionWithoutProperties(u,n)}}function v(e,t,n,a,i){const o=t.definitions.Sections={type:"object",properties:{},description:"Sections",additionalProperties:!1,isViewNode:!0};if(n&&(o.annotationPath=`/${n.fullyQualifiedName}/@com.sap.vocabularies.UI.v1.Facets`),!i)return;const s=r.getObjectPageFacets(n,null==e?void 0:e.serviceAVT,l.FioriElementsVersion.v2,e.logger);if(s&&0!==Object.keys(s).length){for(const r in i){const c=i[r];if(a.includes(c.entitySet))for(const n in s)y(e,s,n,o,t);else v(e,t,n,a,c.pages)}for(const e in t.definitions.CustomSections.properties)o.properties[e]=t.definitions.CustomSections.properties[e]}}t.generateObjectPageSchemaV2=function(e,t,n){p.initI18n();const a=JSON.parse(JSON.stringify(t)),o={};for(const e in a.definitions.CustomSections.properties)o[e]=a.definitions.CustomSections.properties[e];a.properties.sections={$ref:r.DEFINITION_LINK_PREFIX+"Sections"};const f=(null==e?void 0:e.serviceAVT.entitySets)&&(null==e?void 0:e.serviceAVT.entitySets.find((e=>e.entityType.name===n||e.name===n)));if(!f)return void c.log(e.logger,{severity:"error",message:u.default.t("NOENTITYSET4NAME",{entityType:n}),location:{path:r.METADATAPATH}});const d=null==f?void 0:f.entityType,g=e.manifest[l.ManifestSection.generic].pages;return g?(function(e,t,n){r.addCommonHeaderSchema(e,t),r.addHeaderActions(e,t,n,h)}(a,d,null==e?void 0:e.serviceAVT),v(e,a,d,f.name,g),function(e,t,n,a){const i=r.getObjectPageFacetSection(t,n,a,void 0,!0);i&&r.addDefinitionForRelatedFacetKeys(e,["ObjectPageCustomSectionFragment","ObjectPageCustomSectionView"],i,["ID","key"])}(a,d,null==e?void 0:e.serviceAVT,e.logger),i.removeElementsFromEnum(a.definitions.TableColumnExtensionTypeV2.enum,[s.TableColumnExtensionTypeV2.TreeTableColumnsExtension]),a.definitions.Sections||(a.definitions.RelatedFacetKeys&&a.definitions.RelatedFacetKeys.oneOf.length?a.definitions.Sections={type:"object",properties:o,additionalProperties:!1,isViewNode:!0}:delete a.properties.sections),r.addFooterActions(a,d,null==e?void 0:e.serviceAVT),delete a.definitions.GenericSections,delete a.definitions.ObjectPageSectionTableV2,delete a.definitions.GenericColumns,delete a.definitions.ObjectPageSectionFormV2,delete a.definitions.ObjectPageSectionTableV2,delete a.definitions.ObjectPageSubSectionV2,delete a.definitions.ObjectPageResponsiveTableWithMultiSelect,delete a.definitions.ObjectPageResponsiveTableWithInlineDelete,delete a.definitions.ObjectPageAnalyticalTable,delete a.definitions.ObjectPageTreeTable,delete a.definitions.ObjectPageGridTable,delete a.definitions.ObjectPageToolBar,delete a.definitions.ObjectPageToolBarActions,delete a.definitions.ObjectPageToolBarAction,delete a.definitions.ObjectPageForm,delete a.definitions.ObjectPageFormFields,delete a.definitions.ObjectPageFormActions,a):(c.log(e.logger,{severity:"error",message:u.default.t("NOPAGES",{appId:e.manifest["sap.app"].id}),location:{path:s.MANIFESTPATH,range:[l.ManifestSection.generic]}}),a)}},1353:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(6971),r=n(5008);function i(e){const t=e.properties;return(t.cards&&t.cards.additionalProperties&&t.cards.additionalProperties.anyOf||[]).map((e=>{const t=e.$ref.split("/");return t[t.length-1]}))}function o(e,t){const n=t&&t["sap.app"]&&t["sap.app"].dataSources||{},o=[];for(const e in n)n[e].type===a.DataSourceType.OData&&o.push(e);const s=e.definitions;s.CardModel={enum:o,type:"string"};const c=i(e);for(const e of c){const t=s[e].properties.model;delete t.type,t.$ref=r.DEFINITION_LINK_PREFIX+"CardModel"}}t.getCardDefinitionNames=i,t.addModelsEnum=o,t.generateOverviewPageSchemaV2=function(e,t){const n=JSON.parse(JSON.stringify(e));return n.properties.cards.propertyNames={pattern:"^[a-zA-Z0-9_\\.\\-]+$"},o(n,t),n}},468:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5008),r=n(2762),i=n(5622),o=n(4139);function s(e,t,n,r,i,o){if(!0!==i.Determining){const s=`ToolBarAction<${a.prepareRef(i.Action)}>`,c=a.getDatafieldDescription(i,t);n.properties[`DataFieldForAction::${i.Action}`]={$ref:a.DEFINITION_LINK_PREFIX+s,description:c,propertyIndex:o},e.definitions[s]={type:"object",properties:{},description:c,annotationPath:r+"/"+o,isViewNode:!0,additionalProperties:!1}}}function c(e,t,n){const a=e.definitions[n]&&e.definitions[n].properties&&e.definitions[n].properties.leadingProperty;if(a){const e=[...(null==t?void 0:t.entityProperties)||[],...(null==t?void 0:t.navigationProperties)||[]];a.enum=null==e?void 0:e.reduce(((e,t)=>(e.includes(t.name)||e.push(t.name),e)),[])}}function l(e,t,n){const a=e.definitions[t]&&e.definitions[t].properties&&e.definitions[t].properties.tabKey;if(n){const e=n.component&&n.component.settings&&n.component.settings.quickVariantSelectionX&&n.component.settings.quickVariantSelectionX.variants;if(e){const t=[];Object.keys(e).reduce(((t,n)=>{const a=e[n]&&void 0!==e[n].key?e[n].key:void 0;return void 0===a||t.includes(a)||t.push(a),t}),t),a.enum=t}}}function u(e,t,n,a,r){const s=e.definitions[r]&&e.definitions[r].properties&&e.definitions[r].properties[a];if(t&&n&&!n.startsWith("${")){const e=[];t.forEach((t=>{let r=t.dataSourceUri.split("webapp")[1];if(r&&r.indexOf(".fragment.xml")>0){const s=JSON.parse(o.xml2json(t.fileContent,{compact:!0}))["core:FragmentDefinition"];if("fragmentName"===a&&(!s||s.Column||s["table:Column"])||"cellsFragmentName"===a&&(!s||!s.Column&&!s["table:Column"]&&!s["smartfilterbar:ControlConfiguration"])){r=r.replace(new RegExp("\\"+i.sep,"g"),"/");const t=n+r.split(".fragment.xml")[0].replace(/\//g,".");e.push(t)}}})),e.length>0&&(s.enum=e)}}function p(e,t,n,i,o,s,c){if(e){const l=r.getReflectMetadata(e,s);if(l&&("function"==typeof l.generate&&(l.generate(t,c,s),o=c.properties[s]),void 0!==l.manifest?o.artifactType=a.ArtifactType.Manifest:void 0!==l.flex?(o.artifactType=a.ArtifactType.FlexChange,l.flex.controlType&&(o.controlType=l.flex.controlType())):o.artifactType=a.ArtifactType.Annotation),"object"===o.type||o.$ref){const e=a.getNextTargetDefinition(t,"",{},o,s,i,n);e&&d(t,e.targetDefinition,e.configObject,n,i)}else o.anyOf&&o.anyOf.forEach((e=>{const r=a.getNextTargetDefinition(t,"",{},e,s,i,n);r&&d(t,r.targetDefinition,r.configObject,n,i)}))}}function f(e,t,n,r,i,o){if(t[r])for(const s in t[r])if("anyOf"===s)t[r].anyOf.forEach((t=>{const n=a.getNextTargetDefinition(e,"",{},t,s,o,i);n&&d(e,n.targetDefinition,n.configObject,i,o)}));else{const c=t[r][s];if(c.anyOf)c.anyOf.forEach((t=>{const n=a.getNextTargetDefinition(e,"",{},t,s,o,i);n&&d(e,n.targetDefinition,n.configObject,i,o)}));else if("$ref"===s){const n=a.getNextTargetDefinition(e,"",{},t[r],s,o,i);n&&d(e,n.targetDefinition,n.configObject,i,o)}else p(n,e,i,o,c,s,t)}}function d(e,t,n,a,r){f(e,t,n,"properties",a,r),f(e,t,n,"additionalProperties",a,r),f(e,t,n,"patternProperties",a,r)}t.CUSTOM_COLUMNS_DEFINITION="TableCustomColumns",t.CUSTOM_COLUMN_DEFINITION="TableCustomColumn",t.handleActionRecord=s,t.addLineItemsType=function(e,t,n,r,i){let o;r=r||"LineItems";const{actions:c,lineItemPath:l}=a.addCommonLineItemDefinitions(e,t,n,r);if(t){let i=0;t.forEach((t=>{"com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation"===t.$Type||"com.sap.vocabularies.UI.v1.DataFieldForAction"===t.$Type&&(!0!==t.Inline||!0===t.Determining)?s(e,n,c,l,t,i):(o=a.getSchemaKeyOfLineItemRecord(t),o&&(e.definitions[r].properties[o]={$ref:a.DEFINITION_LINK_PREFIX+"TableColumn",description:a.getDatafieldDescription(t,n),propertyIndex:i,annotationPath:l+"/"+i})),i++}))}i&&(e.definitions[r].properties.custom={$ref:`${a.DEFINITION_LINK_PREFIX}${i}`})},t.addListReportLeadingProperties=c,t.addTabkeyEnum=l,t.addFragmentEnum=u,t.addListReportColumnExtensions=function(e,n,r,i,o,s=t.CUSTOM_COLUMNS_DEFINITION,p=t.CUSTOM_COLUMN_DEFINITION){e.definitions.LineItems&&(e.definitions.LineItems.properties.custom={$ref:`${a.DEFINITION_LINK_PREFIX}${s}`}),e.definitions[s]={type:"array",items:{$ref:`${a.DEFINITION_LINK_PREFIX}${p}`},isViewNode:!0,description:"Custom Columns"},c(e,n,p),l(e,p,r);const f=i&&i["sap.app"]&&i["sap.app"].id;u(e,o,f,"fragmentName",p),u(e,o,f,"cellsFragmentName",p)},t.processMetadata=d,t.removeElementsFromEnum=function(e,t){for(let n=0;n<t.length;n++){const a=e.indexOf(t[n]);-1!==a&&e.splice(a,1)}}},3073:function(e,t,n){"use strict";var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});const r=n(6971),i=n(4093),o=n(9609),s=n(2687),c=n(961),l=n(2201),u=n(6088),p=n(5008),f=n(3435),d=a(n(4867));function h(e){return p.generatePageId(p.getPageTypeV2(e.component.name),e.entitySet,e.navigationProperty)}function g(e,t,n,a,i,o){const u={};for(const f in e){const d=e[f],m=h(d),y=Object.assign(Object.assign({pageType:p.getPageTypeV2(d.component.name),entitySet:d.entitySet},d.navigationProperty&&{navigationProperty:d.navigationProperty}),d.defaultLayoutType&&{defaultLayoutType:d.defaultLayoutType});u[m]=y;const v=Object.keys(a).find((e=>e.includes(m)))||Object.keys(a).find((e=>e.includes(m.slice(0,-1))))||Object.keys(a).find((e=>e.includes(y.pageType)));if(v)if(y.pageType===r.PageType.ListReport){const e={manifest:n,flex:t,jsonSchema:a[v],fragments:i,logger:o};y.config=s.createListReportConfig(e)}else if(y.pageType===r.PageType.AnalyticalListPage){const e={manifest:n,flex:t,jsonSchema:a[v],fragments:i,logger:o};y.config=c.createAnalyticalListPageConfig(e)}else{const e={manifest:n,flex:t,jsonSchema:a[v],entitySet:y.entitySet,fragments:i,logger:o};y.config=l.createObjectPageConfigV2(e)}if(d.pages){y.navigation={};const e=g(d.pages,t,n,a,i);for(const t in e){const n=e[t];u[t]=n}for(const t in d.pages){const n=h(d.pages[t]);y.navigation[n]=e[n].navigationProperty?y.entitySet+"."+e[n].navigationProperty:y.entitySet}}}return u}class V2AppProvider extends i.AppProvider{constructor(e,t,n,a,i){const s=e[r.ManifestSection.generic].pages,c=Object.keys(s)[0],l=new u.AppSettings,d=n[p.getSchemaFilePath(f.SchemaType.Application).filename];o.transferSettingsOfObject(l,e,d.definitions.AppSettings,void 0),super(e,n,h(s[c]),g(s,t,e,n,a,i),r.FioriElementsVersion.v2,l)}}t.V2AppProvider=V2AppProvider,t.getPages=function e(t,n){const a={};for(const r in t){const i=t[r];if(i.component.name===n){a[h(i)]=i}if(n===d.FE_TEMPLATE_V2_OBJECT_PAGE&&i.pages){const t=e(i.pages,n);for(const e in t)a[e]=t[e]}}return a}},4370:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(6971),r=n(4093),i=n(9609),o=n(9836),s=n(6088),c=n(5008),l=n(3435);class V2OvpProvider extends r.AppProvider{constructor(e,t,n){const r={},u=e[a.ManifestSection.ovp],p=new s.AppSettings,f=c.getSchemaFilePath(l.SchemaType.Application);i.transferSettingsOfObject(p,e,t[f.filename].definitions.AppSettings,void 0);const d={manifest:e,jsonSchema:t[Object.keys(t).find((e=>e.includes(a.PageType.OverviewPage)))]},h={pageType:a.PageType.OverviewPage,config:o.createOverviewPageConfig(d),entitySet:u.globalFilterEntitySet},g=c.generatePageId(h.pageType,h.entitySet,h.navigationProperty);r[g]=h,super(e,t,g,r,a.FioriElementsVersion.v2,p,n)}}t.V2OvpProvider=V2OvpProvider},9609:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(4681),i=n(3767),o=n(5008),s=n(6442),c=n(2762),l=n(1350),u=n(390),p=n(5921),f=a(n(9154));function d(e){return e.replace(/:2f/g,"/").replace(/:23/g,"#").replace(/:40/g,"@")}t.convertSelector=d,t.addFlex=function(e,t,n,a){var s,l,h,g,m,y,v;try{const a=o.parseChangeString(t),p=a.content.property;if((null===(s=a.controlId)||void 0===s?void 0:s.includes(r.PageType.ListReport))||(null===(l=a.controlId)||void 0===l?void 0:l.includes(r.PageType.AnalyticalListPage)))if(a.controlId=d(a.controlId),a.controlType===o.ControlType.SmartFilterBar){((null===(g=null===(h=n.definitions)||void 0===h?void 0:h.ListReportFilterBar)||void 0===g?void 0:g.properties[p])||(null===(y=null===(m=n.definitions)||void 0===m?void 0:m.AnalyticalListPageFilterBar)||void 0===y?void 0:y.properties[p]))&&(e.filterBar[p]=a.content.newBinding?a.content.newBinding:a.content.newValue)}else if(a.controlType===o.ControlType.DynamicPage){n.properties[p]&&(e[a.content.property]=a.content.newValue)}else if(a.controlType===o.ControlType.SmartChart){if(n.definitions.ChartSettings.properties[p]){const t=c.getReflectMetadata(e.chart,p);(null===(v=null==t?void 0:t.flex)||void 0===v?void 0:v.importFlexValue)?t.flex.importFlexValue(a,e.chart,p):e.chart[p]=a.content.newBinding?a.content.newBinding:a.content.newValue}}else{const t={controlId:a.controlId,propertyId:a.content.property,newValue:a.content.newBinding?a.content.newBinding:a.content.newValue,controlType:a.controlType};let s;s=e.table.type&&e.table.type!==u.TableTypeV2.ResponsiveTable||t.controlId.includes(r.PAGETYPE_VIEW_EXTENSION_TEMPLATE_MAP.get(r.PageType.AnalyticalListPage))?e.table.constructor.name:"ResponsiveTableWithMultiSelect";(n.definitions[`${s}<LineItems>`].properties[t.propertyId]||t.controlType===o.ControlType.TableColumn)&&i.addFlexForTable(e.table,t,n)}}catch(e){p.log(a,{severity:"error",message:f.default.t("FLEXERROR")},...e)}},t.transferSettingsOfObject=function(e,t,n,a,r,i){if(!n)return;let s={};const u=e.getDeprecated?e.getDeprecated():[];if(n.properties)for(const p in n.properties){const n=c.getReflectMetadata(e,p);if(null==n?void 0:n.manifest){const c=n.manifest.path([a],void 0,i);s=l.getManifestSectionByPathV2(t,c),o.importProperty(n,s,p,e),o.checkDeprecatedProperties(u,s,c,r)}if("quickVariantSelectionX"===p&&e[p])for(const t in e[p].variants){const n=e[p].variants[t];if(n.tableSettings){for(const e in n.tableSettings)n[e]=n.tableSettings[e];delete n.tableSettings}}}},t.determineTableType=function(e,t){var n,a;const r=e[s.ManifestSection.generic].pages[t];let i=u.TableTypeV2.ResponsiveTable;return e[s.ManifestSection.generic].pages[t].component.settings&&(e[s.ManifestSection.generic].pages[t].component.settings.tableSettings&&e[s.ManifestSection.generic].pages[t].component.settings.tableSettings.type||e[s.ManifestSection.generic].pages[t].component.settings.tableType)?i=(null===(a=null===(n=r.component.settings)||void 0===n?void 0:n.tableSettings)||void 0===a?void 0:a.type)||r.component.settings.tableType:"sap.suite.ui.generic.template.AnalyticalListPage"===r.component.name&&(i=u.TableTypeV2.AnalyticalTable),i}},3767:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(8517);t.addFlexForTable=function(e,t,n){if(t.controlType.endsWith("Table"))e[t.propertyId]=t.newValue;else if(t.controlType===a.ControlType.TableColumn){if(!(null==n?void 0:n.definitions.TableColumn.properties[t.propertyId]))return;const r=t.controlId.split("-"),i=r[r.length-1].split("template:::TableColumn:::"),o=i[i.length-1].replace(/sSmartTableId.+?:::/,"").replace("::com.sap.vocabularies",a.VOCWITHCOLONS);e.columns||(e.columns={}),e.columns[o]||(e.columns[o]={}),e.columns[o][t.propertyId]=t.newValue}}},4330:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(1403)),a(n(2687)),a(n(2201)),a(n(9836)),a(n(961))},961:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(9609),i=n(6971),o=n(5921),s=n(2449),c=a(n(9154)),l=n(5008),u=n(1403),p=n(2687),f=n(7072);t.createAnalyticalListPageConfig=function(e){if(s.initI18n(),!e.manifest[i.ManifestSection.generic])return void o.log(e.logger,{severity:"error",message:c.default.t("NOFE"),location:{path:l.MANIFESTPATH,range:[i.ManifestSection.generic]}});if(!e.manifest[i.ManifestSection.generic].pages)return void o.log(e.logger,{severity:"error",message:c.default.t("NOPAGES",{appId:e.manifest["sap.app"].id}),location:{path:l.MANIFESTPATH,range:[i.ManifestSection.generic]}});const t=new f.MetadataInstanceFactoryV2,n=t.createPageInstance(i.PageType.AnalyticalListPage),a=[],d=u.findAnalyticalListPage(e.manifest[i.ManifestSection.generic].pages,a);if(d)return function(e,t,n,a){const o=r.determineTableType(e.manifest,a);t.table=n.createInstance(i.PageType.AnalyticalListPage,`ALP${o}`,t.table),r.transferSettingsOfObject(t.table,e.manifest,e.jsonSchema.definitions[`ALP${o}<LineItems>`],a,e.logger),t.filterBar=n.createInstance(i.PageType.AnalyticalListPage,"AnalyticalListPageFilterBar",t.filterBar),r.transferSettingsOfObject(t.filterBar,e.manifest,e.jsonSchema.definitions.AnalyticalListPageFilterBar,a,e.logger),t.chart=n.createInstance(i.PageType.AnalyticalListPage,"ChartSettings",t.chart),r.transferSettingsOfObject(t.chart,e.manifest,e.jsonSchema.definitions.ChartSettings,a,e.logger),t.keyPerformanceIndicators={};const s=e.manifest[i.ManifestSection.generic].pages[a].component.settings.keyPerformanceIndicators;s&&Object.keys(s).forEach((o=>{t.keyPerformanceIndicators[o]=n.createInstance(i.PageType.AnalyticalListPage,"KPISettings"),t.keyPerformanceIndicators=n.createInstance(i.PageType.AnalyticalListPage,"KPISettings",t.keyPerformanceIndicators),r.transferSettingsOfObject(t.keyPerformanceIndicators[o],e.manifest,e.jsonSchema.definitions.KPISettings,a,e.logger,o)}))}(e,n,t,a[0]),e.flex.forEach((t=>{l.parseChangeString(t)&&r.addFlex(n,t,e.jsonSchema)})),p.addFragments(n,e.manifest,d,i.PageType.AnalyticalListPage,e.fragments),n;o.log(e.logger,{severity:"error",message:c.default.t("NOALP"),location:{path:l.MANIFESTPATH,range:[i.ManifestSection.generic]}})}},2687:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(9609),i=n(6971),o=n(5008),s=n(5921),c=a(n(9154)),l=n(2449),u=n(1403),p=n(4139),f=n(7040),d=n(7072),h=n(1205);function g(e,t,n,a,r,i,o){if(e.customData||e["table:customData"]){const s=e.customData?e.customData["core:CustomData"]._attributes.value:e["table:customData"]["core:CustomData"]._attributes.value,c=JSON.parse(s.substr(1,s.length));let l=e.Text&&e.Text._attributes&&e.Text._attributes.text;l||(l=e.Label&&e.Label._attributes&&e.Label._attributes.text);const u={id:e._attributes&&e._attributes.id,text:l,columnKey:c.columnKey,columnIndex:void 0!==c.columnIndex?Number(c.columnIndex):void 0,leadingProperty:c.leadingProperty,className:t[n].className,fragmentName:t[n].fragmentName,tabKey:a,extensionType:i};o&&(u.cellsFragmentName=o),r.table.columns.custom||(r.table.columns.custom=[]);r.table.columns.custom.push(u)}}function m(e,t,n,a,r,s){if(!r)return;const c="|"+(s&&s.target?s.target:n.entitySet);if(t[i.ManifestSection.ui5]&&t[i.ManifestSection.ui5].extends&&t[i.ManifestSection.ui5].extends.extensions&&t[i.ManifestSection.ui5].extends.extensions["sap.ui.viewExtensions"]){const n=i.PAGETYPE_VIEW_EXTENSION_TEMPLATE_MAP.get(a),l=t[i.ManifestSection.ui5].extends.extensions["sap.ui.viewExtensions"][n];if(l)for(const t of Object.keys(l)){const n=t.split("|"),[a,i]=n,u=n[2],d=s&&u===s.key?void 0:u,h=o.ViewTemplateType[a];if(h&&"|"+i===c){const n=l[t].type?l[t].type.toLowerCase():"xml";let a,s=l[t].fragmentName;if(!s)continue;if(h===o.ViewTemplateType.ResponsiveTableColumnsExtension)for(const e of Object.keys(l)){const[t,n,r]=e.split("|");t===o.ViewTemplateType.ResponsiveTableCellsExtension&&n===i&&r===u&&(a=l[e].fragmentName)}const c=s.split(".");s=c[c.length-1]+o.FRAGMENTNAMEPART+n;const m=r.filter((e=>e.dataSourceUri.endsWith(s)));if(m[0]){const n=JSON.parse(p.xml2json(m[0].fileContent,{compact:!0}))[f.FRAGMENT_DEFINITION],r=f.getRootCustomColumnFromFragmentJSON(n);if(r)if(e.table.columns||(e.table.columns={}),Array.isArray(r))for(let n=0;n<r.length;n++)g(r[n],l,t,d,e,h,a);else g(r,l,t,d,e,h,a)}}}}}t.addFragments=m,t.createListReportConfig=function(e){if(l.initI18n(),!e.manifest[i.ManifestSection.generic])return void s.log(e.logger,{severity:"error",message:c.default.t("NOFE"),location:{path:o.MANIFESTPATH,range:[i.ManifestSection.generic]}});if(!e.manifest[i.ManifestSection.generic].pages)return void s.log(e.logger,{severity:"error",message:c.default.t("NOPAGES",{appId:e.manifest["sap.app"].id}),location:{path:o.MANIFESTPATH,range:[i.ManifestSection.generic]}});const t=new d.MetadataInstanceFactoryV2,n=t.createPageInstance(i.PageType.ListReport),a=[],p=u.findListReportPageV2(e.manifest[i.ManifestSection.generic].pages,a);if(p)return function(e,t,n,a){const o=r.determineTableType(e.manifest,a);let s;t.table=n.createInstance(i.PageType.ListReport,o,t.table),"TreeTable"===o||"AnalyticalTable"===o||"GridTable"===o?s=e.jsonSchema.definitions[o+"<LineItems>"]:e.jsonSchema.definitions[h.MULTISELECTTABLE]&&e.jsonSchema.definitions[h.INLINEDELETETABLE]&&(s=JSON.parse(JSON.stringify(e.jsonSchema.definitions[h.MULTISELECTTABLE])),s.properties=Object.assign(Object.assign({},s.properties),e.jsonSchema.definitions[h.INLINEDELETETABLE].properties)),r.transferSettingsOfObject(t.table,e.manifest,s,a,e.logger),t.filterBar=n.createInstance(i.PageType.ListReport,"ListReportFilterBar",t.filterBar),r.transferSettingsOfObject(t.filterBar,e.manifest,e.jsonSchema.definitions.ListReportFilterBar,a,e.logger)}(e,n,t,a[0]),e.flex.forEach((t=>{o.parseChangeString(t)&&r.addFlex(n,t,e.jsonSchema,e.logger)})),m(n,e.manifest,p,i.PageType.ListReport,e.fragments),n;s.log(e.logger,{severity:"error",message:c.default.t("NOLR"),location:{path:o.MANIFESTPATH,range:[i.ManifestSection.generic]}})}},2201:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(3374),i=n(3767),o=n(5921),s=n(1403),c=n(5008),l=n(1350),u=n(4867),p=a(n(9154)),f=n(2449),d=n(6971),h=n(2687),g=n(7072),m=n(1205);const y=(e,t,n)=>{e[t]=n},v=e=>{let t;return e.$ref?(t=e.$ref.includes("<")?e.$ref.split("<")[0]:e.$ref,t.replace(c.DEFINITION_LINK_PREFIX,"")):e.properties.subsections.$ref?(t=e.properties.subsections.$ref,t=t.includes("<")?t.split("<")[0]:t,t.replace(c.DEFINITION_LINK_PREFIX,"")):e.properties.subsections?m.SectionTypeV2.SubSection:void 0};function b(e,t,n,a,s,u,p,f){var d;if(!n)return;let h=[],g={};(null==t?void 0:t.getDeprecated)&&(h=t.getDeprecated());const m=u&&u.replace(/::@com.sap.vocabularies/g,r.VOCWITHSLASH);for(const r in n.properties||n){const v=c.getReflectMetadata(t,r);if(v||"columns"===r)if("columns"===r||v&&v.flex)if(u)for(const n in s){const a=s[n],o=a.propertyId===r,l="columns"===r&&a.controlType===c.ControlType.TableColumn,f=[u,m,p];(o||l)&&f.indexOf(null==a?void 0:a.facetId)>-1&&i.addFlexForTable(t,s[n],e.jsonSchema)}else for(const e in s){const a=s[e],i=!f||new RegExp(`.*${f}\\d?$`).test(e),o=a.propertyId===r,c=null===(d=n.properties[a.propertyId])||void 0===d?void 0:d.controlType,l=a.controlType===c;if(!a.facetId&&i&&o){y(t,r,a.newValue);break}if("action"===a.facetId&&!p&&i&&o){y(t,r,a.newValue);break}if(!p&&i&&o&&l){y(t,r,a.newValue);break}if(e.includes(p)&&i&&o&&l){y(t,r,a.newValue);break}}else if(v.manifest){const n=u?u.replace(/\/@/g,"::").replace(/@com.sap/g,"com.sap"):void 0,i=v.manifest.path(a,{},n);g=l.getManifestSectionByPathV2(e.manifest,i);const s=v.manifest.import;if(s&&"function"==typeof s){const e=s(g,u);void 0!==e&&(t[r]=e)}else{const e=v.manifest.key||r;e in g&&(t[r]=g[e])}if(g&&h)for(const t in g){const n=h[t];n&&(o.log(e.logger,{severity:"warning",message:c.getTextForDeprecated(t,n),location:{path:"webapp/manifest.json/",range:i.split("/")}}),delete h[t])}}}}function P(e,t,n,a,r,i,o){let s;a[t].form.fields={};for(const c in n)s=c.includes("::")?c.split("::")[1]+"::GroupElement":c+"::GroupElement",a[t].form.fields[c]=r.createInstance(d.PageType.ObjectPage,"Field"),b(e,a[t].form.fields[c],e.jsonSchema.definitions.Field,i,o,void 0,void 0,s),0===Object.keys(a[t].form.fields[c]).length&&delete a[t].form.fields[c];0===Object.keys(a[t].form.fields).length&&delete a[t].form.fields}function S(e,t,n,a,i,o,s,c){const l=s.replace(/\/@/g,"::"),u=e.jsonSchema.definitions[`${c}<${s}>`],p=u.title?u.title.split(r.FacetTitlePrefix)[1]:void 0,f=l.replace("@com.sap","com.sap"),h=t&&t.sections&&t.sections[f];if(h||n){const t=h&&h.tableSettings&&h.tableSettings.type?h.tableSettings.type:"ResponsiveTable",r=a.createInstance(d.PageType.ObjectPage,`ObjectPage${t}`);let f;i[l]=a.createInstance(d.PageType.ObjectPage,c,{table:{}}),i[l].table=r;const g=e.jsonSchema.definitions;"TreeTable"===t||"AnalyticalTable"===t||"GridTable"===t?f=g["ObjectPage"+t+"<"+l+">"]:g[`ObjectPageResponsiveTableWithMultiSelect<${l}>`]&&g[`ObjectPageResponsiveTableWithInlineDelete<${l}>`]&&(f=JSON.parse(JSON.stringify(g[`ObjectPageResponsiveTableWithMultiSelect<${l}>`])),f.properties=Object.assign(Object.assign({},f.properties),g[`ObjectPageResponsiveTableWithInlineDelete<${l}>`].properties)),b(e,i[l],u,o,n,void 0,p),b(e,i[l].table,f,o,n,s,p)}}function T(e,t,n,a,r){const i=e.jsonSchema.definitions[t].properties.custom,o=i?s.getTargetFromCustomColumnRef(i.$ref):void 0;if(o){const i={key:n||t.replace("@",""),target:o};h.addFragments(a[t],e.manifest,r,d.PageType.ObjectPage,e.fragments,i)}}function O(e,t,n,a,r,i,o){let s,c;n.actions={};const l=o?"FormAction":"HeaderAction";if(i.constructor===Object&&0!==Object.keys(i).length)for(const u in t)c=u.replace(/@/g,"::"),s=(o?`${u}${o}`:u).replace(/@/g,"::"),n.actions[c]=a.createInstance(d.PageType.ObjectPage,l),b(e,n.actions[c],e.jsonSchema.definitions[l],r,i,void 0,void 0,s),o&&0===Object.keys(n.actions[c]).length&&delete n.actions[c];o&&0===Object.keys(n.actions).length&&delete n.actions}function E(e,t,n,a,r,i,o,s,l){var u,p;for(const f in t){const h=f.replace(/\/@/g,"::");let g=t[f];if(!g.$ref||v(g)!==m.SectionTypeV2.SectionTable&&v(g)!==m.SectionTypeV2.SubSectionTable)if(!g.$ref||v(g)!==m.SectionTypeV2.SectionChart&&v(g)!==m.SectionTypeV2.SubSectionChart)if(!g.$ref||v(g)!==m.SectionTypeV2.SectionForm&&v(g)!==m.SectionTypeV2.SubSectionForm){if(g.properties&&g.properties.subsections||g.$ref&&(v(g)===m.SectionTypeV2.Section||v(g)===m.SectionTypeV2.SubSection)){const t=v(g);g=e.jsonSchema.definitions[`${t}<${f}>`];const m=c.getSectionTitle(g,e.jsonSchema);let y;a[h]=r.createInstance(d.PageType.ObjectPage,t,{subsections:{}}),o&&b(e,a[h],g,i,o,void 0,m),y=(null===(p=null===(u=g.properties)||void 0===u?void 0:u.subsections)||void 0===p?void 0:p.properties)?g.properties.subsections.properties:g.properties,E(e,y,n,a[h].subsections,r,i,o,s,l)}}else{const t=v(g);g=e.jsonSchema.definitions[`${t}<${f}>`];const n=c.getSectionTitle(g,e.jsonSchema),s=g.properties.form.$ref.split("SectionForm")[1];a[h]=r.createInstance(d.PageType.ObjectPage,t,{form:{}}),o&&b(e,a[h],g,i,o,void 0,n);const l=e.jsonSchema.definitions[`SectionActions${s}`];l.properties&&O(e,l.properties,a[h].form,r,i,o,`${h}::FormAction`);const u=e.jsonSchema.definitions[`SectionFields${s}`];u.properties&&P(e,h,u.properties,a,r,i,o),0===Object.keys(a[h].form).length&&delete a[h].form,0===Object.keys(a[h]).length&&delete a[h]}else{const t=v(g);g=e.jsonSchema.definitions[`${t}<${f}>`];const s=c.getSectionTitle(g,e.jsonSchema),l=h.replace("@com.sap","com.sap"),u=n&&n.sections&&n.sections[l];a[h]=r.createInstance(d.PageType.ObjectPage,t,{chart:{}}),a[h].chart=r.createInstance(d.PageType.ObjectPage,"ObjectPageChart"),(u||o)&&(b(e,a[h],g,i,o,void 0,s),b(e,a[h].chart,e.jsonSchema.definitions.ObjectPageChart,i,o,f,s))}else{S(e,n,o,r,a,i,f,v(g)),T(e,h,undefined,a,s)}}}function _(e,t,n,a,r){const i=r.createPageInstance(d.PageType.ObjectPage),o=a.component.settings;b(e,i,e.jsonSchema.properties,t,n),i.header=r.createInstance(d.PageType.ObjectPage,"ObjectPageHeader"),b(e,i.header,e.jsonSchema.definitions.ObjectPageHeader?e.jsonSchema.definitions.ObjectPageHeader:e.jsonSchema.definitions["ObjectPageHeader<GenericActions>"],t,n);const c=e.jsonSchema.definitions.HeaderActions;c&&O(e,c.properties,i.header,r,t,n),i.layout=r.createInstance(d.PageType.ObjectPage,"ObjectPageLayout"),b(e,i.layout,e.jsonSchema.definitions.ObjectPageLayout,t,n),0===Object.keys(i.layout).length&&delete i.layout,i.sections={};const l=e.jsonSchema.definitions.Sections;l&&E(e,l.properties,o,i.sections,r,t,n,a,i);const u=s.findCustomSectionExtensions(e.manifest,e.entitySet);if(Object.keys(u).length>0){i.sections.custom=[];for(const a in u){const o="fragmentName"in u[a]?r.createInstance(d.PageType.ObjectPage,"ObjectPageCustomSectionFragment"):r.createInstance(d.PageType.ObjectPage,"ObjectPageCustomSectionView");b(e,o,e.jsonSchema.definitions["fragmentName"in u[a]?"ObjectPageCustomSectionFragment":"ObjectPageCustomSectionView"],t,n,a),i.sections.custom.push(o)}}return i}t.createObjectPageConfigV2=function(e){if(f.initI18n(),!e.manifest[d.ManifestSection.generic])return void o.log(e.logger,{severity:"error",message:p.default.t("NOFE"),location:{path:r.MANIFESTPATH,range:[d.ManifestSection.generic]}});const t=[],n=e.manifest[d.ManifestSection.generic].pages;if(!n)return void o.log(e.logger,{severity:"error",message:p.default.t("NOPAGES",{appId:e.manifest["sap.app"].id}),location:{path:r.MANIFESTPATH,range:[d.ManifestSection.generic]}});const a=e.entitySet,i=s.findObjectPageV2(n,e.entitySet,t);return i?_(e,t,function(e,t,n){const a={};let r=1;return e.forEach((e=>{var i,s;try{const n=c.parseChangeString(e);if(n&&(null===(i=n.controlId)||void 0===i?void 0:i.includes(u.FE_TEMPLATE_V2_OBJECT_PAGE))&&(null===(s=n.controlId)||void 0===s?void 0:s.includes(t))){let e=n.controlId.split("--")[1].replace(/:3a:3a/g,"::");null!==new RegExp(".+DataField.+:::sSmartTableId::.+").exec(e)&&(e=e.split("template:::TableColumn:::")[1]);const t=e.split(":::");let i,o;if(1===t.length){const e=t[0].split("-");if(i=e[e.length-1],t[0].indexOf("com.sap.vocabularies.UI.v1.LineItem")>=0||t[0].indexOf("UI.LineItem")>=0||t[0].indexOf("::Table")>=0)o=e[0].split("::Table")[0].split("::responsiveTable")[0].replace(/::/g,"/@");else{const t=i.split("::");t.length>1?o=t[0]:e[0].indexOf("::")>-1&&(o=e[0].split("::")[0])}}else if(e.indexOf("sSmartTableId")>=0){for(const e of t)if(e.startsWith("sSmartTableId")){o=e.split("sSmartTableId::")[1].split("::Table")[0].split("/responsiveTable")[0].replace("::com.sap.vocabularies.UI.v1.LineItem","/@com.sap.vocabularies.UI.v1.LineItem");break}}else o=t[0];e=e.replace(/:2f/g,"/").replace(/:40/g,"@").replace(/:23/g,"#").replace(/:3a:3a/g,"::").replace(/\/@com.sap.vocabularies/g,"::com.sap.vocabularies"),a[e]&&a[e].propertyId!==n.content.property&&(e+=r,r++),a[e]={controlId:e,propertyId:n.content.property,facetId:o,newValue:void 0!==n.content.newBinding?n.content.newBinding:n.content.newValue,controlType:n.controlType}}}catch(e){o.log(n,{severity:"error",message:p.default.t("FLEXERROR")},...e)}})),a}(e.flex,a),i,new g.MetadataInstanceFactoryV2):void o.log(e.logger,{severity:"error",message:p.default.t("NOENTITYSET",{entitySet:a}),location:{path:r.MANIFESTPATH,range:[d.ManifestSection.generic]}})}},9836:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(6971),r=n(2762),i=n(1350),o=n(390),s=n(7072),c=n(2432),l=n(5008);function u(e,t,n,a){if("settings"===e)switch(t.template){case"sap.ovp.cards.charts.analytical":n[a[0]][o.CardSettingsType.analyticalCardSettings]=t[e];break;case"sap.ovp.cards.v4.charts.analytical":n[a[0]][o.CardSettingsType.analyticalCardSettingsv4]=t[e];break;case"sap.ovp.cards.list":case"sap.ovp.cards.v4.list":n[a[0]][o.CardSettingsType.listCardSettings]=t[e];break;case"sap.ovp.cards.stack":n[a[0]][o.CardSettingsType.stackCardSettings]=t[e];break;case"sap.ovp.cards.linklist":case"sap.ovp.cards.v4.linklist":n[a[0]][o.CardSettingsType.linkListCardSettings]=t[e];break;case"sap.ovp.cards.table":case"sap.ovp.cards.v4.table":n[a[0]][o.CardSettingsType.tableCardSettings]=t[e];break;default:n[a[0]].settings=t[e]}else n[a[0]][e]=t[e]}function p(e,t,n,a){for(const o in n){const n=r.getReflectMetadata(e,o);if(null==n?void 0:n.manifest){const r=n.manifest.path([...a,o]),s=i.getManifestSectionByPathV2(t,r);Object.prototype.hasOwnProperty.call(s,o)&&(0!==a.length?u(o,s,e,a):l.importProperty(n,s,o,e))}}}t.createOverviewPageConfig=function(e){const t=new s.MetadataInstanceFactoryV2,n=t.createPageInstance(a.PageType.OverviewPage);return e.jsonSchema&&function(e,t,n,r){p(e,t,n.properties,[]),e.cards={},Object.keys(t[a.ManifestSection.ovp].cards).forEach((n=>{const i=t[a.ManifestSection.ovp].cards[n].template,s=o.cardTemplateTypeMap[i];e.cards[n]=c.assignReflectMetadataRules(r,s,{},"CustomCard"),e.cards=c.assignReflectMetadataRules(r,s,e.cards,"CustomCard"),p(e.cards,t,t[a.ManifestSection.ovp].cards[n],[n])}))}(n,e.manifest,e.jsonSchema,t),n}},1403:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(390),r=n(6971),i=n(1350),o=n(5008),s=n(468);function c(e,t){const n=e.split("|");return a.SectionPosition[n[0]]&&n[1]===t}t.findObjectPageV2=function e(t,n,a){for(const i in t){const s=t[i];if(o.getPageTypeV2(s.component.name)===r.PageType.ObjectPage&&s.entitySet===n)return a.push(i),s;if(s.pages)return a.push(i),e(s.pages,n,a)}},t.findListReportPageV2=function(e,t){for(const n in e){const a=e[n];if(t.push(n),o.getPageTypeV2(a.component.name)===r.PageType.ListReport)return a}},t.findAnalyticalListPage=function(e,t){for(const n in e){const a=e[n];if(t.push(n),o.getPageTypeV2(a.component.name)===r.PageType.AnalyticalListPage)return a}},t.isAssociatedCustomSection=c,t.findCustomSectionExtensions=function(e,t){const n=i.getManifestSectionByPathV2(e,`sap.ui5/extends/extensions/${a.SAPUI5_VIEW_EXTENSION}/${a.SAPUI5_VIEW_EXTENSION_OBJECT_PAGE}`),r={};for(const e in n)c(e,t)&&(r[e]=n[e]);return r},t.getTargetFromCustomColumnRef=function(e){const t=e.split(`${s.CUSTOM_COLUMNS_DEFINITION}<`);if(t[1])return t[1].slice(0,-1)}},1205:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MULTISELECTTABLE="ResponsiveTableWithMultiSelect<LineItems>",t.INLINEDELETETABLE="ResponsiveTableWithInlineDelete<LineItems>",t.TREETABLE="TreeTable<LineItems>",t.ANALYTICALTABLE="AnalyticalTable<LineItems>",t.GRIDTABLE="GridTable<LineItems>",function(e){e.Section="ObjectPageSectionV2",e.SubSection="ObjectPageSubSectionV2",e.SectionForm="ObjectPageSectionFormV2",e.SectionTable="ObjectPageSectionTableV2",e.SectionChart="ObjectPageSectionChartV2",e.SubSectionForm="ObjectPageSubSectionFormV2",e.SubSectionTable="ObjectPageSubSectionTableV2",e.SubSectionChart="ObjectPageSubSectionChartV2"}(t.SectionTypeV2||(t.SectionTypeV2={}))},8992:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762);t.getSettingsPathForPage=e=>`sap.ui5/routing/targets/${e[0]}/options/settings`,t.getSettingsPathForHeaderOP=e=>`sap.ui5/routing/targets/${e[0]}/options/settings/content/header`,t.getControlConfigurationPath=e=>t.getSettingsPathForPage(e)+"/controlConfiguration",t.getHeadeFacetSettingPath=(e,n,a)=>t.getControlConfigurationPath(e)+`/@com.sap.vocabularies.UI.v1.HeaderFacets/facets/${a}`,t.getTableSettingsPathForLR=e=>t.getControlConfigurationPath(e)+"/@com.sap.vocabularies.UI.v1.LineItem/tableSettings",t.getColumnsPathForLR=(e,n,a,r)=>t.getControlConfigurationPath(e)+`/@com.sap.vocabularies.UI.v1.LineItem/columns/${r}`,t.getActionsPathForLR=(e,n,a,r)=>t.getControlConfigurationPath(e)+`/@com.sap.vocabularies.UI.v1.LineItem/actions/${r}`,t.getColumnsPathForOP=(e,n,a,r)=>t.getControlConfigurationPath(e)+`/${a}/columns/${r}`,t.getActionsPathForOP=(e,n,a,r)=>t.getControlConfigurationPath(e)+`/${a}/actions/${r}`,t.getTableSettingsPathForOP=(e,n,a)=>t.getControlConfigurationPath(e)+`/${a}/tableSettings`,t.getCustomSectionPath=(e,n,a,r)=>{let i=t.getSettingsPathForPage(e)+`/content/body/sections/${a}`;return r&&(i+="/"+r),i};class ApplicationV4{}a([r.childId("settings")],ApplicationV4.prototype,"settings",void 0),t.ApplicationV4=ApplicationV4;class AppSettings{}a([r.syncRule({manifest:{path:()=>"sap.app"}})],AppSettings.prototype,"title",void 0),a([r.syncRule({manifest:{path:()=>"sap.app"}})],AppSettings.prototype,"description",void 0),a([r.syncRule({manifest:{path:()=>"sap.ui5/routing/config"}}),r.validity({since:"1.78.0"})],AppSettings.prototype,"flexibleColumnLayout",void 0),t.AppSettings=AppSettings},1735:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.FilterBar=class FilterBar{}},4086:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5877),i=n(6971),o=n(2762),s=n(8992);class ObjectPageCustomSectionFragment{}a([o.syncRule({manifest:{path:(e,t,n)=>s.getCustomSectionPath(e,t,n,"position"),key:"anchor"}}),o.validity({since:"1.77.0"})],ObjectPageCustomSectionFragment.prototype,"relatedFacet",void 0),a([o.syncRule({manifest:{path:s.getCustomSectionPath,import:(e,t)=>t,export:!1}}),o.validity({since:"1.77.0"})],ObjectPageCustomSectionFragment.prototype,"id",void 0),a([o.syncRule({manifest:{path:(e,t,n)=>s.getCustomSectionPath(e,t,n,"position"),key:"placement"}}),o.validity({since:"1.77.0"})],ObjectPageCustomSectionFragment.prototype,"relativePosition",void 0),a([o.syncRule({manifest:{path:s.getCustomSectionPath}}),o.validity({since:"1.77.0"})],ObjectPageCustomSectionFragment.prototype,"title",void 0),a([o.syncRule({manifest:{path:s.getCustomSectionPath,import:e=>!e.type||e.type.startsWith(r.CustomSectionViewTypesV4.XML)?r.CustomSectionViewTypesV4.XML:"",export:(e,t)=>{let n="";"type"in t&&(n+=t.type),"className"in t&&(t.className===i.SAPUI5_FRAGMENT_CLASS?n+="Fragment":n+=t.className),e.type=n}}}),o.validity({since:"1.77.0"})],ObjectPageCustomSectionFragment.prototype,"type",void 0),a([o.syncRule({manifest:{path:s.getCustomSectionPath,import:e=>!e.type||e.type.startsWith(r.CustomSectionViewTypesV4.XML)?e.type&&"XMLFragment"!==e.type?e.type.slice(r.CustomSectionViewTypesV4.XML.length):i.SAPUI5_FRAGMENT_CLASS:e.type,export:!1}}),o.validity({since:"1.77.0"})],ObjectPageCustomSectionFragment.prototype,"className",void 0),a([o.syncRule({manifest:{path:s.getCustomSectionPath,key:"name"}}),o.validity({since:"1.77.0"})],ObjectPageCustomSectionFragment.prototype,"fragmentName",void 0),t.ObjectPageCustomSectionFragment=ObjectPageCustomSectionFragment},9509:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(8992),o=n(8992);class ObjectPageHeader{}a([r.syncRule({manifest:{path:e=>i.getSettingsPathForPage(e)}}),r.validity({since:"1.84.0"})],ObjectPageHeader.prototype,"editableHeaderContent",void 0),a([r.syncRule({manifest:{path:e=>i.getSettingsPathForPage(e)}}),r.validity({since:"1.84.0"})],ObjectPageHeader.prototype,"showRelatedApps",void 0),a([r.syncRule({manifest:{path:o.getSettingsPathForHeaderOP}}),r.validity({since:"1.84.0"})],ObjectPageHeader.prototype,"visible",void 0),a([r.syncRule({manifest:{path:o.getSettingsPathForHeaderOP}}),r.validity({since:"1.84.0"})],ObjectPageHeader.prototype,"anchorBarVisible",void 0),t.ObjectPageHeader=ObjectPageHeader},8434:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(8992);class FlexSettings{}a([r.syncRule({manifest:{path:(e,t,n)=>i.getHeadeFacetSettingPath(e,t,n)+"/flexSettings"}}),r.validity({since:"1.81.0"})],FlexSettings.prototype,"designtime",void 0),t.FlexSettings=FlexSettings;class CommonHeaderFacetSettings{}a([r.syncRule({manifest:{path:i.getHeadeFacetSettingPath}}),r.validity({since:"1.81.0"})],CommonHeaderFacetSettings.prototype,"stashed",void 0),a([r.syncRule({manifest:{path:i.getHeadeFacetSettingPath}}),r.validity({since:"1.81.0"})],CommonHeaderFacetSettings.prototype,"flexSettings",void 0),t.CommonHeaderFacetSettings=CommonHeaderFacetSettings;t.ObjectPageHeaderSectionForm=class ObjectPageHeaderSectionForm extends CommonHeaderFacetSettings{};t.ObjectPageHeaderSectionChart=class ObjectPageHeaderSectionChart extends CommonHeaderFacetSettings{};t.ObjectPageHeaderSectionDataPoint=class ObjectPageHeaderSectionDataPoint extends CommonHeaderFacetSettings{};t.ObjectPageHeaderSectionContact=class ObjectPageHeaderSectionContact extends CommonHeaderFacetSettings{};t.ObjectPageHeaderSectionAddress=class ObjectPageHeaderSectionAddress extends CommonHeaderFacetSettings{};t.HeaderSections=class HeaderSections{}},861:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(8992);class ObjectPageLayout{}a([r.syncRule({manifest:{path:e=>i.getSettingsPathForPage(e)}}),r.validity({since:"1.84.0"})],ObjectPageLayout.prototype,"sectionLayout",void 0),t.ObjectPageLayout=ObjectPageLayout},101:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5008),i=n(2762),o=n(8992),s=n(6460);class TableCreationModeOP{}a([i.syncRule({manifest:{path:(e,t,n)=>o.getTableSettingsPathForOP(e,t,n),export:(e,t,n,a)=>{s.exportCreationModeName(e,t,n,a)},delete:(e,t,n,a)=>{s.deleteCreationModeName(e,a)}}})],TableCreationModeOP.prototype,"name",void 0),a([i.syncRule({manifest:{path:(e,t,n)=>o.getTableSettingsPathForOP(e,t,n),export:(e,t,n,a)=>{s.exportCreationModeCreateAtEnd(e,t,n,a)},delete:(e,t,n,a)=>{s.deleteCreationModeCreateAtEnd(e,a)}}})],TableCreationModeOP.prototype,"createAtEnd",void 0),t.TableCreationModeOP=TableCreationModeOP;class PersonalizationTypeOP{}a([i.syncRule({manifest:{path:(e,t,n)=>o.getTableSettingsPathForOP(e,t,n),export:(e,t,n,a)=>{s.exportPersonalizationProperty(e,t,n,a)},delete:(e,t,n,a)=>{s.deletePersonalizationProperty(e,a)}}})],PersonalizationTypeOP.prototype,"column",void 0),a([i.syncRule({manifest:{path:(e,t,n)=>o.getTableSettingsPathForOP(e,t,n),export:(e,t,n,a)=>{s.exportPersonalizationProperty(e,t,n,a)},delete:(e,t,n,a)=>{s.deletePersonalizationProperty(e,a)}}})],PersonalizationTypeOP.prototype,"sort",void 0),a([i.syncRule({manifest:{path:(e,t,n)=>o.getTableSettingsPathForOP(e,t,n),export:(e,t,n,a)=>{s.exportPersonalizationProperty(e,t,n,a)},delete:(e,t,n,a)=>{s.deletePersonalizationProperty(e,a)}}})],PersonalizationTypeOP.prototype,"filter",void 0),t.PersonalizationTypeOP=PersonalizationTypeOP;class QuickVariantSelectionV4OP{}a([i.syncRule({manifest:{path:(e,t,n)=>o.getTableSettingsPathForOP(e,t,n)+r.QUICKVARPATH}})],QuickVariantSelectionV4OP.prototype,"paths",void 0),a([i.syncRule({manifest:{path:(e,t,n)=>o.getTableSettingsPathForOP(e,t,n)+r.QUICKVARPATH}})],QuickVariantSelectionV4OP.prototype,"hideTableTitle",void 0),a([i.syncRule({manifest:{path:(e,t,n)=>o.getTableSettingsPathForOP(e,t,n)+r.QUICKVARPATH}})],QuickVariantSelectionV4OP.prototype,"showCounts",void 0),t.QuickVariantSelectionV4OP=QuickVariantSelectionV4OP;class ObjectPageTable{}a([i.syncRule({manifest:{path:o.getTableSettingsPathForOP}}),i.validity({since:"1.84.0"})],ObjectPageTable.prototype,"type",void 0),a([i.syncRule({manifest:{path:o.getTableSettingsPathForOP,import:e=>{const t=e.creationMode;return"object"==typeof t?t:"string"==typeof t?{name:t}:void 0}}}),i.validity({since:"1.84.0"})],ObjectPageTable.prototype,"creationMode",void 0),a([i.syncRule({manifest:{path:o.getTableSettingsPathForOP,import:e=>{const t=e.personalization;return"object"==typeof t?t:"boolean"==typeof t?{column:t,sort:t,filter:t}:void 0}}}),i.validity({since:"1.84.0"})],ObjectPageTable.prototype,"personalization",void 0),a([i.syncRule({manifest:{path:o.getTableSettingsPathForOP}}),i.validity({since:"1.84.0"})],ObjectPageTable.prototype,"selectionMode",void 0),a([i.syncRule({manifest:{path:o.getTableSettingsPathForOP}}),i.validity({since:"1.84.0"})],ObjectPageTable.prototype,"selectAll",void 0),a([i.syncRule({manifest:{path:o.getTableSettingsPathForOP}}),i.validity({since:"1.84.0"})],ObjectPageTable.prototype,"selectionLimit",void 0),a([i.syncRule({manifest:{path:o.getTableSettingsPathForOP}}),i.validity({since:"1.84.0"})],ObjectPageTable.prototype,"enableExport",void 0),a([i.syncRule({manifest:{path:o.getTableSettingsPathForOP}}),i.validity({since:"1.84.0"})],ObjectPageTable.prototype,"quickVariantSelection",void 0),a([i.syncRule({manifest:{path:o.getTableSettingsPathForOP}}),i.validity({since:"1.84.0"})],ObjectPageTable.prototype,"condensedTableLayout",void 0),a([i.syncRule({manifest:{path:o.getTableSettingsPathForOP}}),i.validity({since:"1.84.0"})],ObjectPageTable.prototype,"enableFullScreen",void 0),a([i.syncRule({manifest:{path:o.getTableSettingsPathForOP}}),i.validity({since:"1.84.0"})],ObjectPageTable.prototype,"enablePaste",void 0),t.ObjectPageTable=ObjectPageTable},2177:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(8992);class ActionAfterExecutionConfigurationOP{}a([r.syncRule({manifest:{path:(e,t,n,a)=>i.getColumnsPathForOP(e,t,n,a)+"/afterExecution"}})],ActionAfterExecutionConfigurationOP.prototype,"navigateToInstance",void 0),a([r.syncRule({manifest:{path:(e,t,n,a)=>i.getColumnsPathForOP(e,t,n,a)+"/afterExecution"}})],ActionAfterExecutionConfigurationOP.prototype,"enableAutoScroll",void 0),t.ActionAfterExecutionConfigurationOP=ActionAfterExecutionConfigurationOP;class ObjectPageTableColumn{}a([r.syncRule({manifest:{path:i.getColumnsPathForOP}}),r.validity({since:"1.84.0"})],ObjectPageTableColumn.prototype,"width",void 0),a([r.syncRule({manifest:{path:i.getColumnsPathForOP}}),r.validity({since:"1.85.0"})],ObjectPageTableColumn.prototype,"availability",void 0),a([r.syncRule({manifest:{path:i.getColumnsPathForOP}}),r.validity({since:"1.84.0"})],ObjectPageTableColumn.prototype,"afterExecution",void 0),t.ObjectPageTableColumn=ObjectPageTableColumn;class ObjectPageTableCustomColumn{}a([r.syncRule({manifest:{path:i.getColumnsPathForOP}}),r.validity({since:"1.84.0"})],ObjectPageTableCustomColumn.prototype,"header",void 0),a([r.syncRule({manifest:{path:i.getColumnsPathForOP}}),r.validity({since:"1.84.0"})],ObjectPageTableCustomColumn.prototype,"width",void 0),a([r.syncRule({manifest:{path:i.getColumnsPathForOP}}),r.validity({since:"1.84.0"})],ObjectPageTableCustomColumn.prototype,"template",void 0),t.ObjectPageTableCustomColumn=ObjectPageTableCustomColumn},100:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(8992);class ObjectPageToolBarAction{}a([r.syncRule({manifest:{path:i.getActionsPathForOP}})],ObjectPageToolBarAction.prototype,"enableOnSelect",void 0),t.ObjectPageToolBarAction=ObjectPageToolBarAction},6460:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5008),i=n(2762),o=n(8992);function s(e,t,n,a){"object"==typeof e.creationMode?e.creationMode[a]=t[n]:"string"==typeof e.creationMode&&(e.creationMode=t[n])}function c(e,t,n,a){"boolean"!=typeof e.personalization&&e.personalization||(e.personalization={}),e.personalization[a]=t[n]}function l(e,t){"object"==typeof e.creationMode&&void 0!==e.creationMode[t]?delete e.creationMode[t]:"string"==typeof e.creationMode&&void 0!==e.creationMode&&delete e.creationMode}function u(e,t){"object"==typeof e.personalization&&void 0!==e.personalization[t]?delete e.personalization[t]:"string"==typeof e.personalization&&void 0!==e.personalization&&delete e.personalization}function p(e,t,n,a){"object"==typeof e.creationMode?e.creationMode[a]=t[n]:"string"==typeof e.creationMode&&(e.creationMode={name:t.name,[a]:t[n]})}function f(e,t){"object"==typeof e.creationMode&&void 0!==e.creationMode[t]&&delete e.creationMode[t]}t.exportCreationModeName=s,t.exportPersonalizationProperty=c,t.deleteCreationModeName=l,t.deletePersonalizationProperty=u,t.exportCreationModeCreateAtEnd=p,t.deleteCreationModeCreateAtEnd=f;class TableCreationMode{}a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e),export:(e,t,n,a)=>{s(e,t,n,a)},delete:(e,t,n,a)=>{l(e,a)}}})],TableCreationMode.prototype,"name",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e),export:(e,t,n,a)=>{p(e,t,n,a)},delete:(e,t,n,a)=>{f(e,a)}}})],TableCreationMode.prototype,"createAtEnd",void 0),t.TableCreationMode=TableCreationMode;class PersonalizationType{}a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e),export:(e,t,n,a)=>{c(e,t,n,a)},delete:(e,t,n,a)=>{u(e,a)}}})],PersonalizationType.prototype,"column",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e),export:(e,t,n,a)=>{c(e,t,n,a)},delete:(e,t,n,a)=>{u(e,a)}}})],PersonalizationType.prototype,"sort",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e),export:(e,t,n,a)=>{c(e,t,n,a)},delete:(e,t,n,a)=>{u(e,a)}}})],PersonalizationType.prototype,"filter",void 0),t.PersonalizationType=PersonalizationType;class QuickVariantSelectionV4{}a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e)+r.QUICKVARPATH}})],QuickVariantSelectionV4.prototype,"paths",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e)+r.QUICKVARPATH}})],QuickVariantSelectionV4.prototype,"hideTableTitle",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e)+r.QUICKVARPATH}})],QuickVariantSelectionV4.prototype,"showCounts",void 0),t.QuickVariantSelectionV4=QuickVariantSelectionV4;class MultiTableModeV4{}a([i.syncRule({manifest:{path:e=>o.getSettingsPathForPage(e)+"/views"}})],MultiTableModeV4.prototype,"paths",void 0),a([i.syncRule({manifest:{path:e=>o.getSettingsPathForPage(e)+"/views"}})],MultiTableModeV4.prototype,"showCounts",void 0),t.MultiTableModeV4=MultiTableModeV4;class Table{}a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e)}}),i.validity({since:"1.84.0"})],Table.prototype,"type",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e),import:e=>{const t=e.creationMode;return"object"==typeof t?t:"string"==typeof t?{name:t}:void 0}}}),i.validity({since:"1.84.0"})],Table.prototype,"creationMode",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e),import:e=>{const t=e.personalization;return"object"==typeof t?t:"boolean"==typeof t?{column:t,sort:t,filter:t}:void 0}}}),i.validity({since:"1.84.0"})],Table.prototype,"personalization",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e)}}),i.validity({since:"1.84.0"})],Table.prototype,"selectionMode",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e)}}),i.validity({since:"1.84.0"})],Table.prototype,"selectAll",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e)}}),i.validity({since:"1.84.0"})],Table.prototype,"selectionLimit",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e)}}),i.validity({since:"1.84.0"})],Table.prototype,"enableExport",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e)}}),i.validity({since:"1.84.0"})],Table.prototype,"condensedTableLayout",void 0),a([i.syncRule({manifest:{path:e=>o.getTableSettingsPathForLR(e)}}),i.validity({since:"1.84.0"})],Table.prototype,"quickVariantSelection",void 0),a([i.syncRule({manifest:{path:e=>o.getSettingsPathForPage(e)}}),i.validity({since:"1.84.0"})],Table.prototype,"views",void 0),a([i.syncRule({manifest:{path:e=>o.getSettingsPathForPage(e)}}),i.validity({since:"1.84.0"})],Table.prototype,"initialLoad",void 0),t.Table=Table},6437:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(8992);class ActionAfterExecutionConfiguration{}a([r.syncRule({manifest:{path:(e,t,n,a)=>i.getColumnsPathForLR(e,t,n,a)+"/afterExecution"}})],ActionAfterExecutionConfiguration.prototype,"navigateToInstance",void 0),a([r.syncRule({manifest:{path:(e,t,n,a)=>i.getColumnsPathForLR(e,t,n,a)+"/afterExecution"}})],ActionAfterExecutionConfiguration.prototype,"enableAutoScroll",void 0),t.ActionAfterExecutionConfiguration=ActionAfterExecutionConfiguration;class TableColumn{}a([r.syncRule({manifest:{path:i.getColumnsPathForLR}}),r.validity({since:"1.84.0"})],TableColumn.prototype,"width",void 0),a([r.syncRule({manifest:{path:i.getColumnsPathForLR}}),r.validity({since:"1.85.0"})],TableColumn.prototype,"availability",void 0),a([r.syncRule({manifest:{path:i.getColumnsPathForLR}}),r.validity({since:"1.84.0"})],TableColumn.prototype,"afterExecution",void 0),t.TableColumn=TableColumn;class TableCustomColumn{}a([r.syncRule({manifest:{path:i.getColumnsPathForLR}}),r.validity({since:"1.84.0"})],TableCustomColumn.prototype,"header",void 0),a([r.syncRule({manifest:{path:i.getColumnsPathForLR}}),r.validity({since:"1.84.0"})],TableCustomColumn.prototype,"width",void 0),a([r.syncRule({manifest:{path:i.getColumnsPathForLR}}),r.validity({since:"1.84.0"})],TableCustomColumn.prototype,"template",void 0),t.TableCustomColumn=TableCustomColumn},5230:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.ToolBar=class ToolBar{}},1707:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(8992);class ToolBarAction{}a([r.syncRule({manifest:{path:i.getActionsPathForLR}})],ToolBarAction.prototype,"enableOnSelect",void 0),t.ToolBarAction=ToolBarAction},1107:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(6460)),a(n(6437)),a(n(5230)),a(n(1707)),a(n(100)),a(n(1735)),a(n(2177)),a(n(9509)),a(n(8434)),a(n(861)),a(n(101)),a(n(4086))},1271:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5008),r=n(8992),i=n(3220),o=n(5555),s=n(6739),c=n(9081),l=n(5709),u={flexChanges:[],manifest:{"sap.ui5":{flexEnabled:!0,routing:{targets:{}}},"sap.app":{}},fragments:[]};function p(e,t,n,r,i,o,l){let u=e.indexOf("subsections");for(;u>-1;)e.splice(u-1,2),u=e.indexOf("subsections");const{targetAnnotationEncoded:p,targetAnnotation:f,custom:d}=function(e,t){let n="",a="",r=!1;return"sections"===e[0]&&("custom"===e[1]&&e[2]!==e[e.length-1]?(r=!0,a=e[2],n=a.replace(/::/g,"/")):(a=e[1]&&e[1].replace(/\//g,"::"),n=a.replace(/::/g,"/"))),"sections"===e[1]&&(n=a=t&&t.indexOf(s.FacetTitlePrefix)>-1?t.split(s.FacetTitlePrefix)[1]:a.replace(/::/g,"/")),{targetAnnotationEncoded:a,targetAnnotation:n,custom:r}}(e,n.title),h=function(e){let t;const n=e.findIndex((e=>"columns"===e||"actions"===e))+1;return n>0&&(t=e[n]),t}(e),g=t.manifest.path(n.pageNameArray,{},p,h),m=a.getManifestSectionByPathV4(n.exportResults.manifest,g,f,d?void 0:p),y=t.manifest.key||r;if(void 0!==i[r])!function(e,t,n,a,r,i,o){if("array"!==e.type&&t&&"object"===t.targetDefinition.type&&t.targetDefinition.properties)"array"!==e.type&&void 0===a[o]&&(a[o]={});else{const e=n.manifest.export;!1!==e&&(e&&"function"==typeof e?e(a,r,i,o):a[o]=r[i])}}(o,l,t,m,i,r,y);else if(void 0!==m[y])delete m[y];else if(t.manifest.delete){const e=t.manifest.delete;"function"==typeof e&&e(m,i,r,y)}c.deleteEmptyStructure(n.exportResults.manifest,g,f,p)}function f(e,t,n,r,i,o,s){const c=a.getReflectMetadata(r,n);c&&(c.flex?function(e,t,n,r,i,o){const s=e.flex.controlId(t.baseId,n,r,e.flex.controlType,t.title),c=a.fillFlexChangeContent(i,e,t.ui5Version,o,s);t.exportResults.flexChanges.push(e.flex.createFlexChange(c,t.exportResults.manifest))}(c,e,i,t,r,n):c.manifest&&p(i,c,e,n,r,o,s))}function d(e,t,n,a,r,i,o,s){let c=[],l=!1;e.$ref&&t?c.push(t.configObject):e.anyOf?c.push(n):"array"===e.type?(c=n,l=!0):c.push(n);for(const e of c){const n=[];"sections"===a[0]&&"custom"===r&&l&&n.push(e.id),i.title=t.title,h(i,e,[...o,...n],s,[...a,r],t.targetDefinition)}}function h(e,t,n,r,i,o){let s;if(o&&o.properties)for(const l in o.properties){s=t[l];const u=a.getChildId(t,l),p=o.properties[l],h=c.getNextTargetDefinition(e.appSchema,e.title,s,p,l,e.factory,e.pageType),g=u?[...n,u]:[...n,l];if(f(e,i,l,t,g,p,h),p&&("object"==typeof s||p.$ref&&h.configObject)){d(p,h,s,i,l,e,g,u?[...r,u]:r)}}}function g(e,t,n){if("custom"===t&&Array.isArray(e.sections[t])){const t=e.sections.custom;for(let e=0;e<t.length;e++)t[e]=n.createInstance(s.PageType.ObjectPage,"ObjectPageCustomSectionView",t[e],t[e].className)}}function m(e,t){if(e.subsections){let n;for(const a in e.subsections)n=e.subsections[a],g(n,a,t),m(n,t)}}const y=(e,t)=>{var n;const r=u;r.manifest=JSON.parse(JSON.stringify(e.manifest));const i=new l.MetadataInstanceFactoryV4,o=i.createPageInstance(s.PageType.ObjectPage,e.page.config),c=a.getPageLayoutInformation(o),p=e.page.name,f=`${e.appId}::${c.id}::${p}--`;(null===(n=e.page.config)||void 0===n?void 0:n.sections)&&function(e,t,n){let a;for(const r in e.sections)a=t.sections[r],g(e,r,n),m(a,n)}(e.page.config,o,i);return h({exportResults:r,appId:e.appId,baseId:f,appSchema:e.jsonSchema,ui5Version:t,factory:i,pageNameArray:[p],pageType:s.PageType.ObjectPage,title:void 0},o,[],[],[],e.jsonSchema),r},v=(e,t,n,r,i)=>{var o;const c=u;if(c.manifest=JSON.parse(JSON.stringify(e.manifest)),n.table=t.createInstance(r,"Table",n.table),null===(o=n.table.toolBar)||void 0===o?void 0:o.actions)for(const a in e.jsonSchema.definitions["Actions<LineItems>"].properties)n.table.toolBar.actions[a]=t.createInstance(r,"ToolBarAction",n.table.toolBar.actions[a]);const l=a.getPageLayoutInformation(n),p=e.page.name,f=`${e.appId}::${l.id}::${p}--`;if(!c.manifest[s.ManifestSection.ui5].routing.targets[p]){const e={type:"Component",id:"",name:l.pageId,options:{settings:{entitySet:p,navigation:{},controlConfiguration:{}}}};c.manifest[s.ManifestSection.ui5].routing.targets[p]=e}return h({exportResults:c,appId:e.appId,baseId:f,appSchema:e.jsonSchema,ui5Version:i,factory:t,pageNameArray:[p],pageType:s.PageType.ListReport,title:void 0},n,[],[],[],e.jsonSchema),c};t.exportPageV4=(e,t)=>{if(e[s.SchemaType.ListReport])return((e,t)=>{const n=new l.MetadataInstanceFactoryV4,a=n.createPageInstance(s.PageType.ListReport,e.page.config);return v(e,n,a,s.PageTypeV4.ListReport,t)})(e[s.SchemaType.ListReport],t);if(e[s.SchemaType.ObjectPage])return y(e[s.SchemaType.ObjectPage],t);if(e[s.SchemaType.Application]){const{application:t,manifest:n,jsonSchema:l}=e[s.SchemaType.Application];return((e,t,n)=>{const l=u;l.manifest=JSON.parse(JSON.stringify(t));const p=Object.assign(new r.ApplicationV4,e);p.settings=Object.assign(new r.AppSettings,p.settings);for(const t in n.definitions.AppSettings.properties){const n=a.getReflectMetadata(p.settings,t);if(n&&n.manifest){const r=n.manifest.path(),i=a.getManifestSectionByPathV4(l.manifest,r);e.settings&&e.settings[t]?i[t]=e.settings[t]:delete i[t],c.deleteEmptyStructure(l.manifest,r)}}return l.manifest[s.ManifestSection.ui5].routing=i.transformRoutingV4(e.home,e.pages,l.manifest),o.updateFcl(l.manifest[s.ManifestSection.ui5],e),l})(t,n,l)}return e[s.SchemaType.AnalyticalListPage]?((e,t)=>{const n=new l.MetadataInstanceFactoryV4,a=n.createPageInstance(s.PageType.AnalyticalListPage,e.page.config);return v(e,n,a,s.PageTypeV4.AnalyticalListPage,t)})(e[s.SchemaType.AnalyticalListPage],t):void 0}},5709:function(e,t,n){"use strict";var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});const r=a(n(1107)),i=a(n(7601)),o=n(6785),s=n(6971),c={Table:r.ObjectPageTable,TableColumn:r.ObjectPageTableColumn,ObjectPageCustomSectionView:r.ObjectPageCustomSectionFragment,ActionAfterExecutionConfiguration:r.ActionAfterExecutionConfigurationOP},l={[s.PageType.AnalyticalListPage]:{},[s.PageType.ListReport]:{},[s.PageType.ObjectPage]:c};class MetadataInstanceFactoryV4 extends o.MetadataFactory{constructor(){super(r,i,l)}}t.MetadataInstanceFactoryV4=MetadataInstanceFactoryV4},5555:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5877),r=n(3220),i=n(6391),o=[a.FlexibleColumnLayoutAggregations.BeginColumnPages,a.FlexibleColumnLayoutAggregations.MidColumnPages,a.FlexibleColumnLayoutAggregations.EndColumnPages],s=(e,t,n,i=[],c=0)=>{const l=t.pages[n],u=e.routing.routes.find((e=>e.name===n));"string"==typeof u.target&&(u.target=c<=2?[...i,u.target]:[u.target]);const p=e.routing.targets[n];p.controlAggregation="controlAggregation"in l?l.controlAggregation:o[c]?o[c]:a.FlexibleColumnLayoutAggregations.EndColumnPages;const f=u.pattern.replace(r.Constants.OptionalQuery,"");if(p.contextPattern=f?`/${f}`:"",l.navigation){c++;for(const n in l.navigation)s(e,t,n,u.target,c)}};t.updateFcl=(e,t)=>{t.settings&&t.settings.flexibleColumnLayout?((e,t)=>{e.routing.config||(e.routing.config={}),e.routing.config.routerClass=a.FIORI_FCL_ROUTER_CLASS,s(e,t,t.home);const n={viewName:a.FIORI_FCL_ROOT_VIEW_NAME,type:a.ViewTypes.XML,async:!0,id:a.FIORI_FCL_ROOT_ID};e.rootView=e.rootView?Object.assign(Object.assign({},e.rootView),n):n,i.updateDependencyLib(e,a.SAPUI5_DEPENDENCY_LIB_SAP_F)})(e,t):(e=>{if(e.rootView&&e.rootView.viewName===a.FIORI_FCL_ROOT_VIEW_NAME&&delete e.rootView,e.routing){e.routing.config&&e.routing.config.routerClass===a.FIORI_FCL_ROUTER_CLASS&&delete e.routing.config.routerClass;const t=e.routing.routes||[];for(const e of t)e.target&&Array.isArray(e.target)&&(e.target=e.name)}})(e)}},3220:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(6739);var r;!function(e){e.OptionalQuery=":?query:",e.Component="sap/fe/AppComponent",e.Namespace="sap.fe.templates"}(r=t.Constants||(t.Constants={}));const i=(e,t,n)=>({pattern:n,name:e,target:t}),o=(e,t)=>({settings:Object.assign(Object.assign(Object.assign({},e&&{entitySet:e}),t&&{variantManagement:t}),{navigation:{}})});function s(e,t,n){e.options||(e.options=o()),e.options.settings||(e.options.settings={}),e.options.settings.navigation||(e.options.settings.navigation={}),e.options.settings.navigation[t]={detail:{route:n}}}function c(e,t){let n="";return e.forEach(((e,r)=>{let i="";t!==a.PageTypeV4.ListReport&&(i=`({key${r?r+1:""}})`),n+=`${n?"/":""}${e}${i}`})),n}function l(e,t,n,o){if(e.navigation)for(const l in e.navigation){const u=e.navigation[l].split("."),p=t[l]&&t[l].pageType,f=c(u,p);let d=u[u.length-1];p!==a.PageTypeV4.ListReport&&(p!==a.PageTypeV4.CustomPage||t[l].entitySet||d)||(d=l),d&&s(n,d,l),o.routes.some((e=>e.name===l))||o.routes.push(i(l,l,`${f}${r.OptionalQuery}`))}}function u(e,t){var n,a,r,i,s,c;e.entitySet?(t.options||(t.options=o(e.entitySet,e.variantManagement)),t.options.settings.entitySet=e.entitySet,(null===(i=null===(r=null===(a=null===(n=null==t?void 0:t.options)||void 0===n?void 0:n.settings)||void 0===a?void 0:a.content)||void 0===r?void 0:r.body)||void 0===i?void 0:i.sections)&&(t.options.settings.content.body.sections={})):null===(c=null===(s=t.options)||void 0===s?void 0:s.settings)||void 0===c||delete c.entitySet}function p(e,t,n){const a=e.routes.find((e=>e.name===t));a&&(n.defaultLayoutType?a.layout=n.defaultLayoutType:delete a.layout)}t.transformRoutingV4=function(e,t,n){var o,s;const c=function(e){let t=e;return t?(t.routes||(t.routes=[]),t.targets||(t.targets={})):t={routes:[],targets:{}},t}(n[a.ManifestSection.ui5].routing);e&&!c.routes.some((t=>t.name===e))&&c.routes.push(i(e,e,r.OptionalQuery));for(const e in t){let n;const i=t[e];c.targets[e]&&(n=c.targets[e]),i.pageType&&i.pageType!==a.PageTypeV4.CustomPage?n=Object.assign(Object.assign({},n),{type:"Component",id:e,name:`${r.Namespace}.${t[e].pageType}`}):i.view&&n&&(n.viewName||n.viewId)?(n=Object.assign(Object.assign({},n),{viewName:i.view.name}),i.view.id&&(n.viewId=i.view.id)):i.view&&(n=Object.assign(Object.assign({},n),{type:"Component",id:i.view.id,name:`${a.FE_TEMPLATE_V4_CUSTOM_PAGE}`,options:{settings:{viewName:i.view.name}}})),u(i,n),n&&!i.controlAggregation&&(delete n.contextPattern,delete n.controlAggregation),(null===(s=null===(o=null==n?void 0:n.options)||void 0===o?void 0:o.settings)||void 0===s?void 0:s.navigation)&&(n.options.settings.navigation={}),l(i,t,n,c),p(c,e,i),c.targets[e]=n}return function(e,t){for(const n in e.targets)if(!t||!t[n]){delete e.targets[n];const t=e.routes.findIndex((e=>e.name===n));-1!==t&&e.routes.splice(t,1)}}(c,t),c}},8535:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5877),i=n(2762),o=n(8992);let s=class AnalyticalListPage{};a([i.syncRule({manifest:{path:e=>o.getSettingsPathForPage(e)}}),i.validity({since:"1.84.0"})],s.prototype,"variantManagement",void 0),a([i.childId("fe::FilterBar")],s.prototype,"filterBar",void 0),a([i.childId("fe::table")],s.prototype,"table",void 0),s=a([i.pageLayoutInformation({id:r.FE_TEMPLATE_V4_ALP,pageId:r.FE_TEMPLATE_V4_ALP})],s),t.AnalyticalListPage=s},3643:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(8992);let o=class ListReport{};a([r.syncRule({manifest:{path:e=>i.getSettingsPathForPage(e)}}),r.validity({since:"1.84.0"})],o.prototype,"variantManagement",void 0),a([r.childId("fe::FilterBar")],o.prototype,"filterbar",void 0),o=a([r.pageLayoutInformation({id:"sap.suite.ui.generic.template.ListReport.view.ListReport",pageId:"sap.suite.ui.generic.template.ListReport"})],o),t.ListReport=o},7066:function(e,t,n){"use strict";var a=this&&this.__decorate||function(e,t,n,a){var r,i=arguments.length,o=i<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(i<3?r(o):i>3?r(t,n,o):r(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const r=n(2762),i=n(8992);let o=class ObjectPage{};a([r.childId("header")],o.prototype,"header",void 0),a([r.childId("layout")],o.prototype,"layout",void 0),a([r.syncRule({manifest:{path:e=>i.getSettingsPathForPage(e)}}),r.validity({since:"1.84.0"})],o.prototype,"variantManagement",void 0),a([r.childId("sections")],o.prototype,"sections",void 0),o=a([r.pageLayoutInformation({id:"sap.suite.ui.generic.template.ObjectPage.view.Details",pageId:"sap.suite.ui.generic.template.ObjectPage"})],o),t.ObjectPage=o},7601:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(3643)),a(n(7066)),a(n(8535))},6391:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.updateDependencyLib=function(e,t,n=!0){n?(e.dependencies||(e.dependencies={}),e.dependencies.libs||(e.dependencies.libs={}),void 0===e.dependencies.libs[t]&&(e.dependencies.libs[t]={})):e.dependencies&&e.dependencies.libs&&void 0!==e.dependencies.libs[t]&&delete e.dependencies.libs[t]}},6151:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(9081),r=n(6882),i=n(4027);t.generateObjectPageInterfaceV4=function(e,t,n,o,s){const c=a.parseAndMergeAndConvert(n,s),l={fioriElementsVersion:i.FioriElementsVersion.v4,manifest:o,fragments:[],serviceAVT:c,logger:s};return r.generateObjectPageSchemaV4(l,e,t)},t.generateListReportInterfaceV4=function(e,t,n,i){const o=a.parseAndMergeAndConvert(n,i),s=o.entitySets.find((e=>e.name===t));return r.generateListReportSchemaV4(e,s.entityType.name,o,i)}},6882:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=n(8106);t.generateListReportSchemaV4=a.generateListReportSchemaV4;var r=n(7067);t.generateObjectPageSchemaV4=r.generateObjectPageSchemaV4;var i=n(6151);t.generateListReportInterfaceV4=i.generateListReportInterfaceV4,t.generateObjectPageInterfaceV4=i.generateObjectPageInterfaceV4},8106:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=a(n(9154)),i=n(5921),o=n(9190),s=n(5008);function c(e,t,n){s.addEnumForSingleTabVariant(e,t,"AnnotationPathAsObject"),s.addEnumForMultiTabVariant(n,t,"AnnotationPathWithKey"),s.addEnumForVariantEntitySet(n,t,"AnnotationPathWithKey")}t.addEnumForVariantPaths=c,t.generateListReportSchemaV4=function(e,t,n,a){var l,u,p,f;const d=JSON.parse(JSON.stringify(e)),h=null==n?void 0:n.entityTypes.find((e=>e.name===t));if(h){const e=s.findAlias(s.UIVOCABULARY,n),t=null===(u=null===(l=null==h?void 0:h.annotations)||void 0===l?void 0:l[e])||void 0===u?void 0:u.LineItem;d.definitions.Table.properties.toolBar.$ref=`${s.DEFINITION_LINK_PREFIX}ToolBar<LineItems>`,o.addLineItemsType(d,t,h,n,"TableColumn"),c(h,d,n);!function(e,t,n){const a=t.definitions.SelectionFields;if(a.additionalProperties=!1,a.properties={},a.annotationPath=s.createAnnotationPath(e.fullyQualifiedName,"com.sap.vocabularies.UI.v1.SelectionFields"),!n)return;let r=0;n.forEach((n=>{var i;let o=n.value;const c="SelectionField::"+s.prepareRef(n.value);"PropertyPath"===n.type&&(o=s.getLabelForPropertyPath(n,e)),a.properties[c]={$ref:s.DEFINITION_LINK_PREFIX+c,propertyIndex:r},t.definitions[c]={type:"object",properties:{},description:o,annotationPath:`${a.annotationPath}/${r}`,isViewNode:!0,additionalProperties:!1,annotationType:null==n?void 0:n.type,dataType:null===(i=null==n?void 0:n.$target)||void 0===i?void 0:i.type.replace("Edm.","")},r++}))}(h,d,null===(f=null===(p=null==h?void 0:h.annotations)||void 0===p?void 0:p[e])||void 0===f?void 0:f.SelectionFields),d.definitions.Table.properties.columns.$ref=s.DEFINITION_LINK_PREFIX+"LineItems",delete d.definitions.GenericColumns,delete d.definitions.ToolBar,delete d.definitions.Actions,delete d.definitions.Action}else i.log(a,{severity:"error",message:r.default.t("NOENTITYTYPE",{entityType:t}),location:{path:s.METADATAPATH}});return d}},7067:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(6971),i=n(6739),o=n(5008),s=n(9190),c=a(n(9154)),l=n(5921);function u(e,t,n,a,r){return(i,s)=>{if(!i.Determining&&"com.sap.vocabularies.UI.v1.DataFieldForAction"===i.$Type||"com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation"===i.$Type){const c=o.replaceAlias(i.Action,r),{actionName:l,actionId:u}=o.getActionNameAndId(c,e),p=i.Label||l,f=`HeaderAction<${o.prepareRef(u)}>`,d=n.fullyQualifiedName.replace("@com.sap.vocabularies.UI.v1.Identification","/@com.sap.vocabularies.UI.v1.Identification");t.definitions[f]={isViewNode:!0,type:"object",properties:{},description:p,annotationPath:`/${d}/${s}`},a.properties[u]={$ref:`${o.DEFINITION_LINK_PREFIX}${f}`}}}}function p(e,t,n,a,c,l){const u=e[t],f=t.replace("#","::");if("CollectionFacet"===u.base)n.properties[t]=o.createSectionWithoutProperties(u,t),function(e,t,n,a,r,i){n.properties[t].properties={subsections:{additionalProperties:!1,type:"object",properties:{},annotationPath:e.annotationPath,isViewNode:!0,description:"Subsections"}};const o=n.properties[t].properties.subsections;for(const t in e.facets)p(e.facets,t,o,a,r,i)}(u,t,n,a,c,l);else if("LineItem"===u.base&&l===i.SectionType.Section){const r=`ObjectPage${l}TableV4<${f}>`;n.properties[t]={$ref:`${o.DEFINITION_LINK_PREFIX}${r}`},function(e,t,n,a,r){let i="",c="";[i,c]=t.split("::");const l="ObjectPageSectionTableV4<"+t+">";a.definitions[l]=JSON.parse(JSON.stringify(a.definitions.ObjectPageSectionTableV4));const u=`ObjectPageTable<${t}>`;a.definitions[l].properties.table.$ref=`${o.DEFINITION_LINK_PREFIX}${u}`,a.definitions[u]=JSON.parse(JSON.stringify(a.definitions.ObjectPageTable)),a.definitions[l].annotationPath=e.annotationPath,o.addSectionTitleAndDescription(e,a.definitions[l],t),a.definitions[l].properties.table.$ref=o.DEFINITION_LINK_PREFIX+"ObjectPageTable<"+t+">";const p="ObjectPageTable<"+t+">";a.definitions[p]=JSON.parse(JSON.stringify(a.definitions.ObjectPageTable)),e.entityType&&c&&(a.definitions[p].annotationPath=`/${e.entityType.fullyQualifiedName}/${c}`),a.definitions[p].properties.columns={$ref:o.DEFINITION_LINK_PREFIX+t},a.definitions[p].properties.toolBar.$ref=`${o.DEFINITION_LINK_PREFIX}ObjectPageToolBar<${t}>`,a.definitions[p].properties.quickVariantSelection.$ref=`${o.DEFINITION_LINK_PREFIX}QuickVariantSelectionV4OP<${t}>`,a.definitions[`QuickVariantSelectionV4OP<${t}>`]=JSON.parse(JSON.stringify(a.definitions.QuickVariantSelectionV4OP)),a.definitions[`AnnotationPathAsObject<${t}>`]=JSON.parse(JSON.stringify(a.definitions.AnnotationPathAsObject)),a.definitions[`QuickVariantSelectionV4OP<${t}>`].properties.paths.items.$ref=`${o.DEFINITION_LINK_PREFIX}AnnotationPathAsObject<${t}>`,o.addEnumForSingleTabVariant(e.entityType,a,`AnnotationPathAsObject<${t}>`);for(const e in n)"LineItem"===n[e].base&&e.includes(i)&&s.addLineItemsType(a,n[e].target,n[e].entityType,r,"ObjectPageTableColumn",t)}(u,f,e,a,c)}else if(u.base===o.FacetBase.Form||u.base===o.FacetBase.Identification){!function(e,t,n,a,i,s){n.properties[t]={$ref:`${o.DEFINITION_LINK_PREFIX}${s}`},a.definitions[s]=JSON.parse(JSON.stringify(a.definitions[`ObjectPage${i}Form`])),e.ID||(a.definitions[s].properties={}),o.addSectionTitleAndDescription(e,a.definitions[s],t),a.definitions[s].annotationPath=e.annotationPath,a.definitions[s].isViewNode=!0;const c=!(e.base===o.FacetBase.Identification&&t.indexOf("#")<0);o.handleForm(i,e,a.definitions[s],a,r.FioriElementsVersion.v4,c)}(u,t,n,a,l,`ObjectPage${l}Form<${f}>`)}else if(u.base===o.FacetBase.DataPoint||u.base===o.FacetBase.Address||u.base===o.FacetBase.Contact){!function(e,t,n,a,r,i){n.properties[t]={$ref:`${o.DEFINITION_LINK_PREFIX}${i}`},a.definitions[i]=JSON.parse(JSON.stringify(a.definitions[`ObjectPage${r}${e.base}`])),o.addSectionTitleAndDescription(e,a.definitions[i],t),a.definitions[i].annotationPath=e.annotationPath,a.definitions[i].isViewNode=!0}(u,t,n,a,l,`ObjectPage${l}${u.base}<${f}>`)}else n.properties[t]=o.createSectionWithoutProperties(u,t)}function f(e,t,n,a,s){o.addCommonHeaderSchema(t,n),o.addHeaderActions(t,n,null==e?void 0:e.serviceAVT,u),t.definitions.HeaderSections.annotationPath=`/${a.entityType.fullyQualifiedName}/@com.sap.vocabularies.UI.v1.HeaderFacets`,function(e,t,n,a,s){const c=o.getObjectPageHeaderFacets(n,null==e?void 0:e.serviceAVT,r.FioriElementsVersion.v4,e.logger),l=t.definitions.HeaderSections;l.properties={},l.additionalProperties=!1,c&&(Object.keys(s).forEach((n=>{var r,o;if((null===(o=null===(r=s[n].options)||void 0===r?void 0:r.settings)||void 0===o?void 0:o.entitySet)===a&&s[n].name===i.FE_TEMPLATE_V4_OBJECT_PAGE)for(const n in c)p(c,n,l,t,null==e?void 0:e.serviceAVT,i.SectionType.HeaderSection)})),delete t.definitions.ObjectPageHeaderSectionForm,delete t.definitions.ObjectPageHeaderSectionChart,delete t.definitions.ObjectPageHeaderSectionDataPoint,delete t.definitions.ObjectPageHeaderSectionContact,delete t.definitions.ObjectPageHeaderSectionAddress)}(e,t,n,a.name,s)}t.generateObjectPageSchemaV4=function(e,t,n){var a,s;const u=JSON.parse(JSON.stringify(t));u.properties.sections={$ref:o.DEFINITION_LINK_PREFIX+"Sections"};const d=null===(s=null===(a=null==e?void 0:e.serviceAVT)||void 0===a?void 0:a.entitySets)||void 0===s?void 0:s.find((e=>e.entityType.name===n));d||l.log(e.logger,{severity:"error",message:c.default.t("NOENTITYSET4NAME",{entityType:n}),location:{path:o.METADATAPATH}});const h=null==d?void 0:d.entityType;if(e.manifest[r.ManifestSection.ui5].routing&&e.manifest[r.ManifestSection.ui5].routing.targets||l.log(e.logger,{severity:"error",message:c.default.t("NOROUTING"),location:{path:i.MANIFESTPATH}}),u.definitions.Sections={type:"object",properties:{},additionalProperties:!1,isViewNode:!0,description:"Sections"},d){const t=e.manifest[r.ManifestSection.ui5].routing.targets;if(!t)return l.log(e.logger,{severity:"error",message:c.default.t("NOPAGES",{appId:e.manifest["sap.app"].id}),location:{path:i.MANIFESTPATH,range:[r.ManifestSection.generic]}}),u;f(e,u,h,d,t),u.definitions.Sections.annotationPath=`/${d.entityType.fullyQualifiedName}/@com.sap.vocabularies.UI.v1.Facets`,function(e,t,n,a,s){const c=o.getObjectPageFacets(n,null==e?void 0:e.serviceAVT,r.FioriElementsVersion.v4,e.logger);if(!c)return void delete t.definitions.ObjectPageSubSections;const l=t.definitions.Sections;Object.keys(s).forEach((n=>{var r,o;if((null===(o=null===(r=s[n].options)||void 0===r?void 0:r.settings)||void 0===o?void 0:o.entitySet)===a&&s[n].name===i.FE_TEMPLATE_V4_OBJECT_PAGE)for(const n in c)p(c,n,l,t,null==e?void 0:e.serviceAVT,i.SectionType.Section)})),t.definitions.CustomSections&&(l.properties=Object.assign(Object.assign({},l.properties),t.definitions.CustomSections.properties))}(e,u,h,d.name,t),function(e,t,n,a,r){Object.keys(r).forEach((s=>{if(r[s].options&&r[s].options.settings&&r[s].options.settings.entitySet===a&&r[s].name===i.FE_TEMPLATE_V4_OBJECT_PAGE){const a=o.getObjectPageFacetSection(n,null==e?void 0:e.serviceAVT,e.logger),i=r[s];i.options&&i.options.settings&&i.options.settings.content&&i.options.settings.content.body&&i.options.settings.content.body.sections&&Object.keys(i.options.settings.content.body.sections).forEach((function(e){a.find((t=>t.key===e))||a.push({key:e,custom:!0})})),o.addDefinitionForRelatedFacetKeys(t,["ObjectPageCustomSectionFragment"],a,["ID","label","key"])}}))}(e,u,h,d.name,t),o.addFooterActions(u,h,null==e?void 0:e.serviceAVT)}return delete u.definitions.GenericSections,delete u.definitions.ObjectPageSubSections,delete u.definitions.ObjectPageTable,delete u.definitions.GenericColumns,delete u.definitions.ObjectPageSectionTableV4,delete u.definitions.ObjectPageSectionForm,delete u.definitions.ObjectPageSectionDataPoint,delete u.definitions.ObjectPageSectionAddress,delete u.definitions.ObjectPageSectionContact,delete u.definitions.ObjectPageToolBar,delete u.definitions.ObjectPageToolBarActions,delete u.definitions.ObjectPageToolBarAction,delete u.definitions.QuickVariantSelectionV4OP,u}},8083:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(4093),i=n(8992),o=n(5008),s=n(3381),c=n(8548),l=n(1168),u=n(5877),p=n(6971),f=n(1491),d=n(5008),h=n(3435),g=n(5921),m=a(n(9154));!function(e){e.OptionalQuery=":?query:",e.Component="sap/fe/AppComponent",e.Namespace="sap.fe.templates"}(t.Constants||(t.Constants={}));const y=[];let v={};function b(e,t){const n=e.target,a=t.target,r=Array.isArray(n),i=Array.isArray(a);return r&&i?n.length-a.length:r||i?r?1:-1:0}function P(e,t=[]){if(!Array.isArray(e))return e;let n=e;for(const e of t)n=n.filter((t=>!e.includes(t)));return n[0]}function S(e,t,n){let a;return e.name?a=e.name===u.FE_TEMPLATE_V4_CUSTOM_PAGE?p.PageTypeV4.CustomPage:e.name.endsWith(p.PageTypeV4.ListReport)?p.PageTypeV4.ListReport:e.name.endsWith(p.PageTypeV4.ObjectPage)?p.PageTypeV4.ObjectPage:e.name.endsWith(p.PageTypeV4.AnalyticalListPage)?p.PageTypeV4.AnalyticalListPage:void 0:"viewId"in e?a=p.PageTypeV4.CustomPage:(g.log(t,{severity:"error",message:m.default.t("INVALIDTARGETDEFINITION",{target:JSON.stringify(e)}),location:{path:o.MANIFESTPATH,range:[`${u.ManifestSection.ui5}/routing/targets/${n}`]}}),"XML"===e.viewType&&"viewName"in e&&(a=p.PageTypeV4.CustomPage)),a}function T(e,t,n,a,r,i,u){const f=o.generatePageId(i.pageType,i.entitySet,i.navigationProperty,e.viewId||t===p.PageTypeV4.CustomPage&&e.id);if(!f)return;const d=Object.keys(a).find((e=>e.includes(f)))||Object.keys(a).find((e=>e.includes(f.slice(0,-1))))||Object.keys(a).find((e=>e.includes(i.pageType)));if(d)if(t===p.PageTypeV4.ListReport){const e={manifest:n,jsonSchema:a[d],logger:r};i.config=s.createListReportConfig(e)}else if(i.pageType===p.PageTypeV4.AnalyticalListPage){const e={manifest:n,jsonSchema:a[d],logger:r};i.config=l.createAnalyticalListPageConfig(e)}else if(i.pageType===p.PageTypeV4.ObjectPage){const e={manifest:n,jsonSchema:a[d],routingId:u,logger:r};i.config=c.createObjectPageConfigV4(e)}}function O(e){if(e.options){if("viewName"in e.options.settings){const t=e.options.settings.viewName.split(".");y.push(t[t.length-1])}}else if("viewId"in e){const t=e.viewName.split(".");y.push(t[t.length-1])}}function E(e,t,n){var a,r;const i={},o=e[u.ManifestSection.ui5].routing;v=function(e){const t={};e=e.concat().sort(b);const n=[];for(const a of e){const e=a.pattern.split(":")[0].split("/");let r;Array.isArray(a.target)?(r=P(a.target,n),n.push(a.target)):r=a.target;for(const n of e){const e=n.split("(")[0];t[r]=t[r]?`${t[r]}.${e}`:e}}return t}(o.routes);for(const s in o.targets){const c=o.targets[s],l=S(c,n,s),u={pageType:l};if(c.options&&(u.entitySet=c.options.settings.entitySet),c.controlAggregation&&(u.controlAggregation=c.controlAggregation),v[s]&&-1!==v[s].indexOf(".")){const e=v[s].split(".");u.navigationProperty=e[e.length-1]}if("viewId"in c)u.view={id:c.viewId,name:c.viewName};else if(l===p.PageTypeV4.CustomPage){const e=(null===(r=null===(a=c.options)||void 0===a?void 0:a.settings)||void 0===r?void 0:r.viewName)||c.viewName;u.view=Object.assign(Object.assign({},c.id&&{id:c.id}),e&&{name:e})}if(c.options){c.options.settings.variantManagement&&(u.variantManagement=c.options.settings.variantManagement),u.navigation={};for(const e in c.options.settings.navigation){const t=c.options.settings.navigation[e];u.navigation[t.detail.route]=v[t.detail.route]}}O(c);const f=o.routes.find((e=>"BookingObjectPage"===e.name));f&&"layout"in f&&(u.defaultLayoutType=f.layout),i[s]=u,T(c,l,e,t,n,u,s)}return i}t.getPagesAndConfigs=E;class V4AppProvider extends r.AppProvider{constructor(e,t,n){const a=new i.AppSettings,r=t[d.getSchemaFilePath(h.SchemaType.Application).filename];var o;f.transferSettingsOfObject(a,e,r.definitions.AppSettings,"",[]),super(e,t,function(e){let t;for(const n of e.routes){if(n.pattern.startsWith(":?query:")){t=n;break}-1!==n.pattern.indexOf("/")||(t=n)}return P(t?t.target:e.routes[0].target)}(e[u.ManifestSection.ui5].routing),E(e,t,n),p.FioriElementsVersion.v4,Object.assign(Object.assign({},(o=e[u.ManifestSection.ui5].routing).config&&o.config.flexibleColumnLayout?{flexibleColumnLayout:o.config.flexibleColumnLayout}:void 0),a),n),this.unhandledControllers=y}}t.V4AppProvider=V4AppProvider,t.getPages=function(e,t){const n=e[u.ManifestSection.ui5].routing,a={};for(const e in n.targets){const r=n.targets[e];r.name===t&&(a[e]=r)}return a}},3517:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(3381)),a(n(8548)),a(n(1168))},1168:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(6971),i=n(5877),o=n(5008),s=n(3381),c=n(5921),l=a(n(9154)),u=n(2449),p=n(5709);t.createAnalyticalListPageConfig=function(e){if(u.initI18n(),!e.manifest[i.ManifestSection.ui5]||!e.manifest[i.ManifestSection.ui5].routing)return void c.log(e.logger,{severity:"error",message:l.default.t("NOROUTING"),location:{path:o.MANIFESTPATH,range:[i.ManifestSection.ui5]}});const t=e.manifest[i.ManifestSection.ui5].routing.targets;if(!t)return void c.log(e.logger,{severity:"error",message:l.default.t("NOTARGETS"),location:{path:o.MANIFESTPATH,range:[i.ManifestSection.ui5,"routing"]}});const n=new p.MetadataInstanceFactoryV4,a=n.createPageInstance(r.PageTypeV4.AnalyticalListPage);return Object.keys(t).forEach((i=>{const c=t[i];"name"in c&&o.getPageTypeV4(c.name)===r.PageTypeV4.AnalyticalListPage&&s.addSettings(e,a,n,c,r.PageTypeV4.AnalyticalListPage)})),a}},3381:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(6971),i=n(5877),o=n(5008),s=n(1491),c=n(2449),l=a(n(9154)),u=n(5921),p=n(5709);function f(e,t,n,a,r){if(s.transferSettingsOfObject(t,e.manifest,e.jsonSchema,a.id,[]),t.table=n.createInstance(r,"Table"),s.transferSettingsOfObject(t.table,e.manifest,e.jsonSchema.definitions.Table,a.id,[]),t.table.toolBar=n.createInstance(r,"ToolBar",{actions:{}}),s.transferSettingsOfObject(t.table.toolBar,e.manifest,e.jsonSchema.definitions[o.TOOLBAR],a.id,[]),e.jsonSchema.definitions["Actions<LineItems>"])for(const i in e.jsonSchema.definitions["Actions<LineItems>"].properties){t.table.toolBar.actions[i]=n.createInstance(r,"ToolBarAction");const o=i.split("DataFieldForAction::")[1];s.transferSettingsOfObject(t.table.toolBar.actions[i],e.manifest,e.jsonSchema.definitions[`ToolBarAction<${o}>`],a.id,[i]),0===Object.keys(t.table.toolBar.actions[i]).length&&delete t.table.toolBar.actions[i]}if(t.filterBar=n.createInstance(r,"FilterBar"),s.transferSettingsOfObject(t.filterBar,e.manifest,e.jsonSchema.definitions.FilterBar,a.id,[]),t.table.columns={},e.jsonSchema.definitions.LineItems){for(const i in e.jsonSchema.definitions.LineItems.properties){e.jsonSchema.definitions.LineItems.properties[i].template||(t.table.columns[i]=n.createInstance(r,"TableColumn"),s.transferSettingsOfObject(t.table.columns[i],e.manifest,e.jsonSchema.definitions.TableColumn,a.id,[i]),0===Object.keys(t.table.columns[i]).length&&delete t.table.columns[i])}return t}u.log(e.logger,{severity:"error",message:l.default.t("NOLINEITEMS")})}t.addSettings=f,t.createListReportConfig=function(e){if(c.initI18n(),!e.manifest[i.ManifestSection.ui5]||!e.manifest[i.ManifestSection.ui5].routing)return void u.log(e.logger,{severity:"error",message:l.default.t("NOROUTING"),location:{path:o.MANIFESTPATH,range:[i.ManifestSection.ui5]}});const t=e.manifest[i.ManifestSection.ui5].routing.targets;if(!t)return void u.log(e.logger,{severity:"error",message:l.default.t("NOTARGETS"),location:{path:o.MANIFESTPATH,range:[i.ManifestSection.ui5]}});const n=new p.MetadataInstanceFactoryV4,a=n.createPageInstance(r.PageTypeV4.ListReport);return Object.keys(t).forEach((i=>{const s=t[i];"name"in s&&o.getPageTypeV4(s.name)===r.PageTypeV4.ListReport&&f(e,a,n,s,r.PageTypeV4.ListReport)})),a}},8548:function(e,t,n){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=n(5877),i=n(6971),o=n(1491),s=n(5008),c=a(n(9154)),l=n(5921),u=n(2449),p=n(5709);function f(e,t,n,a,r,s){const c=a.replace(/::/g,"/"),l=t.controlConfiguration[c];if(l&&l.tableSettings){n[a]={},n[a].table=r.createInstance(i.PageTypeV4.ObjectPage,"ObjectPageTable");const t="ObjectPageTable<"+a+">";o.transferSettingsOfObject(n[a].table,e.manifest,e.jsonSchema.definitions[t],s.id,[],c),n[a].table.toolBar=r.createInstance(i.PageTypeV4.ObjectPage,"ToolBar",{actions:{}}),function(e,t,n,a,r){if(e.jsonSchema.definitions[`Actions<${t}>`]){const s=t.replace(/::/g,"/");for(const c in e.jsonSchema.definitions[`Actions<${t}>`].properties){n[t].table.toolBar.actions[c]=a.createInstance(i.PageTypeV4.ObjectPage,"ObjectPageToolBarAction");const l=c.split("DataFieldForAction::")[1];o.transferSettingsOfObject(n[t].table.toolBar.actions[c],e.manifest,e.jsonSchema.definitions[`ObjectPageToolBarAction<${l}>`],r.id,[c],s),0===Object.keys(n[t].table.toolBar.actions[c]).length&&delete n[t].table.toolBar.actions[c]}}}(e,a,n,r,s),function(e,t,n,a,r,s){if(t.columns){n[a].table.columns={};const c=a.replace(/::/g,"/");for(const l in t.columns)t.columns[l].template||(n[a].table.columns[l]=r.createInstance(i.PageTypeV4.ObjectPage,"ObjectPageTableColumn"),o.transferSettingsOfObject(n[a].table.columns[l],e.manifest,e.jsonSchema.definitions.ObjectPageTableColumn,s.id,[l],c))}}(e,l,n,a,r,s)}}function d(e,t,n,a,r,i){for(const o in t){const c=t[o];c.$ref&&c.$ref.startsWith(s.DEFINITION_LINK_PREFIX+"ObjectPageSectionTableV4")?f(e,n,a,o,r,i):c.properties&&c.properties.subsections&&(a[o]={subsections:{}},d(e,c.properties.subsections.properties,n,a[o].subsections,r,i))}}function h(e,t,n){var a,r;const c=n.createPageInstance(i.PageTypeV4.ObjectPage),l=t.options&&t.options.settings;if(c.header=n.createInstance(i.PageTypeV4.ObjectPage,"ObjectPageHeader"),o.transferSettingsOfObject(c.header,e.manifest,e.jsonSchema.definitions.ObjectPageHeader,t.id,[]),c.layout=n.createInstance(i.PageTypeV4.ObjectPage,"ObjectPageLayout"),o.transferSettingsOfObject(c.layout,e.manifest,e.jsonSchema.definitions.ObjectPageLayout,t.id,[]),o.transferSettingsOfObject(c,e.manifest,e.jsonSchema,t.id,[]),c.sections||(c.sections={}),l){l.controlConfiguration&&e.jsonSchema.definitions.Sections&&(c.sections={},d(e,e.jsonSchema.definitions.Sections.properties,l,c.sections,n,t));const u=null===(r=null===(a=l.content)||void 0===a?void 0:a.body)||void 0===r?void 0:r.sections;if(u){c.sections.custom=[];for(const a in u){const r=n.createInstance(i.PageTypeV4.ObjectPage,"ObjectPageCustomSectionFragment");o.transferSettingsOfObject(r,e.manifest,e.jsonSchema.definitions.ObjectPageCustomSectionFragment,t.id,[],a),c.sections.custom.push(r)}}!function(e,t,n,a,r){var c,l;const u=e.definitions.HeaderSections;if(u&&u.properties){t.header.sections={};for(const p in u.properties){const f=null===(c=u.properties[p].$ref)||void 0===c?void 0:c.split(s.DEFINITION_LINK_PREFIX)[1],d=f?e.definitions[f]:u.properties[p],h=f?f.split("<")[0]:void 0;t.header.sections[p]=h?n.createInstance(i.PageTypeV4.ObjectPage,h):{},o.transferSettingsOfObject(t.header.sections[p],a,d,r.id,[],null===(l=null==d?void 0:d.title)||void 0===l?void 0:l.split(s.FacetTitlePrefix)[1])}}}(e.jsonSchema,c,n,e.manifest,t)}return c}t.createObjectPageConfigV4=function(e){if(u.initI18n(),!e.manifest[r.ManifestSection.ui5]||!e.manifest[r.ManifestSection.ui5].routing)return void l.log(e.logger,{severity:"error",message:c.default.t("NOROUTING"),location:{path:s.MANIFESTPATH,range:[r.ManifestSection.ui5]}});const t=e.manifest[r.ManifestSection.ui5].routing.targets;if(!t)return void l.log(e.logger,{severity:"error",message:c.default.t("NOTARGETS"),location:{path:s.MANIFESTPATH,range:[r.ManifestSection.ui5,"routing"]}});const n=t[e.routingId];return n?h(e,n,new p.MetadataInstanceFactoryV4):void l.log(e.logger,{severity:"error",message:c.default.t("NOROUTINGID",{routingId:e.routingId}),location:{path:s.MANIFESTPATH,range:[r.ManifestSection.ui5,"routing"]}})}},1491:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(5008),r=n(2762),i=n(5008);t.transferSettingsOfObject=function(e,t,n,o,s,c,l){if(!n)return;let u={};const p=e.getDeprecated?e.getDeprecated():[],f=c&&c.replace("/","::");for(const d in n.properties){const n=r.getReflectMetadata(e,d);if(null==n?void 0:n.manifest){const r=n.manifest.path([o],t,f,s[0]);u=i.getManifestSectionByPathV4(t,r,c,f),a.importProperty(n,u,d,e,c),i.checkDeprecatedProperties(p,u,r,l)}}}},1162:(e,t)=>{"use strict";function n(e){if("string"==typeof e){if(e.indexOf(" ")>=0)throw e+" - Spaces are not allowed in ID parts.";for(e=e.replace(/^\/|^@|^#|^\*/,"").replace(/\/$|@$|#$|\*$/,"").replace(/\/|@|\(|\)|#|\*/g,"::");e.indexOf("::::")>-1;)e=e.replace("::::","::");return"::"===e.slice(-2)&&(e=e.slice(0,-2)),e}}function a(e){var t,a;if((null==e?void 0:e.$Path)||(null==e?void 0:e.path))return e.$Path||e.path;if((null==e?void 0:e.$Apply)&&"odata.concat"===e.$Function){let t="";for(let n=0;n<e.$Apply.length;n++)e.$Apply[n].$Path&&(t&&(t+="::"),t+=e.$Apply[n].$Path);return t}return e?n("string"==typeof e?e.replace(/ /g,"_"):null===(a=null===(t=null==e?void 0:e.value)||void 0===t?void 0:t.String)||void 0===a?void 0:a.replace(/ /g,"_")):void 0}Object.defineProperty(t,"__esModule",{value:!0}),t.replaceSpecialChars=n,t.prepareId=function(e){if(e=n(function(e){return(e=e.replace("com.sap.vocabularies.UI.v1.","")).replace("com.sap.vocabularies.Communication.v1.","")}(e)),/^([A-Za-z_][-A-Za-z0-9_.:]*)$/.test(e))return e;throw e+" - Stable Id could not be generated due to insufficient information."},t.getStableIdPartFromSemanticObjectAndAction=function(e){let t="";return"string"==typeof e.SemanticObject?t+=e.SemanticObject:e.SemanticObject.$Path&&(t+=e.SemanticObject.$Path),"string"==typeof e.Action?t+="::"+e.Action:e.Action&&e.Action.$Path&&(t+="::"+e.Action.$Path),e.RequiresContext&&1==e.RequiresContext&&(t+="::RequiresContext"),t},t.getStableIdPartFromDataField=function(e){let n="";return e.$Type&&"com.sap.vocabularies.UI.v1.DataFieldForAction"===e.$Type?(n="DataFieldForAction::",n+=e.Action,t.prepareId(n)):e.$Type&&"com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation"===e.$Type?(n="DataFieldForIntentBasedNavigation::",n+=t.getStableIdPartFromSemanticObjectAndAction(e),n):e.$Type&&"com.sap.vocabularies.UI.v1.DataFieldForAnnotation"===e.$Type?(n="DataFieldForAnnotation::",n+=t.prepareId(e.Target.$AnnotationPath||e.Target.value),n):e.$Type&&"com.sap.vocabularies.UI.v1.DataFieldWithAction"===e.$Type?(n="DataFieldWithAction::",e.Value&&(n+=a(e.Value)+"::"),n+=e.Action,t.prepareId(n)):e.$Type&&"com.sap.vocabularies.UI.v1.DataField"===e.$Type?(n="DataField::",n+=a(e.Value),t.prepareId(n)):e.$Type&&"com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation"===e.$Type?(n="DataFieldWithIntentBasedNavigation::",n+=a(e.Value)+"::",n+=t.getStableIdPartFromSemanticObjectAndAction(e),t.prepareId(n)):e.$Type&&"com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath"===e.$Type?(n="DataFieldWithNavigationPath::",n+=a(e.Value),e.Target&&e.Target.$NavigationPropertyPath&&(n+="::"+e.Target.$NavigationPropertyPath),t.prepareId(n)):e.$Type&&"com.sap.vocabularies.UI.v1.DataFieldWithUrl"===e.$Type?(n="DataFieldWithUrl::",n+=a(e.Value),t.prepareId(n)):void 0}},9190:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=n(9081),r=n(1162),i=n(5008);function o(e,t,n,r,o,s,c){if(!0!==o.Determining){const l="LineItems"===s?"ToolBarAction":"ObjectPageToolBarAction",u=i.prepareRef(`${l}<${o.Action}>`),p=a.getDatafieldDescription(o,t);n.properties[`DataFieldForAction::${o.Action}`]={$ref:a.DEFINITION_LINK_PREFIX+u,description:p,propertyIndex:c,annotationType:o.$Type};const f="LineItems"===s?"ToolBarAction":"ObjectPageToolBarAction";e.definitions[u]=JSON.parse(JSON.stringify(e.definitions[f])),e.definitions[u].annotationPath=r+"/"+c}}t.handleActionRecord=o,t.addLineItemsType=function(e,t,n,s,c,l){e.definitions[c]=JSON.parse(JSON.stringify(e.definitions.GenericColumns.additionalProperties.anyOf[0])),l=l||"LineItems";const{actions:u,lineItemPath:p}=i.addCommonLineItemDefinitions(e,t,n,l);if(t){let f=0;t.forEach((t=>{if("com.sap.vocabularies.UI.v1.DataFieldForAction"!==t.$Type||!0===t.Inline&&!0!==t.Determining){!function(e,t,n,o,s,c){var l,u;const p=e.lineItemId,f=e.lineItemRecord,d=e.lineItemPath;if(f.Target&&f.Target.value){const e=`@${a.findAlias(i.UIVOCABULARY,c)}.`;f.Target.value=f.Target.value.replace(e,"@")}const h=r.getStableIdPartFromDataField(f);h&&(t.definitions[p].properties[h]={$ref:a.DEFINITION_LINK_PREFIX+n,description:a.getDatafieldDescription(f,o),propertyIndex:s,annotationPath:`${d}/${s}`,annotationType:null==f?void 0:f.$Type},"com.sap.vocabularies.UI.v1.DataField"===f.$Type&&(t.definitions[p].properties[h].dataType=null===(u=null===(l=f.Value)||void 0===l?void 0:l.$target)||void 0===u?void 0:u.type.replace("Edm.","")))}({lineItemRecord:t,lineItemId:l,lineItemPath:p},e,c,n,f,s)}else o(e,n,u,p,t,l,f);f++}))}}},3374:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(4027)),a(n(390))},6739:(e,t,n)=>{"use strict";function a(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),a(n(4027)),a(n(5877))},2892:e=>{"use strict";e.exports={}},6354:e=>{"use strict";e.exports=JSON.parse('{"NOPAGES":"No pages found in manifest for app with id \'{{- appId}}\'","NOFE":"The manifest passed is not correct for Fiori Elements V2: section sap.ui.generic.app is missing","NOENTITYSET":"No page found in manifest for entitySet \'{{- entitySet}}\'","NOENTITYSET4NAME":"No entitySet could be found for the given entity type \'{{- entityType}}\'","ENTITYSETNOTFOUND":"Entity set \'{{- entitySetName}}\' was specified in manifest, but this entity set could not be found in metadata","NOLR":"No page found in manifest for list report","NOALP":"No page found in manifest for analytical list page","NOTEMPLATE":"No Fiori Elements template could be determined, as section \'{{- section}}\' is not defined in manifest","ANNOERR":"Error while parsing annotation files","NOROUTING":"Incomplete manifest definition: no routing defined","NOLINEITEMS":"UI.LineItem annotation has not been defined","NOTARGETS":"Incomplete manifest definition: no targets defined","NOTARGET":"Invalid reference: annotation target \'{{- target}}\' not found","NOROUTINGID":"No page found in manifest for routingId \'{{- routingId}}\'","FLEXERROR":"Error while parsing flex change","NOFRAGMENT":"fragmentName is undefined for columnKey \'{{- columnKey}}\'","NOENTITYTYPE":"Entity type \'{{- entityType}}\' is specified in manifest, but not present in metadata","INVALIDTARGETDEFINITION":"Invalid routing target definition in manifest: \'{{- target}}\'","NOID4SECTION":"No ID has been defined for a facet or header facet. As a consequence, manifest settings cannot be written correctly for this element in an OData V4 scenario: \'{{- facet}}\'"}')},2357:e=>{"use strict";e.exports=__webpack_require__(39491)},4293:e=>{"use strict";e.exports=__webpack_require__(14300)},7619:e=>{"use strict";e.exports=__webpack_require__(22057)},8614:e=>{"use strict";e.exports=__webpack_require__(82361)},5747:e=>{"use strict";e.exports=__webpack_require__(57147)},2087:e=>{"use strict";e.exports=__webpack_require__(22037)},5622:e=>{"use strict";e.exports=__webpack_require__(71017)},2413:e=>{"use strict";e.exports=__webpack_require__(12781)},4304:e=>{"use strict";e.exports=__webpack_require__(71576)},1669:e=>{"use strict";e.exports=__webpack_require__(73837)}},t={};function n(a){var r=t[a];if(void 0!==r)return r.exports;var i=t[a]={exports:{}};return e[a].call(i.exports,i,i.exports,n),i.exports}n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var a=n(4027);module.exports=a})();

/***/ }),

/***/ 25791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @module @ui5/logger
 * @private
 */
module.exports = __webpack_require__(28658);


/***/ }),

/***/ 28658:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const npmlog = __webpack_require__(61457);

const levels = ["silly", "verbose", "info", "warn", "error", "silent"];
if (process.env.UI5_LOG_LVL) {
	const logLvl = process.env.UI5_LOG_LVL;
	if (!levels.includes(logLvl)) {
		throw new Error(`UI5 Logger: Environment variable UI5_LOG_LVL is set to an unknown log level "${logLvl}". ` +
			`Valid levels are ${levels.join(", ")}`);
	}
	npmlog.level = logLvl;
} else {
	npmlog.level = "info"; // Our default
}

npmlog.enableUnicode();

npmlog.on("error", (err) => {
	console.log(err);
});

function isLevelEnabled(levelName) {
	const currIdx = levels.indexOf(npmlog.level);
	const reqIdx = levels.indexOf(levelName);
	if (currIdx === -1) {
		throw new Error(`Failed to find current log level "${npmlog.level}" in list of expected log levels`);
	}
	if (reqIdx === -1) {
		throw new Error(`Unknown log level "${levelName}"`);
	}
	if (reqIdx >= currIdx) {
		return true;
	} else {
		return false;
	}
}

class Logger {
	constructor(moduleName) {
		this._moduleName = moduleName;
		this._logger = npmlog;
	}

	isLevelEnabled(levelName) {
		return logger.isLevelEnabled(levelName);
	}

	silly(...messages) {
		return this._logger.silly(this._moduleName, ...messages);
	}

	verbose(...messages) {
		return this._logger.verbose(this._moduleName, ...messages);
	}

	info(...messages) {
		return this._logger.info(this._moduleName, ...messages);
	}

	warn(...messages) {
		return this._logger.warn(this._moduleName, ...messages);
	}

	error(...messages) {
		return this._logger.error(this._moduleName, ...messages);
	}

	_getLogger() {
		return this._logger;
	}
}

class GroupLogger extends Logger {
	constructor(moduleName, weight = 0, parentLogger) {
		super(moduleName);

		if (parentLogger) {
			this._logger = parentLogger._getLogger().newGroup("", weight);
		} else {
			this._logger = npmlog.newGroup("", weight);
		}
	}

	createSubLogger(name, weight) {
		return new GroupLogger(this._moduleName + " " + name, weight, this);
	}

	createTaskLogger(name, todo, weight) {
		return new TaskLogger(this._moduleName + " " + name, todo, weight, this);
	}
}


class TaskLogger extends Logger {
	constructor(moduleName, todo, weight, parentLogger) {
		super(moduleName);
		this._todo = todo || 0;
		this._completed = 0;

		if (parentLogger) {
			this._logger = parentLogger._getLogger().newItem("", todo, weight);
		} else {
			this._logger = npmlog.newItem(this._moduleName, todo, weight);
		}
	}

	addWork(todo) {
		this._logger.addWork(todo);
		this._todo += todo;
	}

	startWork(...messages) {
		// Current job number is completed + 1
		this.info(`(${this._completed + 1}/${this._todo})`, ...messages);
	}

	completeWork(completed) {
		this._completed += completed;
		this._logger.completeWork(completed);
	}

	finish() {
		return this._logger.finish();
	}
}

const logger = {
	getLogger: function(moduleName) {
		return new Logger(moduleName);
	},

	getGroupLogger: function(moduleName) {
		return new GroupLogger(moduleName);
	},

	setLevel(level) {
		if (!levels.includes(level)) {
			throw new Error(`Unknown log level "${level}"`);
		}
		return npmlog.level = level;
	},

	isLevelEnabled,

	setShowProgress(showProgress) {
		if (showProgress) {
			npmlog.enableProgress();
		} else {
			npmlog.disableProgress();
		}
	},
};

// Export internal classes for testing only
if (false) {}

module.exports = logger;


/***/ }),

/***/ 36403:
/***/ ((module) => {

"use strict";


module.exports = ({onlyFirst = false} = {}) => {
	const pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
};


/***/ }),

/***/ 29237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = __webpack_require__(3695);
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});


/***/ }),

/***/ 18142:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = __webpack_require__(49897);

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}

convert.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ 3695:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(18142);
const route = __webpack_require__(6469);

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ 6469:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(18142);

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ 99519:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DiagChannel = __webpack_require__(55332);
var AutoCollectConsole = (function () {
    function AutoCollectConsole(client) {
        if (!!AutoCollectConsole.INSTANCE) {
            throw new Error("Console logging adapter tracking should be configured from the applicationInsights object");
        }
        this._client = client;
        AutoCollectConsole.INSTANCE = this;
    }
    AutoCollectConsole.prototype.enable = function (isEnabled, collectConsoleLog) {
        if (DiagChannel.IsInitialized) {
            (__webpack_require__(55985)/* .enable */ .w)(isEnabled && collectConsoleLog, this._client);
            (__webpack_require__(58043)/* .enable */ .w)(isEnabled, this._client);
            (__webpack_require__(89393)/* .enable */ .w)(isEnabled, this._client);
        }
    };
    AutoCollectConsole.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    AutoCollectConsole.prototype.dispose = function () {
        AutoCollectConsole.INSTANCE = null;
        this.enable(false, false);
    };
    AutoCollectConsole._methodNames = ["debug", "info", "log", "warn", "error"];
    return AutoCollectConsole;
}());
module.exports = AutoCollectConsole;


/***/ }),

/***/ 77023:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Logging = __webpack_require__(579);
var DiagChannel = __webpack_require__(55332);
var CorrelationContextManager = (function () {
    function CorrelationContextManager() {
    }
    /**
     *  Provides the current Context.
     *  The context is the most recent one entered into for the current
     *  logical chain of execution, including across asynchronous calls.
     */
    CorrelationContextManager.getCurrentContext = function () {
        if (!CorrelationContextManager.enabled) {
            return null;
        }
        var context = CorrelationContextManager.session.get(CorrelationContextManager.CONTEXT_NAME);
        if (context === undefined) {
            return null;
        }
        return context;
    };
    /**
     *  A helper to generate objects conforming to the CorrelationContext interface
     */
    CorrelationContextManager.generateContextObject = function (operationId, parentId, operationName, correlationContextHeader, traceparent, tracestate) {
        parentId = parentId || operationId;
        if (this.enabled) {
            return {
                operation: {
                    name: operationName,
                    id: operationId,
                    parentId: parentId,
                    traceparent: traceparent,
                    tracestate: tracestate
                },
                customProperties: new CustomPropertiesImpl(correlationContextHeader)
            };
        }
        return null;
    };
    /**
     *  Runs a function inside a given Context.
     *  All logical children of the execution path that entered this Context
     *  will receive this Context object on calls to GetCurrentContext.
     */
    CorrelationContextManager.runWithContext = function (context, fn) {
        if (CorrelationContextManager.enabled) {
            return CorrelationContextManager.session.bind(fn, (_a = {}, _a[CorrelationContextManager.CONTEXT_NAME] = context, _a))();
        }
        else {
            return fn();
        }
        var _a;
    };
    /**
     * Wrapper for cls-hooked bindEmitter method
     */
    CorrelationContextManager.wrapEmitter = function (emitter) {
        if (CorrelationContextManager.enabled) {
            CorrelationContextManager.session.bindEmitter(emitter);
        }
    };
    /**
     *  Patches a callback to restore the correct Context when getCurrentContext
     *  is run within it. This is necessary if automatic correlation fails to work
     *  with user-included libraries.
     *
     *  The supplied callback will be given the same context that was present for
     *  the call to wrapCallback.  */
    CorrelationContextManager.wrapCallback = function (fn) {
        if (CorrelationContextManager.enabled) {
            return CorrelationContextManager.session.bind(fn);
        }
        return fn;
    };
    /**
     *  Enables the CorrelationContextManager.
     */
    CorrelationContextManager.enable = function (forceClsHooked) {
        if (this.enabled) {
            return;
        }
        if (!this.isNodeVersionCompatible()) {
            this.enabled = false;
            return;
        }
        if (!CorrelationContextManager.hasEverEnabled) {
            this.forceClsHooked = forceClsHooked;
            this.hasEverEnabled = true;
            if (typeof this.cls === "undefined") {
                if ((CorrelationContextManager.forceClsHooked === true) || (CorrelationContextManager.forceClsHooked === undefined && CorrelationContextManager.shouldUseClsHooked())) {
                    this.cls = __webpack_require__(48546);
                }
                else {
                    this.cls = __webpack_require__(59106);
                }
            }
            CorrelationContextManager.session = this.cls.createNamespace("AI-CLS-Session");
            DiagChannel.registerContextPreservation(function (cb) {
                return CorrelationContextManager.session.bind(cb);
            });
        }
        this.enabled = true;
    };
    /**
     *  Disables the CorrelationContextManager.
     */
    CorrelationContextManager.disable = function () {
        this.enabled = false;
    };
    /**
     * Reset the namespace
     */
    CorrelationContextManager.reset = function () {
        if (CorrelationContextManager.hasEverEnabled) {
            CorrelationContextManager.session = null;
            CorrelationContextManager.session = this.cls.createNamespace('AI-CLS-Session');
        }
    };
    /**
     *  Reports if CorrelationContextManager is able to run in this environment
     */
    CorrelationContextManager.isNodeVersionCompatible = function () {
        var nodeVer = process.versions.node.split(".");
        return parseInt(nodeVer[0]) > 3 || (parseInt(nodeVer[0]) > 2 && parseInt(nodeVer[1]) > 2);
    };
    /**
     * We only want to use cls-hooked when it uses async_hooks api (8.2+), else
     * use async-listener (plain -cls)
     */
    CorrelationContextManager.shouldUseClsHooked = function () {
        var nodeVer = process.versions.node.split(".");
        return (parseInt(nodeVer[0]) > 8) || (parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 2);
    };
    /**
     * A TypeError is triggered by cls-hooked for node [8.0, 8.2)
     * @internal Used in tests only
     */
    CorrelationContextManager.canUseClsHooked = function () {
        var nodeVer = process.versions.node.split(".");
        var greater800 = (parseInt(nodeVer[0]) > 8) || (parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 0);
        var less820 = (parseInt(nodeVer[0]) < 8) || (parseInt(nodeVer[0]) <= 8 && parseInt(nodeVer[1]) < 2);
        var greater470 = parseInt(nodeVer[0]) > 4 || (parseInt(nodeVer[0]) >= 4 && parseInt(nodeVer[1]) >= 7); // cls-hooked requires node 4.7+
        return !(greater800 && less820) && greater470;
    };
    CorrelationContextManager.enabled = false;
    CorrelationContextManager.hasEverEnabled = false;
    CorrelationContextManager.forceClsHooked = undefined; // true: use cls-hooked, false: use cls, undefined: choose based on node version
    CorrelationContextManager.CONTEXT_NAME = "ApplicationInsights-Context";
    return CorrelationContextManager;
}());
exports.CorrelationContextManager = CorrelationContextManager;
var CustomPropertiesImpl = (function () {
    function CustomPropertiesImpl(header) {
        this.props = [];
        this.addHeaderData(header);
    }
    CustomPropertiesImpl.prototype.addHeaderData = function (header) {
        var keyvals = header ? header.split(", ") : [];
        this.props = keyvals.map(function (keyval) {
            var parts = keyval.split("=");
            return { key: parts[0], value: parts[1] };
        }).concat(this.props);
    };
    CustomPropertiesImpl.prototype.serializeToHeader = function () {
        return this.props.map(function (keyval) {
            return keyval.key + "=" + keyval.value;
        }).join(", ");
    };
    CustomPropertiesImpl.prototype.getProperty = function (prop) {
        for (var i = 0; i < this.props.length; ++i) {
            var keyval = this.props[i];
            if (keyval.key === prop) {
                return keyval.value;
            }
        }
        return;
    };
    // TODO: Strictly according to the spec, properties which are recieved from
    // an incoming request should be left untouched, while we may add our own new
    // properties. The logic here will need to change to track that.
    CustomPropertiesImpl.prototype.setProperty = function (prop, val) {
        if (CustomPropertiesImpl.bannedCharacters.test(prop) || CustomPropertiesImpl.bannedCharacters.test(val)) {
            Logging.warn("Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: " + prop + " and value: " + val);
            return;
        }
        for (var i = 0; i < this.props.length; ++i) {
            var keyval = this.props[i];
            if (keyval.key === prop) {
                keyval.value = val;
                return;
            }
        }
        this.props.push({ key: prop, value: val });
    };
    CustomPropertiesImpl.bannedCharacters = /[,=]/;
    return CustomPropertiesImpl;
}());


/***/ }),

/***/ 23414:
/***/ ((module) => {

"use strict";

var AutoCollectExceptions = (function () {
    function AutoCollectExceptions(client) {
        if (!!AutoCollectExceptions.INSTANCE) {
            throw new Error("Exception tracking should be configured from the applicationInsights object");
        }
        AutoCollectExceptions.INSTANCE = this;
        this._client = client;
    }
    Object.defineProperty(AutoCollectExceptions, "UNCAUGHT_EXCEPTION_HANDLER_NAME", {
        get: function () { return "uncaughtException"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCollectExceptions, "UNHANDLED_REJECTION_HANDLER_NAME", {
        get: function () { return "unhandledRejection"; },
        enumerable: true,
        configurable: true
    });
    AutoCollectExceptions.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    AutoCollectExceptions.prototype.enable = function (isEnabled) {
        var _this = this;
        if (isEnabled) {
            this._isInitialized = true;
            var self = this;
            if (!this._exceptionListenerHandle) {
                var handle = function (reThrow, error) {
                    _this._client.trackException({ exception: error });
                    _this._client.flush({ isAppCrashing: true });
                    if (reThrow) {
                        var THIS_IS_APPLICATION_INSIGHTS_RETHROWING_YOUR_EXCEPTION = error;
                        throw THIS_IS_APPLICATION_INSIGHTS_RETHROWING_YOUR_EXCEPTION; // Error originated somewhere else in your app
                    }
                };
                this._exceptionListenerHandle = handle.bind(this, true);
                this._rejectionListenerHandle = handle.bind(this, false);
                process.on(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);
                process.on(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);
            }
        }
        else {
            if (this._exceptionListenerHandle) {
                process.removeListener(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);
                process.removeListener(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);
                this._exceptionListenerHandle = undefined;
                this._rejectionListenerHandle = undefined;
                delete this._exceptionListenerHandle;
                delete this._rejectionListenerHandle;
            }
        }
    };
    AutoCollectExceptions.prototype.dispose = function () {
        AutoCollectExceptions.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
    };
    AutoCollectExceptions.INSTANCE = null;
    return AutoCollectExceptions;
}());
module.exports = AutoCollectExceptions;


/***/ }),

/***/ 12992:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var http = __webpack_require__(13685);
var https = __webpack_require__(95687);
var Logging = __webpack_require__(579);
var Util = __webpack_require__(8928);
var RequestResponseHeaders = __webpack_require__(99181);
var HttpDependencyParser = __webpack_require__(14769);
var CorrelationContextManager_1 = __webpack_require__(77023);
var CorrelationIdManager = __webpack_require__(74686);
var Traceparent = __webpack_require__(29337);
var DiagChannel = __webpack_require__(55332);
var AutoCollectHttpDependencies = (function () {
    function AutoCollectHttpDependencies(client) {
        if (!!AutoCollectHttpDependencies.INSTANCE) {
            throw new Error("Client request tracking should be configured from the applicationInsights object");
        }
        AutoCollectHttpDependencies.INSTANCE = this;
        this._client = client;
    }
    AutoCollectHttpDependencies.prototype.enable = function (isEnabled) {
        this._isEnabled = isEnabled;
        if (this._isEnabled && !this._isInitialized) {
            this._initialize();
        }
        if (DiagChannel.IsInitialized) {
            (__webpack_require__(64668)/* .enable */ .wp)(isEnabled, this._client);
            (__webpack_require__(10691)/* .enable */ .wp)(isEnabled, this._client);
            (__webpack_require__(37998)/* .enable */ .wp)(isEnabled, this._client);
            (__webpack_require__(5556)/* .enable */ .wp)(isEnabled, this._client);
        }
    };
    AutoCollectHttpDependencies.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    AutoCollectHttpDependencies.prototype._initialize = function () {
        var _this = this;
        this._isInitialized = true;
        var originalGet = http.get;
        var originalRequest = http.request;
        var originalHttpsRequest = https.request;
        var clientRequestPatch = function (request, options) {
            var shouldCollect = !options[AutoCollectHttpDependencies.disableCollectionRequestOption] &&
                !request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag];
            request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag] = true;
            if (request && options && shouldCollect) {
                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);
                AutoCollectHttpDependencies.trackRequest(_this._client, { options: options, request: request });
            }
        };
        // On node >= v0.11.12 and < 9.0 (excluding 8.9.0) https.request just calls http.request (with additional options).
        // On node < 0.11.12, 8.9.0, and 9.0 > https.request is handled separately
        // Patch both and leave a flag to not double-count on versions that just call through
        // We add the flag to both http and https to protect against strange double collection in other scenarios
        http.request = function (options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                requestArgs[_i - 1] = arguments[_i];
            }
            var request = originalRequest.call.apply(originalRequest, [http, options].concat(requestArgs));
            clientRequestPatch(request, options);
            return request;
        };
        https.request = function (options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                requestArgs[_i - 1] = arguments[_i];
            }
            var request = originalHttpsRequest.call.apply(originalHttpsRequest, [https, options].concat(requestArgs));
            clientRequestPatch(request, options);
            return request;
        };
        // Node 8 calls http.request from http.get using a local reference!
        // We have to patch .get manually in this case and can't just assume request is enough
        // We have to replace the entire method in this case. We can't call the original.
        // This is because calling the original will give us no chance to set headers as it internally does .end().
        http.get = function (options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                requestArgs[_i - 1] = arguments[_i];
            }
            var request = (_a = http.request).call.apply(_a, [http, options].concat(requestArgs));
            request.end();
            return request;
            var _a;
        };
        https.get = function (options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                requestArgs[_i - 1] = arguments[_i];
            }
            var request = (_a = https.request).call.apply(_a, [https, options].concat(requestArgs));
            request.end();
            return request;
            var _a;
        };
    };
    /**
     * Tracks an outgoing request. Because it may set headers this method must be called before
     * writing content to or ending the request.
     */
    AutoCollectHttpDependencies.trackRequest = function (client, telemetry) {
        if (!telemetry.options || !telemetry.request || !client) {
            Logging.info("AutoCollectHttpDependencies.trackRequest was called with invalid parameters: ", !telemetry.options, !telemetry.request, !client);
            return;
        }
        var requestParser = new HttpDependencyParser(telemetry.options, telemetry.request);
        var currentContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        var uniqueRequestId;
        var uniqueTraceparent;
        if (currentContext && currentContext.operation && currentContext.operation.traceparent && Traceparent.isValidTraceId(currentContext.operation.traceparent.traceId)) {
            currentContext.operation.traceparent.updateSpanId();
            uniqueRequestId = currentContext.operation.traceparent.getBackCompatRequestId();
        }
        else if (CorrelationIdManager.w3cEnabled) {
            // Start an operation now so that we can include the w3c headers in the outgoing request
            var traceparent = new Traceparent();
            uniqueTraceparent = traceparent.toString();
            uniqueRequestId = traceparent.getBackCompatRequestId();
        }
        else {
            uniqueRequestId = currentContext && currentContext.operation && (currentContext.operation.parentId + AutoCollectHttpDependencies.requestNumber++ + '.');
        }
        // Add the source correlationId to the request headers, if a value was not already provided.
        // The getHeader/setHeader methods aren't available on very old Node versions, and
        // are not included in the v0.10 type declarations currently used. So check if the
        // methods exist before invoking them.
        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) && telemetry.request.getHeader && telemetry.request.setHeader) {
            if (client.config && client.config.correlationId) {
                // getHeader returns "any" type in newer versions of node. In basic scenarios, this will be <string | string[] | number>, but could be modified to anything else via middleware
                var correlationHeader = telemetry.request.getHeader(RequestResponseHeaders.requestContextHeader);
                try {
                    Util.safeIncludeCorrelationHeader(client, telemetry.request, correlationHeader);
                }
                catch (err) {
                    Logging.warn("Request-Context header could not be set. Correlation of requests may be lost", err);
                }
                if (currentContext && currentContext.operation) {
                    try {
                        telemetry.request.setHeader(RequestResponseHeaders.requestIdHeader, uniqueRequestId);
                        // Also set legacy headers
                        telemetry.request.setHeader(RequestResponseHeaders.parentIdHeader, currentContext.operation.id);
                        telemetry.request.setHeader(RequestResponseHeaders.rootIdHeader, uniqueRequestId);
                        // Set W3C headers, if available
                        if (uniqueTraceparent || currentContext.operation.traceparent) {
                            telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, uniqueTraceparent || currentContext.operation.traceparent.toString());
                        }
                        else if (CorrelationIdManager.w3cEnabled) {
                            // should never get here since we set uniqueTraceparent above for the w3cEnabled scenario
                            var traceparent = new Traceparent().toString();
                            telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, traceparent);
                        }
                        if (currentContext.operation.tracestate) {
                            var tracestate = currentContext.operation.tracestate.toString();
                            if (tracestate) {
                                telemetry.request.setHeader(RequestResponseHeaders.traceStateHeader, tracestate);
                            }
                        }
                        var correlationContextHeader = currentContext.customProperties.serializeToHeader();
                        if (correlationContextHeader) {
                            telemetry.request.setHeader(RequestResponseHeaders.correlationContextHeader, correlationContextHeader);
                        }
                    }
                    catch (err) {
                        Logging.warn("Correlation headers could not be set. Correlation of requests may be lost.", err);
                    }
                }
            }
        }
        // Collect dependency telemetry about the request when it finishes.
        if (telemetry.request.on) {
            telemetry.request.on('response', function (response) {
                requestParser.onResponse(response);
                var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
                dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};
                dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options;
                dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request;
                dependencyTelemetry.contextObjects["http.ClientResponse"] = response;
                client.trackDependency(dependencyTelemetry);
            });
            telemetry.request.on('error', function (e) {
                requestParser.onError(e);
                var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
                dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};
                dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options;
                dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request;
                dependencyTelemetry.contextObjects["Error"] = e;
                client.trackDependency(dependencyTelemetry);
            });
        }
    };
    AutoCollectHttpDependencies.prototype.dispose = function () {
        AutoCollectHttpDependencies.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
    };
    AutoCollectHttpDependencies.disableCollectionRequestOption = 'disableAppInsightsAutoCollection';
    AutoCollectHttpDependencies.requestNumber = 1;
    AutoCollectHttpDependencies.alreadyAutoCollectedFlag = '_appInsightsAutoCollected';
    return AutoCollectHttpDependencies;
}());
module.exports = AutoCollectHttpDependencies;


/***/ }),

/***/ 14769:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var url = __webpack_require__(57310);
var Contracts = __webpack_require__(22220);
var Util = __webpack_require__(8928);
var RequestResponseHeaders = __webpack_require__(99181);
var RequestParser = __webpack_require__(62796);
var CorrelationIdManager = __webpack_require__(74686);
/**
 * Helper class to read data from the requst/response objects and convert them into the telemetry contract
 */
var HttpDependencyParser = (function (_super) {
    __extends(HttpDependencyParser, _super);
    function HttpDependencyParser(requestOptions, request) {
        var _this = _super.call(this) || this;
        if (request && request.method && requestOptions) {
            // The ClientRequest.method property isn't documented, but is always there.
            _this.method = request.method;
            _this.url = HttpDependencyParser._getUrlFromRequestOptions(requestOptions, request);
            _this.startTime = +new Date();
        }
        return _this;
    }
    /**
     * Called when the ClientRequest emits an error event.
     */
    HttpDependencyParser.prototype.onError = function (error) {
        this._setStatus(undefined, error);
    };
    /**
     * Called when the ClientRequest emits a response event.
     */
    HttpDependencyParser.prototype.onResponse = function (response) {
        this._setStatus(response.statusCode, undefined);
        this.correlationId = Util.getCorrelationContextTarget(response, RequestResponseHeaders.requestContextTargetKey);
    };
    /**
     * Gets a dependency data contract object for a completed ClientRequest.
     */
    HttpDependencyParser.prototype.getDependencyTelemetry = function (baseTelemetry, dependencyId) {
        var urlObject = url.parse(this.url);
        urlObject.search = undefined;
        urlObject.hash = undefined;
        var dependencyName = this.method.toUpperCase() + " " + urlObject.pathname;
        var remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;
        var remoteDependencyTarget = urlObject.hostname;
        if (this.correlationId) {
            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_AI;
            if (this.correlationId !== CorrelationIdManager.correlationIdPrefix) {
                remoteDependencyTarget = urlObject.hostname + " | " + this.correlationId;
            }
        }
        else {
            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;
        }
        var dependencyTelemetry = {
            id: dependencyId,
            name: dependencyName,
            data: this.url,
            duration: this.duration,
            success: this._isSuccess(),
            resultCode: this.statusCode ? this.statusCode.toString() : null,
            properties: this.properties || {},
            dependencyTypeName: remoteDependencyType,
            target: remoteDependencyTarget
        };
        // We should keep any parameters the user passed in
        // Except the fields defined above in requestTelemetry, which take priority
        // Except the properties field, where they're merged instead, with baseTelemetry taking priority
        if (baseTelemetry) {
            // Copy missing fields
            for (var key in baseTelemetry) {
                if (!dependencyTelemetry[key]) {
                    dependencyTelemetry[key] = baseTelemetry[key];
                }
            }
            // Merge properties
            if (baseTelemetry.properties) {
                for (var key in baseTelemetry.properties) {
                    dependencyTelemetry.properties[key] = baseTelemetry.properties[key];
                }
            }
        }
        return dependencyTelemetry;
    };
    /**
     * Builds a URL from request options, using the same logic as http.request(). This is
     * necessary because a ClientRequest object does not expose a url property.
     */
    HttpDependencyParser._getUrlFromRequestOptions = function (options, request) {
        if (typeof options === 'string') {
            options = url.parse(options);
        }
        else {
            // Avoid modifying the original options object.
            var originalOptions_1 = options;
            options = {};
            if (originalOptions_1) {
                Object.keys(originalOptions_1).forEach(function (key) {
                    options[key] = originalOptions_1[key];
                });
            }
        }
        // Oddly, url.format ignores path and only uses pathname and search,
        // so create them from the path, if path was specified
        if (options.path) {
            var parsedQuery = url.parse(options.path);
            options.pathname = parsedQuery.pathname;
            options.search = parsedQuery.search;
        }
        // Simiarly, url.format ignores hostname and port if host is specified,
        // even if host doesn't have the port, but http.request does not work
        // this way. It will use the port if one is not specified in host,
        // effectively treating host as hostname, but will use the port specified
        // in host if it exists.
        if (options.host && options.port) {
            // Force a protocol so it will parse the host as the host, not path.
            // It is discarded and not used, so it doesn't matter if it doesn't match
            var parsedHost = url.parse("http://" + options.host);
            if (!parsedHost.port && options.port) {
                options.hostname = options.host;
                delete options.host;
            }
        }
        // Mix in default values used by http.request and others
        options.protocol = options.protocol || (request.agent && request.agent.protocol) || undefined;
        options.hostname = options.hostname || 'localhost';
        return url.format(options);
    };
    return HttpDependencyParser;
}(RequestParser));
module.exports = HttpDependencyParser;


/***/ }),

/***/ 58609:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var url = __webpack_require__(57310);
var Contracts = __webpack_require__(22220);
var Util = __webpack_require__(8928);
var RequestResponseHeaders = __webpack_require__(99181);
var RequestParser = __webpack_require__(62796);
var CorrelationIdManager = __webpack_require__(74686);
var Tracestate = __webpack_require__(91223);
var Traceparent = __webpack_require__(29337);
/**
 * Helper class to read data from the requst/response objects and convert them into the telemetry contract
 */
var HttpRequestParser = (function (_super) {
    __extends(HttpRequestParser, _super);
    function HttpRequestParser(request, requestId) {
        var _this = _super.call(this) || this;
        if (request) {
            _this.method = request.method;
            _this.url = _this._getAbsoluteUrl(request);
            _this.startTime = +new Date();
            _this.socketRemoteAddress = request.socket && request.socket.remoteAddress;
            _this.parseHeaders(request, requestId);
            if (request.connection) {
                _this.connectionRemoteAddress = request.connection.remoteAddress;
                _this.legacySocketRemoteAddress = request.connection["socket"] && request.connection["socket"].remoteAddress;
            }
        }
        return _this;
    }
    HttpRequestParser.prototype.onError = function (error, ellapsedMilliseconds) {
        this._setStatus(undefined, error);
        // This parameter is only for overrides. setStatus handles this internally for the autocollected case
        if (ellapsedMilliseconds) {
            this.duration = ellapsedMilliseconds;
        }
    };
    HttpRequestParser.prototype.onResponse = function (response, ellapsedMilliseconds) {
        this._setStatus(response.statusCode, undefined);
        // This parameter is only for overrides. setStatus handles this internally for the autocollected case
        if (ellapsedMilliseconds) {
            this.duration = ellapsedMilliseconds;
        }
    };
    HttpRequestParser.prototype.getRequestTelemetry = function (baseTelemetry) {
        var requestTelemetry = {
            id: this.requestId,
            name: this.method + " " + url.parse(this.url).pathname,
            url: this.url,
            /*
            See https://github.com/Microsoft/ApplicationInsights-dotnet-server/blob/25d695e6a906fbe977f67be3966d25dbf1c50a79/Src/Web/Web.Shared.Net/RequestTrackingTelemetryModule.cs#L250
            for reference
            */
            source: this.sourceCorrelationId,
            duration: this.duration,
            resultCode: this.statusCode ? this.statusCode.toString() : null,
            success: this._isSuccess(),
            properties: this.properties
        };
        // We should keep any parameters the user passed in
        // Except the fields defined above in requestTelemetry, which take priority
        // Except the properties field, where they're merged instead, with baseTelemetry taking priority
        if (baseTelemetry) {
            // Copy missing fields
            for (var key in baseTelemetry) {
                if (!requestTelemetry[key]) {
                    requestTelemetry[key] = baseTelemetry[key];
                }
            }
            // Merge properties
            if (baseTelemetry.properties) {
                for (var key in baseTelemetry.properties) {
                    requestTelemetry.properties[key] = baseTelemetry.properties[key];
                }
            }
        }
        return requestTelemetry;
    };
    HttpRequestParser.prototype.getRequestTags = function (tags) {
        // create a copy of the context for requests since client info will be used here
        var newTags = {};
        for (var key in tags) {
            newTags[key] = tags[key];
        }
        // don't override tags if they are already set
        newTags[HttpRequestParser.keys.locationIp] = tags[HttpRequestParser.keys.locationIp] || this._getIp();
        newTags[HttpRequestParser.keys.sessionId] = tags[HttpRequestParser.keys.sessionId] || this._getId("ai_session");
        newTags[HttpRequestParser.keys.userId] = tags[HttpRequestParser.keys.userId] || this._getId("ai_user");
        newTags[HttpRequestParser.keys.userAuthUserId] = tags[HttpRequestParser.keys.userAuthUserId] || this._getId("ai_authUser");
        newTags[HttpRequestParser.keys.operationName] = this.getOperationName(tags);
        newTags[HttpRequestParser.keys.operationParentId] = this.getOperationParentId(tags);
        newTags[HttpRequestParser.keys.operationId] = this.getOperationId(tags);
        return newTags;
    };
    HttpRequestParser.prototype.getOperationId = function (tags) {
        return tags[HttpRequestParser.keys.operationId] || this.operationId;
    };
    HttpRequestParser.prototype.getOperationParentId = function (tags) {
        return tags[HttpRequestParser.keys.operationParentId] || this.parentId || this.getOperationId(tags);
    };
    HttpRequestParser.prototype.getOperationName = function (tags) {
        return tags[HttpRequestParser.keys.operationName] || this.method + " " + url.parse(this.url).pathname;
    };
    HttpRequestParser.prototype.getRequestId = function () {
        return this.requestId;
    };
    HttpRequestParser.prototype.getCorrelationContextHeader = function () {
        return this.correlationContextHeader;
    };
    HttpRequestParser.prototype.getTraceparent = function () {
        return this.traceparent;
    };
    HttpRequestParser.prototype.getTracestate = function () {
        return this.tracestate;
    };
    HttpRequestParser.prototype.getLegacyRootId = function () {
        return this.legacyRootId;
    };
    HttpRequestParser.prototype._getAbsoluteUrl = function (request) {
        if (!request.headers) {
            return request.url;
        }
        var encrypted = request.connection ? request.connection.encrypted : null;
        var requestUrl = url.parse(request.url);
        var pathName = requestUrl.pathname;
        var search = requestUrl.search;
        var absoluteUrl = url.format({
            protocol: encrypted ? "https" : "http",
            host: request.headers.host,
            pathname: pathName,
            search: search
        });
        return absoluteUrl;
    };
    HttpRequestParser.prototype._getIp = function () {
        // regex to match ipv4 without port
        // Note: including the port would cause the payload to be rejected by the data collector
        var ipMatch = /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/;
        var check = function (str) {
            var results = ipMatch.exec(str);
            if (results) {
                return results[0];
            }
        };
        var ip = check(this.rawHeaders["x-forwarded-for"])
            || check(this.rawHeaders["x-client-ip"])
            || check(this.rawHeaders["x-real-ip"])
            || check(this.connectionRemoteAddress)
            || check(this.socketRemoteAddress)
            || check(this.legacySocketRemoteAddress);
        // node v12 returns this if the address is "localhost"
        if (!ip
            && this.connectionRemoteAddress
            && this.connectionRemoteAddress.substr
            && this.connectionRemoteAddress.substr(0, 2) === "::") {
            ip = "127.0.0.1";
        }
        return ip;
    };
    HttpRequestParser.prototype._getId = function (name) {
        var cookie = (this.rawHeaders && this.rawHeaders["cookie"] &&
            typeof this.rawHeaders["cookie"] === 'string' && this.rawHeaders["cookie"]) || "";
        var value = HttpRequestParser.parseId(Util.getCookie(name, cookie));
        return value;
    };
    /**
     * Sets this operation's operationId, parentId, requestId (and legacyRootId, if necessary) based on this operation's traceparent
     */
    HttpRequestParser.prototype.setBackCompatFromThisTraceContext = function () {
        // Set operationId
        this.operationId = this.traceparent.traceId;
        if (this.traceparent.legacyRootId) {
            this.legacyRootId = this.traceparent.legacyRootId;
        }
        // Set parentId with existing spanId
        this.parentId = this.traceparent.parentId;
        // Update the spanId and set the current requestId
        this.traceparent.updateSpanId();
        this.requestId = this.traceparent.getBackCompatRequestId();
    };
    HttpRequestParser.prototype.parseHeaders = function (request, requestId) {
        this.rawHeaders = request.headers || request.rawHeaders;
        this.userAgent = request.headers && request.headers["user-agent"];
        this.sourceCorrelationId = Util.getCorrelationContextTarget(request, RequestResponseHeaders.requestContextSourceKey);
        if (request.headers) {
            var tracestateHeader = request.headers[RequestResponseHeaders.traceStateHeader]; // w3c header
            var traceparentHeader = request.headers[RequestResponseHeaders.traceparentHeader]; // w3c header
            var requestIdHeader = request.headers[RequestResponseHeaders.requestIdHeader]; // default AI header
            var legacy_parentId = request.headers[RequestResponseHeaders.parentIdHeader]; // legacy AI header
            var legacy_rootId = request.headers[RequestResponseHeaders.rootIdHeader]; // legacy AI header
            this.correlationContextHeader = request.headers[RequestResponseHeaders.correlationContextHeader];
            if (CorrelationIdManager.w3cEnabled && (traceparentHeader || tracestateHeader)) {
                // Parse W3C Trace Context headers
                this.traceparent = new Traceparent(traceparentHeader); // new traceparent is always created from this
                this.tracestate = traceparentHeader && tracestateHeader && new Tracestate(tracestateHeader); // discard tracestate if no traceparent is present
                this.setBackCompatFromThisTraceContext();
            }
            else if (requestIdHeader) {
                // Parse AI headers
                if (CorrelationIdManager.w3cEnabled) {
                    this.traceparent = new Traceparent(null, requestIdHeader);
                    this.setBackCompatFromThisTraceContext();
                }
                else {
                    this.parentId = requestIdHeader;
                    this.requestId = CorrelationIdManager.generateRequestId(this.parentId);
                    this.operationId = CorrelationIdManager.getRootId(this.requestId);
                }
            }
            else {
                // Legacy fallback
                if (CorrelationIdManager.w3cEnabled) {
                    this.traceparent = new Traceparent();
                    this.traceparent.parentId = legacy_parentId;
                    this.traceparent.legacyRootId = legacy_rootId || legacy_parentId;
                    this.setBackCompatFromThisTraceContext();
                }
                else {
                    this.parentId = legacy_parentId;
                    this.requestId = CorrelationIdManager.generateRequestId(legacy_rootId || this.parentId);
                    this.correlationContextHeader = null;
                    this.operationId = CorrelationIdManager.getRootId(this.requestId);
                }
            }
            if (requestId) {
                // For the scenarios that don't guarantee an AI-created context,
                // override the requestId with the provided one.
                this.requestId = requestId;
                this.operationId = CorrelationIdManager.getRootId(this.requestId);
            }
        }
    };
    HttpRequestParser.parseId = function (cookieValue) {
        var cookieParts = cookieValue.split("|");
        if (cookieParts.length > 0) {
            return cookieParts[0];
        }
        return ""; // old behavior was to return "" for incorrect parsing
    };
    HttpRequestParser.keys = new Contracts.ContextTagKeys();
    return HttpRequestParser;
}(RequestParser));
module.exports = HttpRequestParser;


/***/ }),

/***/ 46281:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var http = __webpack_require__(13685);
var https = __webpack_require__(95687);
var Logging = __webpack_require__(579);
var Util = __webpack_require__(8928);
var RequestResponseHeaders = __webpack_require__(99181);
var HttpRequestParser = __webpack_require__(58609);
var CorrelationContextManager_1 = __webpack_require__(77023);
var AutoCollectPerformance = __webpack_require__(62900);
var AutoCollectHttpRequests = (function () {
    function AutoCollectHttpRequests(client) {
        if (!!AutoCollectHttpRequests.INSTANCE) {
            throw new Error("Server request tracking should be configured from the applicationInsights object");
        }
        AutoCollectHttpRequests.INSTANCE = this;
        this._client = client;
    }
    AutoCollectHttpRequests.prototype.enable = function (isEnabled) {
        this._isEnabled = isEnabled;
        // Autocorrelation requires automatic monitoring of incoming server requests
        // Disabling autocollection but enabling autocorrelation will still enable
        // request monitoring but will not produce request events
        if ((this._isAutoCorrelating || this._isEnabled || AutoCollectPerformance.isEnabled()) && !this._isInitialized) {
            this.useAutoCorrelation(this._isAutoCorrelating);
            this._initialize();
        }
    };
    AutoCollectHttpRequests.prototype.useAutoCorrelation = function (isEnabled, forceClsHooked) {
        if (isEnabled && !this._isAutoCorrelating) {
            CorrelationContextManager_1.CorrelationContextManager.enable(forceClsHooked);
        }
        else if (!isEnabled && this._isAutoCorrelating) {
            CorrelationContextManager_1.CorrelationContextManager.disable();
        }
        this._isAutoCorrelating = isEnabled;
    };
    AutoCollectHttpRequests.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    AutoCollectHttpRequests.prototype.isAutoCorrelating = function () {
        return this._isAutoCorrelating;
    };
    AutoCollectHttpRequests.prototype._generateCorrelationContext = function (requestParser) {
        if (!this._isAutoCorrelating) {
            return;
        }
        return CorrelationContextManager_1.CorrelationContextManager.generateContextObject(requestParser.getOperationId(this._client.context.tags), requestParser.getRequestId(), requestParser.getOperationName(this._client.context.tags), requestParser.getCorrelationContextHeader(), requestParser.getTraceparent(), requestParser.getTracestate());
    };
    AutoCollectHttpRequests.prototype._initialize = function () {
        var _this = this;
        this._isInitialized = true;
        var wrapOnRequestHandler = function (onRequest) {
            if (!onRequest) {
                return undefined;
            }
            if (typeof onRequest !== 'function') {
                throw new Error('onRequest handler must be a function');
            }
            return function (request, response) {
                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);
                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(response);
                var shouldCollect = request && !request[AutoCollectHttpRequests.alreadyAutoCollectedFlag];
                if (request && shouldCollect) {
                    // Set up correlation context
                    var requestParser_1 = new HttpRequestParser(request);
                    var correlationContext = _this._generateCorrelationContext(requestParser_1);
                    // Note: Check for if correlation is enabled happens within this method.
                    // If not enabled, function will directly call the callback.
                    CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function () {
                        if (_this._isEnabled) {
                            // Mark as auto collected
                            request[AutoCollectHttpRequests.alreadyAutoCollectedFlag] = true;
                            // Auto collect request
                            AutoCollectHttpRequests.trackRequest(_this._client, { request: request, response: response }, requestParser_1);
                        }
                        // Add this request to the performance counter
                        // Note: Check for if perf counters are enabled happens within this method.
                        // TODO: Refactor common bits between trackRequest and countRequest so they can
                        // be used together, even when perf counters are on, and request tracking is off
                        AutoCollectPerformance.countRequest(request, response);
                        if (typeof onRequest === "function") {
                            onRequest(request, response);
                        }
                    });
                }
                else {
                    if (typeof onRequest === "function") {
                        onRequest(request, response);
                    }
                }
            };
        };
        // The `http.createServer` function will instantiate a new http.Server object.
        // Inside the Server's constructor, it is using addListener to register the
        // onRequest handler. So there are two ways to inject the wrapped onRequest handler:
        // 1) Overwrite Server.prototype.addListener (and .on()) globally and not patching
        //    the http.createServer call. Or
        // 2) Overwrite the http.createServer method and add a patched addListener to the
        //    fresh server instance. This seems more stable for possible future changes as
        //    it also covers the case where the Server might not use addListener to manage
        //    the callback internally.
        //    And also as long as the constructor uses addListener to add the handle, it is
        //    ok to patch the addListener after construction only. Because if we would patch
        //    the prototype one and the createServer method, we would wrap the handler twice
        //    in case of the constructor call.
        var wrapServerEventHandler = function (server) {
            var originalAddListener = server.addListener.bind(server);
            server.addListener = function (eventType, eventHandler) {
                switch (eventType) {
                    case 'request':
                    case 'checkContinue':
                        return originalAddListener(eventType, wrapOnRequestHandler(eventHandler));
                    default:
                        return originalAddListener(eventType, eventHandler);
                }
            };
            // on is an alias to addListener only
            server.on = server.addListener;
        };
        var originalHttpServer = http.createServer;
        http.createServer = function (onRequest) {
            // todo: get a pointer to the server so the IP address can be read from server.address
            var server = originalHttpServer(wrapOnRequestHandler(onRequest));
            wrapServerEventHandler(server);
            return server;
        };
        var originalHttpsServer = https.createServer;
        https.createServer = function (options, onRequest) {
            var server = originalHttpsServer(options, wrapOnRequestHandler(onRequest));
            wrapServerEventHandler(server);
            return server;
        };
    };
    /**
     * Tracks a request synchronously (doesn't wait for response 'finish' event)
     */
    AutoCollectHttpRequests.trackRequestSync = function (client, telemetry) {
        if (!telemetry.request || !telemetry.response || !client) {
            Logging.info("AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
            return;
        }
        AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);
        // store data about the request
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        var requestParser = new HttpRequestParser(telemetry.request, (correlationContext && correlationContext.operation.parentId));
        // Overwrite correlation context with request parser results
        if (correlationContext) {
            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;
            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;
            correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId;
            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());
        }
        AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, telemetry.duration, telemetry.error);
    };
    /**
     * Tracks a request by listening to the response 'finish' event
     */
    AutoCollectHttpRequests.trackRequest = function (client, telemetry, _requestParser) {
        if (!telemetry.request || !telemetry.response || !client) {
            Logging.info("AutoCollectHttpRequests.trackRequest was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
            return;
        }
        // store data about the request
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        var requestParser = _requestParser || new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);
        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl())) {
            AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);
        }
        // Overwrite correlation context with request parser results (if not an automatic track. we've already precalculated the correlation context in that case)
        if (correlationContext && !_requestParser) {
            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;
            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;
            correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId;
            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());
        }
        // response listeners
        if (telemetry.response.once) {
            telemetry.response.once("finish", function () {
                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, null);
            });
        }
        // track a failed request if an error is emitted
        if (telemetry.request.on) {
            telemetry.request.on("error", function (error) {
                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, error);
            });
        }
    };
    /**
     * Add the target correlationId to the response headers, if not already provided.
     */
    AutoCollectHttpRequests.addResponseCorrelationIdHeader = function (client, response) {
        if (client.config && client.config.correlationId &&
            response.getHeader && response.setHeader && !response.headersSent) {
            var correlationHeader = response.getHeader(RequestResponseHeaders.requestContextHeader);
            Util.safeIncludeCorrelationHeader(client, response, correlationHeader);
        }
    };
    AutoCollectHttpRequests.endRequest = function (client, requestParser, telemetry, ellapsedMilliseconds, error) {
        if (error) {
            requestParser.onError(error, ellapsedMilliseconds);
        }
        else {
            requestParser.onResponse(telemetry.response, ellapsedMilliseconds);
        }
        var requestTelemetry = requestParser.getRequestTelemetry(telemetry);
        requestTelemetry.tagOverrides = requestParser.getRequestTags(client.context.tags);
        if (telemetry.tagOverrides) {
            for (var key in telemetry.tagOverrides) {
                requestTelemetry.tagOverrides[key] = telemetry.tagOverrides[key];
            }
        }
        var legacyRootId = requestParser.getLegacyRootId();
        if (legacyRootId) {
            requestTelemetry.properties["ai_legacyRootId"] = legacyRootId;
        }
        requestTelemetry.contextObjects = requestTelemetry.contextObjects || {};
        requestTelemetry.contextObjects["http.ServerRequest"] = telemetry.request;
        requestTelemetry.contextObjects["http.ServerResponse"] = telemetry.response;
        client.trackRequest(requestTelemetry);
    };
    AutoCollectHttpRequests.prototype.dispose = function () {
        AutoCollectHttpRequests.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
        CorrelationContextManager_1.CorrelationContextManager.disable();
        this._isAutoCorrelating = false;
    };
    AutoCollectHttpRequests.alreadyAutoCollectedFlag = '_appInsightsAutoCollected';
    return AutoCollectHttpRequests;
}());
module.exports = AutoCollectHttpRequests;


/***/ }),

/***/ 79498:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Config = __webpack_require__(4206);
var Context = __webpack_require__(21803);
var Logging = __webpack_require__(579);
var AutoCollectNativePerformance = (function () {
    function AutoCollectNativePerformance(client) {
        this._disabledMetrics = {};
        // Note: Only 1 instance of this can exist. So when we reconstruct this object,
        // just disable old native instance and reset JS member variables
        if (AutoCollectNativePerformance.INSTANCE) {
            AutoCollectNativePerformance.INSTANCE.dispose();
        }
        AutoCollectNativePerformance.INSTANCE = this;
        this._client = client;
    }
    /**
     *  Reports if NativePerformance is able to run in this environment
     */
    AutoCollectNativePerformance.isNodeVersionCompatible = function () {
        var nodeVer = process.versions.node.split(".");
        return parseInt(nodeVer[0]) >= 6;
    };
    /**
     * Start instance of native metrics agent.
     *
     * @param {boolean} isEnabled
     * @param {number} [collectionInterval=60000]
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype.enable = function (isEnabled, disabledMetrics, collectionInterval) {
        var _this = this;
        if (disabledMetrics === void 0) { disabledMetrics = {}; }
        if (collectionInterval === void 0) { collectionInterval = 60000; }
        if (!AutoCollectNativePerformance.isNodeVersionCompatible()) {
            return;
        }
        if (AutoCollectNativePerformance._metricsAvailable == undefined && isEnabled && !this._isInitialized) {
            // Try to require in the native-metrics library. If it's found initialize it, else do nothing and never try again.
            try {
                var NativeMetricsEmitters = __webpack_require__(32220);
                AutoCollectNativePerformance._emitter = new NativeMetricsEmitters();
                AutoCollectNativePerformance._metricsAvailable = true;
                Logging.info("Native metrics module successfully loaded!");
            }
            catch (err) {
                // Package not available. Never try again
                AutoCollectNativePerformance._metricsAvailable = false;
                return;
            }
        }
        this._isEnabled = isEnabled;
        this._disabledMetrics = disabledMetrics;
        if (this._isEnabled && !this._isInitialized) {
            this._isInitialized = true;
        }
        // Enable the emitter if we were able to construct one
        if (this._isEnabled && AutoCollectNativePerformance._emitter) {
            // enable self
            AutoCollectNativePerformance._emitter.enable(true, collectionInterval);
            this._handle = setInterval(function () { return _this._trackNativeMetrics(); }, collectionInterval);
            this._handle.unref();
        }
        else if (AutoCollectNativePerformance._emitter) {
            // disable self
            AutoCollectNativePerformance._emitter.enable(false);
            if (this._handle) {
                clearInterval(this._handle);
                this._handle = undefined;
            }
        }
    };
    /**
     * Cleanup this instance of AutoCollectNativePerformance
     *
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype.dispose = function () {
        this.enable(false);
    };
    /**
     * Parse environment variable and overwrite isEnabled based on respective fields being set
     *
     * @private
     * @static
     * @param {(boolean | IDisabledExtendedMetrics)} collectExtendedMetrics
     * @returns {(boolean | IDisabledExtendedMetrics)}
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.parseEnabled = function (collectExtendedMetrics) {
        var disableAll = process.env[Config.ENV_nativeMetricsDisableAll];
        var individualOptOuts = process.env[Config.ENV_nativeMetricsDisablers];
        // case 1: disable all env var set, RETURN with isEnabled=false
        if (disableAll) {
            return { isEnabled: false, disabledMetrics: {} };
        }
        // case 2: individual env vars set, RETURN with isEnabled=true, disabledMetrics={...}
        if (individualOptOuts) {
            var optOutsArr = individualOptOuts.split(",");
            var disabledMetrics = {};
            if (optOutsArr.length > 0) {
                for (var _i = 0, optOutsArr_1 = optOutsArr; _i < optOutsArr_1.length; _i++) {
                    var opt = optOutsArr_1[_i];
                    disabledMetrics[opt] = true;
                }
            }
            // case 2a: collectExtendedMetrics is an object, overwrite existing ones if they exist
            if (typeof collectExtendedMetrics === "object") {
                return { isEnabled: true, disabledMetrics: __assign({}, collectExtendedMetrics, disabledMetrics) };
            }
            // case 2b: collectExtendedMetrics is a boolean, set disabledMetrics as is
            return { isEnabled: collectExtendedMetrics, disabledMetrics: disabledMetrics };
        }
        // case 4: no env vars set, input arg is a boolean, RETURN with isEnabled=collectExtendedMetrics, disabledMetrics={}
        if (typeof collectExtendedMetrics === "boolean") {
            return { isEnabled: collectExtendedMetrics, disabledMetrics: {} };
        }
        else {
            // case 5: no env vars set, input arg is object, RETURN with isEnabled=true, disabledMetrics=collectExtendedMetrics
            return { isEnabled: true, disabledMetrics: collectExtendedMetrics };
        }
    };
    /**
     * Trigger an iteration of native metrics collection
     *
     * @private
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype._trackNativeMetrics = function () {
        var shouldSendAll = true;
        if (typeof this._isEnabled !== "object") {
            shouldSendAll = this._isEnabled;
        }
        if (shouldSendAll) {
            this._trackGarbageCollection();
            this._trackEventLoop();
            this._trackHeapUsage();
        }
    };
    /**
     * Tracks garbage collection stats for this interval. One custom metric is sent per type of garbage
     * collection that occurred during this collection interval.
     *
     * @private
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype._trackGarbageCollection = function () {
        if (this._disabledMetrics.gc) {
            return;
        }
        var gcData = AutoCollectNativePerformance._emitter.getGCData();
        for (var gc in gcData) {
            var metrics = gcData[gc].metrics;
            var name_1 = gc + " Garbage Collection Duration";
            var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
            this._client.trackMetric({
                name: name_1,
                value: metrics.total,
                count: metrics.count,
                max: metrics.max,
                min: metrics.min,
                stdDev: stdDev,
                tagOverrides: (_a = {},
                    _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion,
                    _a)
            });
        }
        var _a;
    };
    /**
     * Tracks event loop ticks per interval as a custom metric. Also included in the metric is min/max/avg
     * time spent in event loop for this interval.
     *
     * @private
     * @returns {void}
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype._trackEventLoop = function () {
        if (this._disabledMetrics.loop) {
            return;
        }
        var loopData = AutoCollectNativePerformance._emitter.getLoopData();
        var metrics = loopData.loopUsage;
        if (metrics.count == 0) {
            return;
        }
        var name = "Event Loop CPU Time";
        var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
        this._client.trackMetric({
            name: name,
            value: metrics.total,
            count: metrics.count,
            min: metrics.min,
            max: metrics.max,
            stdDev: stdDev,
            tagOverrides: (_a = {},
                _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion,
                _a)
        });
        var _a;
    };
    /**
     * Track heap memory usage metrics as a custom metric.
     *
     * @private
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype._trackHeapUsage = function () {
        if (this._disabledMetrics.heap) {
            return;
        }
        var memoryUsage = process.memoryUsage();
        var heapUsed = memoryUsage.heapUsed, heapTotal = memoryUsage.heapTotal, rss = memoryUsage.rss;
        this._client.trackMetric({
            name: "Memory Usage (Heap)",
            value: heapUsed,
            count: 1,
            tagOverrides: (_a = {},
                _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion,
                _a)
        });
        this._client.trackMetric({
            name: "Memory Total (Heap)",
            value: heapTotal,
            count: 1,
            tagOverrides: (_b = {},
                _b[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion,
                _b)
        });
        this._client.trackMetric({
            name: "Memory Usage (Non-Heap)",
            value: rss - heapTotal,
            count: 1,
            tagOverrides: (_c = {},
                _c[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion,
                _c)
        });
        var _a, _b, _c;
    };
    return AutoCollectNativePerformance;
}());
exports.AutoCollectNativePerformance = AutoCollectNativePerformance;


/***/ }),

/***/ 62900:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var os = __webpack_require__(22037);
var Logging = __webpack_require__(579);
var Constants = __webpack_require__(46273);
var AutoCollectPerformance = (function () {
    /**
     * @param enableLiveMetricsCounters - enable sending additional live metrics information (dependency metrics, exception metrics, committed memory)
     */
    function AutoCollectPerformance(client, collectionInterval, enableLiveMetricsCounters) {
        if (collectionInterval === void 0) { collectionInterval = 60000; }
        if (enableLiveMetricsCounters === void 0) { enableLiveMetricsCounters = false; }
        if (!AutoCollectPerformance.INSTANCE) {
            AutoCollectPerformance.INSTANCE = this;
        }
        this._isInitialized = false;
        this._client = client;
        this._collectionInterval = collectionInterval;
        this._enableLiveMetricsCounters = enableLiveMetricsCounters;
    }
    AutoCollectPerformance.prototype.enable = function (isEnabled, collectionInterval) {
        var _this = this;
        this._isEnabled = isEnabled;
        if (this._isEnabled && !this._isInitialized) {
            this._isInitialized = true;
        }
        if (isEnabled) {
            if (!this._handle) {
                this._lastCpus = os.cpus();
                this._lastRequests = {
                    totalRequestCount: AutoCollectPerformance._totalRequestCount,
                    totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,
                    time: +new Date
                };
                this._lastDependencies = {
                    totalDependencyCount: AutoCollectPerformance._totalDependencyCount,
                    totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,
                    time: +new Date
                };
                this._lastExceptions = {
                    totalExceptionCount: AutoCollectPerformance._totalExceptionCount,
                    time: +new Date
                };
                if (typeof process.cpuUsage === 'function') {
                    this._lastAppCpuUsage = process.cpuUsage();
                }
                this._lastHrtime = process.hrtime();
                this._collectionInterval = collectionInterval || this._collectionInterval;
                this._handle = setInterval(function () { return _this.trackPerformance(); }, this._collectionInterval);
                this._handle.unref(); // Allow the app to terminate even while this loop is going on
            }
        }
        else {
            if (this._handle) {
                clearInterval(this._handle);
                this._handle = undefined;
            }
        }
    };
    AutoCollectPerformance.countRequest = function (request, response) {
        var _this = this;
        if (!AutoCollectPerformance.isEnabled()) {
            return;
        }
        var start = +new Date;
        if (!request || !response) {
            Logging.warn("AutoCollectPerformance.countRequest was called with invalid parameters: ", !!request, !!response);
            return;
        }
        // response listeners
        if (typeof response.once === "function") {
            response.once("finish", function () {
                var end = +new Date;
                AutoCollectPerformance._intervalRequestExecutionTime += _this._lastRequestExecutionTime = end - start;
                AutoCollectPerformance._totalRequestCount++;
                if (response.statusCode >= 400) {
                    AutoCollectPerformance._totalFailedRequestCount++;
                }
            });
        }
    };
    AutoCollectPerformance.countException = function () {
        AutoCollectPerformance._totalExceptionCount++;
    };
    AutoCollectPerformance.countDependency = function (duration, success) {
        var durationMs;
        if (!AutoCollectPerformance.isEnabled()) {
            return;
        }
        if (typeof duration === 'string') {
            // dependency duration is passed in as "00:00:00.123" by autocollectors
            durationMs = +new Date('1970-01-01T' + duration + 'Z'); // convert to num ms, returns NaN if wrong
        }
        else if (typeof duration === 'number') {
            durationMs = duration;
        }
        else {
            return;
        }
        AutoCollectPerformance._intervalDependencyExecutionTime += durationMs;
        if (success === false) {
            AutoCollectPerformance._totalFailedDependencyCount++;
        }
        AutoCollectPerformance._totalDependencyCount++;
    };
    AutoCollectPerformance.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    AutoCollectPerformance.isEnabled = function () {
        return AutoCollectPerformance.INSTANCE && AutoCollectPerformance.INSTANCE._isEnabled;
    };
    AutoCollectPerformance.prototype.trackPerformance = function () {
        this._trackCpu();
        this._trackMemory();
        this._trackNetwork();
        this._trackDependencyRate();
        this._trackExceptionRate();
    };
    AutoCollectPerformance.prototype._trackCpu = function () {
        // this reports total ms spent in each category since the OS was booted, to calculate percent it is necessary
        // to find the delta since the last measurement
        var cpus = os.cpus();
        if (cpus && cpus.length && this._lastCpus && cpus.length === this._lastCpus.length) {
            var totalUser = 0;
            var totalSys = 0;
            var totalNice = 0;
            var totalIdle = 0;
            var totalIrq = 0;
            for (var i = 0; !!cpus && i < cpus.length; i++) {
                var cpu = cpus[i];
                var lastCpu = this._lastCpus[i];
                var name = "% cpu(" + i + ") ";
                var model = cpu.model;
                var speed = cpu.speed;
                var times = cpu.times;
                var lastTimes = lastCpu.times;
                // user cpu time (or) % CPU time spent in user space
                var user = (times.user - lastTimes.user) || 0;
                totalUser += user;
                // system cpu time (or) % CPU time spent in kernel space
                var sys = (times.sys - lastTimes.sys) || 0;
                totalSys += sys;
                // user nice cpu time (or) % CPU time spent on low priority processes
                var nice = (times.nice - lastTimes.nice) || 0;
                totalNice += nice;
                // idle cpu time (or) % CPU time spent idle
                var idle = (times.idle - lastTimes.idle) || 0;
                totalIdle += idle;
                // irq (or) % CPU time spent servicing/handling hardware interrupts
                var irq = (times.irq - lastTimes.irq) || 0;
                totalIrq += irq;
            }
            // Calculate % of total cpu time (user + system) this App Process used (Only supported by node v6.1.0+)
            var appCpuPercent = undefined;
            if (typeof process.cpuUsage === 'function') {
                var appCpuUsage = process.cpuUsage();
                var hrtime = process.hrtime();
                var totalApp = ((appCpuUsage.user - this._lastAppCpuUsage.user) + (appCpuUsage.system - this._lastAppCpuUsage.system)) || 0;
                if (typeof this._lastHrtime !== 'undefined' && this._lastHrtime.length === 2) {
                    var elapsedTime = ((hrtime[0] - this._lastHrtime[0]) * 1e6 + (hrtime[1] - this._lastHrtime[1]) / 1e3) || 0; // convert to microseconds
                    appCpuPercent = 100 * totalApp / (elapsedTime * cpus.length);
                }
                // Set previous
                this._lastAppCpuUsage = appCpuUsage;
                this._lastHrtime = hrtime;
            }
            var combinedTotal = (totalUser + totalSys + totalNice + totalIdle + totalIrq) || 1;
            this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESSOR_TIME, value: ((combinedTotal - totalIdle) / combinedTotal) * 100 });
            this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESS_TIME, value: appCpuPercent || ((totalUser / combinedTotal) * 100) });
        }
        this._lastCpus = cpus;
    };
    AutoCollectPerformance.prototype._trackMemory = function () {
        var freeMem = os.freemem();
        var usedMem = process.memoryUsage().rss;
        var committedMemory = os.totalmem() - freeMem;
        this._client.trackMetric({ name: Constants.PerformanceCounter.PRIVATE_BYTES, value: usedMem });
        this._client.trackMetric({ name: Constants.PerformanceCounter.AVAILABLE_BYTES, value: freeMem });
        // Only supported by quickpulse service
        if (this._enableLiveMetricsCounters) {
            this._client.trackMetric({ name: Constants.QuickPulseCounter.COMMITTED_BYTES, value: committedMemory });
        }
    };
    AutoCollectPerformance.prototype._trackNetwork = function () {
        // track total request counters
        var lastRequests = this._lastRequests;
        var requests = {
            totalRequestCount: AutoCollectPerformance._totalRequestCount,
            totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,
            time: +new Date
        };
        var intervalRequests = (requests.totalRequestCount - lastRequests.totalRequestCount) || 0;
        var intervalFailedRequests = (requests.totalFailedRequestCount - lastRequests.totalFailedRequestCount) || 0;
        var elapsedMs = requests.time - lastRequests.time;
        var elapsedSeconds = elapsedMs / 1000;
        var averageRequestExecutionTime = (AutoCollectPerformance._intervalRequestExecutionTime / intervalRequests) || 0; // default to 0 in case no requests in this interval
        AutoCollectPerformance._intervalRequestExecutionTime = 0; // reset
        if (elapsedMs > 0) {
            var requestsPerSec = intervalRequests / elapsedSeconds;
            var failedRequestsPerSec = intervalFailedRequests / elapsedSeconds;
            this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_RATE, value: requestsPerSec });
            // Only send duration to live metrics if it has been updated!
            if (!this._enableLiveMetricsCounters || intervalRequests > 0) {
                this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_DURATION, value: averageRequestExecutionTime });
            }
            // Only supported by quickpulse service
            if (this._enableLiveMetricsCounters) {
                this._client.trackMetric({ name: Constants.QuickPulseCounter.REQUEST_FAILURE_RATE, value: failedRequestsPerSec });
            }
        }
        this._lastRequests = requests;
    };
    // Static counter is accumulated externally. Report the rate to client here
    // Note: This is currently only used with QuickPulse client
    AutoCollectPerformance.prototype._trackDependencyRate = function () {
        if (this._enableLiveMetricsCounters) {
            var lastDependencies = this._lastDependencies;
            var dependencies = {
                totalDependencyCount: AutoCollectPerformance._totalDependencyCount,
                totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,
                time: +new Date
            };
            var intervalDependencies = (dependencies.totalDependencyCount - lastDependencies.totalDependencyCount) || 0;
            var intervalFailedDependencies = (dependencies.totalFailedDependencyCount - lastDependencies.totalFailedDependencyCount) || 0;
            var elapsedMs = dependencies.time - lastDependencies.time;
            var elapsedSeconds = elapsedMs / 1000;
            var averageDependencyExecutionTime = (AutoCollectPerformance._intervalDependencyExecutionTime / intervalDependencies) || 0;
            AutoCollectPerformance._intervalDependencyExecutionTime = 0; // reset
            if (elapsedMs > 0) {
                var dependenciesPerSec = intervalDependencies / elapsedSeconds;
                var failedDependenciesPerSec = intervalFailedDependencies / elapsedSeconds;
                this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_RATE, value: dependenciesPerSec });
                this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_FAILURE_RATE, value: failedDependenciesPerSec });
                // redundant check for livemetrics, but kept for consistency w/ requests
                // Only send duration to live metrics if it has been updated!
                if (!this._enableLiveMetricsCounters || intervalDependencies > 0) {
                    this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_DURATION, value: averageDependencyExecutionTime });
                }
            }
            this._lastDependencies = dependencies;
        }
    };
    // Static counter is accumulated externally. Report the rate to client here
    // Note: This is currently only used with QuickPulse client
    AutoCollectPerformance.prototype._trackExceptionRate = function () {
        if (this._enableLiveMetricsCounters) {
            var lastExceptions = this._lastExceptions;
            var exceptions = {
                totalExceptionCount: AutoCollectPerformance._totalExceptionCount,
                time: +new Date
            };
            var intervalExceptions = (exceptions.totalExceptionCount - lastExceptions.totalExceptionCount) || 0;
            var elapsedMs = exceptions.time - lastExceptions.time;
            var elapsedSeconds = elapsedMs / 1000;
            if (elapsedMs > 0) {
                var exceptionsPerSec = intervalExceptions / elapsedSeconds;
                this._client.trackMetric({ name: Constants.QuickPulseCounter.EXCEPTION_RATE, value: exceptionsPerSec });
            }
            this._lastExceptions = exceptions;
        }
    };
    AutoCollectPerformance.prototype.dispose = function () {
        AutoCollectPerformance.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
    };
    AutoCollectPerformance._totalRequestCount = 0;
    AutoCollectPerformance._totalFailedRequestCount = 0;
    AutoCollectPerformance._lastRequestExecutionTime = 0;
    AutoCollectPerformance._totalDependencyCount = 0;
    AutoCollectPerformance._totalFailedDependencyCount = 0;
    AutoCollectPerformance._lastDependencyExecutionTime = 0;
    AutoCollectPerformance._totalExceptionCount = 0;
    AutoCollectPerformance._intervalDependencyExecutionTime = 0;
    AutoCollectPerformance._intervalRequestExecutionTime = 0;
    return AutoCollectPerformance;
}());
module.exports = AutoCollectPerformance;


/***/ }),

/***/ 62796:
/***/ ((module) => {

"use strict";

/**
 * Base class for helpers that read data from HTTP requst/response objects and convert them
 * into the telemetry contract objects.
 */
var RequestParser = (function () {
    function RequestParser() {
    }
    /**
     * Gets a url parsed out from request options
     */
    RequestParser.prototype.getUrl = function () {
        return this.url;
    };
    RequestParser.prototype.RequestParser = function () {
        this.startTime = +new Date();
    };
    RequestParser.prototype._setStatus = function (status, error) {
        var endTime = +new Date();
        this.duration = endTime - this.startTime;
        this.statusCode = status;
        var properties = this.properties || {};
        if (error) {
            if (typeof error === "string") {
                properties["error"] = error;
            }
            else if (error instanceof Error) {
                properties["error"] = error.message;
            }
            else if (typeof error === "object") {
                for (var key in error) {
                    properties[key] = error[key] && error[key].toString && error[key].toString();
                }
            }
        }
        this.properties = properties;
    };
    RequestParser.prototype._isSuccess = function () {
        return (0 < this.statusCode) && (this.statusCode < 400);
    };
    return RequestParser;
}());
module.exports = RequestParser;


/***/ }),

/***/ 58043:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
var Contracts_1 = __webpack_require__(22220);
var diagnostic_channel_1 = __webpack_require__(42108);
var clients = [];
// Mapping from bunyan levels defined at https://github.com/trentm/node-bunyan/blob/master/lib/bunyan.js#L256
var bunyanToAILevelMap = {
    10: Contracts_1.SeverityLevel.Verbose,
    20: Contracts_1.SeverityLevel.Verbose,
    30: Contracts_1.SeverityLevel.Information,
    40: Contracts_1.SeverityLevel.Warning,
    50: Contracts_1.SeverityLevel.Error,
    60: Contracts_1.SeverityLevel.Critical,
};
var subscriber = function (event) {
    clients.forEach(function (client) {
        var AIlevel = bunyanToAILevelMap[event.data.level];
        client.trackTrace({ message: event.data.result, severity: AIlevel });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("bunyan", subscriber);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("bunyan", subscriber);
        }
    }
}
exports.w = enable;


/***/ }),

/***/ 55985:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
var Contracts_1 = __webpack_require__(22220);
var diagnostic_channel_1 = __webpack_require__(42108);
var clients = [];
var subscriber = function (event) {
    clients.forEach(function (client) {
        // Message can have a trailing newline
        var message = event.data.message;
        if (message.lastIndexOf("\n") == message.length - 1) {
            message = message.substring(0, message.length - 1);
        }
        client.trackTrace({ message: message, severity: (event.data.stderr ? Contracts_1.SeverityLevel.Warning : Contracts_1.SeverityLevel.Information) });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("console", subscriber);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("console", subscriber);
        }
    }
}
exports.w = enable;


/***/ }),

/***/ 55332:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsInitialized = !process.env["APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL"];
if (exports.IsInitialized) {
    var publishers = __webpack_require__(79553);
    var individualOptOuts = process.env["APPLICATION_INSIGHTS_NO_PATCH_MODULES"] || "";
    var unpatchedModules = individualOptOuts.split(",");
    var modules = {
        bunyan: publishers.bunyan,
        console: publishers.console,
        mongodb: publishers.mongodb,
        mongodbCore: publishers.mongodbCore,
        mysql: publishers.mysql,
        redis: publishers.redis,
        pg: publishers.pg,
        pgPool: publishers.pgPool,
        winston: publishers.winston
    };
    for (var mod in modules) {
        if (unpatchedModules.indexOf(mod) === -1) {
            modules[mod].enable();
        }
    }
}
function registerContextPreservation(cb) {
    if (!exports.IsInitialized) {
        return;
    }
    (__webpack_require__(42108).channel.addContextPreservation)(cb);
}
exports.registerContextPreservation = registerContextPreservation;


/***/ }),

/***/ 64668:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
var diagnostic_channel_1 = __webpack_require__(42108);
var clients = [];
exports.qP = function (event) {
    clients.forEach(function (client) {
        var dbName = (event.data.startedData && event.data.startedData.databaseName) || "Unknown database";
        client.trackDependency({
            target: dbName,
            data: event.data.event.commandName,
            name: event.data.event.commandName,
            duration: event.data.event.duration,
            success: event.data.succeeded,
            /* TODO: transmit result code from mongo */
            resultCode: event.data.succeeded ? "0" : "1",
            dependencyTypeName: 'mongodb'
        });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("mongodb", exports.qP);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("mongodb", exports.qP);
        }
    }
}
exports.wp = enable;


/***/ }),

/***/ 10691:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
var diagnostic_channel_1 = __webpack_require__(42108);
var clients = [];
exports.qP = function (event) {
    clients.forEach(function (client) {
        var queryObj = event.data.query || {};
        var sqlString = queryObj.sql || "Unknown query";
        var success = !event.data.err;
        var connection = queryObj._connection || {};
        var connectionConfig = connection.config || {};
        var dbName = connectionConfig.socketPath ? connectionConfig.socketPath : (connectionConfig.host || "localhost") + ":" + connectionConfig.port;
        client.trackDependency({
            target: dbName,
            data: sqlString,
            name: sqlString,
            duration: event.data.duration,
            success: success,
            /* TODO: transmit result code from mysql */
            resultCode: success ? "0" : "1",
            dependencyTypeName: "mysql"
        });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("mysql", exports.qP);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("mysql", exports.qP);
        }
    }
}
exports.wp = enable;


/***/ }),

/***/ 5556:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
var diagnostic_channel_1 = __webpack_require__(42108);
var clients = [];
exports.qP = function (event) {
    clients.forEach(function (client) {
        var q = event.data.query;
        var sql = (q.preparable && q.preparable.text) || q.plan || q.text || "unknown query";
        var success = !event.data.error;
        var conn = event.data.database.host + ":" + event.data.database.port;
        client.trackDependency({
            target: conn,
            data: sql,
            name: sql,
            duration: event.data.duration,
            success: success,
            resultCode: success ? "0" : "1",
            dependencyTypeName: "postgres"
        });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("postgres", exports.qP);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("postgres", exports.qP);
        }
    }
}
exports.wp = enable;


/***/ }),

/***/ 37998:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
var diagnostic_channel_1 = __webpack_require__(42108);
var clients = [];
exports.qP = function (event) {
    clients.forEach(function (client) {
        if (event.data.commandObj.command === "info") {
            // We don't want to report 'info', it's irrelevant
            return;
        }
        client.trackDependency({
            target: event.data.address,
            name: event.data.commandObj.command,
            data: event.data.commandObj.command,
            duration: event.data.duration,
            success: !event.data.err,
            /* TODO: transmit result code from redis */
            resultCode: event.data.err ? "1" : "0",
            dependencyTypeName: "redis"
        });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("redis", exports.qP);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("redis", exports.qP);
        }
    }
}
exports.wp = enable;


/***/ }),

/***/ 89393:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
var Contracts_1 = __webpack_require__(22220);
var diagnostic_channel_1 = __webpack_require__(42108);
var clients = [];
var winstonToAILevelMap = {
    syslog: function (og) {
        var map = {
            emerg: Contracts_1.SeverityLevel.Critical,
            alert: Contracts_1.SeverityLevel.Critical,
            crit: Contracts_1.SeverityLevel.Critical,
            error: Contracts_1.SeverityLevel.Error,
            warning: Contracts_1.SeverityLevel.Warning,
            notice: Contracts_1.SeverityLevel.Information,
            info: Contracts_1.SeverityLevel.Information,
            debug: Contracts_1.SeverityLevel.Verbose
        };
        return map[og] === undefined ? Contracts_1.SeverityLevel.Information : map[og];
    },
    npm: function (og) {
        var map = {
            error: Contracts_1.SeverityLevel.Error,
            warn: Contracts_1.SeverityLevel.Warning,
            info: Contracts_1.SeverityLevel.Information,
            verbose: Contracts_1.SeverityLevel.Verbose,
            debug: Contracts_1.SeverityLevel.Verbose,
            silly: Contracts_1.SeverityLevel.Verbose
        };
        return map[og] === undefined ? Contracts_1.SeverityLevel.Information : map[og];
    },
    unknown: function (og) {
        return Contracts_1.SeverityLevel.Information;
    }
};
var subscriber = function (event) {
    clients.forEach(function (client) {
        var AIlevel = winstonToAILevelMap[event.data.levelKind](event.data.level);
        client.trackTrace({
            message: event.data.message,
            severity: AIlevel,
            properties: event.data.meta
        });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("winston", subscriber);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("winston", subscriber);
        }
    }
}
exports.w = enable;


/***/ }),

/***/ 46273:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var QuickPulseCounter;
(function (QuickPulseCounter) {
    // Memory
    QuickPulseCounter["COMMITTED_BYTES"] = "\\Memory\\Committed Bytes";
    // CPU
    QuickPulseCounter["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    // Request
    QuickPulseCounter["REQUEST_RATE"] = "\\ApplicationInsights\\Requests/Sec";
    QuickPulseCounter["REQUEST_FAILURE_RATE"] = "\\ApplicationInsights\\Requests Failed/Sec";
    QuickPulseCounter["REQUEST_DURATION"] = "\\ApplicationInsights\\Request Duration";
    // Dependency
    QuickPulseCounter["DEPENDENCY_RATE"] = "\\ApplicationInsights\\Dependency Calls/Sec";
    QuickPulseCounter["DEPENDENCY_FAILURE_RATE"] = "\\ApplicationInsights\\Dependency Calls Failed/Sec";
    QuickPulseCounter["DEPENDENCY_DURATION"] = "\\ApplicationInsights\\Dependency Call Duration";
    // Exception
    QuickPulseCounter["EXCEPTION_RATE"] = "\\ApplicationInsights\\Exceptions/Sec";
})(QuickPulseCounter = exports.QuickPulseCounter || (exports.QuickPulseCounter = {}));
var PerformanceCounter;
(function (PerformanceCounter) {
    // Memory
    PerformanceCounter["PRIVATE_BYTES"] = "\\Process(??APP_WIN32_PROC??)\\Private Bytes";
    PerformanceCounter["AVAILABLE_BYTES"] = "\\Memory\\Available Bytes";
    // CPU
    PerformanceCounter["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    PerformanceCounter["PROCESS_TIME"] = "\\Process(??APP_WIN32_PROC??)\\% Processor Time";
    // Requests
    PerformanceCounter["REQUEST_RATE"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec";
    PerformanceCounter["REQUEST_DURATION"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time";
})(PerformanceCounter = exports.PerformanceCounter || (exports.PerformanceCounter = {}));
;
/**
 * Map a PerformanceCounter/QuickPulseCounter to a QuickPulseCounter. If no mapping exists, mapping is *undefined*
 */
exports.PerformanceToQuickPulseCounter = (_a = {},
    _a[PerformanceCounter.PROCESSOR_TIME] = QuickPulseCounter.PROCESSOR_TIME,
    _a[PerformanceCounter.REQUEST_RATE] = QuickPulseCounter.REQUEST_RATE,
    _a[PerformanceCounter.REQUEST_DURATION] = QuickPulseCounter.REQUEST_DURATION,
    // Remap quick pulse only counters
    _a[QuickPulseCounter.COMMITTED_BYTES] = QuickPulseCounter.COMMITTED_BYTES,
    _a[QuickPulseCounter.REQUEST_FAILURE_RATE] = QuickPulseCounter.REQUEST_FAILURE_RATE,
    _a[QuickPulseCounter.DEPENDENCY_RATE] = QuickPulseCounter.DEPENDENCY_RATE,
    _a[QuickPulseCounter.DEPENDENCY_FAILURE_RATE] = QuickPulseCounter.DEPENDENCY_FAILURE_RATE,
    _a[QuickPulseCounter.DEPENDENCY_DURATION] = QuickPulseCounter.DEPENDENCY_DURATION,
    _a[QuickPulseCounter.EXCEPTION_RATE] = QuickPulseCounter.EXCEPTION_RATE,
    _a);
exports.QuickPulseDocumentType = {
    Event: "Event",
    Exception: "Exception",
    Trace: "Trace",
    Metric: "Metric",
    Request: "Request",
    Dependency: "RemoteDependency"
};
exports.QuickPulseType = {
    Event: "EventTelemetryDocument",
    Exception: "ExceptionTelemetryDocument",
    Trace: "TraceTelemetryDocument",
    Metric: "MetricTelemetryDocument",
    Request: "RequestTelemetryDocument",
    Dependency: "DependencyTelemetryDocument"
};
exports.TelemetryTypeStringToQuickPulseType = {
    EventData: exports.QuickPulseType.Event,
    ExceptionData: exports.QuickPulseType.Exception,
    MessageData: exports.QuickPulseType.Trace,
    MetricData: exports.QuickPulseType.Metric,
    RequestData: exports.QuickPulseType.Request,
    RemoteDependencyData: exports.QuickPulseType.Dependency
};
exports.TelemetryTypeStringToQuickPulseDocumentType = {
    EventData: exports.QuickPulseDocumentType.Event,
    ExceptionData: exports.QuickPulseDocumentType.Exception,
    MessageData: exports.QuickPulseDocumentType.Trace,
    MetricData: exports.QuickPulseDocumentType.Metric,
    RequestData: exports.QuickPulseDocumentType.Request,
    RemoteDependencyData: exports.QuickPulseDocumentType.Dependency
};
var _a;


/***/ }),

/***/ 18271:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Generated_1 = __webpack_require__(62785);
var RemoteDependencyDataConstants = (function () {
    function RemoteDependencyDataConstants() {
    }
    RemoteDependencyDataConstants.TYPE_HTTP = "Http";
    RemoteDependencyDataConstants.TYPE_AI = "Http (tracked component)";
    return RemoteDependencyDataConstants;
}());
exports.RemoteDependencyDataConstants = RemoteDependencyDataConstants;
function domainSupportsProperties(domain) {
    return "properties" in domain ||
        domain instanceof Generated_1.EventData ||
        domain instanceof Generated_1.ExceptionData ||
        domain instanceof Generated_1.MessageData ||
        domain instanceof Generated_1.MetricData ||
        domain instanceof Generated_1.PageViewData ||
        domain instanceof Generated_1.RemoteDependencyData ||
        domain instanceof Generated_1.RequestData;
}
exports.domainSupportsProperties = domainSupportsProperties;


/***/ }),

/***/ 70769:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(22422);
"use strict";
/**
 * Instances of AvailabilityData represent the result of executing an availability test.
 */
var AvailabilityData = (function (_super) {
    __extends(AvailabilityData, _super);
    function AvailabilityData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return AvailabilityData;
}(Domain));
module.exports = AvailabilityData;


/***/ }),

/***/ 63433:
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

/**
 * Data struct to contain only C section with custom fields.
 */
var Base = (function () {
    function Base() {
    }
    return Base;
}());
module.exports = Base;


/***/ }),

/***/ 89595:
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

var ContextTagKeys = (function () {
    function ContextTagKeys() {
        this.applicationVersion = "ai.application.ver";
        this.deviceId = "ai.device.id";
        this.deviceLocale = "ai.device.locale";
        this.deviceModel = "ai.device.model";
        this.deviceOEMName = "ai.device.oemName";
        this.deviceOSVersion = "ai.device.osVersion";
        this.deviceType = "ai.device.type";
        this.locationIp = "ai.location.ip";
        this.operationId = "ai.operation.id";
        this.operationName = "ai.operation.name";
        this.operationParentId = "ai.operation.parentId";
        this.operationSyntheticSource = "ai.operation.syntheticSource";
        this.operationCorrelationVector = "ai.operation.correlationVector";
        this.sessionId = "ai.session.id";
        this.sessionIsFirst = "ai.session.isFirst";
        this.userAccountId = "ai.user.accountId";
        this.userId = "ai.user.id";
        this.userAuthUserId = "ai.user.authUserId";
        this.cloudRole = "ai.cloud.role";
        this.cloudRoleInstance = "ai.cloud.roleInstance";
        this.internalSdkVersion = "ai.internal.sdkVersion";
        this.internalAgentVersion = "ai.internal.agentVersion";
        this.internalNodeName = "ai.internal.nodeName";
    }
    return ContextTagKeys;
}());
module.exports = ContextTagKeys;


/***/ }),

/***/ 48527:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Base = __webpack_require__(63433);
"use strict";
/**
 * Data struct to contain both B and C sections.
 */
var Data = (function (_super) {
    __extends(Data, _super);
    function Data() {
        return _super.call(this) || this;
    }
    return Data;
}(Base));
module.exports = Data;


/***/ }),

/***/ 88778:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// THIS FILE WAS AUTOGENERATED
var DataPointType = __webpack_require__(3310);
"use strict";
/**
 * Metric data single measurement.
 */
var DataPoint = (function () {
    function DataPoint() {
        this.kind = DataPointType.Measurement;
    }
    return DataPoint;
}());
module.exports = DataPoint;


/***/ }),

/***/ 3310:
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

/**
 * Type of the metric data measurement.
 */
var DataPointType;
(function (DataPointType) {
    DataPointType[DataPointType["Measurement"] = 0] = "Measurement";
    DataPointType[DataPointType["Aggregation"] = 1] = "Aggregation";
})(DataPointType || (DataPointType = {}));
module.exports = DataPointType;


/***/ }),

/***/ 22422:
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

/**
 * The abstract common base of all domains.
 */
var Domain = (function () {
    function Domain() {
    }
    return Domain;
}());
module.exports = Domain;


/***/ }),

/***/ 88183:
/***/ ((module) => {

"use strict";

/**
 * System variables for a telemetry item.
 */
var Envelope = (function () {
    function Envelope() {
        this.ver = 1;
        this.sampleRate = 100.0;
        this.tags = {};
    }
    return Envelope;
}());
module.exports = Envelope;


/***/ }),

/***/ 82807:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(22422);
"use strict";
/**
 * Instances of Event represent structured event records that can be grouped and searched by their properties. Event data item also creates a metric of event count by name.
 */
var EventData = (function (_super) {
    __extends(EventData, _super);
    function EventData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return EventData;
}(Domain));
module.exports = EventData;


/***/ }),

/***/ 9463:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(22422);
"use strict";
/**
 * An instance of Exception represents a handled or unhandled exception that occurred during execution of the monitored application.
 */
var ExceptionData = (function (_super) {
    __extends(ExceptionData, _super);
    function ExceptionData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.exceptions = [];
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return ExceptionData;
}(Domain));
module.exports = ExceptionData;


/***/ }),

/***/ 83868:
/***/ ((module) => {

"use strict";

/**
 * Exception details of the exception in a chain.
 */
var ExceptionDetails = (function () {
    function ExceptionDetails() {
        this.hasFullStack = true;
        this.parsedStack = [];
    }
    return ExceptionDetails;
}());
module.exports = ExceptionDetails;


/***/ }),

/***/ 29209:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(22422);
"use strict";
/**
 * Instances of Message represent printf-like trace statements that are text-searched. Log4Net, NLog and other text-based log file entries are translated into intances of this type. The message does not have measurements.
 */
var MessageData = (function (_super) {
    __extends(MessageData, _super);
    function MessageData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        return _this;
    }
    return MessageData;
}(Domain));
module.exports = MessageData;


/***/ }),

/***/ 60696:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(22422);
"use strict";
/**
 * An instance of the Metric item is a list of measurements (single data points) and/or aggregations.
 */
var MetricData = (function (_super) {
    __extends(MetricData, _super);
    function MetricData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.metrics = [];
        _this.properties = {};
        return _this;
    }
    return MetricData;
}(Domain));
module.exports = MetricData;


/***/ }),

/***/ 59022:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var EventData = __webpack_require__(82807);
"use strict";
/**
 * An instance of PageView represents a generic action on a page like a button click. It is also the base type for PageView.
 */
var PageViewData = (function (_super) {
    __extends(PageViewData, _super);
    function PageViewData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return PageViewData;
}(EventData));
module.exports = PageViewData;


/***/ }),

/***/ 97353:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(22422);
"use strict";
/**
 * An instance of Remote Dependency represents an interaction of the monitored component with a remote component/service like SQL or an HTTP endpoint.
 */
var RemoteDependencyData = (function (_super) {
    __extends(RemoteDependencyData, _super);
    function RemoteDependencyData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.success = true;
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return RemoteDependencyData;
}(Domain));
module.exports = RemoteDependencyData;


/***/ }),

/***/ 25091:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(22422);
"use strict";
/**
 * An instance of Request represents completion of an external request to the application to do work and contains a summary of that request execution and the results.
 */
var RequestData = (function (_super) {
    __extends(RequestData, _super);
    function RequestData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return RequestData;
}(Domain));
module.exports = RequestData;


/***/ }),

/***/ 83168:
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

/**
 * Defines the level of severity for the event.
 */
var SeverityLevel;
(function (SeverityLevel) {
    SeverityLevel[SeverityLevel["Verbose"] = 0] = "Verbose";
    SeverityLevel[SeverityLevel["Information"] = 1] = "Information";
    SeverityLevel[SeverityLevel["Warning"] = 2] = "Warning";
    SeverityLevel[SeverityLevel["Error"] = 3] = "Error";
    SeverityLevel[SeverityLevel["Critical"] = 4] = "Critical";
})(SeverityLevel || (SeverityLevel = {}));
module.exports = SeverityLevel;


/***/ }),

/***/ 87118:
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

/**
 * Stack frame information.
 */
var StackFrame = (function () {
    function StackFrame() {
    }
    return StackFrame;
}());
module.exports = StackFrame;


/***/ }),

/***/ 62785:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AvailabilityData = __webpack_require__(70769);
exports.Base = __webpack_require__(63433);
exports.ContextTagKeys = __webpack_require__(89595);
exports.Data = __webpack_require__(48527);
exports.DataPoint = __webpack_require__(88778);
exports.DataPointType = __webpack_require__(3310);
exports.Domain = __webpack_require__(22422);
exports.Envelope = __webpack_require__(88183);
exports.EventData = __webpack_require__(82807);
exports.ExceptionData = __webpack_require__(9463);
exports.ExceptionDetails = __webpack_require__(83868);
exports.MessageData = __webpack_require__(29209);
exports.MetricData = __webpack_require__(60696);
exports.PageViewData = __webpack_require__(59022);
exports.RemoteDependencyData = __webpack_require__(97353);
exports.RequestData = __webpack_require__(25091);
exports.SeverityLevel = __webpack_require__(83168);
exports.StackFrame = __webpack_require__(87118);


/***/ }),

/***/ 48788:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Converts the user-friendly enumeration TelemetryType to the underlying schema baseType value
 * @param type Type to convert to BaseData string
 */
function telemetryTypeToBaseType(type) {
    switch (type) {
        case TelemetryType.Event:
            return "EventData";
        case TelemetryType.Exception:
            return "ExceptionData";
        case TelemetryType.Trace:
            return "MessageData";
        case TelemetryType.Metric:
            return "MetricData";
        case TelemetryType.Request:
            return "RequestData";
        case TelemetryType.Dependency:
            return "RemoteDependencyData";
    }
    return undefined;
}
exports.telemetryTypeToBaseType = telemetryTypeToBaseType;
/**
 * Converts the schema baseType value to the user-friendly enumeration TelemetryType
 * @param baseType BaseData string to convert to TelemetryType
 */
function baseTypeToTelemetryType(baseType) {
    switch (baseType) {
        case "EventData":
            return TelemetryType.Event;
        case "ExceptionData":
            return TelemetryType.Exception;
        case "MessageData":
            return TelemetryType.Trace;
        case "MetricData":
            return TelemetryType.Metric;
        case "RequestData":
            return TelemetryType.Request;
        case "RemoteDependencyData":
            return TelemetryType.Dependency;
    }
    return undefined;
}
exports.baseTypeToTelemetryType = baseTypeToTelemetryType;
exports.TelemetryTypeString = {
    Event: "EventData",
    Exception: "ExceptionData",
    Trace: "MessageData",
    Metric: "MetricData",
    Request: "RequestData",
    Dependency: "RemoteDependencyData"
};
/**
 * Telemetry types supported by this SDK
 */
var TelemetryType;
(function (TelemetryType) {
    TelemetryType[TelemetryType["Event"] = 0] = "Event";
    TelemetryType[TelemetryType["Exception"] = 1] = "Exception";
    TelemetryType[TelemetryType["Trace"] = 2] = "Trace";
    TelemetryType[TelemetryType["Metric"] = 3] = "Metric";
    TelemetryType[TelemetryType["Request"] = 4] = "Request";
    TelemetryType[TelemetryType["Dependency"] = 5] = "Dependency";
})(TelemetryType = exports.TelemetryType || (exports.TelemetryType = {}));


/***/ }),

/***/ 97533:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(48788));


/***/ }),

/***/ 22220:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(18271));
__export(__webpack_require__(62785));
__export(__webpack_require__(97533));


/***/ }),

/***/ 86576:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Logging = __webpack_require__(579);
var Channel = (function () {
    function Channel(isDisabled, getBatchSize, getBatchIntervalMs, sender) {
        this._buffer = [];
        this._lastSend = 0;
        this._isDisabled = isDisabled;
        this._getBatchSize = getBatchSize;
        this._getBatchIntervalMs = getBatchIntervalMs;
        this._sender = sender;
    }
    /**
     * Enable or disable disk-backed retry caching to cache events when client is offline (enabled by default)
     * These cached events are stored in your system or user's temporary directory and access restricted to your user when possible.
     * @param value if true events that occured while client is offline will be cached on disk
     * @param resendInterval The wait interval for resending cached events.
     * @param maxBytesOnDisk The maximum size (in bytes) that the created temporary directory for cache events can grow to, before caching is disabled.
     * @returns {Configuration} this class
     */
    Channel.prototype.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {
        this._sender.setDiskRetryMode(value, resendInterval, maxBytesOnDisk);
    };
    /**
     * Add a telemetry item to the send buffer
     */
    Channel.prototype.send = function (envelope) {
        var _this = this;
        // if master off switch is set, don't send any data
        if (this._isDisabled()) {
            // Do not send/save data
            return;
        }
        // validate input
        if (!envelope) {
            Logging.warn("Cannot send null/undefined telemetry");
            return;
        }
        // check if the incoming payload is too large, truncate if necessary
        var payload = this._stringify(envelope);
        if (typeof payload !== "string") {
            return;
        }
        // enqueue the payload
        this._buffer.push(payload);
        // flush if we would exceed the max-size limit by adding this item
        if (this._buffer.length >= this._getBatchSize()) {
            this.triggerSend(false);
            return;
        }
        // ensure an invocation timeout is set if anything is in the buffer
        if (!this._timeoutHandle && this._buffer.length > 0) {
            this._timeoutHandle = setTimeout(function () {
                _this._timeoutHandle = null;
                _this.triggerSend(false);
            }, this._getBatchIntervalMs());
        }
    };
    /**
     * Immediately send buffered data
     */
    Channel.prototype.triggerSend = function (isNodeCrashing, callback) {
        var bufferIsEmpty = this._buffer.length < 1;
        if (!bufferIsEmpty) {
            // compose an array of payloads
            var batch = this._buffer.join("\n");
            // invoke send
            if (isNodeCrashing) {
                this._sender.saveOnCrash(batch);
                if (typeof callback === "function") {
                    callback("data saved on crash");
                }
            }
            else {
                this._sender.send(Buffer.from ? Buffer.from(batch) : new Buffer(batch), callback);
            }
        }
        // update lastSend time to enable throttling
        this._lastSend = +new Date;
        // clear buffer
        this._buffer.length = 0;
        clearTimeout(this._timeoutHandle);
        this._timeoutHandle = null;
        if (bufferIsEmpty && typeof callback === "function") {
            callback("no data to send");
        }
    };
    Channel.prototype._stringify = function (envelope) {
        try {
            return JSON.stringify(envelope);
        }
        catch (error) {
            Logging.warn("Failed to serialize payload", error, envelope);
        }
    };
    return Channel;
}());
module.exports = Channel;


/***/ }),

/***/ 4206:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var CorrelationIdManager = __webpack_require__(74686);
var Config = (function () {
    function Config(instrumentationKey) {
        var _this = this;
        this.endpointBase = "https://dc.services.visualstudio.com";
        this.instrumentationKey = instrumentationKey || Config._getInstrumentationKey();
        this.endpointUrl = this.endpointBase + "/v2/track";
        this.maxBatchSize = 250;
        this.maxBatchIntervalMs = 15000;
        this.disableAppInsights = false;
        this.samplingPercentage = 100;
        this.correlationIdRetryIntervalMs = 30 * 1000;
        this.correlationHeaderExcludedDomains = [
            "*.core.windows.net",
            "*.core.chinacloudapi.cn",
            "*.core.cloudapi.de",
            "*.core.usgovcloudapi.net"
        ];
        this.setCorrelationId = function (correlationId) { return _this.correlationId = correlationId; };
        this.profileQueryEndpoint = process.env[Config.ENV_profileQueryEndpoint] || this.endpointBase;
        this.proxyHttpUrl = process.env[Config.ENV_http_proxy] || undefined;
        this.proxyHttpsUrl = process.env[Config.ENV_https_proxy] || undefined;
        this.httpAgent = undefined;
        this.httpsAgent = undefined;
        this._quickPulseHost = process.env[Config.ENV_quickPulseHost] || "rt.services.visualstudio.com";
    }
    Object.defineProperty(Config.prototype, "profileQueryEndpoint", {
        get: function () {
            return this._profileQueryEndpoint;
        },
        set: function (endpoint) {
            CorrelationIdManager.cancelCorrelationIdQuery(this, this.setCorrelationId);
            this._profileQueryEndpoint = endpoint;
            this.correlationId = CorrelationIdManager.correlationIdPrefix; // Reset the correlationId while we wait for the new query
            CorrelationIdManager.queryCorrelationId(this, this.setCorrelationId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "quickPulseHost", {
        get: function () {
            return this._quickPulseHost;
        },
        set: function (host) {
            this._quickPulseHost = host;
        },
        enumerable: true,
        configurable: true
    });
    Config._getInstrumentationKey = function () {
        // check for both the documented env variable and the azure-prefixed variable
        var iKey = process.env[Config.ENV_iKey]
            || process.env[Config.ENV_azurePrefix + Config.ENV_iKey]
            || process.env[Config.legacy_ENV_iKey]
            || process.env[Config.ENV_azurePrefix + Config.legacy_ENV_iKey];
        if (!iKey || iKey == "") {
            throw new Error("Instrumentation key not found, pass the key in the config to this method or set the key in the environment variable APPINSIGHTS_INSTRUMENTATIONKEY before starting the server");
        }
        return iKey;
    };
    // Azure adds this prefix to all environment variables
    Config.ENV_azurePrefix = "APPSETTING_";
    // This key is provided in the readme
    Config.ENV_iKey = "APPINSIGHTS_INSTRUMENTATIONKEY";
    Config.legacy_ENV_iKey = "APPINSIGHTS_INSTRUMENTATION_KEY";
    Config.ENV_profileQueryEndpoint = "APPINSIGHTS_PROFILE_QUERY_ENDPOINT";
    Config.ENV_quickPulseHost = "APPINSIGHTS_QUICKPULSE_HOST";
    // Native Metrics Opt Outs
    Config.ENV_nativeMetricsDisablers = "APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC";
    Config.ENV_nativeMetricsDisableAll = "APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS";
    Config.ENV_http_proxy = "http_proxy";
    Config.ENV_https_proxy = "https_proxy";
    return Config;
}());
module.exports = Config;


/***/ }),

/***/ 21803:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var os = __webpack_require__(22037);
var fs = __webpack_require__(57147);
var path = __webpack_require__(71017);
var Contracts = __webpack_require__(22220);
var Logging = __webpack_require__(579);
var Context = (function () {
    function Context(packageJsonPath) {
        this.keys = new Contracts.ContextTagKeys();
        this.tags = {};
        this._loadApplicationContext();
        this._loadDeviceContext();
        this._loadInternalContext();
    }
    Context.prototype._loadApplicationContext = function (packageJsonPath) {
        // note: this should return the host package.json
        packageJsonPath = packageJsonPath || path.resolve(__dirname, "../../../../package.json");
        if (!Context.appVersion[packageJsonPath]) {
            Context.appVersion[packageJsonPath] = "unknown";
            try {
                var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
                if (packageJson && typeof packageJson.version === "string") {
                    Context.appVersion[packageJsonPath] = packageJson.version;
                }
            }
            catch (exception) {
                Logging.info("unable to read app version: ", exception);
            }
        }
        this.tags[this.keys.applicationVersion] = Context.appVersion[packageJsonPath];
    };
    Context.prototype._loadDeviceContext = function () {
        this.tags[this.keys.deviceId] = "";
        this.tags[this.keys.cloudRoleInstance] = os && os.hostname();
        this.tags[this.keys.deviceOSVersion] = os && (os.type() + " " + os.release());
        this.tags[this.keys.cloudRole] = Context.DefaultRoleName;
        // not yet supported tags
        this.tags["ai.device.osArchitecture"] = os && os.arch();
        this.tags["ai.device.osPlatform"] = os && os.platform();
    };
    Context.prototype._loadInternalContext = function () {
        // note: this should return the sdk package.json
        var packageJsonPath = path.resolve(__dirname, "../../package.json");
        if (!Context.sdkVersion) {
            Context.sdkVersion = "unknown";
            try {
                var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
                if (packageJson && typeof packageJson.version === "string") {
                    Context.sdkVersion = packageJson.version;
                }
            }
            catch (exception) {
                Logging.info("unable to read app version: ", exception);
            }
        }
        this.tags[this.keys.internalSdkVersion] = "node:" + Context.sdkVersion;
    };
    Context.DefaultRoleName = "Web";
    Context.appVersion = {};
    Context.sdkVersion = null;
    return Context;
}());
module.exports = Context;


/***/ }),

/***/ 74686:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Util = __webpack_require__(8928);
var Logging = __webpack_require__(579);
var CorrelationIdManager = (function () {
    function CorrelationIdManager() {
    }
    CorrelationIdManager.queryCorrelationId = function (config, callback) {
        // GET request to `${this.endpointBase}/api/profiles/${this.instrumentationKey}/appId`
        // If it 404s, the iKey is bad and we should give up
        // If it fails otherwise, try again later
        var appIdUrlString = config.profileQueryEndpoint + "/api/profiles/" + config.instrumentationKey + "/appId";
        if (CorrelationIdManager.completedLookups.hasOwnProperty(appIdUrlString)) {
            callback(CorrelationIdManager.completedLookups[appIdUrlString]);
            return;
        }
        else if (CorrelationIdManager.pendingLookups[appIdUrlString]) {
            CorrelationIdManager.pendingLookups[appIdUrlString].push(callback);
            return;
        }
        CorrelationIdManager.pendingLookups[appIdUrlString] = [callback];
        var fetchAppId = function () {
            if (!CorrelationIdManager.pendingLookups[appIdUrlString]) {
                // This query has been cancelled.
                return;
            }
            var requestOptions = {
                method: 'GET',
                // Ensure this request is not captured by auto-collection.
                // Note: we don't refer to the property in HttpDependencyParser because that would cause a cyclical dependency
                disableAppInsightsAutoCollection: true
            };
            Logging.info(CorrelationIdManager.TAG, requestOptions);
            var req = Util.makeRequest(config, appIdUrlString, requestOptions, function (res) {
                if (res.statusCode === 200) {
                    // Success; extract the appId from the body
                    var appId_1 = "";
                    res.setEncoding("utf-8");
                    res.on('data', function (data) {
                        appId_1 += data;
                    });
                    res.on('end', function () {
                        Logging.info(CorrelationIdManager.TAG, appId_1);
                        var result = CorrelationIdManager.correlationIdPrefix + appId_1;
                        CorrelationIdManager.completedLookups[appIdUrlString] = result;
                        if (CorrelationIdManager.pendingLookups[appIdUrlString]) {
                            CorrelationIdManager.pendingLookups[appIdUrlString].forEach(function (cb) { return cb(result); });
                        }
                        delete CorrelationIdManager.pendingLookups[appIdUrlString];
                    });
                }
                else if (res.statusCode >= 400 && res.statusCode < 500) {
                    // Not found, probably a bad key. Do not try again.
                    CorrelationIdManager.completedLookups[appIdUrlString] = undefined;
                    delete CorrelationIdManager.pendingLookups[appIdUrlString];
                }
                else {
                    // Retry after timeout.
                    setTimeout(fetchAppId, config.correlationIdRetryIntervalMs);
                }
            });
            if (req) {
                req.on('error', function (error) {
                    // Unable to contact endpoint.
                    // Do nothing for now.
                    Logging.warn(CorrelationIdManager.TAG, error);
                });
                req.end();
            }
        };
        setTimeout(fetchAppId, 0);
    };
    CorrelationIdManager.cancelCorrelationIdQuery = function (config, callback) {
        var appIdUrlString = config.profileQueryEndpoint + "/api/profiles/" + config.instrumentationKey + "/appId";
        var pendingLookups = CorrelationIdManager.pendingLookups[appIdUrlString];
        if (pendingLookups) {
            CorrelationIdManager.pendingLookups[appIdUrlString] = pendingLookups.filter(function (cb) { return cb != callback; });
            if (CorrelationIdManager.pendingLookups[appIdUrlString].length == 0) {
                delete CorrelationIdManager.pendingLookups[appIdUrlString];
            }
        }
    };
    /**
     * Generate a request Id according to https://github.com/lmolkova/correlation/blob/master/hierarchical_request_id.md
     * @param parentId
     */
    CorrelationIdManager.generateRequestId = function (parentId) {
        if (parentId) {
            parentId = parentId[0] == '|' ? parentId : '|' + parentId;
            if (parentId[parentId.length - 1] !== '.') {
                parentId += '.';
            }
            var suffix = (CorrelationIdManager.currentRootId++).toString(16);
            return CorrelationIdManager.appendSuffix(parentId, suffix, '_');
        }
        else {
            return CorrelationIdManager.generateRootId();
        }
    };
    /**
     * Given a hierarchical identifier of the form |X.*
     * return the root identifier X
     * @param id
     */
    CorrelationIdManager.getRootId = function (id) {
        var endIndex = id.indexOf('.');
        if (endIndex < 0) {
            endIndex = id.length;
        }
        var startIndex = id[0] === '|' ? 1 : 0;
        return id.substring(startIndex, endIndex);
    };
    CorrelationIdManager.generateRootId = function () {
        return '|' + Util.w3cTraceId() + '.';
    };
    CorrelationIdManager.appendSuffix = function (parentId, suffix, delimiter) {
        if (parentId.length + suffix.length < CorrelationIdManager.requestIdMaxLength) {
            return parentId + suffix + delimiter;
        }
        // Combined identifier would be too long, so we must truncate it.
        // We need 9 characters of space: 8 for the overflow ID, 1 for the
        // overflow delimiter '#'
        var trimPosition = CorrelationIdManager.requestIdMaxLength - 9;
        if (parentId.length > trimPosition) {
            for (; trimPosition > 1; --trimPosition) {
                var c = parentId[trimPosition - 1];
                if (c === '.' || c === '_') {
                    break;
                }
            }
        }
        if (trimPosition <= 1) {
            // parentId is not a valid ID
            return CorrelationIdManager.generateRootId();
        }
        suffix = Util.randomu32().toString(16);
        while (suffix.length < 8) {
            suffix = '0' + suffix;
        }
        return parentId.substring(0, trimPosition) + suffix + '#';
    };
    CorrelationIdManager.TAG = "CorrelationIdManager";
    CorrelationIdManager.correlationIdPrefix = "cid-v1:";
    CorrelationIdManager.w3cEnabled = false;
    // To avoid extraneous HTTP requests, we maintain a queue of callbacks waiting on a particular appId lookup,
    // as well as a cache of completed lookups so future requests can be resolved immediately.
    CorrelationIdManager.pendingLookups = {};
    CorrelationIdManager.completedLookups = {};
    CorrelationIdManager.requestIdMaxLength = 1024;
    CorrelationIdManager.currentRootId = Util.randomu32();
    return CorrelationIdManager;
}());
module.exports = CorrelationIdManager;


/***/ }),

/***/ 13735:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Contracts = __webpack_require__(22220);
var Util = __webpack_require__(8928);
var CorrelationContextManager_1 = __webpack_require__(77023);
/**
 * Manages the logic of creating envelopes from Telemetry objects
 */
var EnvelopeFactory = (function () {
    function EnvelopeFactory() {
    }
    /**
     * Creates envelope ready to be sent by Channel
     * @param telemetry Telemetry data
     * @param telemetryType Type of telemetry
     * @param commonProperties Bag of custom common properties to be added to the envelope
     * @param context Client context
     * @param config Client configuration
     */
    EnvelopeFactory.createEnvelope = function (telemetry, telemetryType, commonProperties, context, config) {
        var data = null;
        switch (telemetryType) {
            case Contracts.TelemetryType.Trace:
                data = EnvelopeFactory.createTraceData(telemetry);
                break;
            case Contracts.TelemetryType.Dependency:
                data = EnvelopeFactory.createDependencyData(telemetry);
                break;
            case Contracts.TelemetryType.Event:
                data = EnvelopeFactory.createEventData(telemetry);
                break;
            case Contracts.TelemetryType.Exception:
                data = EnvelopeFactory.createExceptionData(telemetry);
                break;
            case Contracts.TelemetryType.Request:
                data = EnvelopeFactory.createRequestData(telemetry);
                break;
            case Contracts.TelemetryType.Metric:
                data = EnvelopeFactory.createMetricData(telemetry);
                break;
        }
        if (commonProperties && Contracts.domainSupportsProperties(data.baseData)) {
            if (data && data.baseData) {
                // if no properties are specified just add the common ones
                if (!data.baseData.properties) {
                    data.baseData.properties = commonProperties;
                }
                else {
                    // otherwise, check each of the common ones
                    for (var name in commonProperties) {
                        // only override if the property `name` has not been set on this item
                        if (!data.baseData.properties[name]) {
                            data.baseData.properties[name] = commonProperties[name];
                        }
                    }
                }
            }
            // sanitize properties
            data.baseData.properties = Util.validateStringMap(data.baseData.properties);
        }
        var iKey = config ? config.instrumentationKey || "" : "";
        var envelope = new Contracts.Envelope();
        envelope.data = data;
        envelope.iKey = iKey;
        // this is kind of a hack, but the envelope name is always the same as the data name sans the chars "data"
        envelope.name =
            "Microsoft.ApplicationInsights." +
                iKey.replace(/-/g, "") +
                "." +
                data.baseType.substr(0, data.baseType.length - 4);
        envelope.tags = this.getTags(context, telemetry.tagOverrides);
        envelope.time = (new Date()).toISOString();
        envelope.ver = 1;
        envelope.sampleRate = config ? config.samplingPercentage : 100;
        // Exclude metrics from sampling by default
        if (telemetryType === Contracts.TelemetryType.Metric) {
            envelope.sampleRate = 100;
        }
        return envelope;
    };
    EnvelopeFactory.createTraceData = function (telemetry) {
        var trace = new Contracts.MessageData();
        trace.message = telemetry.message;
        trace.properties = telemetry.properties;
        if (!isNaN(telemetry.severity)) {
            trace.severityLevel = telemetry.severity;
        }
        else {
            trace.severityLevel = Contracts.SeverityLevel.Information;
        }
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Trace);
        data.baseData = trace;
        return data;
    };
    EnvelopeFactory.createDependencyData = function (telemetry) {
        var remoteDependency = new Contracts.RemoteDependencyData();
        remoteDependency.name = telemetry.name;
        remoteDependency.data = telemetry.data;
        remoteDependency.target = telemetry.target;
        remoteDependency.duration = Util.msToTimeSpan(telemetry.duration);
        remoteDependency.success = telemetry.success;
        remoteDependency.type = telemetry.dependencyTypeName;
        remoteDependency.properties = telemetry.properties;
        remoteDependency.resultCode = (telemetry.resultCode ? telemetry.resultCode + '' : '');
        if (telemetry.id) {
            remoteDependency.id = telemetry.id;
        }
        else {
            remoteDependency.id = Util.w3cTraceId();
        }
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Dependency);
        data.baseData = remoteDependency;
        return data;
    };
    EnvelopeFactory.createEventData = function (telemetry) {
        var event = new Contracts.EventData();
        event.name = telemetry.name;
        event.properties = telemetry.properties;
        event.measurements = telemetry.measurements;
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Event);
        data.baseData = event;
        return data;
    };
    EnvelopeFactory.createExceptionData = function (telemetry) {
        var exception = new Contracts.ExceptionData();
        exception.properties = telemetry.properties;
        exception.severityLevel = Contracts.SeverityLevel.Error;
        exception.measurements = telemetry.measurements;
        exception.exceptions = [];
        var stack = telemetry.exception["stack"];
        var exceptionDetails = new Contracts.ExceptionDetails();
        exceptionDetails.message = telemetry.exception.message;
        exceptionDetails.typeName = telemetry.exception.name;
        exceptionDetails.parsedStack = this.parseStack(stack);
        exceptionDetails.hasFullStack = Util.isArray(exceptionDetails.parsedStack) && exceptionDetails.parsedStack.length > 0;
        exception.exceptions.push(exceptionDetails);
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Exception);
        data.baseData = exception;
        return data;
    };
    EnvelopeFactory.createRequestData = function (telemetry) {
        var requestData = new Contracts.RequestData();
        if (telemetry.id) {
            requestData.id = telemetry.id;
        }
        else {
            requestData.id = Util.w3cTraceId();
        }
        requestData.name = telemetry.name;
        requestData.url = telemetry.url;
        requestData.source = telemetry.source;
        requestData.duration = Util.msToTimeSpan(telemetry.duration);
        requestData.responseCode = (telemetry.resultCode ? telemetry.resultCode + '' : '');
        requestData.success = telemetry.success;
        requestData.properties = telemetry.properties;
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Request);
        data.baseData = requestData;
        return data;
    };
    EnvelopeFactory.createMetricData = function (telemetry) {
        var metrics = new Contracts.MetricData(); // todo: enable client-batching of these
        metrics.metrics = [];
        var metric = new Contracts.DataPoint();
        metric.count = !isNaN(telemetry.count) ? telemetry.count : 1;
        metric.kind = Contracts.DataPointType.Aggregation;
        metric.max = !isNaN(telemetry.max) ? telemetry.max : telemetry.value;
        metric.min = !isNaN(telemetry.min) ? telemetry.min : telemetry.value;
        metric.name = telemetry.name;
        metric.stdDev = !isNaN(telemetry.stdDev) ? telemetry.stdDev : 0;
        metric.value = telemetry.value;
        metrics.metrics.push(metric);
        metrics.properties = telemetry.properties;
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Metric);
        data.baseData = metrics;
        return data;
    };
    EnvelopeFactory.getTags = function (context, tagOverrides) {
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        // Make a copy of context tags so we don't alter the actual object
        // Also perform tag overriding
        var newTags = {};
        if (context && context.tags) {
            for (var key in context.tags) {
                newTags[key] = context.tags[key];
            }
        }
        if (tagOverrides) {
            for (var key in tagOverrides) {
                newTags[key] = tagOverrides[key];
            }
        }
        // Fill in internally-populated values if not already set
        if (correlationContext) {
            newTags[context.keys.operationId] = newTags[context.keys.operationId] || correlationContext.operation.id;
            newTags[context.keys.operationName] = newTags[context.keys.operationName] || correlationContext.operation.name;
            newTags[context.keys.operationParentId] = newTags[context.keys.operationParentId] || correlationContext.operation.parentId;
        }
        return newTags;
    };
    EnvelopeFactory.parseStack = function (stack) {
        var parsedStack = undefined;
        if (typeof stack === "string") {
            var frames = stack.split("\n");
            parsedStack = [];
            var level = 0;
            var totalSizeInBytes = 0;
            for (var i = 0; i <= frames.length; i++) {
                var frame = frames[i];
                if (_StackFrame.regex.test(frame)) {
                    var parsedFrame = new _StackFrame(frames[i], level++);
                    totalSizeInBytes += parsedFrame.sizeInBytes;
                    parsedStack.push(parsedFrame);
                }
            }
            // DP Constraint - exception parsed stack must be < 32KB
            // remove frames from the middle to meet the threshold
            var exceptionParsedStackThreshold = 32 * 1024;
            if (totalSizeInBytes > exceptionParsedStackThreshold) {
                var left = 0;
                var right = parsedStack.length - 1;
                var size = 0;
                var acceptedLeft = left;
                var acceptedRight = right;
                while (left < right) {
                    // check size
                    var lSize = parsedStack[left].sizeInBytes;
                    var rSize = parsedStack[right].sizeInBytes;
                    size += lSize + rSize;
                    if (size > exceptionParsedStackThreshold) {
                        // remove extra frames from the middle
                        var howMany = acceptedRight - acceptedLeft + 1;
                        parsedStack.splice(acceptedLeft, howMany);
                        break;
                    }
                    // update pointers
                    acceptedLeft = left;
                    acceptedRight = right;
                    left++;
                    right--;
                }
            }
        }
        return parsedStack;
    };
    return EnvelopeFactory;
}());
var _StackFrame = (function () {
    function _StackFrame(frame, level) {
        this.sizeInBytes = 0;
        this.level = level;
        this.method = "<no_method>";
        this.assembly = Util.trim(frame);
        var matches = frame.match(_StackFrame.regex);
        if (matches && matches.length >= 5) {
            this.method = Util.trim(matches[2]) || this.method;
            this.fileName = Util.trim(matches[4]) || "<no_filename>";
            this.line = parseInt(matches[5]) || 0;
        }
        this.sizeInBytes += this.method.length;
        this.sizeInBytes += this.fileName.length;
        this.sizeInBytes += this.assembly.length;
        // todo: these might need to be removed depending on how the back-end settles on their size calculation
        this.sizeInBytes += _StackFrame.baseSize;
        this.sizeInBytes += this.level.toString().length;
        this.sizeInBytes += this.line.toString().length;
    }
    // regex to match stack frames from ie/chrome/ff
    // methodName=$2, fileName=$4, lineNo=$5, column=$6
    _StackFrame.regex = /^([\s]+at)?(.*?)(\@|\s\(|\s)([^\(\@\n]+):([0-9]+):([0-9]+)(\)?)$/;
    _StackFrame.baseSize = 58; //'{"method":"","level":,"assembly":"","fileName":"","line":}'.length
    return _StackFrame;
}());
module.exports = EnvelopeFactory;


/***/ }),

/***/ 579:
/***/ ((module) => {

"use strict";

var Logging = (function () {
    function Logging() {
    }
    Logging.info = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (Logging.enableDebug) {
            console.info(Logging.TAG + message, optionalParams);
        }
    };
    Logging.warn = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (!Logging.disableWarnings) {
            console.warn(Logging.TAG + message, optionalParams);
        }
    };
    Logging.enableDebug = false;
    Logging.disableWarnings = false;
    Logging.TAG = "ApplicationInsights:";
    return Logging;
}());
module.exports = Logging;


/***/ }),

/***/ 83103:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TelemetryClient = __webpack_require__(49255);
var ServerRequestTracking = __webpack_require__(46281);
var ClientRequestTracking = __webpack_require__(12992);
var Logging = __webpack_require__(579);
/**
 * Application Insights Telemetry Client for Node.JS. Provides the Application Insights TelemetryClient API
 * in addition to Node-specific helper functions.
 * Construct a new TelemetryClient to have an instance with a different configuration than the default client.
 * In most cases, `appInsights.defaultClient` should be used instead.
 */
var NodeClient = (function (_super) {
    __extends(NodeClient, _super);
    function NodeClient() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Log RequestTelemetry from HTTP request and response. This method will log immediately without waitng for request completion
     * and it requires duration parameter to be specified on NodeHttpRequestTelemetry object.
     * Use trackNodeHttpRequest function to log the telemetry after request completion
     * @param telemetry Object encapsulating incoming request, response and duration information
     */
    NodeClient.prototype.trackNodeHttpRequestSync = function (telemetry) {
        if (telemetry && telemetry.request && telemetry.response && telemetry.duration) {
            ServerRequestTracking.trackRequestSync(this, telemetry);
        }
        else {
            Logging.warn("trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.");
        }
    };
    /**
     * Log RequestTelemetry from HTTP request and response. This method will `follow` the request to completion.
     * Use trackNodeHttpRequestSync function to log telemetry immediately without waiting for request completion
     * @param telemetry Object encapsulating incoming request and response information
     */
    NodeClient.prototype.trackNodeHttpRequest = function (telemetry) {
        if (telemetry.duration || telemetry.error) {
            Logging.warn("trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects.");
        }
        if (telemetry && telemetry.request && telemetry.response) {
            ServerRequestTracking.trackRequest(this, telemetry);
        }
        else {
            Logging.warn("trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.");
        }
    };
    /**
     * Log DependencyTelemetry from outgoing HTTP request. This method will instrument the outgoing request and append
     * the specified headers and will log the telemetry when outgoing request is complete
     * @param telemetry Object encapsulating outgoing request information
     */
    NodeClient.prototype.trackNodeHttpDependency = function (telemetry) {
        if (telemetry && telemetry.request) {
            ClientRequestTracking.trackRequest(this, telemetry);
        }
        else {
            Logging.warn("trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.");
        }
    };
    return NodeClient;
}(TelemetryClient));
module.exports = NodeClient;


/***/ }),

/***/ 81294:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var os = __webpack_require__(22037);
var Contracts = __webpack_require__(22220);
var Constants = __webpack_require__(46273);
var Util = __webpack_require__(8928);
var Logging = __webpack_require__(579);
var StreamId = Util.w3cTraceId(); // Create a guid
var QuickPulseEnvelopeFactory = (function () {
    function QuickPulseEnvelopeFactory() {
    }
    QuickPulseEnvelopeFactory.createQuickPulseEnvelope = function (metrics, documents, config, context) {
        var machineName = (os && typeof os.hostname === "function"
            && os.hostname()) || "Unknown"; // Note: os.hostname() was added in node v0.3.3
        var instance = (context.tags
            && context.keys
            && context.keys.cloudRoleInstance
            && context.tags[context.keys.cloudRoleInstance]) || machineName;
        var envelope = {
            Documents: documents.length > 0 ? documents : null,
            InstrumentationKey: config.instrumentationKey || "",
            Metrics: metrics.length > 0 ? metrics : null,
            InvariantVersion: 1,
            Timestamp: "/Date(" + Date.now() + ")/",
            Version: context.tags[context.keys.internalSdkVersion],
            StreamId: StreamId,
            MachineName: machineName,
            Instance: instance
        };
        return envelope;
    };
    QuickPulseEnvelopeFactory.createQuickPulseMetric = function (telemetry) {
        var data;
        data = {
            Name: telemetry.name,
            Value: telemetry.value,
            Weight: telemetry.count || 1
        };
        return data;
    };
    QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument = function (envelope) {
        switch (envelope.data.baseType) {
            case Contracts.TelemetryTypeString.Event:
                return QuickPulseEnvelopeFactory.createQuickPulseEventDocument(envelope);
            case Contracts.TelemetryTypeString.Exception:
                return QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument(envelope);
            case Contracts.TelemetryTypeString.Trace:
                return QuickPulseEnvelopeFactory.createQuickPulseTraceDocument(envelope);
            case Contracts.TelemetryTypeString.Dependency:
                return QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument(envelope);
            case Contracts.TelemetryTypeString.Request:
                return QuickPulseEnvelopeFactory.createQuickPulseRequestDocument(envelope);
        }
        return null;
    };
    QuickPulseEnvelopeFactory.createQuickPulseEventDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);
        var name = envelope.data.baseData.name;
        var eventDocument = __assign({}, document, { Name: name });
        return eventDocument;
    };
    QuickPulseEnvelopeFactory.createQuickPulseTraceDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);
        var severityLevel = envelope.data.baseData.severityLevel || 0;
        var traceDocument = __assign({}, document, { Message: envelope.data.baseData.message, SeverityLevel: Contracts.SeverityLevel[severityLevel] });
        return traceDocument;
    };
    QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);
        var exceptionDetails = envelope.data.baseData.exceptions;
        var exception = '';
        var exceptionMessage = '';
        var exceptionType = '';
        // Try to fill exception information from first error only
        if (exceptionDetails && exceptionDetails.length > 0) {
            // Try to grab the stack from parsedStack or stack
            if (exceptionDetails[0].parsedStack && exceptionDetails[0].parsedStack.length > 0) {
                exceptionDetails[0].parsedStack.forEach(function (err) {
                    exception += err.assembly + "\n";
                });
            }
            else if (exceptionDetails[0].stack && exceptionDetails[0].stack.length > 0) {
                exception = exceptionDetails[0].stack;
            }
            exceptionMessage = exceptionDetails[0].message;
            exceptionType = exceptionDetails[0].typeName;
        }
        var exceptionDocument = __assign({}, document, { Exception: exception, ExceptionMessage: exceptionMessage, ExceptionType: exceptionType });
        return exceptionDocument;
    };
    QuickPulseEnvelopeFactory.createQuickPulseRequestDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);
        var baseData = envelope.data.baseData;
        var requestDocument = __assign({}, document, { Name: baseData.name, Success: baseData.success, Duration: baseData.duration, ResponseCode: baseData.responseCode, OperationName: baseData.name // TODO: is this correct?
         });
        return requestDocument;
    };
    QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);
        var baseData = envelope.data.baseData;
        var dependencyDocument = __assign({}, document, { Name: baseData.name, Target: baseData.target, Success: baseData.success, Duration: baseData.duration, ResultCode: baseData.resultCode, CommandName: baseData.data, OperationName: document.OperationId, DependencyTypeName: baseData.type });
        return dependencyDocument;
    };
    QuickPulseEnvelopeFactory.createQuickPulseDocument = function (envelope) {
        var documentType;
        var __type;
        var operationId, properties;
        if (envelope.data.baseType) {
            __type = Constants.TelemetryTypeStringToQuickPulseType[envelope.data.baseType];
            documentType = Constants.TelemetryTypeStringToQuickPulseDocumentType[envelope.data.baseType];
        }
        else {
            // Remark: This should never be hit because createQuickPulseDocument is only called within
            // valid baseType values
            Logging.warn("Document type invalid; not sending live metric document", envelope.data.baseType);
        }
        operationId = envelope.tags[QuickPulseEnvelopeFactory.keys.operationId];
        properties = QuickPulseEnvelopeFactory.aggregateProperties(envelope);
        var document = {
            DocumentType: documentType,
            __type: __type,
            OperationId: operationId,
            Version: "1.0",
            Properties: properties
        };
        return document;
    };
    QuickPulseEnvelopeFactory.aggregateProperties = function (envelope) {
        var properties = [];
        // Collect measurements
        var meas = (envelope.data.baseData).measurements || {};
        for (var key in meas) {
            if (meas.hasOwnProperty(key)) {
                var value = meas[key];
                var property = { key: key, value: value };
                properties.push(property);
            }
        }
        // Collect properties
        var props = (envelope.data.baseData).properties || {};
        for (var key in props) {
            if (props.hasOwnProperty(key)) {
                var value = props[key];
                var property = { key: key, value: value };
                properties.push(property);
            }
        }
        return properties;
    };
    QuickPulseEnvelopeFactory.keys = new Contracts.ContextTagKeys();
    return QuickPulseEnvelopeFactory;
}());
module.exports = QuickPulseEnvelopeFactory;


/***/ }),

/***/ 5893:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var https = __webpack_require__(95687);
var AutoCollectHttpDependencies = __webpack_require__(12992);
var Logging = __webpack_require__(579);
var QuickPulseConfig = {
    method: "POST",
    time: "x-ms-qps-transmission-time",
    subscribed: "x-ms-qps-subscribed"
};
var QuickPulseSender = (function () {
    function QuickPulseSender(config) {
        this._config = config;
        this._consecutiveErrors = 0;
    }
    QuickPulseSender.prototype.ping = function (envelope, done) {
        this._submitData(envelope, done, "ping");
    };
    QuickPulseSender.prototype.post = function (envelope, done) {
        // Important: When POSTing data, envelope must be an array
        this._submitData([envelope], done, "post");
    };
    QuickPulseSender.prototype._submitData = function (envelope, done, postOrPing) {
        var _this = this;
        var payload = JSON.stringify(envelope);
        var options = (_a = {},
            _a[AutoCollectHttpDependencies.disableCollectionRequestOption] = true,
            _a.host = this._config.quickPulseHost,
            _a.method = QuickPulseConfig.method,
            _a.path = "/QuickPulseService.svc/" + postOrPing + "?ikey=" + this._config.instrumentationKey,
            _a.headers = (_b = {
                    'Expect': '100-continue'
                },
                _b[QuickPulseConfig.time] = 10000 * Date.now(),
                _b['Content-Type'] = 'application\/json',
                _b['Content-Length'] = Buffer.byteLength(payload),
                _b),
            _a);
        var req = https.request(options, function (res) {
            var shouldPOSTData = res.headers[QuickPulseConfig.subscribed] === "true";
            _this._consecutiveErrors = 0;
            done(shouldPOSTData, res);
        });
        req.on("error", function (error) {
            // Unable to contact qps endpoint.
            // Do nothing for now.
            _this._consecutiveErrors++;
            // LOG every error, but WARN instead when X number of consecutive errors occur
            var notice = "Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:";
            if (_this._consecutiveErrors % QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN === 0) {
                notice = "Live Metrics endpoint could not be reached " + _this._consecutiveErrors + " consecutive times. Most recent error:";
                Logging.warn(QuickPulseSender.TAG, notice, error);
            }
            else {
                // Potentially transient error, do not change the ping/post state yet.
                Logging.info(QuickPulseSender.TAG, notice, error);
            }
            done();
        });
        req.write(payload);
        req.end();
        var _a, _b;
    };
    QuickPulseSender.TAG = "QuickPulseSender";
    QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN = 25;
    return QuickPulseSender;
}());
module.exports = QuickPulseSender;


/***/ }),

/***/ 7445:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Logging = __webpack_require__(579);
var Config = __webpack_require__(4206);
var QuickPulseEnvelopeFactory = __webpack_require__(81294);
var QuickPulseSender = __webpack_require__(5893);
var Constants = __webpack_require__(46273);
var Context = __webpack_require__(21803);
/** State Container for sending to the QuickPulse Service */
var QuickPulseStateManager = (function () {
    function QuickPulseStateManager(iKey, context) {
        this._isCollectingData = false;
        this._lastSuccessTime = Date.now();
        this._lastSendSucceeded = true;
        this._metrics = {};
        this._documents = [];
        this._collectors = [];
        this.config = new Config(iKey);
        this.context = context || new Context();
        this._sender = new QuickPulseSender(this.config);
        this._isEnabled = false;
    }
    /**
     *
     * @param collector
     */
    QuickPulseStateManager.prototype.addCollector = function (collector) {
        this._collectors.push(collector);
    };
    /**
     * Override of TelemetryClient.trackMetric
     */
    QuickPulseStateManager.prototype.trackMetric = function (telemetry) {
        this._addMetric(telemetry);
    };
    /**
     * Add a document to the current buffer
     * @param envelope
     */
    QuickPulseStateManager.prototype.addDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument(envelope);
        if (document) {
            this._documents.push(document);
        }
    };
    /**
     * Enable or disable communication with QuickPulseService
     * @param isEnabled
     */
    QuickPulseStateManager.prototype.enable = function (isEnabled) {
        if (isEnabled && !this._isEnabled) {
            this._isEnabled = true;
            this._goQuickPulse();
        }
        else if (!isEnabled && this._isEnabled) {
            this._isEnabled = false;
            clearTimeout(this._handle);
            this._handle = undefined;
        }
    };
    /**
     * Enable or disable all collectors in this instance
     * @param enable
     */
    QuickPulseStateManager.prototype.enableCollectors = function (enable) {
        this._collectors.forEach(function (collector) {
            collector.enable(enable);
        });
    };
    /**
     * Add the metric to this buffer. If same metric already exists in this buffer, add weight to it
     * @param telemetry
     */
    QuickPulseStateManager.prototype._addMetric = function (telemetry) {
        var value = telemetry.value;
        var count = telemetry.count || 1;
        var name = Constants.PerformanceToQuickPulseCounter[telemetry.name];
        if (name) {
            if (this._metrics[name]) {
                this._metrics[name].Value = (this._metrics[name].Value * this._metrics[name].Weight + value * count) / (this._metrics[name].Weight + count);
                this._metrics[name].Weight += count;
            }
            else {
                this._metrics[name] = QuickPulseEnvelopeFactory.createQuickPulseMetric(telemetry);
                this._metrics[name].Name = name;
                this._metrics[name].Weight = 1;
            }
        }
    };
    QuickPulseStateManager.prototype._resetQuickPulseBuffer = function () {
        delete this._metrics;
        this._metrics = {};
        this._documents.length = 0;
    };
    QuickPulseStateManager.prototype._goQuickPulse = function () {
        var _this = this;
        // Create envelope from Documents and Metrics
        var metrics = Object.keys(this._metrics).map(function (k) { return _this._metrics[k]; });
        var envelope = QuickPulseEnvelopeFactory.createQuickPulseEnvelope(metrics, this._documents.slice(), this.config, this.context);
        // Clear this document, metric buffer
        this._resetQuickPulseBuffer();
        // Send it to QuickPulseService, if collecting
        if (this._isCollectingData) {
            this._post(envelope);
        }
        else {
            this._ping(envelope);
        }
        var currentTimeout = this._isCollectingData ? QuickPulseStateManager.POST_INTERVAL : QuickPulseStateManager.PING_INTERVAL;
        if (this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_POST_WAIT_TIME && !this._lastSendSucceeded) {
            // Haven't posted successfully in 20 seconds, so wait 60 seconds and ping
            this._isCollectingData = false;
            currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL;
        }
        else if (!this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_PING_WAIT_TIME && !this._lastSendSucceeded) {
            // Haven't pinged successfully in 60 seconds, so wait another 60 seconds
            currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL;
        }
        this._lastSendSucceeded = null;
        this._handle = setTimeout(this._goQuickPulse.bind(this), currentTimeout);
        this._handle.unref(); // Don't block apps from terminating
    };
    QuickPulseStateManager.prototype._ping = function (envelope) {
        this._sender.ping(envelope, this._quickPulseDone.bind(this));
    };
    QuickPulseStateManager.prototype._post = function (envelope) {
        this._sender.post(envelope, this._quickPulseDone.bind(this));
    };
    /**
     * Change the current QPS send state. (shouldPOST == undefined) --> error, but do not change the state yet.
     */
    QuickPulseStateManager.prototype._quickPulseDone = function (shouldPOST, res) {
        if (shouldPOST != undefined) {
            if (this._isCollectingData !== shouldPOST) {
                Logging.info("Live Metrics sending data", shouldPOST);
                this.enableCollectors(shouldPOST);
            }
            this._isCollectingData = shouldPOST;
            if (res && res.statusCode < 300 && res.statusCode >= 200) {
                this._lastSuccessTime = Date.now();
                this._lastSendSucceeded = true;
            }
            else {
                this._lastSendSucceeded = false;
            }
        }
        else {
            // Received an error, keep the state as is
            this._lastSendSucceeded = false;
        }
    };
    QuickPulseStateManager.MAX_POST_WAIT_TIME = 20000;
    QuickPulseStateManager.MAX_PING_WAIT_TIME = 60000;
    QuickPulseStateManager.FALLBACK_INTERVAL = 60000;
    QuickPulseStateManager.PING_INTERVAL = 5000;
    QuickPulseStateManager.POST_INTERVAL = 1000;
    return QuickPulseStateManager;
}());
module.exports = QuickPulseStateManager;


/***/ }),

/***/ 99181:
/***/ ((module) => {

"use strict";

module.exports = {
    /**
     * Request-Context header
     */
    requestContextHeader: "request-context",
    /**
     * Source instrumentation header that is added by an application while making http
     * requests and retrieved by the other application when processing incoming requests.
     */
    requestContextSourceKey: "appId",
    /**
     * Target instrumentation header that is added to the response and retrieved by the
     * calling application when processing incoming responses.
     */
    requestContextTargetKey: "appId",
    /**
     * Request-Id header
     */
    requestIdHeader: "request-id",
    /**
     * Legacy Header containing the id of the immidiate caller
     */
    parentIdHeader: "x-ms-request-id",
    /**
     * Legacy Header containing the correlation id that kept the same for every telemetry item
     * accross transactions
     */
    rootIdHeader: "x-ms-request-root-id",
    /**
     * Correlation-Context header
     *
     * Not currently actively used, but the contents should be passed from incoming to outgoing requests
     */
    correlationContextHeader: "correlation-context",
    /**
     * W3C distributed tracing protocol header
     */
    traceparentHeader: "traceparent",
    /**
     * W3C distributed tracing protocol state header
     */
    traceStateHeader: "tracestate"
};


/***/ }),

/***/ 85851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fs = __webpack_require__(57147);
var os = __webpack_require__(22037);
var path = __webpack_require__(71017);
var zlib = __webpack_require__(59796);
var child_process = __webpack_require__(32081);
var Logging = __webpack_require__(579);
var AutoCollectHttpDependencies = __webpack_require__(12992);
var Util = __webpack_require__(8928);
var Sender = (function () {
    function Sender(config, onSuccess, onError) {
        this._config = config;
        this._onSuccess = onSuccess;
        this._onError = onError;
        this._enableDiskRetryMode = false;
        this._resendInterval = Sender.WAIT_BETWEEN_RESEND;
        this._maxBytesOnDisk = Sender.MAX_BYTES_ON_DISK;
        this._numConsecutiveFailures = 0;
        if (!Sender.OS_PROVIDES_FILE_PROTECTION) {
            // Node's chmod levels do not appropriately restrict file access on Windows
            // Use the built-in command line tool ICACLS on Windows to properly restrict
            // access to the temporary directory used for disk retry mode.
            if (Sender.USE_ICACLS) {
                // This should be async - but it's currently safer to have this synchronous
                // This guarantees we can immediately fail setDiskRetryMode if we need to
                try {
                    Sender.OS_PROVIDES_FILE_PROTECTION = fs.existsSync(Sender.ICACLS_PATH);
                }
                catch (e) { }
                if (!Sender.OS_PROVIDES_FILE_PROTECTION) {
                    Logging.warn(Sender.TAG, "Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.");
                }
            }
            else {
                // chmod works everywhere else
                Sender.OS_PROVIDES_FILE_PROTECTION = true;
            }
        }
    }
    /**
    * Enable or disable offline mode
    */
    Sender.prototype.setDiskRetryMode = function (value, resendInterval, maxBytesOnDisk) {
        this._enableDiskRetryMode = Sender.OS_PROVIDES_FILE_PROTECTION && value;
        if (typeof resendInterval === 'number' && resendInterval >= 0) {
            this._resendInterval = Math.floor(resendInterval);
        }
        if (typeof maxBytesOnDisk === 'number' && maxBytesOnDisk >= 0) {
            this._maxBytesOnDisk = Math.floor(maxBytesOnDisk);
        }
        if (value && !Sender.OS_PROVIDES_FILE_PROTECTION) {
            this._enableDiskRetryMode = false;
            Logging.warn(Sender.TAG, "Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.");
        }
    };
    Sender.prototype.send = function (payload, callback) {
        var _this = this;
        var endpointUrl = this._config.endpointUrl;
        // todo: investigate specifying an agent here: https://nodejs.org/api/http.html#http_class_http_agent
        var options = {
            method: "POST",
            withCredentials: false,
            headers: {
                "Content-Type": "application/x-json-stream"
            }
        };
        zlib.gzip(payload, function (err, buffer) {
            var dataToSend = buffer;
            if (err) {
                Logging.warn(err);
                dataToSend = payload; // something went wrong so send without gzip
                options.headers["Content-Length"] = payload.length.toString();
            }
            else {
                options.headers["Content-Encoding"] = "gzip";
                options.headers["Content-Length"] = buffer.length;
            }
            Logging.info(Sender.TAG, options);
            // Ensure this request is not captured by auto-collection.
            options[AutoCollectHttpDependencies.disableCollectionRequestOption] = true;
            var requestCallback = function (res) {
                res.setEncoding("utf-8");
                //returns empty if the data is accepted
                var responseString = "";
                res.on("data", function (data) {
                    responseString += data;
                });
                res.on("end", function () {
                    _this._numConsecutiveFailures = 0;
                    Logging.info(Sender.TAG, responseString);
                    if (typeof _this._onSuccess === "function") {
                        _this._onSuccess(responseString);
                    }
                    if (typeof callback === "function") {
                        callback(responseString);
                    }
                    if (_this._enableDiskRetryMode) {
                        // try to send any cached events if the user is back online
                        if (res.statusCode === 200) {
                            setTimeout(function () { return _this._sendFirstFileOnDisk(); }, _this._resendInterval).unref();
                            // store to disk in case of burst throttling
                        }
                        else if (res.statusCode === 408 ||
                            res.statusCode === 429 ||
                            res.statusCode === 439 ||
                            res.statusCode === 500 ||
                            res.statusCode === 503) {
                            // TODO: Do not support partial success (206) until _sendFirstFileOnDisk checks payload age
                            _this._storeToDisk(payload);
                        }
                    }
                });
            };
            var req = Util.makeRequest(_this._config, endpointUrl, options, requestCallback);
            req.on("error", function (error) {
                // todo: handle error codes better (group to recoverable/non-recoverable and persist)
                _this._numConsecutiveFailures++;
                // Only use warn level if retries are disabled or we've had some number of consecutive failures sending data
                // This is because warn level is printed in the console by default, and we don't want to be noisy for transient and self-recovering errors
                // Continue informing on each failure if verbose logging is being used
                if (!_this._enableDiskRetryMode || _this._numConsecutiveFailures > 0 && _this._numConsecutiveFailures % Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN === 0) {
                    var notice = "Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:";
                    if (_this._enableDiskRetryMode) {
                        notice = "Ingestion endpoint could not be reached " + _this._numConsecutiveFailures + " consecutive times. There may be resulting telemetry loss. Most recent error:";
                    }
                    Logging.warn(Sender.TAG, notice, error);
                }
                else {
                    var notice = "Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:";
                    Logging.info(Sender.TAG, notice, error);
                }
                _this._onErrorHelper(error);
                if (typeof callback === "function") {
                    var errorMessage = "error sending telemetry";
                    if (error && (typeof error.toString === "function")) {
                        errorMessage = error.toString();
                    }
                    callback(errorMessage);
                }
                if (_this._enableDiskRetryMode) {
                    _this._storeToDisk(payload);
                }
            });
            req.write(dataToSend);
            req.end();
        });
    };
    Sender.prototype.saveOnCrash = function (payload) {
        if (this._enableDiskRetryMode) {
            this._storeToDiskSync(payload);
        }
    };
    Sender.prototype._runICACLS = function (args, callback) {
        var aclProc = child_process.spawn(Sender.ICACLS_PATH, args, { windowsHide: true });
        aclProc.on("error", function (e) { return callback(e); });
        aclProc.on("close", function (code, signal) {
            return callback(code === 0 ? null : new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + code + ")"));
        });
    };
    Sender.prototype._runICACLSSync = function (args) {
        // Some very old versions of Node (< 0.11) don't have this
        if (child_process.spawnSync) {
            var aclProc = child_process.spawnSync(Sender.ICACLS_PATH, args, { windowsHide: true });
            if (aclProc.error) {
                throw aclProc.error;
            }
            else if (aclProc.status !== 0) {
                throw new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + aclProc.status + ")");
            }
        }
        else {
            throw new Error("Could not synchronously call ICACLS under current version of Node.js");
        }
    };
    Sender.prototype._getACLIdentity = function (callback) {
        if (Sender.ACL_IDENTITY) {
            return callback(null, Sender.ACL_IDENTITY);
        }
        var psProc = child_process.spawn(Sender.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
            windowsHide: true,
            stdio: ['ignore', 'pipe', 'pipe'] // Needed to prevent hanging on Win 7
        });
        var data = "";
        psProc.stdout.on("data", function (d) { return data += d; });
        psProc.on("error", function (e) { return callback(e, null); });
        psProc.on("close", function (code, signal) {
            Sender.ACL_IDENTITY = data && data.trim();
            return callback(code === 0 ? null : new Error("Getting ACL identity did not succeed (PS returned code " + code + ")"), Sender.ACL_IDENTITY);
        });
    };
    Sender.prototype._getACLIdentitySync = function () {
        if (Sender.ACL_IDENTITY) {
            return Sender.ACL_IDENTITY;
        }
        // Some very old versions of Node (< 0.11) don't have this
        if (child_process.spawnSync) {
            var psProc = child_process.spawnSync(Sender.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
                windowsHide: true,
                stdio: ['ignore', 'pipe', 'pipe'] // Needed to prevent hanging on Win 7
            });
            if (psProc.error) {
                throw psProc.error;
            }
            else if (psProc.status !== 0) {
                throw new Error("Getting ACL identity did not succeed (PS returned code " + psProc.status + ")");
            }
            Sender.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim();
            return Sender.ACL_IDENTITY;
        }
        else {
            throw new Error("Could not synchronously get ACL identity under current version of Node.js");
        }
    };
    Sender.prototype._getACLArguments = function (directory, identity) {
        return [directory,
            "/grant", "*S-1-5-32-544:(OI)(CI)F",
            "/grant", identity + ":(OI)(CI)F",
            "/inheritance:r"]; // Remove all inherited permissions
    };
    Sender.prototype._applyACLRules = function (directory, callback) {
        var _this = this;
        if (!Sender.USE_ICACLS) {
            return callback(null);
        }
        // For performance, only run ACL rules if we haven't already during this session
        if (Sender.ACLED_DIRECTORIES[directory] === undefined) {
            // Avoid multiple calls race condition by setting ACLED_DIRECTORIES to false for this directory immediately
            // If batches are being failed faster than the processes spawned below return, some data won't be stored to disk
            // This is better than the alternative of potentially infinitely spawned processes
            Sender.ACLED_DIRECTORIES[directory] = false;
            // Restrict this directory to only current user and administrator access
            this._getACLIdentity(function (err, identity) {
                if (err) {
                    Sender.ACLED_DIRECTORIES[directory] = false; // false is used to cache failed (vs undefined which is "not yet tried")
                    return callback(err);
                }
                else {
                    _this._runICACLS(_this._getACLArguments(directory, identity), function (err) {
                        Sender.ACLED_DIRECTORIES[directory] = !err;
                        return callback(err);
                    });
                }
            });
        }
        else {
            return callback(Sender.ACLED_DIRECTORIES[directory] ? null :
                new Error("Setting ACL restrictions did not succeed (cached result)"));
        }
    };
    Sender.prototype._applyACLRulesSync = function (directory) {
        if (Sender.USE_ICACLS) {
            // For performance, only run ACL rules if we haven't already during this session
            if (Sender.ACLED_DIRECTORIES[directory] === undefined) {
                this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync()));
                Sender.ACLED_DIRECTORIES[directory] = true; // If we get here, it succeeded. _runIACLSSync will throw on failures
                return;
            }
            else if (!Sender.ACLED_DIRECTORIES[directory]) {
                throw new Error("Setting ACL restrictions did not succeed (cached result)");
            }
        }
    };
    Sender.prototype._confirmDirExists = function (directory, callback) {
        var _this = this;
        fs.lstat(directory, function (err, stats) {
            if (err && err.code === 'ENOENT') {
                fs.mkdir(directory, function (err) {
                    if (err && err.code !== 'EEXIST') {
                        callback(err);
                    }
                    else {
                        _this._applyACLRules(directory, callback);
                    }
                });
            }
            else if (!err && stats.isDirectory()) {
                _this._applyACLRules(directory, callback);
            }
            else {
                callback(err || new Error("Path existed but was not a directory"));
            }
        });
    };
    /**
     * Computes the size (in bytes) of all files in a directory at the root level. Asynchronously.
     */
    Sender.prototype._getShallowDirectorySize = function (directory, callback) {
        // Get the directory listing
        fs.readdir(directory, function (err, files) {
            if (err) {
                return callback(err, -1);
            }
            var error = null;
            var totalSize = 0;
            var count = 0;
            if (files.length === 0) {
                callback(null, 0);
                return;
            }
            // Query all file sizes
            for (var i = 0; i < files.length; i++) {
                fs.stat(path.join(directory, files[i]), function (err, fileStats) {
                    count++;
                    if (err) {
                        error = err;
                    }
                    else {
                        if (fileStats.isFile()) {
                            totalSize += fileStats.size;
                        }
                    }
                    if (count === files.length) {
                        // Did we get an error?
                        if (error) {
                            callback(error, -1);
                        }
                        else {
                            callback(error, totalSize);
                        }
                    }
                });
            }
        });
    };
    /**
     * Computes the size (in bytes) of all files in a directory at the root level. Synchronously.
     */
    Sender.prototype._getShallowDirectorySizeSync = function (directory) {
        var files = fs.readdirSync(directory);
        var totalSize = 0;
        for (var i = 0; i < files.length; i++) {
            totalSize += fs.statSync(path.join(directory, files[i])).size;
        }
        return totalSize;
    };
    /**
     * Stores the payload as a json file on disk in the temp directory
     */
    Sender.prototype._storeToDisk = function (payload) {
        var _this = this;
        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows
        var directory = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);
        // This will create the dir if it does not exist
        // Default permissions on *nix are directory listing from other users but no file creations
        Logging.info(Sender.TAG, "Checking existance of data storage directory: " + directory);
        this._confirmDirExists(directory, function (error) {
            if (error) {
                Logging.warn(Sender.TAG, "Error while checking/creating directory: " + (error && error.message));
                _this._onErrorHelper(error);
                return;
            }
            _this._getShallowDirectorySize(directory, function (err, size) {
                if (err || size < 0) {
                    Logging.warn(Sender.TAG, "Error while checking directory size: " + (err && err.message));
                    _this._onErrorHelper(err);
                    return;
                }
                else if (size > _this._maxBytesOnDisk) {
                    Logging.warn(Sender.TAG, "Not saving data due to max size limit being met. Directory size in bytes is: " + size);
                    return;
                }
                //create file - file name for now is the timestamp, a better approach would be a UUID but that
                //would require an external dependency
                var fileName = new Date().getTime() + ".ai.json";
                var fileFullPath = path.join(directory, fileName);
                // Mode 600 is w/r for creator and no read access for others (only applies on *nix)
                // For Windows, ACL rules are applied to the entire directory (see logic in _confirmDirExists and _applyACLRules)
                Logging.info(Sender.TAG, "saving data to disk at: " + fileFullPath);
                fs.writeFile(fileFullPath, payload, { mode: 384 }, function (error) { return _this._onErrorHelper(error); });
            });
        });
    };
    /**
     * Stores the payload as a json file on disk using sync file operations
     * this is used when storing data before crashes
     */
    Sender.prototype._storeToDiskSync = function (payload) {
        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows
        var directory = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);
        try {
            Logging.info(Sender.TAG, "Checking existance of data storage directory: " + directory);
            if (!fs.existsSync(directory)) {
                fs.mkdirSync(directory);
            }
            // Make sure permissions are valid
            this._applyACLRulesSync(directory);
            var dirSize = this._getShallowDirectorySizeSync(directory);
            if (dirSize > this._maxBytesOnDisk) {
                Logging.info(Sender.TAG, "Not saving data due to max size limit being met. Directory size in bytes is: " + dirSize);
                return;
            }
            //create file - file name for now is the timestamp, a better approach would be a UUID but that
            //would require an external dependency
            var fileName = new Date().getTime() + ".ai.json";
            var fileFullPath = path.join(directory, fileName);
            // Mode 600 is w/r for creator and no access for anyone else (only applies on *nix)
            Logging.info(Sender.TAG, "saving data before crash to disk at: " + fileFullPath);
            fs.writeFileSync(fileFullPath, payload, { mode: 384 });
        }
        catch (error) {
            Logging.warn(Sender.TAG, "Error while saving data to disk: " + (error && error.message));
            this._onErrorHelper(error);
        }
    };
    /**
     * Check for temp telemetry files
     * reads the first file if exist, deletes it and tries to send its load
     */
    Sender.prototype._sendFirstFileOnDisk = function () {
        var _this = this;
        var tempDir = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);
        fs.exists(tempDir, function (exists) {
            if (exists) {
                fs.readdir(tempDir, function (error, files) {
                    if (!error) {
                        files = files.filter(function (f) { return path.basename(f).indexOf(".ai.json") > -1; });
                        if (files.length > 0) {
                            var firstFile = files[0];
                            var filePath = path.join(tempDir, firstFile);
                            fs.readFile(filePath, function (error, payload) {
                                if (!error) {
                                    // delete the file first to prevent double sending
                                    fs.unlink(filePath, function (error) {
                                        if (!error) {
                                            _this.send(payload);
                                        }
                                        else {
                                            _this._onErrorHelper(error);
                                        }
                                    });
                                }
                                else {
                                    _this._onErrorHelper(error);
                                }
                            });
                        }
                    }
                    else {
                        _this._onErrorHelper(error);
                    }
                });
            }
        });
    };
    Sender.prototype._onErrorHelper = function (error) {
        if (typeof this._onError === "function") {
            this._onError(error);
        }
    };
    Sender.TAG = "Sender";
    Sender.ICACLS_PATH = process.env.systemdrive + "/windows/system32/icacls.exe";
    Sender.POWERSHELL_PATH = process.env.systemdrive + "/windows/system32/windowspowershell/v1.0/powershell.exe";
    Sender.ACLED_DIRECTORIES = {};
    Sender.ACL_IDENTITY = null;
    // the amount of time the SDK will wait between resending cached data, this buffer is to avoid any throtelling from the service side
    Sender.WAIT_BETWEEN_RESEND = 60 * 1000;
    Sender.MAX_BYTES_ON_DISK = 50 * 1000 * 1000;
    Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5;
    Sender.TEMPDIR_PREFIX = "appInsights-node";
    Sender.OS_PROVIDES_FILE_PROTECTION = false;
    Sender.USE_ICACLS = os.type() === "Windows_NT";
    return Sender;
}());
module.exports = Sender;


/***/ }),

/***/ 49255:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var url = __webpack_require__(57310);
var Config = __webpack_require__(4206);
var Context = __webpack_require__(21803);
var Contracts = __webpack_require__(22220);
var Channel = __webpack_require__(86576);
var TelemetryProcessors = __webpack_require__(13684);
var CorrelationContextManager_1 = __webpack_require__(77023);
var Sender = __webpack_require__(85851);
var Util = __webpack_require__(8928);
var Logging = __webpack_require__(579);
var EnvelopeFactory = __webpack_require__(13735);
/**
 * Application Insights telemetry client provides interface to track telemetry items, register telemetry initializers and
 * and manually trigger immediate sending (flushing)
 */
var TelemetryClient = (function () {
    /**
     * Constructs a new client of the client
     * @param iKey the instrumentation key to use (read from environment variable if not specified)
     */
    function TelemetryClient(iKey) {
        this._telemetryProcessors = [];
        var config = new Config(iKey);
        this.config = config;
        this.context = new Context();
        this.commonProperties = {};
        var sender = new Sender(this.config);
        this.channel = new Channel(function () { return config.disableAppInsights; }, function () { return config.maxBatchSize; }, function () { return config.maxBatchIntervalMs; }, sender);
    }
    /**
     * Log a trace message
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackTrace = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Trace);
    };
    /**
     * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.
     * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the
     * telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackMetric = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Metric);
    };
    /**
     * Log an exception
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackException = function (telemetry) {
        if (telemetry && telemetry.exception && !Util.isError(telemetry.exception)) {
            telemetry.exception = new Error(telemetry.exception.toString());
        }
        this.track(telemetry, Contracts.TelemetryType.Exception);
    };
    /**
     * Log a user action or other occurrence.
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackEvent = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Event);
    };
    /**
     * Log a request. Note that the default client will attempt to collect HTTP requests automatically so only use this for requests
     * that aren't automatically captured or if you've disabled automatic request collection.
     *
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackRequest = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Request);
    };
    /**
     * Log a dependency. Note that the default client will attempt to collect dependencies automatically so only use this for dependencies
     * that aren't automatically captured or if you've disabled automatic dependency collection.
     *
     * @param telemetry      Object encapsulating tracking option
     * */
    TelemetryClient.prototype.trackDependency = function (telemetry) {
        if (telemetry && !telemetry.target && telemetry.data) {
            // url.parse().host returns null for non-urls,
            // making this essentially a no-op in those cases
            // If this logic is moved, update jsdoc in DependencyTelemetry.target
            telemetry.target = url.parse(telemetry.data).host;
        }
        this.track(telemetry, Contracts.TelemetryType.Dependency);
    };
    /**
     * Immediately send all queued telemetry.
     * @param options Flush options, including indicator whether app is crashing and callback
     */
    TelemetryClient.prototype.flush = function (options) {
        this.channel.triggerSend(options ? !!options.isAppCrashing : false, options ? options.callback : undefined);
    };
    /**
     * Generic track method for all telemetry types
     * @param data the telemetry to send
     * @param telemetryType specify the type of telemetry you are tracking from the list of Contracts.DataTypes
     */
    TelemetryClient.prototype.track = function (telemetry, telemetryType) {
        if (telemetry && Contracts.telemetryTypeToBaseType(telemetryType)) {
            var envelope = EnvelopeFactory.createEnvelope(telemetry, telemetryType, this.commonProperties, this.context, this.config);
            // Set time on the envelope if it was set on the telemetry item
            if (telemetry.time) {
                envelope.time = telemetry.time.toISOString();
            }
            var accepted = this.runTelemetryProcessors(envelope, telemetry.contextObjects);
            // Ideally we would have a central place for "internal" telemetry processors and users can configure which ones are in use.
            // This will do for now. Otherwise clearTelemetryProcessors() would be problematic.
            accepted = accepted && TelemetryProcessors.samplingTelemetryProcessor(envelope, { correlationContext: CorrelationContextManager_1.CorrelationContextManager.getCurrentContext() });
            TelemetryProcessors.quickPulseTelemetryProcessor(envelope, this.quickPulseClient);
            if (accepted) {
                this.channel.send(envelope);
            }
        }
        else {
            Logging.warn("track() requires telemetry object and telemetryType to be specified.");
        }
    };
    /**
     * Adds telemetry processor to the collection. Telemetry processors will be called one by one
     * before telemetry item is pushed for sending and in the order they were added.
     *
     * @param telemetryProcessor function, takes Envelope, and optional context object and returns boolean
     */
    TelemetryClient.prototype.addTelemetryProcessor = function (telemetryProcessor) {
        this._telemetryProcessors.push(telemetryProcessor);
    };
    /*
     * Removes all telemetry processors
     */
    TelemetryClient.prototype.clearTelemetryProcessors = function () {
        this._telemetryProcessors = [];
    };
    TelemetryClient.prototype.runTelemetryProcessors = function (envelope, contextObjects) {
        var accepted = true;
        var telemetryProcessorsCount = this._telemetryProcessors.length;
        if (telemetryProcessorsCount === 0) {
            return accepted;
        }
        contextObjects = contextObjects || {};
        contextObjects['correlationContext'] = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        for (var i = 0; i < telemetryProcessorsCount; ++i) {
            try {
                var processor = this._telemetryProcessors[i];
                if (processor) {
                    if (processor.apply(null, [envelope, contextObjects]) === false) {
                        accepted = false;
                        break;
                    }
                }
            }
            catch (error) {
                accepted = true;
                Logging.warn("One of telemetry processors failed, telemetry item will be sent.", error, envelope);
            }
        }
        return accepted;
    };
    return TelemetryClient;
}());
module.exports = TelemetryClient;


/***/ }),

/***/ 29337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Util = __webpack_require__(8928);
var CorrelationIdManager = __webpack_require__(74686);
/**
 * Helper class to manage parsing and validation of traceparent header. Also handles hierarchical
 * back-compatibility headers generated from traceparent. W3C traceparent spec is documented at
 * https://www.w3.org/TR/trace-context/#traceparent-field
 */
var Traceparent = (function () {
    function Traceparent(traceparent, parentId) {
        this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG;
        this.version = Traceparent.DEFAULT_VERSION;
        if (traceparent && typeof traceparent === "string") {
            // If incoming request contains traceparent: parse it, set operation, parent and telemetry id accordingly. traceparent should be injected into outgoing requests. request-id should be injected in back-compat format |traceId.spanId. so that older SDKs could understand it.
            if (traceparent.split(",").length > 1) {
                this.traceId = Util.w3cTraceId();
                this.spanId = Util.w3cTraceId().substr(0, 16);
            }
            else {
                var traceparentArr = traceparent.trim().split("-");
                var len = traceparentArr.length;
                if (len >= 4) {
                    this.version = traceparentArr[0];
                    this.traceId = traceparentArr[1];
                    this.spanId = traceparentArr[2];
                    this.traceFlag = traceparentArr[3];
                }
                else {
                    this.traceId = Util.w3cTraceId();
                    this.spanId = Util.w3cTraceId().substr(0, 16);
                }
                // Version validation
                if (!this.version.match(/^[0-9a-f]{2}$/g)) {
                    this.version = Traceparent.DEFAULT_VERSION;
                    this.traceId = Util.w3cTraceId();
                }
                if (this.version === "00" && len !== 4) {
                    this.traceId = Util.w3cTraceId();
                    this.spanId = Util.w3cTraceId().substr(0, 16);
                }
                if (this.version === "ff") {
                    this.version = Traceparent.DEFAULT_VERSION;
                    this.traceId = Util.w3cTraceId();
                    this.spanId = Util.w3cTraceId().substr(0, 16);
                }
                if (!this.version.match(/^0[0-9a-f]$/g)) {
                    this.version = Traceparent.DEFAULT_VERSION;
                }
                // TraceFlag validation
                if (!this.traceFlag.match(/^[0-9a-f]{2}$/g)) {
                    this.traceFlag = Traceparent.DEFAULT_VERSION;
                    this.traceId = Util.w3cTraceId();
                }
                // Validate TraceId, regenerate new traceid if invalid
                if (!Traceparent.isValidTraceId(this.traceId)) {
                    this.traceId = Util.w3cTraceId();
                }
                // Validate Span Id, discard entire traceparent if invalid
                if (!Traceparent.isValidSpanId(this.spanId)) {
                    this.spanId = Util.w3cTraceId().substr(0, 16);
                    this.traceId = Util.w3cTraceId();
                }
                // Save backCompat parentId
                this.parentId = this.getBackCompatRequestId();
            }
        }
        else if (parentId) {
            // If incoming request contains only request-id, new traceid and spanid should be started, request-id value should be used as a parent. Root part of request-id should be stored in custom dimension on the request telemetry if root part is different from traceid. On the outgoing request side, request-id should be emitted in the |traceId.spanId. format.
            this.parentId = parentId.slice(); // copy
            var operationId = CorrelationIdManager.getRootId(parentId);
            if (!Traceparent.isValidTraceId(operationId)) {
                this.legacyRootId = operationId;
                operationId = Util.w3cTraceId();
            }
            if (parentId.indexOf("|") !== -1) {
                parentId = parentId.substring(1 + parentId.substring(0, parentId.length - 1).lastIndexOf("."), parentId.length - 1);
            }
            this.traceId = operationId;
            this.spanId = parentId;
        }
        else {
            // Fallback default constructor
            // if request does not contain any correlation headers, see case p2
            this.traceId = Util.w3cTraceId();
            this.spanId = Util.w3cTraceId().substr(0, 16);
        }
    }
    Traceparent.isValidTraceId = function (id) {
        return id.match(/^[0-9a-f]{32}$/) && id !== "00000000000000000000000000000000";
    };
    Traceparent.isValidSpanId = function (id) {
        return id.match(/^[0-9a-f]{16}$/) && id !== "0000000000000000";
    };
    Traceparent.prototype.getBackCompatRequestId = function () {
        return "|" + this.traceId + "." + this.spanId + ".";
    };
    Traceparent.prototype.toString = function () {
        return this.version + "-" + this.traceId + "-" + this.spanId + "-" + this.traceFlag;
    };
    Traceparent.prototype.updateSpanId = function () {
        this.spanId = Util.w3cTraceId().substr(0, 16);
    };
    Traceparent.DEFAULT_TRACE_FLAG = "00";
    Traceparent.DEFAULT_VERSION = "00";
    return Traceparent;
}());
module.exports = Traceparent;


/***/ }),

/***/ 91223:
/***/ ((module) => {

"use strict";

/**
 * Helper class to manage parsing and strict-validation of tracestate header. W3C tracestate spec
 * is documented at https://www.w3.org/TR/trace-context/#header-value
 * @class Tracestate
 */
var Tracestate = (function () {
    // if true, performs strict tracestate header checking, else just passes it along
    function Tracestate(id) {
        this.fieldmap = [];
        if (!id) {
            return;
        }
        this.fieldmap = this.parseHeader(id);
    }
    Tracestate.prototype.toString = function () {
        var fieldarr = this.fieldmap;
        if (!fieldarr || fieldarr.length == 0) {
            return null;
        }
        return fieldarr.join(", ");
    };
    Tracestate.validateKeyChars = function (key) {
        var keyParts = key.split("@");
        if (keyParts.length == 2) {
            // Parse for tenant@vendor format
            var tenant = keyParts[0].trim();
            var vendor = keyParts[1].trim();
            var tenantValid = Boolean(tenant.match(/^[\ ]?[a-z0-9\*\-\_/]{1,241}$/));
            var vendorValid = Boolean(vendor.match(/^[\ ]?[a-z0-9\*\-\_/]{1,14}$/));
            return tenantValid && vendorValid;
        }
        else if (keyParts.length == 1) {
            // Parse for standard key format
            return Boolean(key.match(/^[\ ]?[a-z0-9\*\-\_/]{1,256}$/));
        }
        return false;
    };
    Tracestate.prototype.parseHeader = function (id) {
        var res = [];
        var keydeduper = {};
        var parts = id.split(",");
        if (parts.length > 32)
            return null;
        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
            var rawPart = parts_1[_i];
            var part = rawPart.trim(); // trim out whitespace
            if (part.length === 0) {
                continue; // Discard empty pairs, but keep the rest of this tracestate
            }
            var pair = part.split("=");
            // pair should contain exactly one "="
            if (pair.length !== 2) {
                return null; // invalid pair: discard entire tracestate
            }
            // Validate length and charset of this key
            if (!Tracestate.validateKeyChars(pair[0])) {
                return null;
            }
            // Assert uniqueness of this key
            if (keydeduper[pair[0]]) {
                return null; // duplicate key: discard entire tracestate
            }
            else {
                keydeduper[pair[0]] = true;
            }
            // All checks passed -- add this part
            res.push(part);
        }
        return res;
    };
    Tracestate.strict = true;
    return Tracestate;
}());
module.exports = Tracestate;


/***/ }),

/***/ 8928:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var http = __webpack_require__(13685);
var https = __webpack_require__(95687);
var url = __webpack_require__(57310);
var constants = __webpack_require__(22057);
var Logging = __webpack_require__(579);
var RequestResponseHeaders = __webpack_require__(99181);
var Util = (function () {
    function Util() {
    }
    /**
     * helper method to access userId and sessionId cookie
     */
    Util.getCookie = function (name, cookie) {
        var value = "";
        if (name && name.length && typeof cookie === "string") {
            var cookieName = name + "=";
            var cookies = cookie.split(";");
            for (var i = 0; i < cookies.length; i++) {
                var cookie = cookies[i];
                cookie = Util.trim(cookie);
                if (cookie && cookie.indexOf(cookieName) === 0) {
                    value = cookie.substring(cookieName.length, cookies[i].length);
                    break;
                }
            }
        }
        return value;
    };
    /**
     * helper method to trim strings (IE8 does not implement String.prototype.trim)
     */
    Util.trim = function (str) {
        if (typeof str === "string") {
            return str.replace(/^\s+|\s+$/g, "");
        }
        else {
            return "";
        }
    };
    /**
     * Convert an array of int32 to Base64 (no '==' at the end).
     * MSB first.
     */
    Util.int32ArrayToBase64 = function (array) {
        var toChar = function (v, i) {
            return String.fromCharCode((v >> i) & 0xFF);
        };
        var int32AsString = function (v) {
            return toChar(v, 24) + toChar(v, 16) + toChar(v, 8) + toChar(v, 0);
        };
        var x = array.map(int32AsString).join("");
        var b = Buffer.from ? Buffer.from(x, "binary") : new Buffer(x, "binary");
        var s = b.toString("base64");
        return s.substr(0, s.indexOf("="));
    };
    /**
     * generate a random 32bit number (-0x80000000..0x7FFFFFFF).
     */
    Util.random32 = function () {
        return (0x100000000 * Math.random()) | 0;
    };
    /**
     * generate a random 32bit number (0x00000000..0xFFFFFFFF).
     */
    Util.randomu32 = function () {
        return Util.random32() + 0x80000000;
    };
    /**
     * generate W3C-compatible trace id
     * https://github.com/w3c/distributed-tracing/blob/master/trace_context/HTTP_HEADER_FORMAT.md#trace-id
     */
    Util.w3cTraceId = function () {
        var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        // rfc4122 version 4 UUID without dashes and with lowercase letters
        var oct = "", tmp;
        for (var a = 0; a < 4; a++) {
            tmp = Util.random32();
            oct +=
                hexValues[tmp & 0xF] +
                    hexValues[tmp >> 4 & 0xF] +
                    hexValues[tmp >> 8 & 0xF] +
                    hexValues[tmp >> 12 & 0xF] +
                    hexValues[tmp >> 16 & 0xF] +
                    hexValues[tmp >> 20 & 0xF] +
                    hexValues[tmp >> 24 & 0xF] +
                    hexValues[tmp >> 28 & 0xF];
        }
        // "Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively"
        var clockSequenceHi = hexValues[8 + (Math.random() * 4) | 0];
        return oct.substr(0, 8) + oct.substr(9, 4) + "4" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);
    };
    Util.isValidW3CId = function (id) {
        return id.length === 32 && id !== "00000000000000000000000000000000";
    };
    /**
     * Check if an object is of type Array
     */
    Util.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };
    /**
     * Check if an object is of type Error
     */
    Util.isError = function (obj) {
        return obj instanceof Error;
    };
    Util.isPrimitive = function (input) {
        var propType = typeof input;
        return propType === "string" || propType === "number" || propType === "boolean";
    };
    /**
     * Check if an object is of type Date
     */
    Util.isDate = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Date]";
    };
    /**
     * Convert ms to c# time span format
     */
    Util.msToTimeSpan = function (totalms) {
        if (isNaN(totalms) || totalms < 0) {
            totalms = 0;
        }
        var sec = ((totalms / 1000) % 60).toFixed(7).replace(/0{0,4}$/, "");
        var min = "" + Math.floor(totalms / (1000 * 60)) % 60;
        var hour = "" + Math.floor(totalms / (1000 * 60 * 60)) % 24;
        var days = Math.floor(totalms / (1000 * 60 * 60 * 24));
        sec = sec.indexOf(".") < 2 ? "0" + sec : sec;
        min = min.length < 2 ? "0" + min : min;
        hour = hour.length < 2 ? "0" + hour : hour;
        var daysText = days > 0 ? days + "." : "";
        return daysText + hour + ":" + min + ":" + sec;
    };
    /**
     * Using JSON.stringify, by default Errors do not serialize to something useful:
     * Simplify a generic Node Error into a simpler map for customDimensions
     * Custom errors can still implement toJSON to override this functionality
     */
    Util.extractError = function (err) {
        // Error is often subclassed so may have code OR id properties:
        // https://nodejs.org/api/errors.html#errors_error_code
        var looseError = err;
        return {
            message: err.message,
            code: looseError.code || looseError.id || "",
        };
    };
    /**
     * Manually call toJSON if available to pre-convert the value.
     * If a primitive is returned, then the consumer of this function can skip JSON.stringify.
     * This avoids double escaping of quotes for Date objects, for example.
     */
    Util.extractObject = function (origProperty) {
        if (origProperty instanceof Error) {
            return Util.extractError(origProperty);
        }
        if (typeof origProperty.toJSON === "function") {
            return origProperty.toJSON();
        }
        return origProperty;
    };
    /**
     * Validate that an object is of type { [key: string]: string }
     */
    Util.validateStringMap = function (obj) {
        if (typeof obj !== "object") {
            Logging.info("Invalid properties dropped from payload");
            return;
        }
        var map = {};
        for (var field in obj) {
            var property = '';
            var origProperty = obj[field];
            var propType = typeof origProperty;
            if (Util.isPrimitive(origProperty)) {
                property = origProperty.toString();
            }
            else if (origProperty === null || propType === "undefined") {
                property = "";
            }
            else if (propType === "function") {
                Logging.info("key: " + field + " was function; will not serialize");
                continue;
            }
            else {
                var stringTarget = Util.isArray(origProperty) ? origProperty : Util.extractObject(origProperty);
                try {
                    if (Util.isPrimitive(stringTarget)) {
                        property = stringTarget;
                    }
                    else {
                        property = JSON.stringify(stringTarget);
                    }
                }
                catch (e) {
                    property = origProperty.constructor.name.toString() + " (Error: " + e.message + ")";
                    Logging.info("key: " + field + ", could not be serialized");
                }
            }
            map[field] = property.substring(0, Util.MAX_PROPERTY_LENGTH);
        }
        return map;
    };
    /**
     * Checks if a request url is not on a excluded domain list
     * and if it is safe to add correlation headers
     */
    Util.canIncludeCorrelationHeader = function (client, requestUrl) {
        var excludedDomains = client && client.config && client.config.correlationHeaderExcludedDomains;
        if (!excludedDomains || excludedDomains.length == 0 || !requestUrl) {
            return true;
        }
        for (var i = 0; i < excludedDomains.length; i++) {
            var regex = new RegExp(excludedDomains[i].replace(/\./g, "\.").replace(/\*/g, ".*"));
            if (regex.test(url.parse(requestUrl).hostname)) {
                return false;
            }
        }
        return true;
    };
    Util.getCorrelationContextTarget = function (response, key) {
        var contextHeaders = response.headers && response.headers[RequestResponseHeaders.requestContextHeader];
        if (contextHeaders) {
            var keyValues = contextHeaders.split(",");
            for (var i = 0; i < keyValues.length; ++i) {
                var keyValue = keyValues[i].split("=");
                if (keyValue.length == 2 && keyValue[0] == key) {
                    return keyValue[1];
                }
            }
        }
    };
    /**
     * Generate request
     *
     * Proxify the request creation to handle proxy http
     *
     * @param {string} requestUrl url endpoint
     * @param {Object} requestOptions Request option
     * @param {Function} requestCallback callback on request
     * @returns {http.ClientRequest} request object
     */
    Util.makeRequest = function (config, requestUrl, requestOptions, requestCallback) {
        if (requestUrl && requestUrl.indexOf('//') === 0) {
            requestUrl = 'https:' + requestUrl;
        }
        var requestUrlParsed = url.parse(requestUrl);
        var options = __assign({}, requestOptions, { host: requestUrlParsed.hostname, port: requestUrlParsed.port, path: requestUrlParsed.pathname });
        var proxyUrl = undefined;
        if (requestUrlParsed.protocol === 'https:') {
            proxyUrl = config.proxyHttpsUrl || undefined;
        }
        if (requestUrlParsed.protocol === 'http:') {
            proxyUrl = config.proxyHttpUrl || undefined;
        }
        if (proxyUrl) {
            if (proxyUrl.indexOf('//') === 0) {
                proxyUrl = 'http:' + proxyUrl;
            }
            var proxyUrlParsed = url.parse(proxyUrl);
            // https is not supported at the moment
            if (proxyUrlParsed.protocol === 'https:') {
                Logging.info("Proxies that use HTTPS are not supported");
                proxyUrl = undefined;
            }
            else {
                options = __assign({}, options, { host: proxyUrlParsed.hostname, port: proxyUrlParsed.port || "80", path: requestUrl, headers: __assign({}, options.headers, { Host: requestUrlParsed.hostname }) });
            }
        }
        var isHttps = requestUrlParsed.protocol === 'https:' && !proxyUrl;
        if (isHttps && config.httpsAgent !== undefined) {
            options.agent = config.httpsAgent;
        }
        else if (!isHttps && config.httpAgent !== undefined) {
            options.agent = config.httpAgent;
        }
        else if (isHttps) {
            // HTTPS without a passed in agent. Use one that enforces our TLS rules
            options.agent = Util.tlsRestrictedAgent;
        }
        if (isHttps) {
            return https.request(options, requestCallback);
        }
        else {
            return http.request(options, requestCallback);
        }
    };
    ;
    /**
     * Parse standard <string | string[] | number> request-context header
     */
    Util.safeIncludeCorrelationHeader = function (client, request, correlationHeader) {
        var header; // attempt to cast correlationHeader to string
        if (typeof correlationHeader === "string") {
            header = correlationHeader;
        }
        else if (correlationHeader instanceof Array) {
            header = correlationHeader.join(",");
        }
        else if (correlationHeader && typeof correlationHeader.toString === "function") {
            // best effort attempt: requires well-defined toString
            try {
                header = correlationHeader.toString();
            }
            catch (err) {
                Logging.warn("Outgoing request-context header could not be read. Correlation of requests may be lost.", err, correlationHeader);
            }
        }
        if (header) {
            Util.addCorrelationIdHeaderFromString(client, request, header);
        }
        else {
            request.setHeader(RequestResponseHeaders.requestContextHeader, RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
        }
    };
    Util.addCorrelationIdHeaderFromString = function (client, response, correlationHeader) {
        var components = correlationHeader.split(",");
        var key = RequestResponseHeaders.requestContextSourceKey + "=";
        var found = components.some(function (value) { return value.substring(0, key.length) === key; });
        if (!found) {
            response.setHeader(RequestResponseHeaders.requestContextHeader, correlationHeader + "," + RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
        }
    };
    Util.MAX_PROPERTY_LENGTH = 8192;
    Util.tlsRestrictedAgent = new https.Agent({
        secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 |
            constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1
    });
    return Util;
}());
module.exports = Util;


/***/ }),

/***/ 99406:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var AutoCollectPerformance = __webpack_require__(62900);
function quickPulseTelemetryProcessor(envelope, client) {
    if (client) {
        client.addDocument(envelope);
        // Increment rate counters
        switch (envelope.data.baseType) {
            case "ExceptionData":
                AutoCollectPerformance.countException();
                break;
            case "RequestData":
                // These are already autocounted by HttpRequest.
                // Note: Not currently counting manual trackRequest calls
                // here to avoid affecting existing autocollection metrics
                break;
            case "RemoteDependencyData":
                var baseData = envelope.data.baseData;
                AutoCollectPerformance.countDependency(baseData.duration, baseData.success);
                break;
        }
    }
    return true;
}
exports.quickPulseTelemetryProcessor = quickPulseTelemetryProcessor;


/***/ }),

/***/ 6770:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Contracts = __webpack_require__(22220);
/**
 *  A telemetry processor that handles sampling.
 */
function samplingTelemetryProcessor(envelope, contextObjects) {
    var samplingPercentage = envelope.sampleRate; // Set for us in Client.getEnvelope
    var isSampledIn = false;
    if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {
        return true;
    }
    else if (envelope.data && Contracts.TelemetryType.Metric === Contracts.baseTypeToTelemetryType(envelope.data.baseType)) {
        // Exclude MetricData telemetry from sampling
        return true;
    }
    else if (contextObjects.correlationContext && contextObjects.correlationContext.operation) {
        // If we're using dependency correlation, sampling should retain all telemetry from a given request
        isSampledIn = getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage;
    }
    else {
        // If we're not using dependency correlation, sampling should use a random distribution on each item
        isSampledIn = (Math.random() * 100) < samplingPercentage;
    }
    return isSampledIn;
}
exports.samplingTelemetryProcessor = samplingTelemetryProcessor;
/** Ported from AI .NET SDK */
function getSamplingHashCode(input) {
    var csharpMin = -2147483648;
    var csharpMax = 2147483647;
    var hash = 5381;
    if (!input) {
        return 0;
    }
    while (input.length < 8) {
        input = input + input;
    }
    for (var i = 0; i < input.length; i++) {
        // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)
        hash = ((((hash << 5) + hash) | 0) + input.charCodeAt(i) | 0);
    }
    hash = hash <= csharpMin ? csharpMax : Math.abs(hash);
    return (hash / csharpMax) * 100;
}
exports.getSamplingHashCode = getSamplingHashCode;


/***/ }),

/***/ 13684:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(6770));
__export(__webpack_require__(99406));


/***/ }),

/***/ 14585:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var CorrelationContextManager = __webpack_require__(77023); // Keep this first
var AutoCollectConsole = __webpack_require__(99519);
var AutoCollectExceptions = __webpack_require__(23414);
var AutoCollectPerformance = __webpack_require__(62900);
var AutoCollectHttpDependencies = __webpack_require__(12992);
var AutoCollectHttpRequests = __webpack_require__(46281);
var CorrelationIdManager = __webpack_require__(74686);
var Logging = __webpack_require__(579);
var QuickPulseClient = __webpack_require__(7445);
var NativePerformance_1 = __webpack_require__(79498);
// We export these imports so that SDK users may use these classes directly.
// They're exposed using "export import" so that types are passed along as expected
exports.TelemetryClient = __webpack_require__(83103);
exports.Contracts = __webpack_require__(22220);
var DistributedTracingModes;
(function (DistributedTracingModes) {
    /**
     * (Default) Send Application Insights correlation headers
     */
    DistributedTracingModes[DistributedTracingModes["AI"] = 0] = "AI";
    /**
     * Send both W3C Trace Context headers and back-compatibility Application Insights headers
     */
    DistributedTracingModes[DistributedTracingModes["AI_AND_W3C"] = 1] = "AI_AND_W3C";
})(DistributedTracingModes = exports.DistributedTracingModes || (exports.DistributedTracingModes = {}));
// Default autocollection configuration
var _isConsole = true;
var _isConsoleLog = false;
var _isExceptions = true;
var _isPerformance = true;
var _isRequests = true;
var _isDependencies = true;
var _isDiskRetry = true;
var _isCorrelating = true;
var _forceClsHooked;
var _isSendingLiveMetrics = false; // Off by default
var _isNativePerformance = true;
var _disabledExtendedMetrics;
var _diskRetryInterval = undefined;
var _diskRetryMaxBytes = undefined;
var _console;
var _exceptions;
var _performance;
var _nativePerformance;
var _serverRequests;
var _clientRequests;
var _isStarted = false;
var _performanceLiveMetrics;
/**
 * Initializes the default client. Should be called after setting
 * configuration options.
 *
 * @param instrumentationKey the instrumentation key to use. Optional, if
 * this is not specified, the value will be read from the environment
 * variable APPINSIGHTS_INSTRUMENTATIONKEY.
 * @returns {Configuration} the configuration class to initialize
 * and start the SDK.
 */
function setup(instrumentationKey) {
    if (!exports.defaultClient) {
        exports.defaultClient = new exports.TelemetryClient(instrumentationKey);
        _console = new AutoCollectConsole(exports.defaultClient);
        _exceptions = new AutoCollectExceptions(exports.defaultClient);
        _performance = new AutoCollectPerformance(exports.defaultClient);
        _serverRequests = new AutoCollectHttpRequests(exports.defaultClient);
        _clientRequests = new AutoCollectHttpDependencies(exports.defaultClient);
        if (!_nativePerformance) {
            _nativePerformance = new NativePerformance_1.AutoCollectNativePerformance(exports.defaultClient);
        }
    }
    else {
        Logging.info("The default client is already setup");
    }
    if (exports.defaultClient && exports.defaultClient.channel) {
        exports.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes);
    }
    return Configuration;
}
exports.setup = setup;
/**
 * Starts automatic collection of telemetry. Prior to calling start no
 * telemetry will be *automatically* collected, though manual collection
 * is enabled.
 * @returns {ApplicationInsights} this class
 */
function start() {
    if (!!exports.defaultClient) {
        _isStarted = true;
        _console.enable(_isConsole, _isConsoleLog);
        _exceptions.enable(_isExceptions);
        _performance.enable(_isPerformance);
        _nativePerformance.enable(_isNativePerformance, _disabledExtendedMetrics);
        _serverRequests.useAutoCorrelation(_isCorrelating, _forceClsHooked);
        _serverRequests.enable(_isRequests);
        _clientRequests.enable(_isDependencies);
        if (exports.liveMetricsClient && _isSendingLiveMetrics) {
            exports.liveMetricsClient.enable(_isSendingLiveMetrics);
        }
    }
    else {
        Logging.warn("Start cannot be called before setup");
    }
    return Configuration;
}
exports.start = start;
/**
 * Returns an object that is shared across all code handling a given request.
 * This can be used similarly to thread-local storage in other languages.
 * Properties set on this object will be available to telemetry processors.
 *
 * Do not store sensitive information here.
 * Custom properties set on this object can be exposed in a future SDK
 * release via outgoing HTTP headers.
 * This is to allow for correlating data cross-component.
 *
 * This method will return null if automatic dependency correlation is disabled.
 * @returns A plain object for request storage or null if automatic dependency correlation is disabled.
 */
function getCorrelationContext() {
    if (_isCorrelating) {
        return CorrelationContextManager.CorrelationContextManager.getCurrentContext();
    }
    return null;
}
exports.getCorrelationContext = getCorrelationContext;
/**
 * Returns a function that will get the same correlation context within its
 * function body as the code executing this function.
 * Use this method if automatic dependency correlation is not propagating
 * correctly to an asynchronous callback.
 */
function wrapWithCorrelationContext(fn) {
    return CorrelationContextManager.CorrelationContextManager.wrapCallback(fn);
}
exports.wrapWithCorrelationContext = wrapWithCorrelationContext;
/**
 * The active configuration for global SDK behaviors, such as autocollection.
 */
var Configuration = (function () {
    function Configuration() {
    }
    /**
     * Sets the distributed tracing modes. If W3C mode is enabled, W3C trace context
     * headers (traceparent/tracestate) will be parsed in all incoming requests, and included in outgoing
     * requests. In W3C mode, existing back-compatibility AI headers will also be parsed and included.
     * Enabling W3C mode will not break existing correlation with other Application Insights instrumented
     * services. Default=AI
    */
    Configuration.setDistributedTracingMode = function (value) {
        CorrelationIdManager.w3cEnabled = value === DistributedTracingModes.AI_AND_W3C;
        return Configuration;
    };
    /**
     * Sets the state of console and logger tracking (enabled by default for third-party loggers only)
     * @param value if true logger activity will be sent to Application Insights
     * @param collectConsoleLog if true, logger autocollection will include console.log calls (default false)
     * @returns {Configuration} this class
     */
    Configuration.setAutoCollectConsole = function (value, collectConsoleLog) {
        if (collectConsoleLog === void 0) { collectConsoleLog = false; }
        _isConsole = value;
        _isConsoleLog = collectConsoleLog;
        if (_isStarted) {
            _console.enable(value, collectConsoleLog);
        }
        return Configuration;
    };
    /**
     * Sets the state of exception tracking (enabled by default)
     * @param value if true uncaught exceptions will be sent to Application Insights
     * @returns {Configuration} this class
     */
    Configuration.setAutoCollectExceptions = function (value) {
        _isExceptions = value;
        if (_isStarted) {
            _exceptions.enable(value);
        }
        return Configuration;
    };
    /**
     * Sets the state of performance tracking (enabled by default)
     * @param value if true performance counters will be collected every second and sent to Application Insights
     * @param collectExtendedMetrics if true, extended metrics counters will be collected every minute and sent to Application Insights
     * @returns {Configuration} this class
     */
    Configuration.setAutoCollectPerformance = function (value, collectExtendedMetrics) {
        if (collectExtendedMetrics === void 0) { collectExtendedMetrics = true; }
        _isPerformance = value;
        var extendedMetricsConfig = NativePerformance_1.AutoCollectNativePerformance.parseEnabled(collectExtendedMetrics);
        _isNativePerformance = extendedMetricsConfig.isEnabled;
        _disabledExtendedMetrics = extendedMetricsConfig.disabledMetrics;
        if (_isStarted) {
            _performance.enable(value);
            _nativePerformance.enable(extendedMetricsConfig.isEnabled, extendedMetricsConfig.disabledMetrics);
        }
        return Configuration;
    };
    /**
     * Sets the state of request tracking (enabled by default)
     * @param value if true requests will be sent to Application Insights
     * @returns {Configuration} this class
     */
    Configuration.setAutoCollectRequests = function (value) {
        _isRequests = value;
        if (_isStarted) {
            _serverRequests.enable(value);
        }
        return Configuration;
    };
    /**
     * Sets the state of dependency tracking (enabled by default)
     * @param value if true dependencies will be sent to Application Insights
     * @returns {Configuration} this class
     */
    Configuration.setAutoCollectDependencies = function (value) {
        _isDependencies = value;
        if (_isStarted) {
            _clientRequests.enable(value);
        }
        return Configuration;
    };
    /**
     * Sets the state of automatic dependency correlation (enabled by default)
     * @param value if true dependencies will be correlated with requests
     * @param useAsyncHooks if true, forces use of experimental async_hooks module to provide correlation. If false, instead uses only patching-based techniques. If left blank, the best option is chosen for you based on your version of Node.js.
     * @returns {Configuration} this class
     */
    Configuration.setAutoDependencyCorrelation = function (value, useAsyncHooks) {
        _isCorrelating = value;
        _forceClsHooked = useAsyncHooks;
        if (_isStarted) {
            _serverRequests.useAutoCorrelation(value, useAsyncHooks);
        }
        return Configuration;
    };
    /**
     * Enable or disable disk-backed retry caching to cache events when client is offline (enabled by default)
     * Note that this method only applies to the default client. Disk-backed retry caching is disabled by default for additional clients.
     * For enable for additional clients, use client.channel.setUseDiskRetryCaching(true).
     * These cached events are stored in your system or user's temporary directory and access restricted to your user when possible.
     * @param value if true events that occured while client is offline will be cached on disk
     * @param resendInterval The wait interval for resending cached events.
     * @param maxBytesOnDisk The maximum size (in bytes) that the created temporary directory for cache events can grow to, before caching is disabled.
     * @returns {Configuration} this class
     */
    Configuration.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {
        _isDiskRetry = value;
        _diskRetryInterval = resendInterval;
        _diskRetryMaxBytes = maxBytesOnDisk;
        if (exports.defaultClient && exports.defaultClient.channel) {
            exports.defaultClient.channel.setUseDiskRetryCaching(value, resendInterval, maxBytesOnDisk);
        }
        return Configuration;
    };
    /**
     * Enables debug and warning logging for AppInsights itself.
     * @param enableDebugLogging if true, enables debug logging
     * @param enableWarningLogging if true, enables warning logging
     * @returns {Configuration} this class
     */
    Configuration.setInternalLogging = function (enableDebugLogging, enableWarningLogging) {
        if (enableDebugLogging === void 0) { enableDebugLogging = false; }
        if (enableWarningLogging === void 0) { enableWarningLogging = true; }
        Logging.enableDebug = enableDebugLogging;
        Logging.disableWarnings = !enableWarningLogging;
        return Configuration;
    };
    /**
     * Enables communication with Application Insights Live Metrics.
     * @param enable if true, enables communication with the live metrics service
     */
    Configuration.setSendLiveMetrics = function (enable) {
        if (enable === void 0) { enable = false; }
        if (!exports.defaultClient) {
            // Need a defaultClient so that we can add the QPS telemetry processor to it
            Logging.warn("Live metrics client cannot be setup without the default client");
            return Configuration;
        }
        if (!exports.liveMetricsClient) {
            // No qps client exists. Create one and prepare it to be enabled at .start()
            exports.liveMetricsClient = new QuickPulseClient(exports.defaultClient.config.instrumentationKey);
            _performanceLiveMetrics = new AutoCollectPerformance(exports.liveMetricsClient, 1000, true);
            exports.liveMetricsClient.addCollector(_performanceLiveMetrics);
            exports.defaultClient.quickPulseClient = exports.liveMetricsClient; // Need this so we can forward all manual tracks to live metrics via quickPulseTelemetryProcessor
            _isSendingLiveMetrics = enable;
        }
        else {
            // qps client already exists; enable/disable it
            exports.liveMetricsClient.enable(enable);
        }
        return Configuration;
    };
    // Convenience shortcut to ApplicationInsights.start
    Configuration.start = start;
    return Configuration;
}());
exports.Configuration = Configuration;
/**
 * Disposes the default client and all the auto collectors so they can be reinitialized with different configuration
*/
function dispose() {
    exports.defaultClient = null;
    _isStarted = false;
    if (_console) {
        _console.dispose();
    }
    if (_exceptions) {
        _exceptions.dispose();
    }
    if (_performance) {
        _performance.dispose();
    }
    if (_nativePerformance) {
        _nativePerformance.dispose();
    }
    if (_serverRequests) {
        _serverRequests.dispose();
    }
    if (_clientRequests) {
        _clientRequests.dispose();
    }
}
exports.dispose = dispose;


/***/ }),

/***/ 83666:
/***/ ((module) => {

"use strict";


function isArguments (thingy) {
  return thingy != null && typeof thingy === 'object' && thingy.hasOwnProperty('callee')
}

var types = {
  '*': {label: 'any', check: function () { return true }},
  A: {label: 'array', check: function (thingy) { return Array.isArray(thingy) || isArguments(thingy) }},
  S: {label: 'string', check: function (thingy) { return typeof thingy === 'string' }},
  N: {label: 'number', check: function (thingy) { return typeof thingy === 'number' }},
  F: {label: 'function', check: function (thingy) { return typeof thingy === 'function' }},
  O: {label: 'object', check: function (thingy) { return typeof thingy === 'object' && thingy != null && !types.A.check(thingy) && !types.E.check(thingy) }},
  B: {label: 'boolean', check: function (thingy) { return typeof thingy === 'boolean' }},
  E: {label: 'error', check: function (thingy) { return thingy instanceof Error }},
  Z: {label: 'null', check: function (thingy) { return thingy == null }}
}

function addSchema (schema, arity) {
  var group = arity[schema.length] = arity[schema.length] || []
  if (group.indexOf(schema) === -1) group.push(schema)
}

var validate = module.exports = function (rawSchemas, args) {
  if (arguments.length !== 2) throw wrongNumberOfArgs(['SA'], arguments.length)
  if (!rawSchemas) throw missingRequiredArg(0, 'rawSchemas')
  if (!args) throw missingRequiredArg(1, 'args')
  if (!types.S.check(rawSchemas)) throw invalidType(0, ['string'], rawSchemas)
  if (!types.A.check(args)) throw invalidType(1, ['array'], args)
  var schemas = rawSchemas.split('|')
  var arity = {}

  schemas.forEach(function (schema) {
    for (var ii = 0; ii < schema.length; ++ii) {
      var type = schema[ii]
      if (!types[type]) throw unknownType(ii, type)
    }
    if (/E.*E/.test(schema)) throw moreThanOneError(schema)
    addSchema(schema, arity)
    if (/E/.test(schema)) {
      addSchema(schema.replace(/E.*$/, 'E'), arity)
      addSchema(schema.replace(/E/, 'Z'), arity)
      if (schema.length === 1) addSchema('', arity)
    }
  })
  var matching = arity[args.length]
  if (!matching) {
    throw wrongNumberOfArgs(Object.keys(arity), args.length)
  }
  for (var ii = 0; ii < args.length; ++ii) {
    var newMatching = matching.filter(function (schema) {
      var type = schema[ii]
      var typeCheck = types[type].check
      return typeCheck(args[ii])
    })
    if (!newMatching.length) {
      var labels = matching.map(function (schema) {
        return types[schema[ii]].label
      }).filter(function (schema) { return schema != null })
      throw invalidType(ii, labels, args[ii])
    }
    matching = newMatching
  }
}

function missingRequiredArg (num) {
  return newException('EMISSINGARG', 'Missing required argument #' + (num + 1))
}

function unknownType (num, type) {
  return newException('EUNKNOWNTYPE', 'Unknown type ' + type + ' in argument #' + (num + 1))
}

function invalidType (num, expectedTypes, value) {
  var valueType
  Object.keys(types).forEach(function (typeCode) {
    if (types[typeCode].check(value)) valueType = types[typeCode].label
  })
  return newException('EINVALIDTYPE', 'Argument #' + (num + 1) + ': Expected ' +
    englishList(expectedTypes) + ' but got ' + valueType)
}

function englishList (list) {
  return list.join(', ').replace(/, ([^,]+)$/, ' or $1')
}

function wrongNumberOfArgs (expected, got) {
  var english = englishList(expected)
  var args = expected.every(function (ex) { return ex.length === 1 })
    ? 'argument'
    : 'arguments'
  return newException('EWRONGARGCOUNT', 'Expected ' + english + ' ' + args + ' but got ' + got)
}

function moreThanOneError (schema) {
  return newException('ETOOMANYERRORTYPES',
    'Only one error type per argument signature is allowed, more than one found in "' + schema + '"')
}

function newException (code, msg) {
  var e = new Error(msg)
  e.code = code
  if (Error.captureStackTrace) Error.captureStackTrace(e, validate)
  return e
}


/***/ }),

/***/ 70275:
/***/ ((module) => {

/**
 * Default minimum size of a run.
 */
const DEFAULT_MIN_MERGE = 32

/**
 * Minimum ordered subsequece required to do galloping.
 */
const DEFAULT_MIN_GALLOPING = 7

/**
 * Default tmp storage length. Can increase depending on the size of the
 * smallest run to merge.
 */
const DEFAULT_TMP_STORAGE_LENGTH = 256

/**
 * Pre-computed powers of 10 for efficient lexicographic comparison of
 * small integers.
 */
const POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9]

let results

/**
 * Estimate the logarithm base 10 of a small integer.
 *
 * @param {number} x - The integer to estimate the logarithm of.
 * @return {number} - The estimated logarithm of the integer.
 */
const log10 = x => x < 1e5
  ? x < 1e2
    ? x < 1e1
      ? 0
      : 1
    : x < 1e4
      ? x < 1e3
        ? 2
        : 3
      : 4
  : x < 1e7
    ? x < 1e6
      ? 5
      : 6
    : x < 1e9
      ? x < 1e8
        ? 7
        : 8
      : 9

/**
 * Default alphabetical comparison of items.
 *
 * @param {string|object|number} a - First element to compare.
 * @param {string|object|number} b - Second element to compare.
 * @return {number} - A positive number if a.toString() > b.toString(), a
 * negative number if .toString() < b.toString(), 0 otherwise.
 */
function alphabeticalCompare (a, b) {
  if (a === b) {
    return 0
  }

  if (~ ~ a === a && ~ ~ b === b) {
    if (a === 0 || b === 0) {
      return a < b ? - 1 : 1
    }

    if (a < 0 || b < 0) {
      if (b >= 0) {
        return - 1
      }

      if (a >= 0) {
        return 1
      }

      a = - a
      b = - b
    }

    const al = log10(a)
    const bl = log10(b)

    let t = 0

    if (al < bl) {
      a *= POWERS_OF_TEN[bl - al - 1]
      b /= 10
      t = - 1
    } else if (al > bl) {
      b *= POWERS_OF_TEN[al - bl - 1]
      a /= 10
      t = 1
    }

    if (a === b) {
      return t
    }

    return a < b ? - 1 : 1
  }

  const aStr = String(a)
  const bStr = String(b)

  if (aStr === bStr) {
    return 0
  }

  return aStr < bStr ? - 1 : 1
}

/**
 * Compute minimum run length for TimSort
 *
 * @param {number} n - The size of the array to sort.
 */
function minRunLength (n) {
  let r = 0

  while (n >= DEFAULT_MIN_MERGE) {
    r |= (n & 1)
    n >>= 1
  }

  return n + r
}

/**
 * Counts the length of a monotonically ascending or strictly monotonically
 * descending sequence (run) starting at array[lo] in the range [lo, hi). If
 * the run is descending it is made ascending.
 *
 * @param {array} array - The array to reverse.
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 * @param {function} compare - Item comparison function.
 * @return {number} - The length of the run.
 */
function makeAscendingRun (array, lo, hi, compare) {
  let runHi = lo + 1

  if (runHi === hi) {
    return 1
  }

  // Descending
  if (compare(array[runHi ++], array[lo]) < 0) {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
      runHi ++
    }

    reverseRun(array, lo, runHi)
    reverseRun(results, lo, runHi)
    // Ascending
  } else {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
      runHi ++
    }
  }

  return runHi - lo
}

/**
 * Reverse an array in the range [lo, hi).
 *
 * @param {array} array - The array to reverse.
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 */
function reverseRun (array, lo, hi) {
  hi --

  while (lo < hi) {
    const t = array[lo]
    array[lo ++] = array[hi]
    array[hi --] = t
  }
}

/**
 * Perform the binary sort of the array in the range [lo, hi) where start is
 * the first element possibly out of order.
 *
 * @param {array} array - The array to sort.
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 * @param {number} start - First element possibly out of order.
 * @param {function} compare - Item comparison function.
 */
function binaryInsertionSort (array, lo, hi, start, compare) {
  if (start === lo) {
    start ++
  }

  for (; start < hi; start ++) {
    const pivot = array[start]
    const pivotIndex = results[start]

    // Ranges of the array where pivot belongs
    let left = lo
    let right = start

    /*
     *   pivot >= array[i] for i in [lo, left)
     *   pivot <  array[i] for i in  in [right, start)
     */
    while (left < right) {
      const mid = (left + right) >>> 1

      if (compare(pivot, array[mid]) < 0) {
        right = mid
      } else {
        left = mid + 1
      }
    }

    /*
     * Move elements right to make room for the pivot. If there are elements
     * equal to pivot, left points to the first slot after them: this is also
     * a reason for which TimSort is stable
     */
    let n = start - left
    // Switch is just an optimization for small arrays
    switch (n) {
    case 3:
      array[left + 3] = array[left + 2]
      results[left + 3] = results[left + 2]
      /* falls through */
    case 2:
      array[left + 2] = array[left + 1]
      results[left + 2] = results[left + 1]
      /* falls through */
    case 1:
      array[left + 1] = array[left]
      results[left + 1] = results[left]
      break
    default:
      while (n > 0) {
        array[left + n] = array[left + n - 1]
        results[left + n] = results[left + n - 1]
        n --
      }
    }

    array[left] = pivot
    results[left] = pivotIndex
  }
}

/**
 * Find the position at which to insert a value in a sorted range. If the range
 * contains elements equal to the value the leftmost element index is returned
 * (for stability).
 *
 * @param {number} value - Value to insert.
 * @param {array} array - The array in which to insert value.
 * @param {number} start - First element in the range.
 * @param {number} length - Length of the range.
 * @param {number} hint - The index at which to begin the search.
 * @param {function} compare - Item comparison function.
 * @return {number} - The index where to insert value.
 */
function gallopLeft (value, array, start, length, hint, compare) {
  let lastOffset = 0
  let maxOffset = 0
  let offset = 1

  if (compare(value, array[start + hint]) > 0) {
    maxOffset = length - hint

    while (
      offset < maxOffset
      && compare(value, array[start + hint + offset]) > 0
    ) {
      lastOffset = offset
      offset = (offset << 1) + 1

      if (offset <= 0) {
        offset = maxOffset
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset
    }

    // Make offsets relative to start
    lastOffset += hint
    offset += hint

    // value <= array[start + hint]
  } else {
    maxOffset = hint + 1
    while (
      offset < maxOffset
      && compare(value, array[start + hint - offset]) <= 0
    ) {
      lastOffset = offset
      offset = (offset << 1) + 1

      if (offset <= 0) {
        offset = maxOffset
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset
    }

    // Make offsets relative to start
    const tmp = lastOffset
    lastOffset = hint - offset
    offset = hint - tmp
  }

  /*
   * Now array[start+lastOffset] < value <= array[start+offset], so value
   * belongs somewhere in the range (start + lastOffset, start + offset]. Do a
   * binary search, with invariant array[start + lastOffset - 1] < value <=
   * array[start + offset].
   */
  lastOffset ++
  while (lastOffset < offset) {
    const m = lastOffset + ((offset - lastOffset) >>> 1)

    if (compare(value, array[start + m]) > 0) {
      lastOffset = m + 1
    } else {
      offset = m
    }
  }
  return offset
}

/**
 * Find the position at which to insert a value in a sorted range. If the range
 * contains elements equal to the value the rightmost element index is returned
 * (for stability).
 *
 * @param {number} value - Value to insert.
 * @param {array} array - The array in which to insert value.
 * @param {number} start - First element in the range.
 * @param {number} length - Length of the range.
 * @param {number} hint - The index at which to begin the search.
 * @param {function} compare - Item comparison function.
 * @return {number} - The index where to insert value.
 */
function gallopRight (value, array, start, length, hint, compare) {
  let lastOffset = 0
  let maxOffset = 0
  let offset = 1

  if (compare(value, array[start + hint]) < 0) {
    maxOffset = hint + 1

    while (
      offset < maxOffset
      && compare(value, array[start + hint - offset]) < 0
    ) {
      lastOffset = offset
      offset = (offset << 1) + 1

      if (offset <= 0) {
        offset = maxOffset
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset
    }

    // Make offsets relative to start
    const tmp = lastOffset
    lastOffset = hint - offset
    offset = hint - tmp

    // value >= array[start + hint]
  } else {
    maxOffset = length - hint

    while (
      offset < maxOffset
      && compare(value, array[start + hint + offset]) >= 0
    ) {
      lastOffset = offset
      offset = (offset << 1) + 1

      if (offset <= 0) {
        offset = maxOffset
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset
    }

    // Make offsets relative to start
    lastOffset += hint
    offset += hint
  }

  /*
   * Now array[start+lastOffset] < value <= array[start+offset], so value
   * belongs somewhere in the range (start + lastOffset, start + offset]. Do a
   * binary search, with invariant array[start + lastOffset - 1] < value <=
   * array[start + offset].
   */
  lastOffset ++

  while (lastOffset < offset) {
    const m = lastOffset + ((offset - lastOffset) >>> 1)

    if (compare(value, array[start + m]) < 0) {
      offset = m
    } else {
      lastOffset = m + 1
    }
  }

  return offset
}

class TimSort {
  constructor (array, compare) {
    this.array = array
    this.compare = compare

    const {length} = array

    this.length = length
    this.minGallop = DEFAULT_MIN_GALLOPING

    this.tmpStorageLength = length < 2 * DEFAULT_TMP_STORAGE_LENGTH
      ? length >>> 1
      : DEFAULT_TMP_STORAGE_LENGTH

    this.tmp = new Array(this.tmpStorageLength)
    this.tmpIndex = new Array(this.tmpStorageLength)

    this.stackLength = length < 120
      ? 5
      : length < 1542
        ? 10
        : length < 119151
          ? 19
          : 40

    this.runStart = new Array(this.stackLength)
    this.runLength = new Array(this.stackLength)

    this.stackSize = 0
  }

  /**
   * Push a new run on TimSort's stack.
   *
   * @param {number} runStart - Start index of the run in the original array.
   * @param {number} runLength - Length of the run;
   */
  pushRun (runStart, runLength) {
    this.runStart[this.stackSize] = runStart
    this.runLength[this.stackSize] = runLength
    this.stackSize += 1
  }

  /**
   * Merge runs on TimSort's stack so that the following holds for all i:
   * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]
   * 2) runLength[i - 2] > runLength[i - 1]
   */
  mergeRuns () {
    while (this.stackSize > 1) {
      let n = this.stackSize - 2

      if (
        (
          n >= 1
          && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1]
        )
        || (
          n >= 2
          && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]
        )
      ) {
        if (this.runLength[n - 1] < this.runLength[n + 1]) {
          n --
        }
      } else if (this.runLength[n] > this.runLength[n + 1]) {
        break
      }
      this.mergeAt(n)
    }
  }

  /**
   * Merge all runs on TimSort's stack until only one remains.
   */
  forceMergeRuns () {
    while (this.stackSize > 1) {
      let n = this.stackSize - 2

      if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
        n --
      }

      this.mergeAt(n)
    }
  }

  /**
   * Merge the runs on the stack at positions i and i+1. Must be always be called
   * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).
   *
   * @param {number} i - Index of the run to merge in TimSort's stack.
   */
  mergeAt (i) {
    const {compare} = this
    const {array} = this

    let start1 = this.runStart[i]
    let length1 = this.runLength[i]
    const start2 = this.runStart[i + 1]
    let length2 = this.runLength[i + 1]

    this.runLength[i] = length1 + length2

    if (i === this.stackSize - 3) {
      this.runStart[i + 1] = this.runStart[i + 2]
      this.runLength[i + 1] = this.runLength[i + 2]
    }

    this.stackSize --

    /*
     * Find where the first element in the second run goes in run1. Previous
     * elements in run1 are already in place
     */
    const k = gallopRight(array[start2], array, start1, length1, 0, compare)
    start1 += k
    length1 -= k

    if (length1 === 0) {
      return
    }

    /*
     * Find where the last element in the first run goes in run2. Next elements
     * in run2 are already in place
     */
    length2 = gallopLeft(
      array[start1 + length1 - 1],
      array,
      start2,
      length2,
      length2 - 1,
      compare
    )

    if (length2 === 0) {
      return
    }

    /*
     * Merge remaining runs. A tmp array with length = min(length1, length2) is
     * used
     */
    if (length1 <= length2) {
      this.mergeLow(start1, length1, start2, length2)
    } else {
      this.mergeHigh(start1, length1, start2, length2)
    }
  }

  /**
   * Merge two adjacent runs in a stable way. The runs must be such that the
   * first element of run1 is bigger than the first element in run2 and the
   * last element of run1 is greater than all the elements in run2.
   * The method should be called when run1.length <= run2.length as it uses
   * TimSort temporary array to store run1. Use mergeHigh if run1.length >
   * run2.length.
   *
   * @param {number} start1 - First element in run1.
   * @param {number} length1 - Length of run1.
   * @param {number} start2 - First element in run2.
   * @param {number} length2 - Length of run2.
   */
  mergeLow (start1, length1, start2, length2) {
    const {compare} = this
    const {array} = this
    const {tmp} = this
    const {tmpIndex} = this
    let i = 0

    for (i = 0; i < length1; i ++) {
      tmp[i] = array[start1 + i]
      tmpIndex[i] = results[start1 + i]
    }

    let cursor1 = 0
    let cursor2 = start2
    let dest = start1

    array[dest] = array[cursor2]
    results[dest] = results[cursor2]

    dest ++
    cursor2 ++

    if (-- length2 === 0) {
      for (i = 0; i < length1; i ++) {
        array[dest + i] = tmp[cursor1 + i]
        results[dest + i] = tmpIndex[cursor1 + i]
      }
      return
    }

    if (length1 === 1) {
      for (i = 0; i < length2; i ++) {
        array[dest + i] = array[cursor2 + i]
        results[dest + i] = results[cursor2 + i]
      }
      array[dest + length2] = tmp[cursor1]
      results[dest + length2] = tmpIndex[cursor1]
      return
    }

    let {minGallop} = this

    while (true) {
      let count1 = 0
      let count2 = 0
      let exit = false

      do {
        if (compare(array[cursor2], tmp[cursor1]) < 0) {
          array[dest] = array[cursor2]
          results[dest] = results[cursor2]
          dest ++
          cursor2 ++
          count2 ++
          count1 = 0

          if (-- length2 === 0) {
            exit = true
            break
          }
        } else {
          array[dest] = tmp[cursor1]
          results[dest] = tmpIndex[cursor1]
          dest ++
          cursor1 ++
          count1 ++
          count2 = 0
          if (-- length1 === 1) {
            exit = true
            break
          }
        }
      } while ((count1 | count2) < minGallop)

      if (exit) {
        break
      }

      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare)

        if (count1 !== 0) {
          for (i = 0; i < count1; i ++) {
            array[dest + i] = tmp[cursor1 + i]
            results[dest + i] = tmpIndex[cursor1 + i]
          }

          dest += count1
          cursor1 += count1
          length1 -= count1
          if (length1 <= 1) {
            exit = true
            break
          }
        }

        array[dest] = array[cursor2]
        results[dest] = results[cursor2]

        dest ++
        cursor2 ++

        if (-- length2 === 0) {
          exit = true
          break
        }

        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare)

        if (count2 !== 0) {
          for (i = 0; i < count2; i ++) {
            array[dest + i] = array[cursor2 + i]
            results[dest + i] = results[cursor2 + i]
          }

          dest += count2
          cursor2 += count2
          length2 -= count2

          if (length2 === 0) {
            exit = true
            break
          }
        }
        array[dest] = tmp[cursor1]
        results[dest] = tmpIndex[cursor1]
        dest ++
        cursor1 ++

        if (-- length1 === 1) {
          exit = true
          break
        }

        minGallop --
      } while (
        count1 >= DEFAULT_MIN_GALLOPING
        || count2 >= DEFAULT_MIN_GALLOPING
      )

      if (exit) {
        break
      }

      if (minGallop < 0) {
        minGallop = 0
      }

      minGallop += 2
    }

    this.minGallop = minGallop

    if (minGallop < 1) {
      this.minGallop = 1
    }

    if (length1 === 1) {
      for (i = 0; i < length2; i ++) {
        array[dest + i] = array[cursor2 + i]
        results[dest + i] = results[cursor2 + i]
      }
      array[dest + length2] = tmp[cursor1]
      results[dest + length2] = tmpIndex[cursor1]
    } else if (length1 === 0) {
      throw new Error('mergeLow preconditions were not respected')
    } else {
      for (i = 0; i < length1; i ++) {
        array[dest + i] = tmp[cursor1 + i]
        results[dest + i] = tmpIndex[cursor1 + i]
      }
    }
  }

  /**
   * Merge two adjacent runs in a stable way. The runs must be such that the
   * first element of run1 is bigger than the first element in run2 and the
   * last element of run1 is greater than all the elements in run2.
   * The method should be called when run1.length > run2.length as it uses
   * TimSort temporary array to store run2. Use mergeLow if run1.length <=
   * run2.length.
   *
   * @param {number} start1 - First element in run1.
   * @param {number} length1 - Length of run1.
   * @param {number} start2 - First element in run2.
   * @param {number} length2 - Length of run2.
   */
  mergeHigh (start1, length1, start2, length2) {
    const {compare} = this
    const {array} = this
    const {tmp} = this
    const {tmpIndex} = this
    let i = 0

    for (i = 0; i < length2; i ++) {
      tmp[i] = array[start2 + i]
      tmpIndex[i] = results[start2 + i]
    }

    let cursor1 = start1 + length1 - 1
    let cursor2 = length2 - 1
    let dest = start2 + length2 - 1
    let customCursor = 0
    let customDest = 0

    array[dest] = array[cursor1]
    results[dest] = results[cursor1]

    dest --
    cursor1 --

    if (-- length1 === 0) {
      customCursor = dest - (length2 - 1)

      for (i = 0; i < length2; i ++) {
        array[customCursor + i] = tmp[i]
        results[customCursor + i] = tmpIndex[i]
      }

      return
    }

    if (length2 === 1) {
      dest -= length1
      cursor1 -= length1
      customDest = dest + 1
      customCursor = cursor1 + 1

      for (i = length1 - 1; i >= 0; i --) {
        array[customDest + i] = array[customCursor + i]
        results[customDest + i] = results[customCursor + i]
      }

      array[dest] = tmp[cursor2]
      results[dest] = tmpIndex[cursor2]
      return
    }

    let {minGallop} = this

    while (true) {
      let count1 = 0
      let count2 = 0
      let exit = false

      do {
        if (compare(tmp[cursor2], array[cursor1]) < 0) {
          array[dest] = array[cursor1]
          results[dest] = results[cursor1]
          dest --
          cursor1 --
          count1 ++
          count2 = 0
          if (-- length1 === 0) {
            exit = true
            break
          }
        } else {
          array[dest] = tmp[cursor2]
          results[dest] = tmpIndex[cursor2]
          dest --
          cursor2 --
          count2 ++
          count1 = 0
          if (-- length2 === 1) {
            exit = true
            break
          }
        }
      } while ((count1 | count2) < minGallop)

      if (exit) {
        break
      }

      do {
        count1 = length1 - gallopRight(
          tmp[cursor2],
          array,
          start1,
          length1,
          length1 - 1,
          compare
        )

        if (count1 !== 0) {
          dest -= count1
          cursor1 -= count1
          length1 -= count1
          customDest = dest + 1
          customCursor = cursor1 + 1

          for (i = count1 - 1; i >= 0; i --) {
            array[customDest + i] = array[customCursor + i]
            results[customDest + i] = results[customCursor + i]
          }

          if (length1 === 0) {
            exit = true
            break
          }
        }

        array[dest] = tmp[cursor2]
        results[dest] = tmpIndex[cursor2]
        dest --
        cursor2 --

        if (-- length2 === 1) {
          exit = true
          break
        }

        count2 = length2 - gallopLeft(
          array[cursor1],
          tmp,
          0,
          length2,
          length2 - 1,
          compare
        )

        if (count2 !== 0) {
          dest -= count2
          cursor2 -= count2
          length2 -= count2
          customDest = dest + 1
          customCursor = cursor2 + 1

          for (i = 0; i < count2; i ++) {
            array[customDest + i] = tmp[customCursor + i]
            results[customDest + i] = tmpIndex[customCursor + i]
          }

          if (length2 <= 1) {
            exit = true
            break
          }
        }

        array[dest] = array[cursor1]
        results[dest] = results[cursor1]
        dest --
        cursor1 --

        if (-- length1 === 0) {
          exit = true
          break
        }

        minGallop --
      } while (
        count1 >= DEFAULT_MIN_GALLOPING
        || count2 >= DEFAULT_MIN_GALLOPING
      )

      if (exit) {
        break
      }

      if (minGallop < 0) {
        minGallop = 0
      }

      minGallop += 2
    }

    this.minGallop = minGallop

    if (minGallop < 1) {
      this.minGallop = 1
    }

    if (length2 === 1) {
      dest -= length1
      cursor1 -= length1
      customDest = dest + 1
      customCursor = cursor1 + 1

      for (i = length1 - 1; i >= 0; i --) {
        array[customDest + i] = array[customCursor + i]
        results[customDest + i] = results[customCursor + i]
      }

      array[dest] = tmp[cursor2]
      results[dest] = tmpIndex[cursor2]
    } else if (length2 === 0) {
      throw new Error('mergeHigh preconditions were not respected')
    } else {
      customCursor = dest - (length2 - 1)
      for (i = 0; i < length2; i ++) {
        array[customCursor + i] = tmp[i]
        results[customCursor + i] = tmpIndex[i]
      }
    }
  }
}

/**
 * Sort an array in the range [lo, hi) using TimSort.
 *
 * @param {array} array - The array to sort.
 * @param {function=} compare - Item comparison function. Default is
 *     alphabetical
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 *     comparator.
 */
function sort (array, compare, lo, hi) {
  if (!Array.isArray(array)) {
    throw new TypeError(
      `The "array" argument must be an array. Received ${array}`
    )
  }

  results = []

  const {length} = array

  let i = 0

  while (i < length) {
    results[i] = i ++
  }

  /*
   * Handle the case where a comparison function is not provided. We do
   * lexicographic sorting
   */
  if (!compare) {
    compare = alphabeticalCompare
  } else if (typeof compare !== 'function') {
    hi = lo
    lo = compare
    compare = alphabeticalCompare
  }

  if (!lo) {
    lo = 0
  }
  if (!hi) {
    hi = length
  }

  let remaining = hi - lo

  // The array is already sorted
  if (remaining < 2) {
    return results
  }

  let runLength = 0
  // On small arrays binary sort can be used directly
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare)
    binaryInsertionSort(array, lo, hi, lo + runLength, compare)
    return results
  }

  const ts = new TimSort(array, compare)

  const minRun = minRunLength(remaining)

  do {
    runLength = makeAscendingRun(array, lo, hi, compare)
    if (runLength < minRun) {
      let force = remaining
      if (force > minRun) {
        force = minRun
      }

      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare)
      runLength = force
    }
    // Push new run and merge if necessary
    ts.pushRun(lo, runLength)
    ts.mergeRuns()

    // Go find next run
    remaining -= runLength
    lo += runLength
  } while (remaining !== 0)

  // Force merging of remaining runs
  ts.forceMergeRuns()

  return results
}

module.exports = {
  sort
}


/***/ }),

/***/ 81895:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const asyncWrap = process.binding('async_wrap');
const TIMERWRAP = asyncWrap.Providers.TIMERWRAP;

const patchs = {
  'nextTick': __webpack_require__(31861),
  'promise': __webpack_require__(95098),
  'timers': __webpack_require__(85150)
};

const ignoreUIDs = new Set();

function State() {
  this.enabled = false;
  this.counter = 0;
}

function Hooks() {
  const initFns = this.initFns = [];
  const preFns = this.preFns = [];
  const postFns = this.postFns = [];
  const destroyFns = this.destroyFns = [];

  this.init = function (uid, provider, parentUid, parentHandle) {
    // Ignore TIMERWRAP, since setTimeout etc. is monkey patched
    if (provider === TIMERWRAP) {
      ignoreUIDs.add(uid);
      return;
    }

    // call hooks
    for (const hook of initFns) {
      hook(uid, this, provider, parentUid, parentHandle);
    }
  };

  this.pre = function (uid) {
    if (ignoreUIDs.has(uid)) return;

    // call hooks
    for (const hook of preFns) {
      hook(uid, this);
    }
  };

  this.post = function (uid, didThrow) {
    if (ignoreUIDs.has(uid)) return;

    // call hooks
    for (const hook of postFns) {
      hook(uid, this, didThrow);
    }
  };

  this.destroy = function (uid) {
    // Cleanup the ignore list if this uid should be ignored
    if (ignoreUIDs.has(uid)) {
      ignoreUIDs.delete(uid);
      return;
    }

    // call hooks
    for (const hook of destroyFns) {
      hook(uid);
    }
  };
}

Hooks.prototype.add = function (hooks) {
  if (hooks.init) this.initFns.push(hooks.init);
  if (hooks.pre) this.preFns.push(hooks.pre);
  if (hooks.post) this.postFns.push(hooks.post);
  if (hooks.destroy) this.destroyFns.push(hooks.destroy);
};

function removeElement(array, item) {
  const index = array.indexOf(item);
  if (index === -1) return;
  array.splice(index, 1);
}

Hooks.prototype.remove = function (hooks) {
  if (hooks.init) removeElement(this.initFns, hooks.init);
  if (hooks.pre) removeElement(this.preFns, hooks.pre);
  if (hooks.post) removeElement(this.postFns, hooks.post);
  if (hooks.destroy) removeElement(this.destroyFns, hooks.destroy);
};

function AsyncHook() {
  this._state = new State();
  this._hooks = new Hooks();

  // expose version for conflict detection
  this.version = (__webpack_require__(11304)/* .version */ .i8);

  // expose the Providers map
  this.providers = asyncWrap.Providers;

  // apply patches
  for (const key of Object.keys(patchs)) {
    patchs[key].call(this);
  }

  // setup async wrap
  if (process.env.hasOwnProperty('NODE_ASYNC_HOOK_WARNING')) {
    console.warn('warning: you are using async-hook-jl which is unstable.');
  }
  asyncWrap.setupHooks({
    init: this._hooks.init,
    pre: this._hooks.pre,
    post: this._hooks.post,
    destroy: this._hooks.destroy
  });
}
module.exports = AsyncHook;

AsyncHook.prototype.addHooks = function (hooks) {
  this._hooks.add(hooks);
};

AsyncHook.prototype.removeHooks = function (hooks) {
  this._hooks.remove(hooks);
};

AsyncHook.prototype.enable = function () {
  this._state.enabled = true;
  asyncWrap.enable();
};

AsyncHook.prototype.disable = function () {
  this._state.enabled = false;
  asyncWrap.disable();
};

/***/ }),

/***/ 98375:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AsyncHook = __webpack_require__(81895);

// If a another copy (same version or not) of stack-chain exists it will result
// in wrong stack traces (most likely dublicate callSites).
if (global._asyncHook) {
  // In case the version match, we can simply return the first initialized copy
  if (global._asyncHook.version === (__webpack_require__(11304)/* .version */ .i8)) {
    module.exports = global._asyncHook;
  }
  // The version don't match, this is really bad. Lets just throw
  else {
    throw new Error('Conflicting version of async-hook-jl found');
  }
} else {
  const stackChain = __webpack_require__(33705);

  // Remove callSites from this module. AsyncWrap doesn't have any callSites
  // and the hooks are expected to be completely transparent.
  stackChain.filter.attach(function (error, frames) {
    return frames.filter(function (callSite) {
      const filename = callSite.getFileName();
      // filename is not always a string, for example in case of eval it is
      // undefined. So check if the filename is defined.
      return !(filename && filename.slice(0, __dirname.length) === __dirname);
    });
  });

  module.exports = global._asyncHook = new AsyncHook();
}

/***/ }),

/***/ 31861:
/***/ ((module) => {

"use strict";


function NextTickWrap() {}

module.exports = function patch() {
  const hooks = this._hooks;
  const state = this._state;

  const oldNextTick = process.nextTick;
  process.nextTick = function () {
    if (!state.enabled) return oldNextTick.apply(process, arguments);

    const args = new Array(arguments.length);
    for (let i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    const callback = args[0];

    if (typeof callback !== 'function') {
      throw new TypeError('callback is not a function');
    }

    const handle = new NextTickWrap();
    const uid = --state.counter;

    // call the init hook
    hooks.init.call(handle, uid, 0, null, null);

    // overwrite callback
    args[0] = function () {
      // call the pre hook
      hooks.pre.call(handle, uid);

      let didThrow = true;
      try {
        callback.apply(this, arguments);
        didThrow = false;
      } finally {
        // If `callback` threw and there is an uncaughtException handler
        // then call the `post` and `destroy` hook after the uncaughtException
        // user handlers have been invoked.
        if(didThrow && process.listenerCount('uncaughtException') > 0) {
          process.once('uncaughtException', function () {
            hooks.post.call(handle, uid, true);
            hooks.destroy.call(null, uid);
          });
        }
      }

      // callback done successfully
      hooks.post.call(handle, uid, false);
      hooks.destroy.call(null, uid);
    };

    return oldNextTick.apply(process, args);
  };
}


/***/ }),

/***/ 95098:
/***/ ((module) => {

"use strict";


function PromiseWrap() {}

module.exports = function patchPromise() {
  const hooks = this._hooks;
  const state = this._state;

  const Promise = global.Promise;

  /* As per ECMAScript 2015, .catch must be implemented by calling .then, as
   * such we need needn't patch .catch as well. see:
   * http://www.ecma-international.org/ecma-262/6.0/#sec-promise.prototype.catch
   */
  const oldThen = Promise.prototype.then;
  Promise.prototype.then = wrappedThen;

  function makeWrappedHandler(fn, handle, uid, isOnFulfilled) {
    if ('function' !== typeof fn) {
      return isOnFulfilled
        ? makeUnhandledResolutionHandler(uid)
        : makeUnhandledRejectionHandler(uid);
    }

    return function wrappedHandler() {
      hooks.pre.call(handle, uid);
      try {
        return fn.apply(this, arguments);
      } finally {
        hooks.post.call(handle, uid, false);
        hooks.destroy.call(null, uid);
      }
    };
  }

  function makeUnhandledResolutionHandler(uid) {
    return function unhandledResolutionHandler(val) {
      hooks.destroy.call(null, uid);
      return val;
    };
  }

  function makeUnhandledRejectionHandler(uid) {
    return function unhandledRejectedHandler(val) {
      hooks.destroy.call(null, uid);
      throw val;
    };
  }

  function wrappedThen(onFulfilled, onRejected) {
    if (!state.enabled) return oldThen.call(this, onFulfilled, onRejected);

    const handle = new PromiseWrap();
    const uid = --state.counter;

    hooks.init.call(handle, uid, 0, null, null);

    return oldThen.call(
      this,
      makeWrappedHandler(onFulfilled, handle, uid, true),
      makeWrappedHandler(onRejected, handle, uid, false)
    );
  }
};


/***/ }),

/***/ 85150:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const timers = __webpack_require__(39512);

function TimeoutWrap() {}
function IntervalWrap() {}
function ImmediateWrap() {}

const timeoutMap = new Map();
const intervalMap = new Map();
const ImmediateMap = new Map();

let activeCallback = null;
let clearedInCallback = false;

module.exports = function patch() {
  patchTimer(this._hooks, this._state, 'setTimeout', 'clearTimeout', TimeoutWrap, timeoutMap, true);
  patchTimer(this._hooks, this._state, 'setInterval', 'clearInterval', IntervalWrap, intervalMap, false);
  patchTimer(this._hooks, this._state, 'setImmediate', 'clearImmediate', ImmediateWrap, ImmediateMap, true);

  global.setTimeout = timers.setTimeout;
  global.setInterval = timers.setInterval;
  global.setImmediate = timers.setImmediate;

  global.clearTimeout = timers.clearTimeout;
  global.clearInterval = timers.clearInterval;
  global.clearImmediate = timers.clearImmediate;
};

function patchTimer(hooks, state, setFn, clearFn, Handle, timerMap, singleCall) {
  const oldSetFn = timers[setFn];
  const oldClearFn = timers[clearFn];

  // overwrite set[Timeout]
  timers[setFn] = function () {
    if (!state.enabled) return oldSetFn.apply(timers, arguments);

    const args = new Array(arguments.length);
    for (let i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    const callback = args[0];

    if (typeof callback !== 'function') {
      throw new TypeError('"callback" argument must be a function');
    }

    const handle = new Handle();
    const uid = --state.counter;
    let timerId = undefined;

    // call the init hook
    hooks.init.call(handle, uid, 0, null, null);

    // overwrite callback
    args[0] = function () {
      // call the pre hook
      activeCallback = timerId;
      hooks.pre.call(handle, uid);

      let didThrow = true;
      try {
        callback.apply(this, arguments);
        didThrow = false;
      } finally {
        // If `callback` threw and there is an uncaughtException handler
        // then call the `post` and `destroy` hook after the uncaughtException
        // user handlers have been invoked.
        if (didThrow && process.listenerCount('uncaughtException') > 0) {
          process.once('uncaughtException', function () {
            // call the post hook
            hooks.post.call(handle, uid, true);
            // setInterval won't continue
            timerMap.delete(timerId);
            hooks.destroy.call(null, uid);
          });
        }
      }

      // callback done successfully
      hooks.post.call(handle, uid, false);
      activeCallback = null;

      // call the destroy hook if the callback will only be called once
      if (singleCall || clearedInCallback) {
        clearedInCallback = false;
        timerMap.delete(timerId);
        hooks.destroy.call(null, uid);
      }
    };

    timerId = oldSetFn.apply(timers, args);
    // Bind the timerId and uid for later use, in case the clear* function is
    // called.
    timerMap.set(timerId, uid);

    return timerId;
  };

  // overwrite clear[Timeout]
  timers[clearFn] = function (timerId) {
    // If clear* was called within the timer callback, then delay the destroy
    // event to after the post event has been called.
    if (activeCallback === timerId && timerId !== null) {
      clearedInCallback = true;
    }
    // clear should call the destroy hook. Note if timerId doesn't exists
    // it is because asyncWrap wasn't enabled at the time.
    else if (timerMap.has(timerId)) {
      const uid = timerMap.get(timerId);
      timerMap.delete(timerId);
      hooks.destroy.call(null, uid);
    }

    oldClearFn.apply(timers, arguments);
  };
}


/***/ }),

/***/ 67710:
/***/ ((module) => {

"use strict";


module.exports = (Promise, ensureAslWrapper) => {
  // Updates to this class should also be applied to the the ES3 version
  // in index.js.
  return class WrappedPromise extends Promise {
    constructor(executor) {
      var context, args;
      super(wrappedExecutor);
      var promise = this;

      try {
        executor.apply(context, args);
      } catch (err) {
        args[1](err);
      }

      return promise;
      function wrappedExecutor(resolve, reject) {
        context = this;
        args = [wrappedResolve, wrappedReject];

        // These wrappers create a function that can be passed a function and an argument to
        // call as a continuation from the resolve or reject.
        function wrappedResolve(val) {
          ensureAslWrapper(promise, false);
          return resolve(val);
        }

        function wrappedReject(val) {
          ensureAslWrapper(promise, false);
          return reject(val);
        }
      }
    }
  }
};


/***/ }),

/***/ 20292:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrap = (__webpack_require__(88073).wrap);

/*
 *
 * CONSTANTS
 *
 */
var HAS_CREATE_AL = 1 << 0;
var HAS_BEFORE_AL = 1 << 1;
var HAS_AFTER_AL = 1 << 2;
var HAS_ERROR_AL = 1 << 3;

/**
 * There is one list of currently active listeners that is mutated in place by
 * addAsyncListener and removeAsyncListener. This complicates error-handling,
 * for reasons that are discussed below.
 */
var listeners = [];

/**
 * There can be multiple listeners with the same properties, so disambiguate
 * them by assigning them an ID at creation time.
 */
var uid = 0;

/**
 * Ensure that errors coming from within listeners are handed off to domains,
 * process._fatalException, or uncaughtException without being treated like
 * user errors.
 */
var inAsyncTick = false;

/**
 * Because asynchronous contexts can be nested, and errors can come from anywhere
 * in the stack, a little extra work is required to keep track of where in the
 * nesting we are. Because JS arrays are frequently mutated in place
 */
var listenerStack = [];

/**
 * The error handler on a listener can capture errors thrown during synchronous
 * execution immediately after the listener is added. To capture both
 * synchronous and asynchronous errors, the error handler just uses the
 * "global" list of active listeners, and the rest of the code ensures that the
 * listener list is correct by using a stack of listener lists during
 * asynchronous execution.
 */
var asyncCatcher;

/**
 * The guts of the system -- called each time an asynchronous event happens
 * while one or more listeners are active.
 */
var asyncWrap;

/**
 * Simple helper function that's probably faster than using Array
 * filter methods and can be inlined.
 */
function union(dest, added) {
  var destLength = dest.length;
  var addedLength = added.length;
  var returned = [];

  if (destLength === 0 && addedLength === 0) return returned;

  for (var j  = 0; j < destLength; j++) returned[j] = dest[j];

  if (addedLength === 0) return returned;

  for (var i = 0; i < addedLength; i++) {
    var missing = true;
    for (j = 0; j < destLength; j++) {
      if (dest[j].uid === added[i].uid) {
        missing = false;
        break;
      }
    }
    if (missing) returned.push(added[i]);
  }

  return returned;
}

/*
 * For performance, split error-handlers and asyncCatcher up into two separate
 * code paths.
 */

// 0.9+
if (process._fatalException) {
  /**
   * Error handlers on listeners can throw, the catcher needs to be able to
   * discriminate between exceptions thrown by user code, and exceptions coming
   * from within the catcher itself. Use a global to keep track of which state
   * the catcher is currently in.
   */
  var inErrorTick = false;

  /**
   * Throwing always happens synchronously. If the current array of values for
   * the current list of asyncListeners is put in a module-scoped variable right
   * before a call that can throw, it will always be correct when the error
   * handlers are run.
   */
  var errorValues;

  asyncCatcher = function asyncCatcher(er) {
    var length = listeners.length;
    if (inErrorTick || length === 0) return false;

    var handled = false;

    /*
     * error handlers
     */
    inErrorTick = true;
    for (var i = 0; i < length; ++i) {
      var listener = listeners[i];
      if ((listener.flags & HAS_ERROR_AL) === 0) continue;

      var value = errorValues && errorValues[listener.uid];
      handled = listener.error(value, er) || handled;
    }
    inErrorTick = false;

    /* Test whether there are any listener arrays on the stack. In the case of
     * synchronous throws when the listener is active, there may have been
     * none pushed yet.
     */
    if (listenerStack.length > 0) listeners = listenerStack.pop();
    errorValues = undefined;

    return handled && !inAsyncTick;
  };

  asyncWrap = function asyncWrap(original, list, length) {
    var values = [];

    /*
     * listeners
     */
    inAsyncTick = true;
    for (var i = 0; i < length; ++i) {
      var listener = list[i];
      values[listener.uid] = listener.data;

      if ((listener.flags & HAS_CREATE_AL) === 0) continue;

      var value = listener.create(listener.data);
      if (value !== undefined) values[listener.uid] = value;
    }
    inAsyncTick = false;

    /* One of the main differences between this polyfill and the core
     * asyncListener support is that core avoids creating closures by putting a
     * lot of the state managemnt on the C++ side of Node (and of course also it
     * bakes support for async listeners into the Node C++ API through the
     * AsyncWrap class, which means that it doesn't monkeypatch basically every
     * async method like this does).
     */
    return function () {
      // put the current values where the catcher can see them
      errorValues = values;

      /* More than one listener can end up inside these closures, so save the
       * current listeners on a stack.
       */
      listenerStack.push(listeners);

      /* Activate both the listeners that were active when the closure was
       * created and the listeners that were previously active.
       */
      listeners = union(list, listeners);

      /*
       * before handlers
       */
      inAsyncTick = true;
      for (var i = 0; i < length; ++i) {
        if ((list[i].flags & HAS_BEFORE_AL) > 0) {
          list[i].before(this, values[list[i].uid]);
        }
      }
      inAsyncTick = false;

      // save the return value to pass to the after callbacks
      var returned = original.apply(this, arguments);

      /*
       * after handlers (not run if original throws)
       */
      inAsyncTick = true;
      for (i = 0; i < length; ++i) {
        if ((list[i].flags & HAS_AFTER_AL) > 0) {
          list[i].after(this, values[list[i].uid]);
        }
      }
      inAsyncTick = false;

      // back to the previous listener list on the stack
      listeners = listenerStack.pop();
      errorValues = undefined;

      return returned;
    };
  };

  wrap(process, '_fatalException', function (_fatalException) {
    return function _asyncFatalException(er) {
      return asyncCatcher(er) || _fatalException(er);
    };
  });
}
// 0.8 and below
else {
  /**
   * If an error handler in asyncWrap throws, the process must die. Under 0.8
   * and earlier the only way to put a bullet through the head of the process
   * is to rethrow from inside the exception handler, so rethrow and set
   * errorThrew to tell the uncaughtHandler what to do.
   */
  var errorThrew = false;

  /**
   * Under Node 0.8, this handler *only* handles synchronously thrown errors.
   * This simplifies it, which almost but not quite makes up for the hit taken
   * by putting everything in a try-catch.
   */
  asyncCatcher = function uncaughtCatcher(er) {
    // going down hard
    if (errorThrew) throw er;

    var handled = false;

    /*
     * error handlers
     */
    var length = listeners.length;
    for (var i = 0; i < length; ++i) {
      var listener = listeners[i];
      if ((listener.flags & HAS_ERROR_AL) === 0) continue;
      handled = listener.error(null, er) || handled;
    }

    /* Rethrow if one of the before / after handlers fire, which will bring the
     * process down immediately.
     */
    if (!handled && inAsyncTick) throw er;
  };

  asyncWrap = function asyncWrap(original, list, length) {
    var values = [];

    /*
     * listeners
     */
    inAsyncTick = true;
    for (var i = 0; i < length; ++i) {
      var listener = list[i];
      values[listener.uid] = listener.data;

      if ((listener.flags & HAS_CREATE_AL) === 0) continue;

      var value = listener.create(listener.data);
      if (value !== undefined) values[listener.uid] = value;
    }
    inAsyncTick = false;

    /* One of the main differences between this polyfill and the core
     * asyncListener support is that core avoids creating closures by putting a
     * lot of the state managemnt on the C++ side of Node (and of course also it
     * bakes support for async listeners into the Node C++ API through the
     * AsyncWrap class, which means that it doesn't monkeypatch basically every
     * async method like this does).
     */
    return function () {
      /*jshint maxdepth:4*/

      // after() handlers don't run if threw
      var threw = false;

      // ...unless the error is handled
      var handled = false;

      /* More than one listener can end up inside these closures, so save the
       * current listeners on a stack.
       */
      listenerStack.push(listeners);

      /* Activate both the listeners that were active when the closure was
       * created and the listeners that were previously active.
       */
      listeners = union(list, listeners);

      /*
       * before handlers
       */
      inAsyncTick = true;
      for (var i = 0; i < length; ++i) {
        if ((list[i].flags & HAS_BEFORE_AL) > 0) {
          list[i].before(this, values[list[i].uid]);
        }
      }
      inAsyncTick = false;

      // save the return value to pass to the after callbacks
      var returned;
      try {
        returned = original.apply(this, arguments);
      }
      catch (er) {
        threw = true;
        for (var i = 0; i < length; ++i) {
          if ((listeners[i].flags & HAS_ERROR_AL) == 0) continue;
          try {
            handled = listeners[i].error(values[list[i].uid], er) || handled;
          }
          catch (x) {
            errorThrew = true;
            throw x;
          }
        }

        if (!handled) {
          // having an uncaughtException handler here alters crash semantics
          process.removeListener('uncaughtException', asyncCatcher);
          process._originalNextTick(function () {
            process.addListener('uncaughtException', asyncCatcher);
          });

          throw er;
        }
      }
      finally {
        /*
         * after handlers (not run if original throws)
         */
        if (!threw || handled) {
          inAsyncTick = true;
          for (i = 0; i < length; ++i) {
            if ((list[i].flags & HAS_AFTER_AL) > 0) {
              list[i].after(this, values[list[i].uid]);
            }
          }
          inAsyncTick = false;
        }

        // back to the previous listener list on the stack
        listeners = listenerStack.pop();
      }


      return returned;
    };
  };

  // will be the first to fire if async-listener is the first module loaded
  process.addListener('uncaughtException', asyncCatcher);
}

// for performance in the case where there are no handlers, just the listener
function simpleWrap(original, list, length) {
  inAsyncTick = true;
  for (var i = 0; i < length; ++i) {
    var listener = list[i];
    if (listener.create) listener.create(listener.data);
  }
  inAsyncTick = false;

  // still need to make sure nested async calls are made in the context
  // of the listeners active at their creation
  return function () {
    listenerStack.push(listeners);
    listeners = union(list, listeners);

    var returned = original.apply(this, arguments);

    listeners = listenerStack.pop();

    return returned;
  };
}

/**
 * Called each time an asynchronous function that's been monkeypatched in
 * index.js is called. If there are no listeners, return the function
 * unwrapped.  If there are any asyncListeners and any of them have callbacks,
 * pass them off to asyncWrap for later use, otherwise just call the listener.
 */
function wrapCallback(original) {
  var length = listeners.length;

  // no context to capture, so avoid closure creation
  if (length === 0) return original;

  // capture the active listeners as of when the wrapped function was called
  var list = listeners.slice();

  for (var i = 0; i < length; ++i) {
    if (list[i].flags > 0) return asyncWrap(original, list, length);
  }

  return simpleWrap(original, list, length);
}

function AsyncListener(callbacks, data) {
  if (typeof callbacks.create === 'function') {
    this.create = callbacks.create;
    this.flags |= HAS_CREATE_AL;
  }

  if (typeof callbacks.before === 'function') {
    this.before = callbacks.before;
    this.flags |= HAS_BEFORE_AL;
  }

  if (typeof callbacks.after === 'function') {
    this.after = callbacks.after;
    this.flags |= HAS_AFTER_AL;
  }

  if (typeof callbacks.error === 'function') {
    this.error = callbacks.error;
    this.flags |= HAS_ERROR_AL;
  }

  this.uid = ++uid;
  this.data = data === undefined ? null : data;
}
AsyncListener.prototype.create = undefined;
AsyncListener.prototype.before = undefined;
AsyncListener.prototype.after  = undefined;
AsyncListener.prototype.error  = undefined;
AsyncListener.prototype.data   = undefined;
AsyncListener.prototype.uid    = 0;
AsyncListener.prototype.flags  = 0;

function createAsyncListener(callbacks, data) {
  if (typeof callbacks !== 'object' || !callbacks) {
    throw new TypeError('callbacks argument must be an object');
  }

  if (callbacks instanceof AsyncListener) {
    return callbacks;
  }
  else {
    return new AsyncListener(callbacks, data);
  }
}

function addAsyncListener(callbacks, data) {
  var listener;
  if (!(callbacks instanceof AsyncListener)) {
    listener = createAsyncListener(callbacks, data);
  }
  else {
    listener = callbacks;
  }

  // Make sure the listener isn't already in the list.
  var registered = false;
  for (var i = 0; i < listeners.length; i++) {
    if (listener === listeners[i]) {
      registered = true;
      break;
    }
  }

  if (!registered) listeners.push(listener);

  return listener;
}

function removeAsyncListener(listener) {
  for (var i = 0; i < listeners.length; i++) {
    if (listener === listeners[i]) {
      listeners.splice(i, 1);
      break;
    }
  }
}

process.createAsyncListener = createAsyncListener;
process.addAsyncListener    = addAsyncListener;
process.removeAsyncListener = removeAsyncListener;

module.exports = wrapCallback;


/***/ }),

/***/ 89468:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.addAsyncListener) throw new Error("Don't require polyfill unless needed");

var shimmer      = __webpack_require__(88073)
  , semver       = __webpack_require__(89611)
  , wrap         = shimmer.wrap
  , massWrap     = shimmer.massWrap
  , wrapCallback = __webpack_require__(20292)
  , util         = __webpack_require__(73837)
  ;

var v6plus = semver.gte(process.version, '6.0.0');
var v7plus = semver.gte(process.version, '7.0.0');
var v8plus = semver.gte(process.version, '8.0.0');
var v11plus = semver.gte(process.version, '11.0.0');

var net = __webpack_require__(41808);

// From Node.js v7.0.0, net._normalizeConnectArgs have been renamed net._normalizeArgs
if (v7plus && !net._normalizeArgs) {
  // a polyfill in our polyfill etc so forth -- taken from node master on 2017/03/09
  net._normalizeArgs = function (args) {
    if (args.length === 0) {
      return [{}, null];
    }

    var arg0 = args[0];
    var options = {};
    if (typeof arg0 === 'object' && arg0 !== null) {
      // (options[...][, cb])
      options = arg0;
    } else if (isPipeName(arg0)) {
      // (path[...][, cb])
      options.path = arg0;
    } else {
      // ([port][, host][...][, cb])
      options.port = arg0;
      if (args.length > 1 && typeof args[1] === 'string') {
        options.host = args[1];
      }
    }

    var cb = args[args.length - 1];
    if (typeof cb !== 'function')
      return [options, null];
    else
      return [options, cb];
  }
} else if (!v7plus && !net._normalizeConnectArgs) {
  // a polyfill in our polyfill etc so forth -- taken from node master on 2013/10/30
  net._normalizeConnectArgs = function (args) {
    var options = {};

    function toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }

    if (typeof args[0] === 'object' && args[0] !== null) {
      // connect(options, [cb])
      options = args[0];
    }
    else if (typeof args[0] === 'string' && toNumber(args[0]) === false) {
      // connect(path, [cb]);
      options.path = args[0];
    }
    else {
      // connect(port, [host], [cb])
      options.port = args[0];
      if (typeof args[1] === 'string') {
        options.host = args[1];
      }
    }

    var cb = args[args.length - 1];
    return typeof cb === 'function' ? [options, cb] : [options];
  };
}

// In https://github.com/nodejs/node/pull/11796 `_listen2` was renamed
// `_setUpListenHandle`. It's still aliased as `_listen2`, and currently the
// Node internals still call the alias - but who knows for how long. So better
// make sure we use the new name instead if available.
if ('_setUpListenHandle' in net.Server.prototype) {
  wrap(net.Server.prototype, '_setUpListenHandle', wrapSetUpListenHandle);
} else {
  wrap(net.Server.prototype, '_listen2', wrapSetUpListenHandle);
}

function wrapSetUpListenHandle(original) {
  return function () {
    this.on('connection', function (socket) {
      if (socket._handle) {
        socket._handle.onread = wrapCallback(socket._handle.onread);
      }
    });

    try {
      return original.apply(this, arguments);
    }
    finally {
      // the handle will only not be set in cases where there has been an error
      if (this._handle && this._handle.onconnection) {
        this._handle.onconnection = wrapCallback(this._handle.onconnection);
      }
    }
  };
}

function patchOnRead(ctx) {
  if (ctx && ctx._handle) {
    var handle = ctx._handle;
    if (!handle._originalOnread) {
      handle._originalOnread = handle.onread;
    }
    handle.onread = wrapCallback(handle._originalOnread);
  }
}

wrap(net.Socket.prototype, 'connect', function (original) {
  return function () {
    var args;
    // Node core uses an internal Symbol here to guard against the edge-case
    // where the user accidentally passes in an array. As we don't have access
    // to this Symbol we resort to this hack where we just detect if there is a
    // symbol or not. Checking for the number of Symbols is by no means a fool
    // proof solution, but it catches the most basic cases.
    if (v8plus &&
        Array.isArray(arguments[0]) &&
        Object.getOwnPropertySymbols(arguments[0]).length > 0) {
      // already normalized
      args = arguments[0];
    } else {
      // From Node.js v7.0.0, net._normalizeConnectArgs have been renamed net._normalizeArgs
      args = v7plus
        ? net._normalizeArgs(arguments)
        : net._normalizeConnectArgs(arguments);
    }
    if (args[1]) args[1] = wrapCallback(args[1]);
    var result = original.apply(this, args);
    patchOnRead(this);
    return result;
  };
});

var http = __webpack_require__(13685);

// NOTE: A rewrite occurred in 0.11 that changed the addRequest signature
// from (req, host, port, localAddress) to (req, options)
// Here, I use the longer signature to maintain 0.10 support, even though
// the rest of the arguments aren't actually used
wrap(http.Agent.prototype, 'addRequest', function (original) {
  return function (req) {
    var onSocket = req.onSocket;
    req.onSocket = wrapCallback(function (socket) {
      patchOnRead(socket);
      return onSocket.apply(this, arguments);
    });
    return original.apply(this, arguments);
  };
});

var childProcess = __webpack_require__(32081);

function wrapChildProcess(child) {
  if (Array.isArray(child.stdio)) {
    child.stdio.forEach(function (socket) {
      if (socket && socket._handle) {
        socket._handle.onread = wrapCallback(socket._handle.onread);
        wrap(socket._handle, 'close', activatorFirst);
      }
    });
  }

  if (child._handle) {
    child._handle.onexit = wrapCallback(child._handle.onexit);
  }
}

// iojs v2.0.0+
if (childProcess.ChildProcess) {
  wrap(childProcess.ChildProcess.prototype, 'spawn', function (original) {
    return function () {
      var result = original.apply(this, arguments);
      wrapChildProcess(this);
      return result;
    };
  });
} else {
  massWrap(childProcess, [
    'execFile', // exec is implemented in terms of execFile
    'fork',
    'spawn'
  ], function (original) {
    return function () {
      var result = original.apply(this, arguments);
      wrapChildProcess(result);
      return result;
    };
  });
}

// need unwrapped nextTick for use within < 0.9 async error handling
if (!process._fatalException) {
  process._originalNextTick = process.nextTick;
}

var processors = [];
if (process._nextDomainTick) processors.push('_nextDomainTick');
if (process._tickDomainCallback) processors.push('_tickDomainCallback');

massWrap(
  process,
  processors,
  activator
);
wrap(process, 'nextTick', activatorFirst);

var asynchronizers = [
  'setTimeout',
  'setInterval'
];
if (global.setImmediate) asynchronizers.push('setImmediate');

var timers = __webpack_require__(39512);
var patchGlobalTimers = global.setTimeout === timers.setTimeout;

massWrap(
  timers,
  asynchronizers,
  activatorFirst
);

if (patchGlobalTimers) {
  massWrap(
    global,
    asynchronizers,
    activatorFirst
  );
}

var dns = __webpack_require__(9523);
massWrap(
  dns,
  [
    'lookup',
    'resolve',
    'resolve4',
    'resolve6',
    'resolveCname',
    'resolveMx',
    'resolveNs',
    'resolveTxt',
    'resolveSrv',
    'reverse'
  ],
  activator
);

if (dns.resolveNaptr) wrap(dns, 'resolveNaptr', activator);

var fs = __webpack_require__(57147);
massWrap(
  fs,
  [
    'watch',
    'rename',
    'truncate',
    'chown',
    'fchown',
    'chmod',
    'fchmod',
    'stat',
    'lstat',
    'fstat',
    'link',
    'symlink',
    'readlink',
    'realpath',
    'unlink',
    'rmdir',
    'mkdir',
    'readdir',
    'close',
    'open',
    'utimes',
    'futimes',
    'fsync',
    'write',
    'read',
    'readFile',
    'writeFile',
    'appendFile',
    'watchFile',
    'unwatchFile',
    "exists",
  ],
  activator
);

// only wrap lchown and lchmod on systems that have them.
if (fs.lchown) wrap(fs, 'lchown', activator);
if (fs.lchmod) wrap(fs, 'lchmod', activator);

// only wrap ftruncate in versions of node that have it
if (fs.ftruncate) wrap(fs, 'ftruncate', activator);

// Wrap zlib streams
var zlib;
try { zlib = __webpack_require__(59796); } catch (err) { }
if (zlib && zlib.Deflate && zlib.Deflate.prototype) {
  var proto = Object.getPrototypeOf(zlib.Deflate.prototype);
  if (proto._transform) {
    // streams2
    wrap(proto, "_transform", activator);
  }
  else if (proto.write && proto.flush && proto.end) {
    // plain ol' streams
    massWrap(
      proto,
      [
        'write',
        'flush',
        'end'
      ],
      activator
    );
  }
}

// Wrap Crypto
var crypto;
try { crypto = __webpack_require__(6113); } catch (err) { }
if (crypto) {

  var toWrap = [
      'pbkdf2',
      'randomBytes',
  ];
  if (!v11plus) {
    toWrap.push('pseudoRandomBytes');
  }

  massWrap(crypto, toWrap, activator);
}

// It is unlikely that any userspace promise implementations have a native
// implementation of both Promise and Promise.toString.
var instrumentPromise = !!global.Promise &&
    Promise.toString() === 'function Promise() { [native code] }' &&
    Promise.toString.toString() === 'function toString() { [native code] }';

// Check that global Promise is native
if (instrumentPromise) {
  // shoult not use any methods that have already been wrapped
  var promiseListener = process.addAsyncListener({
    create: function create() {
      instrumentPromise = false;
    }
  });

  // should not resolve synchronously
  global.Promise.resolve(true).then(function notSync() {
    instrumentPromise = false;
  });

  process.removeAsyncListener(promiseListener);
}

/*
 * Native promises use the microtask queue to make all callbacks run
 * asynchronously to avoid Zalgo issues. Since the microtask queue is not
 * exposed externally, promises need to be modified in a fairly invasive and
 * complex way.
 *
 * The async boundary in promises that must be patched is between the
 * fulfillment of the promise and the execution of any callback that is waiting
 * for that fulfillment to happen. This means that we need to trigger a create
 * when resolve or reject is called and trigger before, after and error handlers
 * around the callback execution. There may be multiple callbacks for each
 * fulfilled promise, so handlers will behave similar to setInterval where
 * there may be multiple before after and error calls for each create call.
 *
 * async-listener monkeypatching has one basic entry point: `wrapCallback`.
 * `wrapCallback` should be called when create should be triggered and be
 * passed a function to wrap, which will execute the body of the async work.
 * The resolve and reject calls can be modified fairly easily to call
 * `wrapCallback`, but at the time of resolve and reject all the work to be done
 * on fulfillment may not be defined, since a call to then, chain or fetch can
 * be made even after the promise has been fulfilled. To get around this, we
 * create a placeholder function which will call a function passed into it,
 * since the call to the main work is being made from within the wrapped
 * function, async-listener will work correctly.
 *
 * There is another complication with monkeypatching Promises. Calls to then,
 * chain and catch each create new Promises that are fulfilled internally in
 * different ways depending on the return value of the callback. When the
 * callback return a Promise, the new Promise is resolved asynchronously after
 * the returned Promise has been also been resolved. When something other than
 * a promise is resolved the resolve call for the new Promise is put in the
 * microtask queue and asynchronously resolved.
 *
 * Then must be wrapped so that its returned promise has a wrapper that can be
 * used to invoke further continuations. This wrapper cannot be created until
 * after the callback has run, since the callback may return either a promise
 * or another value. Fortunately we already have a wrapper function around the
 * callback we can use (the wrapper created by resolve or reject).
 *
 * By adding an additional argument to this wrapper, we can pass in the
 * returned promise so it can have its own wrapper appended. the wrapper
 * function can the call the callback, and take action based on the return
 * value. If a promise is returned, the new Promise can proxy the returned
 * Promise's wrapper (this wrapper may not exist yet, but will by the time the
 * wrapper needs to be invoked). Otherwise, a new wrapper can be create the
 * same way as in resolve and reject. Since this wrapper is created
 * synchronously within another wrapper, it will properly appear as a
 * continuation from within the callback.
 */

if (instrumentPromise) {
  wrapPromise();
}

function wrapPromise() {
  var Promise = global.Promise;

  // Updates to this class should also be applied to the the ES6 version
  // in es6-wrapped-promise.js.
  function wrappedPromise(executor) {
    if (!(this instanceof wrappedPromise)) {
      return Promise(executor);
    }

    if (typeof executor !== 'function') {
      return new Promise(executor);
    }

    var context, args;
    var promise = new Promise(wrappedExecutor);
    promise.__proto__ = wrappedPromise.prototype;

    try {
      executor.apply(context, args);
    } catch (err) {
      args[1](err);
    }

    return promise;

    function wrappedExecutor(resolve, reject) {
      context = this;
      args = [wrappedResolve, wrappedReject];

      // These wrappers create a function that can be passed a function and an argument to
      // call as a continuation from the resolve or reject.
      function wrappedResolve(val) {
        ensureAslWrapper(promise, false);
        return resolve(val);
      }

      function wrappedReject(val) {
        ensureAslWrapper(promise, false);
        return reject(val);
      }
    }
  }

  util.inherits(wrappedPromise, Promise);

  wrap(Promise.prototype, 'then', wrapThen);
  // Node.js <v7 only, alias for .then
  if (Promise.prototype.chain) {
    wrap(Promise.prototype, 'chain', wrapThen);
  }

  if (v6plus) {
    global.Promise = __webpack_require__(67710)(Promise, ensureAslWrapper);
  } else {
    var PromiseFunctions = [
      'all',
      'race',
      'reject',
      'resolve',
      'accept',  // Node.js <v7 only
      'defer'    // Node.js <v7 only
    ];

    PromiseFunctions.forEach(function(key) {
      // don't break `in` by creating a key for undefined entries
      if (typeof Promise[key] === 'function') {
        wrappedPromise[key] = Promise[key];
      }
    });
    global.Promise = wrappedPromise
  }

  function ensureAslWrapper(promise, overwrite) {
    if (!promise.__asl_wrapper || overwrite) {
      promise.__asl_wrapper = wrapCallback(propagateAslWrapper);
    }
  }

  function propagateAslWrapper(ctx, fn, result, next) {
    var nextResult;
    try {
      nextResult = fn.call(ctx, result);
      return {returnVal: nextResult, error: false}
    } catch (err) {
      return {errorVal: err, error: true}
    } finally {
      // Wrap any resulting futures as continuations.
      if (nextResult instanceof Promise) {
        next.__asl_wrapper = function proxyWrapper() {
          var aslWrapper = nextResult.__asl_wrapper || propagateAslWrapper;
          return aslWrapper.apply(this, arguments);
        }
      } else {
        ensureAslWrapper(next, true);
      }
    }
  }

  function wrapThen(original) {
    return function wrappedThen() {
      var promise = this;
      var next = original.apply(promise, Array.prototype.map.call(arguments, bind));

      next.__asl_wrapper = function proxyWrapper(ctx, fn, val, last) {
        if (promise.__asl_wrapper) {
          promise.__asl_wrapper(ctx, function () {}, null, next);
          return next.__asl_wrapper(ctx, fn, val, last);
        }
        return propagateAslWrapper(ctx, fn, val, last);
      }

      return next;

      // wrap callbacks (success, error) so that the callbacks will be called as a
      // continuations of the resolve or reject call using the __asl_wrapper created above.
      function bind(fn) {
        if (typeof fn !== 'function') return fn;
        return wrapCallback(function (val) {
          var result = (promise.__asl_wrapper || propagateAslWrapper)(this, fn, val, next);
          if (result.error) {
            throw result.errorVal
          } else {
            return result.returnVal
          }
        });
      }
    }
  }
}

// Shim activator for functions that have callback last
function activator(fn) {
  var fallback = function () {
    var args;
    var cbIdx = arguments.length - 1;
    if (typeof arguments[cbIdx] === "function") {
      args = Array(arguments.length)
      for (var i = 0; i < arguments.length - 1; i++) {
        args[i] = arguments[i];
      }
      args[cbIdx] = wrapCallback(arguments[cbIdx]);
    }
    return fn.apply(this, args || arguments);
  };
  // Preserve function length for small arg count functions.
  switch (fn.length) {
    case 1:
      return function (cb) {
        if (arguments.length !== 1) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb);
      };
    case 2:
      return function (a, cb) {
        if (arguments.length !== 2) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, a, cb);
      };
    case 3:
      return function (a, b, cb) {
        if (arguments.length !== 3) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, a, b, cb);
      };
    case 4:
      return function (a, b, c, cb) {
        if (arguments.length !== 4) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, a, b, c, cb);
      };
    case 5:
      return function (a, b, c, d, cb) {
        if (arguments.length !== 5) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, a, b, c, d, cb);
      };
    case 6:
      return function (a, b, c, d, e, cb) {
        if (arguments.length !== 6) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, a, b, c, d, e, cb);
      };
    default:
      return fallback;
  }
}

// Shim activator for functions that have callback first
function activatorFirst(fn) {
  var fallback = function () {
    var args;
    if (typeof arguments[0] === "function") {
      args = Array(arguments.length)
      args[0] = wrapCallback(arguments[0]);
      for (var i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
    }
    return fn.apply(this, args || arguments);
  };
  // Preserve function length for small arg count functions.
  switch (fn.length) {
    case 1:
      return function (cb) {
        if (arguments.length !== 1) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb);
      };
    case 2:
      return function (cb, a) {
        if (arguments.length !== 2) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb, a);
      };
    case 3:
      return function (cb, a, b) {
        if (arguments.length !== 3) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb, a, b);
      };
    case 4:
      return function (cb, a, b, c) {
        if (arguments.length !== 4) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb, a, b, c);
      };
    case 5:
      return function (cb, a, b, c, d) {
        if (arguments.length !== 5) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb, a, b, c, d);
      };
    case 6:
      return function (cb, a, b, c, d, e) {
        if (arguments.length !== 6) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb, a, b, c, d, e);
      };
    default:
      return fallback;
  }
}

// taken from node master on 2017/03/09
function toNumber(x) {
  return (x = Number(x)) >= 0 ? x : false;
}

// taken from node master on 2017/03/09
function isPipeName(s) {
  return typeof s === 'string' && toNumber(s) === false;
}


/***/ }),

/***/ 89611:
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),

/***/ 61674:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(21554);

/***/ }),

/***/ 68110:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);
var settle = __webpack_require__(13499);
var buildFullPath = __webpack_require__(52643);
var buildURL = __webpack_require__(54787);
var http = __webpack_require__(13685);
var https = __webpack_require__(95687);
var httpFollow = (__webpack_require__(36740).http);
var httpsFollow = (__webpack_require__(36740).https);
var url = __webpack_require__(57310);
var zlib = __webpack_require__(59796);
var pkg = __webpack_require__(19521);
var createError = __webpack_require__(48839);
var enhanceError = __webpack_require__(69793);

var isHttps = /https:?/;

/**
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} proxy
 * @param {string} location
 */
function setProxy(options, proxy, location) {
  options.hostname = proxy.host;
  options.host = proxy.host;
  options.port = proxy.port;
  options.path = location;

  // Basic proxy authorization
  if (proxy.auth) {
    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
    options.headers['Proxy-Authorization'] = 'Basic ' + base64;
  }

  // If a proxy is used, any redirects must also pass through the proxy
  options.beforeRedirect = function beforeRedirect(redirection) {
    redirection.headers.host = redirection.host;
    setProxy(redirection, proxy, redirection.href);
  };
}

/*eslint consistent-return:0*/
module.exports = function httpAdapter(config) {
  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
    var resolve = function resolve(value) {
      resolvePromise(value);
    };
    var reject = function reject(value) {
      rejectPromise(value);
    };
    var data = config.data;
    var headers = config.headers;

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    if ('User-Agent' in headers || 'user-agent' in headers) {
      // User-Agent is specified; handle case where no UA header is desired
      if (!headers['User-Agent'] && !headers['user-agent']) {
        delete headers['User-Agent'];
        delete headers['user-agent'];
      }
      // Otherwise, use specified value
    } else {
      // Only set header if it hasn't been set in config
      headers['User-Agent'] = 'axios/' + pkg.version;
    }

    if (data && !utils.isStream(data)) {
      if (Buffer.isBuffer(data)) {
        // Nothing to do...
      } else if (utils.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(createError(
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          config
        ));
      }

      // Add Content-Length header if data exists
      headers['Content-Length'] = data.length;
    }

    // HTTP basic authentication
    var auth = undefined;
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      auth = username + ':' + password;
    }

    // Parse url
    var fullPath = buildFullPath(config.baseURL, config.url);
    var parsed = url.parse(fullPath);
    var protocol = parsed.protocol || 'http:';

    if (!auth && parsed.auth) {
      var urlAuth = parsed.auth.split(':');
      var urlUsername = urlAuth[0] || '';
      var urlPassword = urlAuth[1] || '';
      auth = urlUsername + ':' + urlPassword;
    }

    if (auth) {
      delete headers.Authorization;
    }

    var isHttpsRequest = isHttps.test(protocol);
    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

    var options = {
      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
      method: config.method.toUpperCase(),
      headers: headers,
      agent: agent,
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth: auth
    };

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
    }

    var proxy = config.proxy;
    if (!proxy && proxy !== false) {
      var proxyEnv = protocol.slice(0, -1) + '_proxy';
      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
      if (proxyUrl) {
        var parsedProxyUrl = url.parse(proxyUrl);
        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
        var shouldProxy = true;

        if (noProxyEnv) {
          var noProxy = noProxyEnv.split(',').map(function trim(s) {
            return s.trim();
          });

          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
            if (!proxyElement) {
              return false;
            }
            if (proxyElement === '*') {
              return true;
            }
            if (proxyElement[0] === '.' &&
                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
              return true;
            }

            return parsed.hostname === proxyElement;
          });
        }

        if (shouldProxy) {
          proxy = {
            host: parsedProxyUrl.hostname,
            port: parsedProxyUrl.port,
            protocol: parsedProxyUrl.protocol
          };

          if (parsedProxyUrl.auth) {
            var proxyUrlAuth = parsedProxyUrl.auth.split(':');
            proxy.auth = {
              username: proxyUrlAuth[0],
              password: proxyUrlAuth[1]
            };
          }
        }
      }
    }

    if (proxy) {
      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    var transport;
    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsProxy ? https : http;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      transport = isHttpsProxy ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    }

    // Create the request
    var req = transport.request(options, function handleResponse(res) {
      if (req.aborted) return;

      // uncompress the response body transparently if required
      var stream = res;

      // return the last request in case of redirects
      var lastRequest = res.req || req;


      // if no content, is HEAD request or decompress disabled we should not decompress
      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
        switch (res.headers['content-encoding']) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'compress':
        case 'deflate':
        // add the unzipper to the body stream processing pipeline
          stream = stream.pipe(zlib.createUnzip());

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        }
      }

      var response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: res.headers,
        config: config,
        request: lastRequest
      };

      if (config.responseType === 'stream') {
        response.data = stream;
        settle(resolve, reject, response);
      } else {
        var responseBuffer = [];
        var totalResponseBytes = 0;
        stream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            stream.destroy();
            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              config, null, lastRequest));
          }
        });

        stream.on('error', function handleStreamError(err) {
          if (req.aborted) return;
          reject(enhanceError(err, config, null, lastRequest));
        });

        stream.on('end', function handleStreamEnd() {
          var responseData = Buffer.concat(responseBuffer);
          if (config.responseType !== 'arraybuffer') {
            responseData = responseData.toString(config.responseEncoding);
            if (!config.responseEncoding || config.responseEncoding === 'utf8') {
              responseData = utils.stripBOM(responseData);
            }
          }

          response.data = responseData;
          settle(resolve, reject, response);
        });
      }
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;
      reject(enhanceError(err, config, null, req));
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      var timeout = parseInt(config.timeout, 10);

      if (isNaN(timeout)) {
        reject(createError(
          'error trying to parse `config.timeout` to int',
          config,
          'ERR_PARSE_TIMEOUT',
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devoring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        req.abort();
        reject(createError(
          'timeout of ' + timeout + 'ms exceeded',
          config,
          config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
          req
        ));
      });
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (req.aborted) return;

        req.abort();
        reject(cancel);
      });
    }

    // Send the request
    if (utils.isStream(data)) {
      data.on('error', function handleStreamError(err) {
        reject(enhanceError(err, config, null, req));
      }).pipe(req);
    } else {
      req.end(data);
    }
  });
};


/***/ }),

/***/ 67268:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);
var settle = __webpack_require__(13499);
var cookies = __webpack_require__(23966);
var buildURL = __webpack_require__(54787);
var buildFullPath = __webpack_require__(52643);
var parseHeaders = __webpack_require__(21451);
var isURLSameOrigin = __webpack_require__(3968);
var createError = __webpack_require__(48839);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ 21554:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);
var bind = __webpack_require__(36542);
var Axios = __webpack_require__(83930);
var mergeConfig = __webpack_require__(81842);
var defaults = __webpack_require__(60130);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(64831);
axios.CancelToken = __webpack_require__(82086);
axios.isCancel = __webpack_require__(27777);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(96769);

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(4997);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ 64831:
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ 82086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(64831);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ 27777:
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ 83930:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);
var buildURL = __webpack_require__(54787);
var InterceptorManager = __webpack_require__(14239);
var dispatchRequest = __webpack_require__(82705);
var mergeConfig = __webpack_require__(81842);
var validator = __webpack_require__(59033);

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ 14239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ 52643:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(95930);
var combineURLs = __webpack_require__(65446);

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ 48839:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(69793);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ 82705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);
var transformData = __webpack_require__(51672);
var isCancel = __webpack_require__(27777);
var defaults = __webpack_require__(60130);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ 69793:
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ 81842:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ 13499:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(48839);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ 51672:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);
var defaults = __webpack_require__(60130);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ 60130:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);
var normalizeHeaderName = __webpack_require__(77642);
var enhanceError = __webpack_require__(69793);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(67268);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(68110);
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ 36542:
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ 54787:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ 65446:
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ 23966:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ 95930:
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ 4997:
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ 3968:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ 77642:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ 21451:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(97770);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ 96769:
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ 59033:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var pkg = __webpack_require__(19521);

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');

/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */
function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}

/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ 97770:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(36542);

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ 11424:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ansiStyles = __webpack_require__(29237);
const {stdout: stdoutColor, stderr: stderrColor} = __webpack_require__(82035);
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = __webpack_require__(50621);

const {isArray} = Array;

// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
			return applyStyle(builder, chalkTag(builder, ...arguments_));
		}

		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!isArray(firstString) || !isArray(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = __webpack_require__(79397);
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

module.exports = chalk;


/***/ }),

/***/ 79397:
/***/ ((module) => {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

module.exports = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMessage);
	}

	return chunks.join('');
};


/***/ }),

/***/ 50621:
/***/ ((module) => {

"use strict";


const stringReplaceAll = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

module.exports = {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
};


/***/ }),

/***/ 28807:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(73837);
const assert = __webpack_require__(39491);
const wrapEmitter = __webpack_require__(5422);
const asyncHook = __webpack_require__(98375);

const CONTEXTS_SYMBOL = 'cls@contexts';
const ERROR_SYMBOL = 'error@context';

//const trace = [];

const invertedProviders = [];
for (let key in asyncHook.providers) {
  invertedProviders[asyncHook.providers[key]] = key;
}

const DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;

let currentUid = -1;

module.exports = {
  getNamespace: getNamespace,
  createNamespace: createNamespace,
  destroyNamespace: destroyNamespace,
  reset: reset,
  //trace: trace,
  ERROR_SYMBOL: ERROR_SYMBOL
};

function Namespace(name) {
  this.name = name;
  // changed in 2.7: no default context
  this.active = null;
  this._set = [];
  this.id = null;
  this._contexts = new Map();
}

Namespace.prototype.set = function set(key, value) {
  if (!this.active) {
    throw new Error('No context available. ns.run() or ns.bind() must be called first.');
  }

  if (DEBUG_CLS_HOOKED) {
    debug2('    SETTING KEY:' + key + '=' + value + ' in ns:' + this.name + ' uid:' + currentUid + ' active:' +
      util.inspect(this.active, true));
  }
  this.active[key] = value;
  return value;
};

Namespace.prototype.get = function get(key) {
  if (!this.active) {
    if (DEBUG_CLS_HOOKED) {
      debug2('    GETTING KEY:' + key + '=undefined' + ' ' + this.name + ' uid:' + currentUid + ' active:' +
        util.inspect(this.active, true));
    }
    return undefined;
  }
  if (DEBUG_CLS_HOOKED) {
    debug2('    GETTING KEY:' + key + '=' + this.active[key] + ' ' + this.name + ' uid:' + currentUid + ' active:' +
      util.inspect(this.active, true));
  }
  return this.active[key];
};

Namespace.prototype.createContext = function createContext() {
  if (DEBUG_CLS_HOOKED) {
    debug2('   CREATING Context: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' + ' active:' +
      util.inspect(this.active, true, 2, true));
  }

  let context = Object.create(this.active ? this.active : Object.prototype);
  context._ns_name = this.name;
  context.id = currentUid;

  if (DEBUG_CLS_HOOKED) {
    debug2('   CREATED Context: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' + ' context:' +
      util.inspect(context, true, 2, true));
  }

  return context;
};

Namespace.prototype.run = function run(fn) {
  let context = this.createContext();
  this.enter(context);
  try {
    if (DEBUG_CLS_HOOKED) {
      debug2(' BEFORE RUN: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +
        util.inspect(context));
    }
    fn(context);
    return context;
  }
  catch (exception) {
    if (exception) {
      exception[ERROR_SYMBOL] = context;
    }
    throw exception;
  }
  finally {
    if (DEBUG_CLS_HOOKED) {
      debug2(' AFTER RUN: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +
        util.inspect(context));
    }
    this.exit(context);
  }
};

Namespace.prototype.runAndReturn = function runAndReturn(fn) {
  var value;
  this.run(function (context) {
    value = fn(context);
  });
  return value;
};

/**
 * Uses global Promise and assumes Promise is cls friendly or wrapped already.
 * @param {function} fn
 * @returns {*}
 */
Namespace.prototype.runPromise = function runPromise(fn) {
  let context = this.createContext();
  this.enter(context);

  let promise = fn(context);
  if (!promise || !promise.then || !promise.catch) {
    throw new Error('fn must return a promise.');
  }

  if (DEBUG_CLS_HOOKED) {
    debug2(' BEFORE runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +
      util.inspect(context));
  }

  return promise
    .then(result => {
      if (DEBUG_CLS_HOOKED) {
        debug2(' AFTER runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +
          util.inspect(context));
      }
      this.exit(context);
      return result;
    })
    .catch(err => {
      err[ERROR_SYMBOL] = context;
      if (DEBUG_CLS_HOOKED) {
        debug2(' AFTER runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +
          util.inspect(context));
      }
      this.exit(context);
      throw err;
    });
};

Namespace.prototype.bind = function bindFactory(fn, context) {
  if (!context) {
    if (!this.active) {
      context = this.createContext();
    }
    else {
      context = this.active;
    }
  }

  let self = this;
  return function clsBind() {
    self.enter(context);
    try {
      return fn.apply(this, arguments);
    }
    catch (exception) {
      if (exception) {
        exception[ERROR_SYMBOL] = context;
      }
      throw exception;
    }
    finally {
      self.exit(context);
    }
  };
};

Namespace.prototype.enter = function enter(context) {
  assert.ok(context, 'context must be provided for entering');
  if (DEBUG_CLS_HOOKED) {
    debug2('  ENTER ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' context: ' +
      util.inspect(context));
  }

  this._set.push(this.active);
  this.active = context;
};

Namespace.prototype.exit = function exit(context) {
  assert.ok(context, 'context must be provided for exiting');
  if (DEBUG_CLS_HOOKED) {
    debug2('  EXIT ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' context: ' +
      util.inspect(context));
  }

  // Fast path for most exits that are at the top of the stack
  if (this.active === context) {
    assert.ok(this._set.length, 'can\'t remove top context');
    this.active = this._set.pop();
    return;
  }

  // Fast search in the stack using lastIndexOf
  let index = this._set.lastIndexOf(context);

  if (index < 0) {
    if (DEBUG_CLS_HOOKED) {
      debug2('??ERROR?? context exiting but not entered - ignoring: ' + util.inspect(context));
    }
    assert.ok(index >= 0, 'context not currently entered; can\'t exit. \n' + util.inspect(this) + '\n' +
      util.inspect(context));
  } else {
    assert.ok(index, 'can\'t remove top context');
    this._set.splice(index, 1);
  }
};

Namespace.prototype.bindEmitter = function bindEmitter(emitter) {
  assert.ok(emitter.on && emitter.addListener && emitter.emit, 'can only bind real EEs');

  let namespace = this;
  let thisSymbol = 'context@' + this.name;

  // Capture the context active at the time the emitter is bound.
  function attach(listener) {
    if (!listener) {
      return;
    }
    if (!listener[CONTEXTS_SYMBOL]) {
      listener[CONTEXTS_SYMBOL] = Object.create(null);
    }

    listener[CONTEXTS_SYMBOL][thisSymbol] = {
      namespace: namespace,
      context: namespace.active
    };
  }

  // At emit time, bind the listener within the correct context.
  function bind(unwrapped) {
    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {
      return unwrapped;
    }

    let wrapped = unwrapped;
    let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];
    Object.keys(unwrappedContexts).forEach(function (name) {
      let thunk = unwrappedContexts[name];
      wrapped = thunk.namespace.bind(wrapped, thunk.context);
    });
    return wrapped;
  }

  wrapEmitter(emitter, attach, bind);
};

/**
 * If an error comes out of a namespace, it will have a context attached to it.
 * This function knows how to find it.
 *
 * @param {Error} exception Possibly annotated error.
 */
Namespace.prototype.fromException = function fromException(exception) {
  return exception[ERROR_SYMBOL];
};

function getNamespace(name) {
  return process.namespaces[name];
}

function createNamespace(name) {
  assert.ok(name, 'namespace must be given a name.');

  if (DEBUG_CLS_HOOKED) {
    debug2('CREATING NAMESPACE ' + name);
  }
  let namespace = new Namespace(name);
  namespace.id = currentUid;

  asyncHook.addHooks({
    init(uid, handle, provider, parentUid, parentHandle) {
      //parentUid = parentUid || currentUid;  // Suggested usage but appears to work better for tracing modules.
      currentUid = uid;

      //CHAIN Parent's Context onto child if none exists. This is needed to pass net-events.spec
      if (parentUid) {
        namespace._contexts.set(uid, namespace._contexts.get(parentUid));
        if (DEBUG_CLS_HOOKED) {
          debug2('PARENTID: ' + name + ' uid:' + uid + ' parent:' + parentUid + ' provider:' + provider);
        }
      } else {
        namespace._contexts.set(currentUid, namespace.active);
      }

      if (DEBUG_CLS_HOOKED) {
        debug2('INIT ' + name + ' uid:' + uid + ' parent:' + parentUid + ' provider:' + invertedProviders[provider]
          + ' active:' + util.inspect(namespace.active, true));
      }

    },
    pre(uid, handle) {
      currentUid = uid;
      let context = namespace._contexts.get(uid);
      if (context) {
        if (DEBUG_CLS_HOOKED) {
          debug2(' PRE ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle) + ' context:' +
            util.inspect(context));
        }

        namespace.enter(context);
      } else {
        if (DEBUG_CLS_HOOKED) {
          debug2(' PRE MISSING CONTEXT ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle));
        }
      }
    },
    post(uid, handle) {
      currentUid = uid;
      let context = namespace._contexts.get(uid);
      if (context) {
        if (DEBUG_CLS_HOOKED) {
          debug2(' POST ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle) + ' context:' +
            util.inspect(context));
        }

        namespace.exit(context);
      } else {
        if (DEBUG_CLS_HOOKED) {
          debug2(' POST MISSING CONTEXT ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle));
        }
      }
    },
    destroy(uid) {
      currentUid = uid;

      if (DEBUG_CLS_HOOKED) {
        debug2('DESTROY ' + name + ' uid:' + uid + ' context:' + util.inspect(namespace._contexts.get(currentUid))
          + ' active:' + util.inspect(namespace.active, true));
      }

      namespace._contexts.delete(uid);
    }
  });

  process.namespaces[name] = namespace;
  return namespace;
}

function destroyNamespace(name) {
  let namespace = getNamespace(name);

  assert.ok(namespace, 'can\'t delete nonexistent namespace! "' + name + '"');
  assert.ok(namespace.id, 'don\'t assign to process.namespaces directly! ' + util.inspect(namespace));

  process.namespaces[name] = null;
}

function reset() {
  // must unregister async listeners
  if (process.namespaces) {
    Object.keys(process.namespaces).forEach(function (name) {
      destroyNamespace(name);
    });
  }
  process.namespaces = Object.create(null);
}

process.namespaces = {};

if (asyncHook._state && !asyncHook._state.enabled) {
  asyncHook.enable();
}

function debug2(msg) {
  if (process.env.DEBUG) {
    process._rawDebug(msg);
  }
}


/*function debug(from, ns) {
 process._rawDebug('DEBUG: ' + util.inspect({
 from: from,
 currentUid: currentUid,
 context: ns ? ns._contexts.get(currentUid) : 'no ns'
 }, true, 2, true));
 }*/


function getFunctionName(fn) {
  if (!fn) {
    return fn;
  }
  if (typeof fn === 'function') {
    if (fn.name) {
      return fn.name;
    }
    return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
  } else if (fn.constructor && fn.constructor.name) {
    return fn.constructor.name;
  }
}


// Add back to callstack
if (DEBUG_CLS_HOOKED) {
  var stackChain = __webpack_require__(33705);
  for (var modifier in stackChain.filter._modifiers) {
    stackChain.filter.deattach(modifier);
  }
}


/***/ }),

/***/ 20410:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable max-len */


const util = __webpack_require__(73837);
const assert = __webpack_require__(39491);
const wrapEmitter = __webpack_require__(5422);
const async_hooks = __webpack_require__(50852);

const CONTEXTS_SYMBOL = 'cls@contexts';
const ERROR_SYMBOL = 'error@context';

const DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;

let currentUid = -1;

module.exports = {
  getNamespace: getNamespace,
  createNamespace: createNamespace,
  destroyNamespace: destroyNamespace,
  reset: reset,
  ERROR_SYMBOL: ERROR_SYMBOL
};

function Namespace(name) {
  this.name = name;
  // changed in 2.7: no default context
  this.active = null;
  this._set = [];
  this.id = null;
  this._contexts = new Map();
  this._indent = 0;
}

Namespace.prototype.set = function set(key, value) {
  if (!this.active) {
    throw new Error('No context available. ns.run() or ns.bind() must be called first.');
  }

  this.active[key] = value;

  if (DEBUG_CLS_HOOKED) {
    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
    debug2(indentStr + 'CONTEXT-SET KEY:' + key + '=' + value + ' in ns:' + this.name + ' currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));
  }

  return value;
};

Namespace.prototype.get = function get(key) {
  if (!this.active) {
    if (DEBUG_CLS_HOOKED) {
      const asyncHooksCurrentId = async_hooks.currentId();
      const triggerId = async_hooks.triggerAsyncId();
      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
      //debug2(indentStr + 'CONTEXT-GETTING KEY NO ACTIVE NS:' + key + '=undefined' + ' (' + this.name + ') currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));
      debug2(`${indentStr}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${key}=undefined currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length}`);
    }
    return undefined;
  }
  if (DEBUG_CLS_HOOKED) {
    const asyncHooksCurrentId = async_hooks.executionAsyncId();
    const triggerId = async_hooks.triggerAsyncId();
    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
    debug2(indentStr + 'CONTEXT-GETTING KEY:' + key + '=' + this.active[key] + ' (' + this.name + ') currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));
    debug2(`${indentStr}CONTEXT-GETTING KEY: (${this.name}) ${key}=${this.active[key]} currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} active:${util.inspect(this.active)}`);
  }
  return this.active[key];
};

Namespace.prototype.createContext = function createContext() {
  // Prototype inherit existing context if created a new child context within existing context.
  let context = Object.create(this.active ? this.active : Object.prototype);
  context._ns_name = this.name;
  context.id = currentUid;

  if (DEBUG_CLS_HOOKED) {
    const asyncHooksCurrentId = async_hooks.executionAsyncId();
    const triggerId = async_hooks.triggerAsyncId();
    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
    debug2(`${indentStr}CONTEXT-CREATED Context: (${this.name}) currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} context:${util.inspect(context, {showHidden:true, depth:2, colors:true})}`);
  }

  return context;
};

Namespace.prototype.run = function run(fn) {
  let context = this.createContext();
  this.enter(context);

  try {
    if (DEBUG_CLS_HOOKED) {
      const triggerId = async_hooks.triggerAsyncId();
      const asyncHooksCurrentId = async_hooks.executionAsyncId();
      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
      debug2(`${indentStr}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} context:${util.inspect(context)}`);
    }
    fn(context);
    return context;
  } catch (exception) {
    if (exception) {
      exception[ERROR_SYMBOL] = context;
    }
    throw exception;
  } finally {
    if (DEBUG_CLS_HOOKED) {
      const triggerId = async_hooks.triggerAsyncId();
      const asyncHooksCurrentId = async_hooks.executionAsyncId();
      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
      debug2(`${indentStr}CONTEXT-RUN END: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
    }
    this.exit(context);
  }
};

Namespace.prototype.runAndReturn = function runAndReturn(fn) {
  let value;
  this.run(function (context) {
    value = fn(context);
  });
  return value;
};

/**
 * Uses global Promise and assumes Promise is cls friendly or wrapped already.
 * @param {function} fn
 * @returns {*}
 */
Namespace.prototype.runPromise = function runPromise(fn) {
  let context = this.createContext();
  this.enter(context);

  let promise = fn(context);
  if (!promise || !promise.then || !promise.catch) {
    throw new Error('fn must return a promise.');
  }

  if (DEBUG_CLS_HOOKED) {
    debug2('CONTEXT-runPromise BEFORE: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));
  }

  return promise
    .then(result => {
      if (DEBUG_CLS_HOOKED) {
        debug2('CONTEXT-runPromise AFTER then: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));
      }
      this.exit(context);
      return result;
    })
    .catch(err => {
      err[ERROR_SYMBOL] = context;
      if (DEBUG_CLS_HOOKED) {
        debug2('CONTEXT-runPromise AFTER catch: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));
      }
      this.exit(context);
      throw err;
    });
};

Namespace.prototype.bind = function bindFactory(fn, context) {
  if (!context) {
    if (!this.active) {
      context = this.createContext();
    } else {
      context = this.active;
    }
  }

  let self = this;
  return function clsBind() {
    self.enter(context);
    try {
      return fn.apply(this, arguments);
    } catch (exception) {
      if (exception) {
        exception[ERROR_SYMBOL] = context;
      }
      throw exception;
    } finally {
      self.exit(context);
    }
  };
};

Namespace.prototype.enter = function enter(context) {
  assert.ok(context, 'context must be provided for entering');
  if (DEBUG_CLS_HOOKED) {
    const asyncHooksCurrentId = async_hooks.executionAsyncId();
    const triggerId = async_hooks.triggerAsyncId();
    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
    debug2(`${indentStr}CONTEXT-ENTER: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
  }

  this._set.push(this.active);
  this.active = context;
};

Namespace.prototype.exit = function exit(context) {
  assert.ok(context, 'context must be provided for exiting');
  if (DEBUG_CLS_HOOKED) {
    const asyncHooksCurrentId = async_hooks.executionAsyncId();
    const triggerId = async_hooks.triggerAsyncId();
    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
    debug2(`${indentStr}CONTEXT-EXIT: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
  }

  // Fast path for most exits that are at the top of the stack
  if (this.active === context) {
    assert.ok(this._set.length, 'can\'t remove top context');
    this.active = this._set.pop();
    return;
  }

  // Fast search in the stack using lastIndexOf
  let index = this._set.lastIndexOf(context);

  if (index < 0) {
    if (DEBUG_CLS_HOOKED) {
      debug2('??ERROR?? context exiting but not entered - ignoring: ' + util.inspect(context));
    }
    assert.ok(index >= 0, 'context not currently entered; can\'t exit. \n' + util.inspect(this) + '\n' + util.inspect(context));
  } else {
    assert.ok(index, 'can\'t remove top context');
    this._set.splice(index, 1);
  }
};

Namespace.prototype.bindEmitter = function bindEmitter(emitter) {
  assert.ok(emitter.on && emitter.addListener && emitter.emit, 'can only bind real EEs');

  let namespace = this;
  let thisSymbol = 'context@' + this.name;

  // Capture the context active at the time the emitter is bound.
  function attach(listener) {
    if (!listener) {
      return;
    }
    if (!listener[CONTEXTS_SYMBOL]) {
      listener[CONTEXTS_SYMBOL] = Object.create(null);
    }

    listener[CONTEXTS_SYMBOL][thisSymbol] = {
      namespace: namespace,
      context: namespace.active
    };
  }

  // At emit time, bind the listener within the correct context.
  function bind(unwrapped) {
    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {
      return unwrapped;
    }

    let wrapped = unwrapped;
    let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];
    Object.keys(unwrappedContexts).forEach(function (name) {
      let thunk = unwrappedContexts[name];
      wrapped = thunk.namespace.bind(wrapped, thunk.context);
    });
    return wrapped;
  }

  wrapEmitter(emitter, attach, bind);
};

/**
 * If an error comes out of a namespace, it will have a context attached to it.
 * This function knows how to find it.
 *
 * @param {Error} exception Possibly annotated error.
 */
Namespace.prototype.fromException = function fromException(exception) {
  return exception[ERROR_SYMBOL];
};

function getNamespace(name) {
  return process.namespaces[name];
}

function createNamespace(name) {
  assert.ok(name, 'namespace must be given a name.');

  if (DEBUG_CLS_HOOKED) {
    debug2(`NS-CREATING NAMESPACE (${name})`);
  }
  let namespace = new Namespace(name);
  namespace.id = currentUid;

  const hook = async_hooks.createHook({
    init(asyncId, type, triggerId, resource) {
      currentUid = async_hooks.executionAsyncId();

      //CHAIN Parent's Context onto child if none exists. This is needed to pass net-events.spec
      // let initContext = namespace.active;
      // if(!initContext && triggerId) {
      //   let parentContext = namespace._contexts.get(triggerId);
      //   if (parentContext) {
      //     namespace.active = parentContext;
      //     namespace._contexts.set(currentUid, parentContext);
      //     if (DEBUG_CLS_HOOKED) {
      //       const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
      //       debug2(`${indentStr}INIT [${type}] (${name}) WITH PARENT CONTEXT asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);
      //     }
      //   } else if (DEBUG_CLS_HOOKED) {
      //       const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
      //       debug2(`${indentStr}INIT [${type}] (${name}) MISSING CONTEXT asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);
      //     }
      // }else {
      //   namespace._contexts.set(currentUid, namespace.active);
      //   if (DEBUG_CLS_HOOKED) {
      //     const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
      //     debug2(`${indentStr}INIT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);
      //   }
      // }
      if(namespace.active) {
        namespace._contexts.set(asyncId, namespace.active);

        if (DEBUG_CLS_HOOKED) {
          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}INIT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} resource:${resource}`);
        }
      }else if(currentUid === 0){
        // CurrentId will be 0 when triggered from C++. Promise events
        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid
        const triggerId = async_hooks.triggerAsyncId();
        const triggerIdContext = namespace._contexts.get(triggerId);
        if (triggerIdContext) {
          namespace._contexts.set(asyncId, triggerIdContext);
          if (DEBUG_CLS_HOOKED) {
            const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}INIT USING CONTEXT FROM TRIGGERID [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
          }
        } else if (DEBUG_CLS_HOOKED) {
          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}INIT MISSING CONTEXT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
        }
      }


      if(DEBUG_CLS_HOOKED && type === 'PROMISE'){
        debug2(util.inspect(resource, {showHidden: true}));
        const parentId = resource.parentId;
        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}INIT RESOURCE-PROMISE [${type}] (${name}) parentId:${parentId} asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} resource:${resource}`);
      }

    },
    before(asyncId) {
      currentUid = async_hooks.executionAsyncId();
      let context;

      /*
      if(currentUid === 0){
        // CurrentId will be 0 when triggered from C++. Promise events
        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid
        //const triggerId = async_hooks.triggerAsyncId();
        context = namespace._contexts.get(asyncId); // || namespace._contexts.get(triggerId);
      }else{
        context = namespace._contexts.get(currentUid);
      }
      */

      //HACK to work with promises until they are fixed in node > 8.1.1
      context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);

      if (context) {
        if (DEBUG_CLS_HOOKED) {
          const triggerId = async_hooks.triggerAsyncId();
          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}BEFORE (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);
          namespace._indent += 2;
        }

        namespace.enter(context);

      } else if (DEBUG_CLS_HOOKED) {
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}BEFORE MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} namespace._contexts:${util.inspect(namespace._contexts, {showHidden:true, depth:2, colors:true})}`);
        namespace._indent += 2;
      }
    },
    after(asyncId) {
      currentUid = async_hooks.executionAsyncId();
      let context; // = namespace._contexts.get(currentUid);
      /*
      if(currentUid === 0){
        // CurrentId will be 0 when triggered from C++. Promise events
        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid
        //const triggerId = async_hooks.triggerAsyncId();
        context = namespace._contexts.get(asyncId); // || namespace._contexts.get(triggerId);
      }else{
        context = namespace._contexts.get(currentUid);
      }
      */
      //HACK to work with promises until they are fixed in node > 8.1.1
      context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);

      if (context) {
        if (DEBUG_CLS_HOOKED) {
          const triggerId = async_hooks.triggerAsyncId();
          namespace._indent -= 2;
          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}AFTER (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);
        }

        namespace.exit(context);

      } else if (DEBUG_CLS_HOOKED) {
        const triggerId = async_hooks.triggerAsyncId();
        namespace._indent -= 2;
        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}AFTER MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);
      }
    },
    destroy(asyncId) {
      currentUid = async_hooks.executionAsyncId();
      if (DEBUG_CLS_HOOKED) {
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}DESTROY (${name}) currentUid:${currentUid} asyncId:${asyncId} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(namespace._contexts.get(currentUid))}`);
      }

      namespace._contexts.delete(asyncId);
    }
  });

  hook.enable();

  process.namespaces[name] = namespace;
  return namespace;
}

function destroyNamespace(name) {
  let namespace = getNamespace(name);

  assert.ok(namespace, 'can\'t delete nonexistent namespace! "' + name + '"');
  assert.ok(namespace.id, 'don\'t assign to process.namespaces directly! ' + util.inspect(namespace));

  process.namespaces[name] = null;
}

function reset() {
  // must unregister async listeners
  if (process.namespaces) {
    Object.keys(process.namespaces).forEach(function (name) {
      destroyNamespace(name);
    });
  }
  process.namespaces = Object.create(null);
}

process.namespaces = {};

//const fs = require('fs');
function debug2(...args) {
  if (DEBUG_CLS_HOOKED) {
    //fs.writeSync(1, `${util.format(...args)}\n`);
    process._rawDebug(`${util.format(...args)}`);
  }
}

/*function getFunctionName(fn) {
  if (!fn) {
    return fn;
  }
  if (typeof fn === 'function') {
    if (fn.name) {
      return fn.name;
    }
    return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
  } else if (fn.constructor && fn.constructor.name) {
    return fn.constructor.name;
  }
}*/




/***/ }),

/***/ 48546:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const semver = __webpack_require__(41108);

/**
 * In order to increase node version support, this loads the version of context
 * that is appropriate for the version of on nodejs that is running.
 * Node < v8 - uses AsyncWrap and async-hooks-jl
 * Node >= v8 - uses native async-hooks
 */
if(process && semver.gte(process.versions.node, '8.0.0')){
  module.exports = __webpack_require__(20410);
}else{
  module.exports = __webpack_require__(28807);
}


/***/ }),

/***/ 41108:
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),

/***/ 13353:
/***/ ((module) => {

"use strict";
/* eslint-disable babel/new-cap, xo/throw-new-error */

module.exports = function (str, pos) {
	if (str === null || str === undefined) {
		throw TypeError();
	}

	str = String(str);

	var size = str.length;
	var i = pos ? Number(pos) : 0;

	if (Number.isNaN(i)) {
		i = 0;
	}

	if (i < 0 || i >= size) {
		return undefined;
	}

	var first = str.charCodeAt(i);

	if (first >= 0xD800 && first <= 0xDBFF && size > i + 1) {
		var second = str.charCodeAt(i + 1);

		if (second >= 0xDC00 && second <= 0xDFFF) {
			return ((first - 0xD800) * 0x400) + second - 0xDC00 + 0x10000;
		}
	}

	return first;
};


/***/ }),

/***/ 49897:
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ 55912:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {isArray} = __webpack_require__(22862)
const {sort} = __webpack_require__(70275)

const {
  SYMBOL_PREFIXES,

  UNDEFINED,

  symbol,
  copy_comments,
  swap_comments
} = __webpack_require__(70083)


const reverse_comments = array => {
  const {length} = array
  let i = 0
  const max = length / 2

  for (; i < max; i ++) {
    swap_comments(array, i, length - i - 1)
  }
}

const move_comment = (target, source, i, offset, remove) => {
  copy_comments(target, source, i + offset, i, remove)
}

const move_comments = (
  // `Array` target array
  target,
  // `Array` source array
  source,
  // `number` start index
  start,
  // `number` number of indexes to move
  count,
  // `number` offset to move
  offset,
  // `boolean` whether should remove the comments from source
  remove
) => {
  if (offset > 0) {
    let i = count
    //         |   count   | offset |
    // source: -------------
    // target:          -------------
    //         | remove |
    // => remove === offset

    // From [count - 1, 0]
    while (i -- > 0) {
      move_comment(target, source, start + i, offset, remove)
    }
    return
  }

  let i = 0
  // | remove  |  count    |
  //           -------------
  // -------------
  //             | offset  |

  // From [0, count - 1]
  while (i < count) {
    const ii = i ++
    move_comment(target, source, start + ii, offset, remove)
  }
}

const remove_comments = (array, key) => {
  SYMBOL_PREFIXES.forEach(prefix => {
    const prop = symbol(prefix, key)
    delete array[prop]
  })
}

const get_mapped = (map, key) => {
  let mapped = key

  while (mapped in map) {
    mapped = map[mapped]
  }

  return mapped
}


class CommentArray extends Array {
  // - deleteCount + items.length

  // We should avoid `splice(begin, deleteCount, ...items)`,
  // because `splice(0, undefined)` is not equivalent to `splice(0)`,
  // as well as:
  // - slice
  splice (...args) {
    const {length} = this
    const ret = super.splice(...args)

    // #16
    // If no element removed, we might still need to move comments,
    //   because splice could add new items

    // if (!ret.length) {
    //   return ret
    // }

    // JavaScript syntax is silly
    // eslint-disable-next-line prefer-const
    let [begin, deleteCount, ...items] = args

    if (begin < 0) {
      begin += length
    }

    if (arguments.length === 1) {
      deleteCount = length - begin
    } else {
      deleteCount = Math.min(length - begin, deleteCount)
    }

    const {
      length: item_length
    } = items

    // itemsToDelete: -
    // itemsToAdd: +
    //        |    dc      |  count   |
    // =======-------------============
    // =======++++++============
    //        | il |
    const offset = item_length - deleteCount
    const start = begin + deleteCount
    const count = length - start

    move_comments(this, this, start, count, offset, true)

    return ret
  }

  slice (...args) {
    const {length} = this
    const array = super.slice(...args)
    if (!array.length) {
      return new CommentArray()
    }

    let [begin, before] = args

    // Ref:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
    if (before === UNDEFINED) {
      before = length
    } else if (before < 0) {
      before += length
    }

    if (begin < 0) {
      begin += length
    } else if (begin === UNDEFINED) {
      begin = 0
    }

    move_comments(array, this, begin, before - begin, - begin)

    return array
  }

  unshift (...items) {
    const {length} = this
    const ret = super.unshift(...items)
    const {
      length: items_length
    } = items

    if (items_length > 0) {
      move_comments(this, this, 0, length, items_length, true)
    }

    return ret
  }

  shift () {
    const ret = super.shift()
    const {length} = this

    remove_comments(this, 0)
    move_comments(this, this, 1, length, - 1, true)

    return ret
  }

  reverse () {
    super.reverse()

    reverse_comments(this)

    return this
  }

  pop () {
    const ret = super.pop()

    // Removes comments
    remove_comments(this, this.length)

    return ret
  }

  concat (...items) {
    let {length} = this
    const ret = super.concat(...items)

    if (!items.length) {
      return ret
    }

    items.forEach(item => {
      const prev = length
      length += isArray(item)
        ? item.length
        : 1

      if (!(item instanceof CommentArray)) {
        return
      }

      move_comments(ret, item, 0, item.length, prev)
    })

    return ret
  }

  sort (...args) {
    const result = sort(
      this,
      // Make sure there is no more than one argument
      ...args.slice(0, 1)
    )

    // For example,
    // if we sort ['b', 'd', 'c', 'a'],
    // then `result` will be [3, 0, 2, 1], and the array is ['a', 'b', 'c', 'd']

    // First, we swap index 0 (b) and index 3 (a), then the array comments are
    // ['a.comments', 'd.comments', 'c.comments', 'b.comments']
    // index 0 is finalized
    // index 3 is actually mapped to original index 0, we present as 0 -> 3

    // Then swap index 1 (d) and index 0 (-> 3, b)
    // 1 (index) -> 0 (new index) -> 3 (real_index)
    // ['d.comments', 'b.comments', 'c.comments', 'd.comments']
    // index 1 is finalized
    // index 3 is contains the item of original index 1
    // - we present as 1 -> 3
    // - it is ok that we don't remove mapping 0 -> 3

    // Then index 2 should be skipped

    // Then swap index 3 (d) and index 1 (-> 3, b), skipped

    const map = Object.create(null)

    result.forEach((source_index, index) => {
      if (source_index === index) {
        return
      }

      const real_source_index = get_mapped(map, source_index)

      if (real_source_index === index) {
        return
      }

      // The item of index `index` gets the final value
      // delete map[index]
      map[index] = real_source_index

      swap_comments(this, index, real_source_index)
    })
  }
}


module.exports = {
  CommentArray
}


/***/ }),

/***/ 70083:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const hasOwnProperty = __webpack_require__(24339)
const {isObject, isArray} = __webpack_require__(22862)


const PREFIX_BEFORE = 'before'
const PREFIX_AFTER_PROP = 'after-prop'
const PREFIX_AFTER_COLON = 'after-colon'
const PREFIX_AFTER_VALUE = 'after-value'
const PREFIX_AFTER = 'after'

const PREFIX_BEFORE_ALL = 'before-all'
const PREFIX_AFTER_ALL = 'after-all'

const BRACKET_OPEN = '['
const BRACKET_CLOSE = ']'
const CURLY_BRACKET_OPEN = '{'
const CURLY_BRACKET_CLOSE = '}'
const COMMA = ','
const EMPTY = ''
const MINUS = '-'

const SYMBOL_PREFIXES = [
  PREFIX_BEFORE,
  PREFIX_AFTER_PROP,
  PREFIX_AFTER_COLON,
  PREFIX_AFTER_VALUE,
  PREFIX_AFTER
]

const NON_PROP_SYMBOL_KEYS = [
  PREFIX_BEFORE,
  PREFIX_BEFORE_ALL,
  PREFIX_AFTER_ALL
].map(Symbol.for)

const COLON = ':'
const UNDEFINED = undefined


const symbol = (prefix, key) => Symbol.for(prefix + COLON + key)

const define = (target, key, value) => Object.defineProperty(target, key, {
  value,
  writable: true,
  configurable: true
})

const copy_comments_by_kind = (
  target, source, target_key, source_key, prefix, remove_source
) => {
  const source_prop = symbol(prefix, source_key)
  if (!hasOwnProperty(source, source_prop)) {
    return
  }

  const target_prop = target_key === source_key
    ? source_prop
    : symbol(prefix, target_key)

  define(target, target_prop, source[source_prop])

  if (remove_source) {
    delete source[source_prop]
  }
}

const copy_comments = (
  target, source, target_key, source_key, remove_source
) => {
  SYMBOL_PREFIXES.forEach(prefix => {
    copy_comments_by_kind(
      target, source, target_key, source_key, prefix, remove_source
    )
  })
}

const swap_comments = (array, from, to) => {
  if (from === to) {
    return
  }

  SYMBOL_PREFIXES.forEach(prefix => {
    const target_prop = symbol(prefix, to)
    if (!hasOwnProperty(array, target_prop)) {
      copy_comments_by_kind(array, array, to, from, prefix, true)
      return
    }

    const comments = array[target_prop]
    delete array[target_prop]

    copy_comments_by_kind(array, array, to, from, prefix, true)
    define(array, symbol(prefix, from), comments)
  })
}

const assign_non_prop_comments = (target, source) => {
  NON_PROP_SYMBOL_KEYS.forEach(key => {
    const comments = source[key]

    if (comments) {
      define(target, key, comments)
    }
  })
}

// Assign keys and comments
const assign = (target, source, keys) => {
  keys.forEach(key => {
    if (!hasOwnProperty(source, key)) {
      return
    }

    target[key] = source[key]
    copy_comments(target, source, key, key)
  })

  return target
}


module.exports = {
  SYMBOL_PREFIXES,

  PREFIX_BEFORE,
  PREFIX_AFTER_PROP,
  PREFIX_AFTER_COLON,
  PREFIX_AFTER_VALUE,
  PREFIX_AFTER,

  PREFIX_BEFORE_ALL,
  PREFIX_AFTER_ALL,

  BRACKET_OPEN,
  BRACKET_CLOSE,
  CURLY_BRACKET_OPEN,
  CURLY_BRACKET_CLOSE,

  COLON,
  COMMA,
  MINUS,
  EMPTY,

  UNDEFINED,

  symbol,
  define,
  copy_comments,
  swap_comments,
  assign_non_prop_comments,

  assign (target, source, keys) {
    if (!isObject(target)) {
      throw new TypeError('Cannot convert undefined or null to object')
    }

    if (!isObject(source)) {
      return target
    }

    if (keys === UNDEFINED) {
      keys = Object.keys(source)
      // We assign non-property comments
      // if argument `keys` is not specified
      assign_non_prop_comments(target, source)
    } else if (!isArray(keys)) {
      throw new TypeError('keys must be array or undefined')
    } else if (keys.length === 0) {
      // Or argument `keys` is an empty array
      assign_non_prop_comments(target, source)
    }

    return assign(target, source, keys)
  }
}


/***/ }),

/***/ 36862:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {parse, tokenize} = __webpack_require__(24199)
const stringify = __webpack_require__(86953)
const {CommentArray} = __webpack_require__(55912)
const {assign} = __webpack_require__(70083)

module.exports = {
  parse,
  stringify,
  tokenize,

  CommentArray,
  assign
}


/***/ }),

/***/ 24199:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// JSON formatting

const esprima = __webpack_require__(21904)

const {
  CommentArray,
} = __webpack_require__(55912)

const {
  PREFIX_BEFORE,
  PREFIX_AFTER_PROP,
  PREFIX_AFTER_COLON,
  PREFIX_AFTER_VALUE,
  PREFIX_AFTER,

  PREFIX_BEFORE_ALL,
  PREFIX_AFTER_ALL,

  BRACKET_OPEN,
  BRACKET_CLOSE,
  CURLY_BRACKET_OPEN,
  CURLY_BRACKET_CLOSE,

  COLON,
  COMMA,
  MINUS,
  EMPTY,

  UNDEFINED,

  define,
  assign_non_prop_comments
} = __webpack_require__(70083)

const tokenize = code => esprima.tokenize(code, {
  comment: true,
  loc: true
})

const previous_hosts = []
let comments_host = null
let unassigned_comments = null

const previous_props = []
let last_prop

let remove_comments = false
let inline = false
let tokens = null
let last = null
let current = null
let index
let reviver = null

const clean = () => {
  previous_props.length =
  previous_hosts.length = 0

  last = null
  last_prop = UNDEFINED
}

const free = () => {
  clean()

  tokens.length = 0

  unassigned_comments =
  comments_host =
  tokens =
  last =
  current =
  reviver = null
}

const symbolFor = prefix => Symbol.for(
  last_prop !== UNDEFINED
    ? prefix + COLON + last_prop
    : prefix
)

const transform = (k, v) => reviver
  ? reviver(k, v)
  : v

const unexpected = () => {
  const error = new SyntaxError(`Unexpected token ${current.value.slice(0, 1)}`)
  Object.assign(error, current.loc.start)

  throw error
}

const unexpected_end = () => {
  const error = new SyntaxError('Unexpected end of JSON input')
  Object.assign(error, last
    ? last.loc.end
    // Empty string
    : {
      line: 1,
      column: 0
    })

  throw error
}

// Move the reader to the next
const next = () => {
  const new_token = tokens[++ index]
  inline = current
    && new_token
    && current.loc.end.line === new_token.loc.start.line
    || false

  last = current
  current = new_token
}

const type = () => {
  if (!current) {
    unexpected_end()
  }

  return current.type === 'Punctuator'
    ? current.value
    : current.type
}

const is = t => type() === t

const expect = a => {
  if (!is(a)) {
    unexpected()
  }
}

const set_comments_host = new_host => {
  previous_hosts.push(comments_host)
  comments_host = new_host
}

const restore_comments_host = () => {
  comments_host = previous_hosts.pop()
}

const assign_after_comments = () => {
  if (!unassigned_comments) {
    return
  }

  const after_comments = []

  for (const comment of unassigned_comments) {
    // If the comment is inline, then it is an after-comma comment
    if (comment.inline) {
      after_comments.push(comment)
    // Otherwise, all comments are before:<next-prop> comment
    } else {
      break
    }
  }

  const {length} = after_comments
  if (!length) {
    return
  }

  if (length === unassigned_comments.length) {
    // If unassigned_comments are all consumed
    unassigned_comments = null
  } else {
    unassigned_comments.splice(0, length)
  }

  define(comments_host, symbolFor(PREFIX_AFTER), after_comments)
}

const assign_comments = prefix => {
  if (!unassigned_comments) {
    return
  }

  define(comments_host, symbolFor(prefix), unassigned_comments)

  unassigned_comments = null
}

const parse_comments = prefix => {
  const comments = []

  while (
    current
    && (
      is('LineComment')
      || is('BlockComment')
    )
  ) {
    const comment = {
      ...current,
      inline
    }

    // delete comment.loc
    comments.push(comment)

    next()
  }

  if (remove_comments) {
    return
  }

  if (!comments.length) {
    return
  }

  if (prefix) {
    define(comments_host, symbolFor(prefix), comments)
    return
  }

  unassigned_comments = comments
}

const set_prop = (prop, push) => {
  if (push) {
    previous_props.push(last_prop)
  }

  last_prop = prop
}

const restore_prop = () => {
  last_prop = previous_props.pop()
}

const parse_object = () => {
  const obj = {}
  set_comments_host(obj)
  set_prop(UNDEFINED, true)

  let started = false
  let name

  parse_comments()

  while (!is(CURLY_BRACKET_CLOSE)) {
    if (started) {
      assign_comments(PREFIX_AFTER_VALUE)

      // key-value pair delimiter
      expect(COMMA)
      next()
      parse_comments()

      assign_after_comments()

      // If there is a trailing comma, we might reach the end
      // ```
      // {
      //   "a": 1,
      // }
      // ```
      if (is(CURLY_BRACKET_CLOSE)) {
        break
      }
    }

    started = true
    expect('String')
    name = JSON.parse(current.value)

    set_prop(name)
    assign_comments(PREFIX_BEFORE)

    next()
    parse_comments(PREFIX_AFTER_PROP)

    expect(COLON)

    next()
    parse_comments(PREFIX_AFTER_COLON)

    obj[name] = transform(name, walk())
    parse_comments()
  }

  if (started) {
    // If there are properties,
    // then the unassigned comments are after comments
    assign_comments(PREFIX_AFTER)
  }

  // bypass }
  next()
  last_prop = undefined

  if (!started) {
    // Otherwise, they are before comments
    assign_comments(PREFIX_BEFORE)
  }

  restore_comments_host()
  restore_prop()

  return obj
}

const parse_array = () => {
  const array = new CommentArray()
  set_comments_host(array)
  set_prop(UNDEFINED, true)

  let started = false
  let i = 0

  parse_comments()

  while (!is(BRACKET_CLOSE)) {
    if (started) {
      assign_comments(PREFIX_AFTER_VALUE)
      expect(COMMA)
      next()
      parse_comments()

      assign_after_comments()

      if (is(BRACKET_CLOSE)) {
        break
      }
    }

    started = true

    set_prop(i)
    assign_comments(PREFIX_BEFORE)

    array[i] = transform(i, walk())
    i ++

    parse_comments()
  }

  if (started) {
    assign_comments(PREFIX_AFTER)
  }

  next()
  last_prop = undefined

  if (!started) {
    assign_comments(PREFIX_BEFORE)
  }

  restore_comments_host()
  restore_prop()

  return array
}

function walk () {
  let tt = type()

  if (tt === CURLY_BRACKET_OPEN) {
    next()
    return parse_object()
  }

  if (tt === BRACKET_OPEN) {
    next()
    return parse_array()
  }

  let negative = EMPTY

  // -1
  if (tt === MINUS) {
    next()
    tt = type()
    negative = MINUS
  }

  let v

  switch (tt) {
  case 'String':
  case 'Boolean':
  case 'Null':
  case 'Numeric':
    v = current.value
    next()
    return JSON.parse(negative + v)
  default:
  }
}

const isObject = subject => Object(subject) === subject

const parse = (code, rev, no_comments) => {
  // Clean variables in closure
  clean()

  tokens = tokenize(code)
  reviver = rev
  remove_comments = no_comments

  if (!tokens.length) {
    unexpected_end()
  }

  index = - 1
  next()

  set_comments_host({})

  parse_comments(PREFIX_BEFORE_ALL)

  let result = walk()

  parse_comments(PREFIX_AFTER_ALL)

  if (current) {
    unexpected()
  }

  if (!no_comments && result !== null) {
    if (!isObject(result)) {
      // 1 -> new Number(1)
      // true -> new Boolean(1)
      // "foo" -> new String("foo")

      // eslint-disable-next-line no-new-object
      result = new Object(result)
    }

    assign_non_prop_comments(result, comments_host)
  }

  restore_comments_host()

  // reviver
  result = transform('', result)

  free()

  return result
}

module.exports = {
  parse,
  tokenize
}


/***/ }),

/***/ 86953:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  isArray, isObject, isFunction, isNumber, isString
} = __webpack_require__(22862)
const repeat = __webpack_require__(27947)

const {
  PREFIX_BEFORE_ALL,
  PREFIX_BEFORE,
  PREFIX_AFTER_PROP,
  PREFIX_AFTER_COLON,
  PREFIX_AFTER_VALUE,
  PREFIX_AFTER,
  PREFIX_AFTER_ALL,

  BRACKET_OPEN,
  BRACKET_CLOSE,
  CURLY_BRACKET_OPEN,
  CURLY_BRACKET_CLOSE,
  COLON,
  COMMA,
  EMPTY,

  UNDEFINED
} = __webpack_require__(70083)

// eslint-disable-next-line no-control-regex, no-misleading-character-class
const ESCAPABLE = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g

// String constants
const SPACE = ' '
const LF = '\n'
const STR_NULL = 'null'

// Symbol tags
const BEFORE = prop => `${PREFIX_BEFORE}:${prop}`
const AFTER_PROP = prop => `${PREFIX_AFTER_PROP}:${prop}`
const AFTER_COLON = prop => `${PREFIX_AFTER_COLON}:${prop}`
const AFTER_VALUE = prop => `${PREFIX_AFTER_VALUE}:${prop}`
const AFTER = prop => `${PREFIX_AFTER}:${prop}`

// table of character substitutions
const meta = {
  '\b': '\\b',
  '\t': '\\t',
  '\n': '\\n',
  '\f': '\\f',
  '\r': '\\r',
  '"': '\\"',
  '\\': '\\\\'
}

const escape = string => {
  ESCAPABLE.lastIndex = 0

  if (!ESCAPABLE.test(string)) {
    return string
  }

  return string.replace(ESCAPABLE, a => {
    const c = meta[a]
    return typeof c === 'string'
      ? c
      : a
  })
}

// Escape no control characters, no quote characters,
// and no backslash characters,
// then we can safely slap some quotes around it.
const quote = string => `"${escape(string)}"`
const comment_stringify = (value, line) => line
  ? `//${value}`
  : `/*${value}*/`

// display_block `boolean` whether the
//   WHOLE block of comments is always a block group
const process_comments = (host, symbol_tag, deeper_gap, display_block) => {
  const comments = host[Symbol.for(symbol_tag)]
  if (!comments || !comments.length) {
    return EMPTY
  }

  let is_line_comment = false

  const str = comments.reduce((prev, {
    inline,
    type,
    value
  }) => {
    const delimiter = inline
      ? SPACE
      : LF + deeper_gap

    is_line_comment = type === 'LineComment'

    return prev + delimiter + comment_stringify(value, is_line_comment)
  }, EMPTY)


  return display_block
  // line comment should always end with a LF
  || is_line_comment
    ? str + LF + deeper_gap
    : str
}

let replacer = null
let indent = EMPTY

const clean = () => {
  replacer = null
  indent = EMPTY
}

const join = (one, two, gap) =>
  one
    ? two
      // Symbol.for('before') and Symbol.for('before:prop')
      // might both exist if user mannually add comments to the object
      // and make a mistake.
      // SO, we are not to only trimRight but trim for both sides
      ? one + two.trim() + LF + gap
      : one.trimRight() + LF + gap
    : two
      ? two.trimRight() + LF + gap
      : EMPTY

const join_content = (inside, value, gap) => {
  const comment = process_comments(value, PREFIX_BEFORE, gap + indent, true)

  return join(comment, inside, gap)
}

// | deeper_gap   |
// | gap | indent |
//       [
//                "foo",
//                "bar"
//       ]
const array_stringify = (value, gap) => {
  const deeper_gap = gap + indent

  const {length} = value

  // From the item to before close
  let inside = EMPTY
  let after_comma = EMPTY

  // Never use Array.prototype.forEach,
  // that we should iterate all items
  for (let i = 0; i < length; i ++) {
    if (i !== 0) {
      inside += COMMA
    }

    const before = join(
      after_comma,
      process_comments(value, BEFORE(i), deeper_gap),
      deeper_gap
    )

    inside += before || (LF + deeper_gap)

    // JSON.stringify([undefined])  => [null]
    inside += stringify(i, value, deeper_gap) || STR_NULL

    inside += process_comments(value, AFTER_VALUE(i), deeper_gap)

    after_comma = process_comments(value, AFTER(i), deeper_gap)
  }

  inside += join(
    after_comma,
    process_comments(value, PREFIX_AFTER, deeper_gap),
    deeper_gap
  )

  return BRACKET_OPEN
   + join_content(inside, value, gap)
   + BRACKET_CLOSE
}

// | deeper_gap   |
// | gap | indent |
//       {
//                "foo": 1,
//                "bar": 2
//       }
const object_stringify = (value, gap) => {
  // Due to a specification blunder in ECMAScript, typeof null is 'object',
  // so watch out for that case.
  if (!value) {
    return 'null'
  }

  const deeper_gap = gap + indent

  // From the first element to before close
  let inside = EMPTY
  let after_comma = EMPTY
  let first = true

  const keys = isArray(replacer)
    ? replacer
    : Object.keys(value)

  const iteratee = key => {
    // Stringified value
    const sv = stringify(key, value, deeper_gap)

    // If a value is undefined, then the key-value pair should be ignored
    if (sv === UNDEFINED) {
      return
    }

    // The treat ment
    if (!first) {
      inside += COMMA
    }

    first = false

    const before = join(
      after_comma,
      process_comments(value, BEFORE(key), deeper_gap),
      deeper_gap
    )

    inside += before || (LF + deeper_gap)

    inside += quote(key)
    + process_comments(value, AFTER_PROP(key), deeper_gap)
    + COLON
    + process_comments(value, AFTER_COLON(key), deeper_gap)
    + SPACE
    + sv
    + process_comments(value, AFTER_VALUE(key), deeper_gap)

    after_comma = process_comments(value, AFTER(key), deeper_gap)
  }

  keys.forEach(iteratee)

  // if (after_comma) {
  //   inside += COMMA
  // }

  inside += join(
    after_comma,
    process_comments(value, PREFIX_AFTER, deeper_gap),
    deeper_gap
  )

  return CURLY_BRACKET_OPEN
  + join_content(inside, value, gap)
  + CURLY_BRACKET_CLOSE
}

// @param {string} key
// @param {Object} holder
// @param {function()|Array} replacer
// @param {string} indent
// @param {string} gap
function stringify (key, holder, gap) {
  let value = holder[key]

  // If the value has a toJSON method, call it to obtain a replacement value.
  if (isObject(value) && isFunction(value.toJSON)) {
    value = value.toJSON(key)
  }

  // If we were called with a replacer function, then call the replacer to
  // obtain a replacement value.
  if (isFunction(replacer)) {
    value = replacer.call(holder, key, value)
  }

  switch (typeof value) {
  case 'string':
    return quote(value)

  case 'number':
    // JSON numbers must be finite. Encode non-finite numbers as null.
    return Number.isFinite(value) ? String(value) : STR_NULL

  case 'boolean':
  case 'null':

    // If the value is a boolean or null, convert it to a string. Note:
    // typeof null does not produce 'null'. The case is included here in
    // the remote chance that this gets fixed someday.
    return String(value)

  // If the type is 'object', we might be dealing with an object or an array or
  // null.
  case 'object':
    return isArray(value)
      ? array_stringify(value, gap)
      : object_stringify(value, gap)

  // undefined
  default:
    // JSON.stringify(undefined) === undefined
    // JSON.stringify('foo', () => undefined) === undefined
  }
}

const get_indent = space => isString(space)
  // If the space parameter is a string, it will be used as the indent string.
  ? space
  : isNumber(space)
    ? repeat(SPACE, space)
    : EMPTY

const {toString} = Object.prototype
const PRIMITIVE_OBJECT_TYPES = [
  '[object Number]',
  '[object String]',
  '[object Boolean]'
]

const is_primitive_object = subject => {
  if (typeof subject !== 'object') {
    return false
  }

  const str = toString.call(subject)
  return PRIMITIVE_OBJECT_TYPES.includes(str)
}

// @param {function()|Array} replacer
// @param {string|number} space
module.exports = (value, replacer_, space) => {
  // The stringify method takes a value and an optional replacer, and an optional
  // space parameter, and returns a JSON text. The replacer can be a function
  // that can replace values, or an array of strings that will select the keys.
  // A default replacer method can be provided. Use of the space parameter can
  // produce text that is more easily readable.

  // If the space parameter is a number, make an indent string containing that
  // many spaces.
  const indent_ = get_indent(space)

  if (!indent_) {
    return JSON.stringify(value, replacer_)
  }

  // vanilla `JSON.parse` allow invalid replacer
  if (!isFunction(replacer_) && !isArray(replacer_)) {
    replacer_ = null
  }

  replacer = replacer_
  indent = indent_

  const str = is_primitive_object(value)
    ? JSON.stringify(value)
    : stringify('', {'': value}, EMPTY)

  clean()

  return isObject(value)
    ? process_comments(value, PREFIX_BEFORE_ALL, EMPTY).trimLeft()
      + str
      + process_comments(value, PREFIX_AFTER_ALL, EMPTY).trimRight()
    : str
}


/***/ }),

/***/ 64034:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// These tables borrowed from `ansi`

var prefix = '\x1b['

exports.up = function up (num) {
  return prefix + (num || '') + 'A'
}

exports.down = function down (num) {
  return prefix + (num || '') + 'B'
}

exports.forward = function forward (num) {
  return prefix + (num || '') + 'C'
}

exports.back = function back (num) {
  return prefix + (num || '') + 'D'
}

exports.nextLine = function nextLine (num) {
  return prefix + (num || '') + 'E'
}

exports.previousLine = function previousLine (num) {
  return prefix + (num || '') + 'F'
}

exports.horizontalAbsolute = function horizontalAbsolute (num) {
  if (num == null) throw new Error('horizontalAboslute requires a column to position to')
  return prefix + num + 'G'
}

exports.eraseData = function eraseData () {
  return prefix + 'J'
}

exports.eraseLine = function eraseLine () {
  return prefix + 'K'
}

exports.goto = function (x, y) {
  return prefix + y + ';' + x + 'H'
}

exports.gotoSOL = function () {
  return '\r'
}

exports.beep = function () {
  return '\x07'
}

exports.hideCursor = function hideCursor () {
  return prefix + '?25l'
}

exports.showCursor = function showCursor () {
  return prefix + '?25h'
}

var colors = {
  reset: 0,
// styles
  bold: 1,
  italic: 3,
  underline: 4,
  inverse: 7,
// resets
  stopBold: 22,
  stopItalic: 23,
  stopUnderline: 24,
  stopInverse: 27,
// colors
  white: 37,
  black: 30,
  blue: 34,
  cyan: 36,
  green: 32,
  magenta: 35,
  red: 31,
  yellow: 33,
  bgWhite: 47,
  bgBlack: 40,
  bgBlue: 44,
  bgCyan: 46,
  bgGreen: 42,
  bgMagenta: 45,
  bgRed: 41,
  bgYellow: 43,

  grey: 90,
  brightBlack: 90,
  brightRed: 91,
  brightGreen: 92,
  brightYellow: 93,
  brightBlue: 94,
  brightMagenta: 95,
  brightCyan: 96,
  brightWhite: 97,

  bgGrey: 100,
  bgBrightBlack: 100,
  bgBrightRed: 101,
  bgBrightGreen: 102,
  bgBrightYellow: 103,
  bgBrightBlue: 104,
  bgBrightMagenta: 105,
  bgBrightCyan: 106,
  bgBrightWhite: 107
}

exports.color = function color (colorWith) {
  if (arguments.length !== 1 || !Array.isArray(colorWith)) {
    colorWith = Array.prototype.slice.call(arguments)
  }
  return prefix + colorWith.map(colorNameToCode).join(';') + 'm'
}

function colorNameToCode (color) {
  if (colors[color] != null) return colors[color]
  throw new Error('Unknown color or style name: ' + color)
}


/***/ }),

/***/ 59106:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assert      = __webpack_require__(39491);
var wrapEmitter = __webpack_require__(5422);

/*
 *
 * CONSTANTS
 *
 */
var CONTEXTS_SYMBOL = 'cls@contexts';
var ERROR_SYMBOL = 'error@context';

// load polyfill if native support is unavailable
if (!process.addAsyncListener) __webpack_require__(89468);

function Namespace(name) {
  this.name   = name;
  // changed in 2.7: no default context
  this.active = null;
  this._set   = [];
  this.id     = null;
}

Namespace.prototype.set = function (key, value) {
  if (!this.active) {
    throw new Error("No context available. ns.run() or ns.bind() must be called first.");
  }

  this.active[key] = value;
  return value;
};

Namespace.prototype.get = function (key) {
  if (!this.active) return undefined;

  return this.active[key];
};

Namespace.prototype.createContext = function () {
  return Object.create(this.active);
};

Namespace.prototype.run = function (fn) {
  var context = this.createContext();
  this.enter(context);
  try {
    fn(context);
    return context;
  }
  catch (exception) {
    if (exception) {
      exception[ERROR_SYMBOL] = context;
    }
    throw exception;
  }
  finally {
    this.exit(context);
  }
};

Namespace.prototype.runAndReturn = function (fn) {
  var value;
  this.run(function (context) {
    value = fn(context);
  });
  return value;
};

Namespace.prototype.bind = function (fn, context) {
  if (!context) {
    if (!this.active) {
      context = this.createContext();
    }
    else {
      context = this.active;
    }
  }

  var self = this;
  return function () {
    self.enter(context);
    try {
      return fn.apply(this, arguments);
    }
    catch (exception) {
      if (exception) {
        exception[ERROR_SYMBOL] = context;
      }
      throw exception;
    }
    finally {
      self.exit(context);
    }
  };
};

Namespace.prototype.enter = function (context) {
  assert.ok(context, "context must be provided for entering");

  this._set.push(this.active);
  this.active = context;
};

Namespace.prototype.exit = function (context) {
  assert.ok(context, "context must be provided for exiting");

  // Fast path for most exits that are at the top of the stack
  if (this.active === context) {
    assert.ok(this._set.length, "can't remove top context");
    this.active = this._set.pop();
    return;
  }

  // Fast search in the stack using lastIndexOf
  var index = this._set.lastIndexOf(context);

  assert.ok(index >= 0, "context not currently entered; can't exit");
  assert.ok(index,      "can't remove top context");

  this._set.splice(index, 1);
};

Namespace.prototype.bindEmitter = function (emitter) {
  assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");

  var namespace  = this;
  var thisSymbol = 'context@' + this.name;

  // Capture the context active at the time the emitter is bound.
  function attach(listener) {
    if (!listener) return;
    if (!listener[CONTEXTS_SYMBOL]) listener[CONTEXTS_SYMBOL] = Object.create(null);

    listener[CONTEXTS_SYMBOL][thisSymbol] = {
      namespace : namespace,
      context   : namespace.active
    };
  }

  // At emit time, bind the listener within the correct context.
  function bind(unwrapped) {
    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) return unwrapped;

    var wrapped  = unwrapped;
    var contexts = unwrapped[CONTEXTS_SYMBOL];
    Object.keys(contexts).forEach(function (name) {
      var thunk = contexts[name];
      wrapped = thunk.namespace.bind(wrapped, thunk.context);
    });
    return wrapped;
  }

  wrapEmitter(emitter, attach, bind);
};

/**
 * If an error comes out of a namespace, it will have a context attached to it.
 * This function knows how to find it.
 *
 * @param {Error} exception Possibly annotated error.
 */
Namespace.prototype.fromException = function (exception) {
  return exception[ERROR_SYMBOL];
};

function get(name) {
  return process.namespaces[name];
}

function create(name) {
  assert.ok(name, "namespace must be given a name!");

  var namespace = new Namespace(name);
  namespace.id = process.addAsyncListener({
    create : function () { return namespace.active; },
    before : function (context, storage) { if (storage) namespace.enter(storage); },
    after  : function (context, storage) { if (storage) namespace.exit(storage); },
    error  : function (storage) { if (storage) namespace.exit(storage); }
  });

  process.namespaces[name] = namespace;
  return namespace;
}

function destroy(name) {
  var namespace = get(name);

  assert.ok(namespace,    "can't delete nonexistent namespace!");
  assert.ok(namespace.id, "don't assign to process.namespaces directly!");

  process.removeAsyncListener(namespace.id);
  process.namespaces[name] = null;
}

function reset() {
  // must unregister async listeners
  if (process.namespaces) {
    Object.keys(process.namespaces).forEach(function (name) {
      destroy(name);
    });
  }
  process.namespaces = Object.create(null);
}
if (!process.namespaces) reset(); // call immediately to set up

module.exports = {
  getNamespace     : get,
  createNamespace  : create,
  destroyNamespace : destroy,
  reset            : reset
};


/***/ }),

/***/ 22862:
/***/ ((__unused_webpack_module, exports) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),

/***/ 27401:
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(30761)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 30761:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(571);

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 78634:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(27401);
} else {
	module.exports = __webpack_require__(22354);
}


/***/ }),

/***/ 22354:
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(76224);
const util = __webpack_require__(73837);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(82035);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(30761)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.replace(/\s*\n\s*/g, ' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 16285:
/***/ ((module) => {


/**
 * Expose `Delegator`.
 */

module.exports = Delegator;

/**
 * Initialize a delegator.
 *
 * @param {Object} proto
 * @param {String} target
 * @api public
 */

function Delegator(proto, target) {
  if (!(this instanceof Delegator)) return new Delegator(proto, target);
  this.proto = proto;
  this.target = target;
  this.methods = [];
  this.getters = [];
  this.setters = [];
  this.fluents = [];
}

/**
 * Delegate method `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.method = function(name){
  var proto = this.proto;
  var target = this.target;
  this.methods.push(name);

  proto[name] = function(){
    return this[target][name].apply(this[target], arguments);
  };

  return this;
};

/**
 * Delegator accessor `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.access = function(name){
  return this.getter(name).setter(name);
};

/**
 * Delegator getter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.getter = function(name){
  var proto = this.proto;
  var target = this.target;
  this.getters.push(name);

  proto.__defineGetter__(name, function(){
    return this[target][name];
  });

  return this;
};

/**
 * Delegator setter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.setter = function(name){
  var proto = this.proto;
  var target = this.target;
  this.setters.push(name);

  proto.__defineSetter__(name, function(val){
    return this[target][name] = val;
  });

  return this;
};

/**
 * Delegator fluent accessor
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.fluent = function (name) {
  var proto = this.proto;
  var target = this.target;
  this.fluents.push(name);

  proto[name] = function(val){
    if ('undefined' != typeof val) {
      this[target][name] = val;
      return this;
    } else {
      return this[target][name];
    }
  };

  return this;
};


/***/ }),

/***/ 50307:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var diagnostic_channel_1 = __webpack_require__(42108);
exports.AzureMonitorSymbol = "Azure_Monitor_Tracer";
/**
 * By default, @azure/core-tracing default tracer is a NoopTracer.
 * This patching changes the default tracer to a patched BasicTracer
 * which emits ended spans as diag-channel events.
 *
 * The @opentelemetry/tracing package must be installed to use these patches
 * https://www.npmjs.com/package/@opentelemetry/tracing
 * @param coreTracing
 */
var azureCoreTracingPatchFunction = function (coreTracing) {
    try {
        var BasicTracer = (__webpack_require__(54529).BasicTracer);
        var tracerConfig = diagnostic_channel_1.channel.spanContextPropagator
            ? { scopeManager: diagnostic_channel_1.channel.spanContextPropagator }
            : undefined;
        var tracer_1 = new BasicTracer(tracerConfig);
        // Patch startSpan instead of using spanProcessor.onStart because parentSpan must be
        // set while the span is constructed
        var startSpanOriginal_1 = tracer_1.startSpan;
        tracer_1.startSpan = function (name, options) {
            // if no parent span was provided, apply the current context
            if (!options || !options.parent) {
                var parentOperation = tracer_1.getCurrentSpan();
                if (parentOperation && parentOperation.operation && parentOperation.operation.traceparent) {
                    options = __assign({}, options, { parent: {
                            traceId: parentOperation.operation.traceparent.traceId,
                            spanId: parentOperation.operation.traceparent.spanId,
                        } });
                }
            }
            var span = startSpanOriginal_1.call(this, name, options);
            span.addEvent("Application Insights Integration enabled");
            return span;
        };
        tracer_1.addSpanProcessor(new AzureMonitorSpanProcessor());
        tracer_1[exports.AzureMonitorSymbol] = true;
        coreTracing.setTracer(tracer_1); // recordSpanData is not present on BasicTracer - cast to any
    }
    catch (e) { /* squash errors */ }
    return coreTracing;
};
var AzureMonitorSpanProcessor = /** @class */ (function () {
    function AzureMonitorSpanProcessor() {
    }
    AzureMonitorSpanProcessor.prototype.onStart = function (span) {
        // noop since startSpan is already patched
    };
    AzureMonitorSpanProcessor.prototype.onEnd = function (span) {
        diagnostic_channel_1.channel.publish("azure-coretracing", span);
    };
    AzureMonitorSpanProcessor.prototype.shutdown = function () {
        // noop
    };
    return AzureMonitorSpanProcessor;
}());
exports.azureCoreTracing = {
    versionSpecifier: ">= 1.0.0 < 2.0.0",
    patch: azureCoreTracingPatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("@azure/core-tracing", exports.azureCoreTracing);
}
exports.enable = enable;
//# sourceMappingURL=azure-coretracing.pub.js.map

/***/ }),

/***/ 32903:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(42108);
var bunyanPatchFunction = function (originalBunyan) {
    var originalEmit = originalBunyan.prototype._emit;
    originalBunyan.prototype._emit = function (rec, noemit) {
        var ret = originalEmit.apply(this, arguments);
        if (!noemit) {
            var str = ret;
            if (!str) {
                str = originalEmit.call(this, rec, true);
            }
            diagnostic_channel_1.channel.publish("bunyan", { level: rec.level, result: str });
        }
        return ret;
    };
    return originalBunyan;
};
exports.bunyan = {
    versionSpecifier: ">= 1.0.0 < 2.0.0",
    patch: bunyanPatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("bunyan", exports.bunyan);
}
exports.enable = enable;
//# sourceMappingURL=bunyan.pub.js.map

/***/ }),

/***/ 89645:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(42108);
var stream_1 = __webpack_require__(12781);
var consolePatchFunction = function (originalConsole) {
    var aiLoggingOutStream = new stream_1.Writable();
    var aiLoggingErrStream = new stream_1.Writable();
    // Default console is roughly equivalent to `new Console(process.stdout, process.stderr)`
    // We create a version which publishes to the channel and also to stdout/stderr
    aiLoggingOutStream.write = function (chunk) {
        if (!chunk) {
            return true;
        }
        var message = chunk.toString();
        diagnostic_channel_1.channel.publish("console", { message: message });
        return true;
    };
    aiLoggingErrStream.write = function (chunk) {
        if (!chunk) {
            return true;
        }
        var message = chunk.toString();
        diagnostic_channel_1.channel.publish("console", { message: message, stderr: true });
        return true;
    };
    var aiLoggingConsole = new originalConsole.Console(aiLoggingOutStream, aiLoggingErrStream);
    var consoleMethods = ["log", "info", "warn", "error", "dir", "time", "timeEnd", "trace", "assert"];
    var _loop_1 = function (method) {
        var originalMethod = originalConsole[method];
        if (originalMethod) {
            originalConsole[method] = function () {
                if (aiLoggingConsole[method]) {
                    try {
                        aiLoggingConsole[method].apply(aiLoggingConsole, arguments);
                    }
                    catch (e) {
                        // Ignore errors; allow the original method to throw if necessary
                    }
                }
                return originalMethod.apply(originalConsole, arguments);
            };
        }
    };
    for (var _i = 0, consoleMethods_1 = consoleMethods; _i < consoleMethods_1.length; _i++) {
        var method = consoleMethods_1[_i];
        _loop_1(method);
    }
    return originalConsole;
};
exports.console = {
    versionSpecifier: ">= 4.0.0",
    patch: consolePatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("console", exports.console);
    // Force patching of console
    /* tslint:disable-next-line:no-var-requires */
    __webpack_require__(96206);
}
exports.enable = enable;
//# sourceMappingURL=console.pub.js.map

/***/ }),

/***/ 79553:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
var azuresdk = __webpack_require__(50307);
exports.azuresdk = azuresdk;
var bunyan = __webpack_require__(32903);
exports.bunyan = bunyan;
var consolePub = __webpack_require__(89645);
exports.console = consolePub;
var mongodbCore = __webpack_require__(90752);
exports.mongodbCore = mongodbCore;
var mongodb = __webpack_require__(60784);
exports.mongodb = mongodb;
var mysql = __webpack_require__(25121);
exports.mysql = mysql;
var pgPool = __webpack_require__(99233);
exports.pgPool = pgPool;
var pg = __webpack_require__(64605);
exports.pg = pg;
var redis = __webpack_require__(33046);
exports.redis = redis;
var tedious = __webpack_require__(30897);
exports.tedious = tedious;
var winston = __webpack_require__(89067);
exports.winston = winston;
function enable() {
    bunyan.enable();
    consolePub.enable();
    mongodbCore.enable();
    mongodb.enable();
    mysql.enable();
    pg.enable();
    pgPool.enable();
    redis.enable();
    winston.enable();
    azuresdk.enable();
    tedious.enable();
}
exports.enable = enable;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 90752:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(42108);
var mongodbcorePatchFunction = function (originalMongoCore) {
    var originalConnect = originalMongoCore.Server.prototype.connect;
    originalMongoCore.Server.prototype.connect = function contextPreservingConnect() {
        var ret = originalConnect.apply(this, arguments);
        // Messages sent to mongo progress through a pool
        // This can result in context getting mixed between different responses
        // so we wrap the callbacks to restore appropriate state
        var originalWrite = this.s.pool.write;
        this.s.pool.write = function contextPreservingWrite() {
            var cbidx = typeof arguments[1] === "function" ? 1 : 2;
            if (typeof arguments[cbidx] === "function") {
                arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);
            }
            return originalWrite.apply(this, arguments);
        };
        // Logout is a special case, it doesn't call the write function but instead
        // directly calls into connection.write
        var originalLogout = this.s.pool.logout;
        this.s.pool.logout = function contextPreservingLogout() {
            if (typeof arguments[1] === "function") {
                arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);
            }
            return originalLogout.apply(this, arguments);
        };
        return ret;
    };
    return originalMongoCore;
};
exports.mongoCore = {
    versionSpecifier: ">= 2.0.0 < 4.0.0",
    patch: mongodbcorePatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb-core", exports.mongoCore);
}
exports.enable = enable;
//# sourceMappingURL=mongodb-core.pub.js.map

/***/ }),

/***/ 60784:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(42108);
var mongodbPatchFunction = function (originalMongo) {
    var listener = originalMongo.instrument({
        operationIdGenerator: {
            next: function () {
                return diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });
            },
        },
    });
    var eventMap = {};
    listener.on("started", function (event) {
        if (eventMap[event.requestId]) {
            // Note: Mongo can generate 2 completely separate requests
            // which share the same requestId, if a certain race condition is triggered.
            // For now, we accept that this can happen and potentially miss or mislabel some events.
            return;
        }
        eventMap[event.requestId] = __assign({}, event, { time: new Date() });
    });
    listener.on("succeeded", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event.operationId === "function") {
            event.operationId(function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: true }); });
        }
        else {
            // fallback -- correlation will not work here
            diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: true });
        }
    });
    listener.on("failed", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event.operationId === "function") {
            event.operationId(function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: false }); });
        }
        else {
            // fallback -- correlation will not work here
            diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: false });
        }
    });
    return originalMongo;
};
var mongodb3PatchFunction = function (originalMongo) {
    var listener = originalMongo.instrument();
    var eventMap = {};
    var contextMap = {};
    listener.on("started", function (event) {
        if (eventMap[event.requestId]) {
            // Note: Mongo can generate 2 completely separate requests
            // which share the same requestId, if a certain race condition is triggered.
            // For now, we accept that this can happen and potentially miss or mislabel some events.
            return;
        }
        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });
        eventMap[event.requestId] = __assign({}, event, { time: new Date() });
    });
    listener.on("succeeded", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: true }); });
            delete contextMap[event.requestId];
        }
    });
    listener.on("failed", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: false }); });
            delete contextMap[event.requestId];
        }
    });
    return originalMongo;
};
// In mongodb 3.3.0, mongodb-core was merged into mongodb, so the same patching
// can be used here. this.s.pool was changed to this.s.coreTopology.s.pool
var mongodbcorePatchFunction = function (originalMongo) {
    var originalConnect = originalMongo.Server.prototype.connect;
    originalMongo.Server.prototype.connect = function contextPreservingConnect() {
        var ret = originalConnect.apply(this, arguments);
        // Messages sent to mongo progress through a pool
        // This can result in context getting mixed between different responses
        // so we wrap the callbacks to restore appropriate state
        var originalWrite = this.s.coreTopology.s.pool.write;
        this.s.coreTopology.s.pool.write = function contextPreservingWrite() {
            var cbidx = typeof arguments[1] === "function" ? 1 : 2;
            if (typeof arguments[cbidx] === "function") {
                arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);
            }
            return originalWrite.apply(this, arguments);
        };
        // Logout is a special case, it doesn't call the write function but instead
        // directly calls into connection.write
        var originalLogout = this.s.coreTopology.s.pool.logout;
        this.s.coreTopology.s.pool.logout = function contextPreservingLogout() {
            if (typeof arguments[1] === "function") {
                arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);
            }
            return originalLogout.apply(this, arguments);
        };
        return ret;
    };
    return originalMongo;
};
var mongodb330PatchFunction = function (originalMongo) {
    mongodbcorePatchFunction(originalMongo); // apply mongodb-core patches
    var listener = originalMongo.instrument();
    var eventMap = {};
    var contextMap = {};
    listener.on("started", function (event) {
        if (eventMap[event.requestId]) {
            // Note: Mongo can generate 2 completely separate requests
            // which share the same requestId, if a certain race condition is triggered.
            // For now, we accept that this can happen and potentially miss or mislabel some events.
            return;
        }
        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });
        eventMap[event.requestId] = event;
    });
    listener.on("succeeded", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: true }); });
            delete contextMap[event.requestId];
        }
    });
    listener.on("failed", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: false }); });
            delete contextMap[event.requestId];
        }
    });
    return originalMongo;
};
exports.mongo2 = {
    versionSpecifier: ">= 2.0.0 <= 3.0.5",
    patch: mongodbPatchFunction,
};
exports.mongo3 = {
    versionSpecifier: "> 3.0.5 < 3.3.0",
    patch: mongodb3PatchFunction,
};
exports.mongo330 = {
    versionSpecifier: ">= 3.3.0 < 4.0.0",
    patch: mongodb330PatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo2);
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo3);
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo330);
}
exports.enable = enable;
//# sourceMappingURL=mongodb.pub.js.map

/***/ }),

/***/ 25121:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(42108);
var path = __webpack_require__(71017);
var mysqlPatchFunction = function (originalMysql, originalMysqlPath) {
    // The `name` passed in here is for debugging purposes,
    // to help distinguish which object is being patched.
    var patchObjectFunction = function (obj, name) {
        return function (func, cbWrapper) {
            var originalFunc = obj[func];
            if (originalFunc) {
                obj[func] = function mysqlContextPreserver() {
                    // Find the callback, if there is one
                    var cbidx = arguments.length - 1;
                    for (var i = arguments.length - 1; i >= 0; --i) {
                        if (typeof arguments[i] === "function") {
                            cbidx = i;
                            break;
                        }
                        else if (typeof arguments[i] !== "undefined") {
                            break;
                        }
                    }
                    var cb = arguments[cbidx];
                    var resultContainer = { result: null, startTime: null, startDate: null };
                    if (typeof cb === "function") {
                        // Preserve context on the callback.
                        // If this is one of the functions that we want to track,
                        // then wrap the callback with the tracking wrapper
                        if (cbWrapper) {
                            resultContainer.startTime = process.hrtime();
                            resultContainer.startDate = new Date();
                            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cbWrapper(resultContainer, cb));
                        }
                        else {
                            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cb);
                        }
                    }
                    var result = originalFunc.apply(this, arguments);
                    resultContainer.result = result;
                    return result;
                };
            }
        };
    };
    var patchClassMemberFunction = function (classObject, name) {
        return patchObjectFunction(classObject.prototype, name + ".prototype");
    };
    var connectionCallbackFunctions = [
        "connect", "changeUser",
        "ping", "statistics", "end",
    ];
    var connectionClass = __webpack_require__(25710)(path.dirname(originalMysqlPath) + "/lib/Connection");
    connectionCallbackFunctions.forEach(function (value) { return patchClassMemberFunction(connectionClass, "Connection")(value); });
    // Connection.createQuery is a static method
    patchObjectFunction(connectionClass, "Connection")("createQuery", function (resultContainer, cb) {
        return function (err) {
            var hrDuration = process.hrtime(resultContainer.startTime);
            /* tslint:disable-next-line:no-bitwise */
            var duration = (hrDuration[0] * 1e3 + hrDuration[1] / 1e6) | 0;
            diagnostic_channel_1.channel.publish("mysql", { query: resultContainer.result, callbackArgs: arguments, err: err, duration: duration, time: resultContainer.startDate });
            cb.apply(this, arguments);
        };
    });
    var poolCallbackFunctions = [
        "_enqueueCallback",
    ];
    var poolClass = __webpack_require__(18523)(path.dirname(originalMysqlPath) + "/lib/Pool");
    poolCallbackFunctions.forEach(function (value) { return patchClassMemberFunction(poolClass, "Pool")(value); });
    return originalMysql;
};
exports.mysql = {
    versionSpecifier: ">= 2.0.0 < 3.0.0",
    patch: mysqlPatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mysql", exports.mysql);
}
exports.enable = enable;
//# sourceMappingURL=mysql.pub.js.map

/***/ }),

/***/ 99233:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(42108);
function postgresPool1PatchFunction(originalPgPool) {
    var originalConnect = originalPgPool.prototype.connect;
    originalPgPool.prototype.connect = function connect(callback) {
        if (callback) {
            arguments[0] = diagnostic_channel_1.channel.bindToContext(callback);
        }
        return originalConnect.apply(this, arguments);
    };
    return originalPgPool;
}
exports.postgresPool1 = {
    versionSpecifier: ">= 1.0.0 < 3.0.0",
    patch: postgresPool1PatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("pg-pool", exports.postgresPool1);
}
exports.enable = enable;
//# sourceMappingURL=pg-pool.pub.js.map

/***/ }),

/***/ 64605:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(42108);
var events_1 = __webpack_require__(82361);
function postgres6PatchFunction(originalPg, originalPgPath) {
    var originalClientQuery = originalPg.Client.prototype.query;
    var diagnosticOriginalFunc = "__diagnosticOriginalFunc";
    // wherever the callback is passed, find it, save it, and remove it from the call
    // to the the original .query() function
    originalPg.Client.prototype.query = function query(config, values, callback) {
        var data = {
            query: {},
            database: {
                host: this.connectionParameters.host,
                port: this.connectionParameters.port,
            },
            result: null,
            error: null,
            duration: 0,
            time: new Date(),
        };
        var start = process.hrtime();
        var queryResult;
        function patchCallback(cb) {
            if (cb && cb[diagnosticOriginalFunc]) {
                cb = cb[diagnosticOriginalFunc];
            }
            var trackingCallback = diagnostic_channel_1.channel.bindToContext(function (err, res) {
                var end = process.hrtime(start);
                data.result = res && { rowCount: res.rowCount, command: res.command };
                data.error = err;
                data.duration = Math.ceil((end[0] * 1e3) + (end[1] / 1e6));
                diagnostic_channel_1.channel.publish("postgres", data);
                // emulate weird internal behavior in pg@6
                // on success, the callback is called *before* query events are emitted
                // on failure, the callback is called *instead of* the query emitting events
                // with no events, that means no promises (since the promise is resolved/rejected in an event handler)
                // since we are always inserting ourselves as a callback, we have to restore the original
                // behavior if the user didn't provide one themselves
                if (err) {
                    if (cb) {
                        return cb.apply(this, arguments);
                    }
                    else if (queryResult && queryResult instanceof events_1.EventEmitter) {
                        queryResult.emit("error", err);
                    }
                }
                else if (cb) {
                    cb.apply(this, arguments);
                }
            });
            try {
                Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });
                return trackingCallback;
            }
            catch (e) {
                // this should never happen, but bailout in case it does
                return cb;
            }
        }
        // this function takes too many variations of arguments.
        // this patches any provided callback or creates a new callback if one wasn't provided.
        // since the callback is always called (if provided) in addition to always having a Promisified
        // EventEmitter returned (well, sometimes -- see above), its safe to insert a callback if none was given
        try {
            if (typeof config === "string") {
                if (values instanceof Array) {
                    data.query.preparable = {
                        text: config,
                        args: values,
                    };
                    callback = patchCallback(callback);
                }
                else {
                    data.query.text = config;
                    // pg v6 will, for some reason, accept both
                    // client.query("...", undefined, () => {...})
                    // **and**
                    // client.query("...", () => {...});
                    // Internally, precedence is given to the callback argument
                    if (callback) {
                        callback = patchCallback(callback);
                    }
                    else {
                        values = patchCallback(values);
                    }
                }
            }
            else {
                if (typeof config.name === "string") {
                    data.query.plan = config.name;
                }
                else if (config.values instanceof Array) {
                    data.query.preparable = {
                        text: config.text,
                        args: config.values,
                    };
                }
                else {
                    data.query.text = config.text;
                }
                if (callback) {
                    callback = patchCallback(callback);
                }
                else if (values) {
                    values = patchCallback(values);
                }
                else {
                    config.callback = patchCallback(config.callback);
                }
            }
        }
        catch (e) {
            // if our logic here throws, bail out and just let pg do its thing
            return originalClientQuery.apply(this, arguments);
        }
        arguments[0] = config;
        arguments[1] = values;
        arguments[2] = callback;
        arguments.length = (arguments.length > 3) ? arguments.length : 3;
        queryResult = originalClientQuery.apply(this, arguments);
        return queryResult;
    };
    return originalPg;
}
function postgres7PatchFunction(originalPg, originalPgPath) {
    var originalClientQuery = originalPg.Client.prototype.query;
    var diagnosticOriginalFunc = "__diagnosticOriginalFunc";
    // wherever the callback is passed, find it, save it, and remove it from the call
    // to the the original .query() function
    originalPg.Client.prototype.query = function query(config, values, callback) {
        var _this = this;
        var callbackProvided = !!callback; // Starting in pg@7.x+, Promise is returned only if !callbackProvided
        var data = {
            query: {},
            database: {
                host: this.connectionParameters.host,
                port: this.connectionParameters.port,
            },
            result: null,
            error: null,
            duration: 0,
            time: new Date(),
        };
        var start = process.hrtime();
        var queryResult;
        function patchCallback(cb) {
            if (cb && cb[diagnosticOriginalFunc]) {
                cb = cb[diagnosticOriginalFunc];
            }
            var trackingCallback = diagnostic_channel_1.channel.bindToContext(function (err, res) {
                var end = process.hrtime(start);
                data.result = res && { rowCount: res.rowCount, command: res.command };
                data.error = err;
                data.duration = Math.ceil((end[0] * 1e3) + (end[1] / 1e6));
                diagnostic_channel_1.channel.publish("postgres", data);
                if (err) {
                    if (cb) {
                        return cb.apply(this, arguments);
                    }
                    else if (queryResult && queryResult instanceof events_1.EventEmitter) {
                        queryResult.emit("error", err);
                    }
                }
                else if (cb) {
                    cb.apply(this, arguments);
                }
            });
            try {
                Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });
                return trackingCallback;
            }
            catch (e) {
                // this should never happen, but bailout in case it does
                return cb;
            }
        }
        // Only try to wrap the callback if it is a function. We want to keep the same
        // behavior of returning a promise only if no callback is provided. Wrapping
        // a nonfunction makes it a function and pg will interpret it as a callback
        try {
            if (typeof config === "string") {
                if (values instanceof Array) {
                    data.query.preparable = {
                        text: config,
                        args: values,
                    };
                    callbackProvided = typeof callback === "function";
                    callback = callbackProvided ? patchCallback(callback) : callback;
                }
                else {
                    data.query.text = config;
                    if (callback) {
                        callbackProvided = typeof callback === "function";
                        callback = callbackProvided ? patchCallback(callback) : callback;
                    }
                    else {
                        callbackProvided = typeof values === "function";
                        values = callbackProvided ? patchCallback(values) : values;
                    }
                }
            }
            else {
                if (typeof config.name === "string") {
                    data.query.plan = config.name;
                }
                else if (config.values instanceof Array) {
                    data.query.preparable = {
                        text: config.text,
                        args: config.values,
                    };
                }
                else {
                    data.query.text = config.text;
                }
                if (callback) {
                    callbackProvided = typeof callback === "function";
                    callback = patchCallback(callback);
                }
                else if (values) {
                    callbackProvided = typeof values === "function";
                    values = callbackProvided ? patchCallback(values) : values;
                }
                else {
                    callbackProvided = typeof config.callback === "function";
                    config.callback = callbackProvided ? patchCallback(config.callback) : config.callback;
                }
            }
        }
        catch (e) {
            // if our logic here throws, bail out and just let pg do its thing
            return originalClientQuery.apply(this, arguments);
        }
        arguments[0] = config;
        arguments[1] = values;
        arguments[2] = callback;
        arguments.length = (arguments.length > 3) ? arguments.length : 3;
        queryResult = originalClientQuery.apply(this, arguments);
        if (!callbackProvided) {
            // no callback, so create a pass along promise
            return queryResult
                // pass resolved promise after publishing the event
                .then(function (result) {
                patchCallback()(undefined, result);
                return new _this._Promise(function (resolve, reject) {
                    resolve(result);
                });
            })
                // pass along rejected promise after publishing the error
                .catch(function (error) {
                patchCallback()(error, undefined);
                return new _this._Promise(function (resolve, reject) {
                    reject(error);
                });
            });
        }
        return queryResult;
    };
    return originalPg;
}
exports.postgres6 = {
    versionSpecifier: "6.*",
    patch: postgres6PatchFunction,
};
exports.postgres7 = {
    versionSpecifier: ">=7.* <=8.*",
    patch: postgres7PatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports.postgres6);
    diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports.postgres7);
}
exports.enable = enable;
//# sourceMappingURL=pg.pub.js.map

/***/ }),

/***/ 33046:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(42108);
var redisPatchFunction = function (originalRedis) {
    var originalSend = originalRedis.RedisClient.prototype.internal_send_command;
    // Note: This is mixing together both context tracking and dependency tracking
    originalRedis.RedisClient.prototype.internal_send_command = function (commandObj) {
        if (commandObj) {
            var cb_1 = commandObj.callback;
            if (!cb_1 || !cb_1.pubsubBound) {
                var address_1 = this.address;
                var startTime_1 = process.hrtime();
                var startDate_1 = new Date();
                // Note: augmenting the callback on internal_send_command is correct for context
                // tracking, but may be too low-level for dependency tracking. There are some 'errors'
                // which higher levels expect in some cases
                // However, the only other option is to intercept every individual command.
                commandObj.callback = diagnostic_channel_1.channel.bindToContext(function (err, result) {
                    var hrDuration = process.hrtime(startTime_1);
                    /* tslint:disable-next-line:no-bitwise */
                    var duration = (hrDuration[0] * 1e3 + hrDuration[1] / 1e6) | 0;
                    diagnostic_channel_1.channel.publish("redis", { duration: duration, address: address_1, commandObj: commandObj, err: err, result: result, time: startDate_1 });
                    if (typeof cb_1 === "function") {
                        cb_1.apply(this, arguments);
                    }
                });
                commandObj.callback.pubsubBound = true;
            }
        }
        return originalSend.call(this, commandObj);
    };
    return originalRedis;
};
exports.redis = {
    versionSpecifier: ">= 2.0.0 < 4.0.0",
    patch: redisPatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("redis", exports.redis);
}
exports.enable = enable;
//# sourceMappingURL=redis.pub.js.map

/***/ }),

/***/ 30897:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(42108);
var tediousPatchFunction = function (originalTedious) {
    var originalMakeRequest = originalTedious.Connection.prototype.makeRequest;
    originalTedious.Connection.prototype.makeRequest = function makeRequest() {
        function getPatchedCallback(origCallback) {
            var start = process.hrtime();
            var data = {
                query: {},
                database: {
                    host: null,
                    port: null,
                },
                result: null,
                error: null,
                duration: 0,
            };
            return diagnostic_channel_1.channel.bindToContext(function (err, rowCount, rows) {
                var end = process.hrtime(start);
                data = __assign({}, data, { database: {
                        host: this.connection.config.server,
                        port: this.connection.config.options.port,
                    }, result: !err && { rowCount: rowCount, rows: rows }, query: {
                        text: this.parametersByName.statement.value,
                    }, error: err, duration: Math.ceil((end[0] * 1e3) + (end[1] / 1e6)) });
                diagnostic_channel_1.channel.publish("tedious", data);
                origCallback.call(this, err, rowCount, rows);
            });
        }
        var request = arguments[0];
        arguments[0].callback = getPatchedCallback(request.callback);
        originalMakeRequest.apply(this, arguments);
    };
    return originalTedious;
};
exports.tedious = {
    versionSpecifier: ">= 6.0.0 < 9.0.0",
    patch: tediousPatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("tedious", exports.tedious);
}
exports.enable = enable;
//# sourceMappingURL=tedious.pub.js.map

/***/ }),

/***/ 89067:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(42108);
// register a "filter" with each logger that publishes the data about to be logged
var winston2PatchFunction = function (originalWinston) {
    var originalLog = originalWinston.Logger.prototype.log;
    var curLevels;
    var loggingFilter = function (level, message, meta) {
        var levelKind;
        if (curLevels === originalWinston.config.npm.levels) {
            levelKind = "npm";
        }
        else if (curLevels === originalWinston.config.syslog.levels) {
            levelKind = "syslog";
        }
        else {
            levelKind = "unknown";
        }
        diagnostic_channel_1.channel.publish("winston", { level: level, message: message, meta: meta, levelKind: levelKind });
        return message;
    };
    // whenever someone logs, ensure our filter comes last
    originalWinston.Logger.prototype.log = function log() {
        curLevels = this.levels;
        if (!this.filters || this.filters.length === 0) {
            this.filters = [loggingFilter];
        }
        else if (this.filters[this.filters.length - 1] !== loggingFilter) {
            this.filters = this.filters.filter(function (f) { return f !== loggingFilter; });
            this.filters.push(loggingFilter);
        }
        return originalLog.apply(this, arguments);
    };
    return originalWinston;
};
var winston3PatchFunction = function (originalWinston) {
    var mapLevelToKind = function (winston, level) {
        var levelKind;
        if (winston.config.npm.levels[level] != null) {
            levelKind = "npm";
        }
        else if (winston.config.syslog.levels[level] != null) {
            levelKind = "syslog";
        }
        else {
            levelKind = "unknown";
        }
        return levelKind;
    };
    var AppInsightsTransport = /** @class */ (function (_super) {
        __extends(AppInsightsTransport, _super);
        function AppInsightsTransport(winston, opts) {
            var _this = _super.call(this, opts) || this;
            _this.winston = winston;
            return _this;
        }
        AppInsightsTransport.prototype.log = function (info, callback) {
            // tslint:disable-next-line:prefer-const - try to obtain level from Symbol(level) afterwards
            var message = info.message, level = info.level, meta = info.meta, splat = __rest(info, ["message", "level", "meta"]);
            level = typeof Symbol["for"] === "function" ? info[Symbol["for"]("level")] : level; // Symbol(level) is uncolorized, so prefer getting it from here
            message = info instanceof Error ? info : message; // Winston places Errors at info, strings at info.message
            var levelKind = mapLevelToKind(this.winston, level);
            meta = meta || {}; // Winston _somtimes_ puts metadata inside meta, so start from here
            for (var key in splat) {
                if (splat.hasOwnProperty(key)) {
                    meta[key] = splat[key];
                }
            }
            diagnostic_channel_1.channel.publish("winston", { message: message, level: level, levelKind: levelKind, meta: meta });
            callback();
        };
        return AppInsightsTransport;
    }(originalWinston.Transport));
    // Patch this function
    function patchedConfigure() {
        // Grab highest sev logging level in case of custom logging levels
        var levels = arguments[0].levels || originalWinston.config.npm.levels;
        var lastLevel;
        for (var level in levels) {
            if (levels.hasOwnProperty(level)) {
                lastLevel = lastLevel === undefined || levels[level] > levels[lastLevel] ? level : lastLevel;
            }
        }
        this.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));
    }
    var origCreate = originalWinston.createLogger;
    originalWinston.createLogger = function patchedCreate() {
        // Grab highest sev logging level in case of custom logging levels
        var levels = arguments[0].levels || originalWinston.config.npm.levels;
        var lastLevel;
        for (var level in levels) {
            if (levels.hasOwnProperty(level)) {
                lastLevel = lastLevel === undefined || levels[level] > levels[lastLevel] ? level : lastLevel;
            }
        }
        // Add custom app insights transport to the end
        // Remark: Configure is not available until after createLogger()
        // and the Logger prototype is not exported in winston 3.x, so
        // patch both createLogger and configure. Could also call configure
        // again after createLogger, but that would cause configure to be called
        // twice per create.
        var result = origCreate.apply(this, arguments);
        result.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));
        var origConfigure = result.configure;
        result.configure = function () {
            origConfigure.apply(this, arguments);
            patchedConfigure.apply(this, arguments);
        };
        return result;
    };
    var origRootConfigure = originalWinston.createLogger;
    originalWinston.configure = function () {
        origRootConfigure.apply(this, arguments);
        patchedConfigure.apply(this, arguments);
    };
    originalWinston.add(new AppInsightsTransport(originalWinston));
    return originalWinston;
};
exports.winston3 = {
    versionSpecifier: "3.x",
    patch: winston3PatchFunction,
};
exports.winston2 = {
    versionSpecifier: "2.x",
    patch: winston2PatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports.winston2);
    diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports.winston3);
}
exports.enable = enable;
//# sourceMappingURL=winston.pub.js.map

/***/ }),

/***/ 42108:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
var patchRequire_1 = __webpack_require__(94587);
var patchRequire_2 = __webpack_require__(94587);
exports.makePatchingRequire = patchRequire_2.makePatchingRequire;
var trueFilter = function (publishing) { return true; };
var ContextPreservingEventEmitter = (function () {
    function ContextPreservingEventEmitter() {
        this.version = (__webpack_require__(52306)/* .version */ .i8); // Allow for future versions to replace things?
        this.subscribers = {};
        this.contextPreservationFunction = function (cb) { return cb; };
        this.knownPatches = {};
        this.currentlyPublishing = false;
    }
    ContextPreservingEventEmitter.prototype.shouldPublish = function (name) {
        var listeners = this.subscribers[name];
        if (listeners) {
            return listeners.some(function (_a) {
                var filter = _a.filter;
                return !filter || filter(false);
            });
        }
        return false;
    };
    ContextPreservingEventEmitter.prototype.publish = function (name, event) {
        if (this.currentlyPublishing) {
            return; // Avoid reentrancy
        }
        var listeners = this.subscribers[name];
        // Note: Listeners called synchronously to preserve context
        if (listeners) {
            var standardEvent_1 = {
                timestamp: Date.now(),
                data: event,
            };
            this.currentlyPublishing = true;
            listeners.forEach(function (_a) {
                var listener = _a.listener, filter = _a.filter;
                try {
                    if (filter && filter(true)) {
                        listener(standardEvent_1);
                    }
                }
                catch (e) {
                    // Subscriber threw an error
                }
            });
            this.currentlyPublishing = false;
        }
    };
    ContextPreservingEventEmitter.prototype.subscribe = function (name, listener, filter) {
        if (filter === void 0) { filter = trueFilter; }
        if (!this.subscribers[name]) {
            this.subscribers[name] = [];
        }
        this.subscribers[name].push({ listener: listener, filter: filter });
    };
    ContextPreservingEventEmitter.prototype.unsubscribe = function (name, listener, filter) {
        if (filter === void 0) { filter = trueFilter; }
        var listeners = this.subscribers[name];
        if (listeners) {
            for (var index = 0; index < listeners.length; ++index) {
                if (listeners[index].listener === listener && listeners[index].filter === filter) {
                    listeners.splice(index, 1);
                    return true;
                }
            }
        }
        return false;
    };
    // Used for tests
    ContextPreservingEventEmitter.prototype.reset = function () {
        var _this = this;
        this.subscribers = {};
        this.contextPreservationFunction = function (cb) { return cb; };
        // Modify the knownPatches object rather than replace, since a reference will be used in the require patcher
        Object.getOwnPropertyNames(this.knownPatches).forEach(function (prop) { return delete _this.knownPatches[prop]; });
    };
    ContextPreservingEventEmitter.prototype.bindToContext = function (cb) {
        return this.contextPreservationFunction(cb);
    };
    ContextPreservingEventEmitter.prototype.addContextPreservation = function (preserver) {
        var previousPreservationStack = this.contextPreservationFunction;
        this.contextPreservationFunction = (function (cb) { return preserver(previousPreservationStack(cb)); });
    };
    ContextPreservingEventEmitter.prototype.registerMonkeyPatch = function (packageName, patcher) {
        if (!this.knownPatches[packageName]) {
            this.knownPatches[packageName] = [];
        }
        this.knownPatches[packageName].push(patcher);
    };
    ContextPreservingEventEmitter.prototype.getPatchesObject = function () {
        return this.knownPatches;
    };
    return ContextPreservingEventEmitter;
}());
if (!global.diagnosticsSource) {
    global.diagnosticsSource = new ContextPreservingEventEmitter();
    // TODO: should this only patch require after at least one monkey patch is registered?
    /* tslint:disable-next-line:no-var-requires */
    var moduleModule = __webpack_require__(98188);
    // Note: We pass in the object now before any patches are registered, but the object is passed by reference
    // so any updates made to the object will be visible in the patcher.
    moduleModule.prototype.require = patchRequire_1.makePatchingRequire(global.diagnosticsSource.getPatchesObject());
}
exports.channel = global.diagnosticsSource;
//# sourceMappingURL=channel.js.map

/***/ }),

/***/ 94587:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
var path = __webpack_require__(71017);
var semver = __webpack_require__(95408);
/* tslint:disable-next-line:no-var-requires */
var moduleModule = __webpack_require__(98188);
var nativeModules = Object.keys(process.binding("natives"));
var originalRequire = moduleModule.prototype.require;
function makePatchingRequire(knownPatches) {
    var patchedModules = {};
    return function patchedRequire(moduleId) {
        var originalModule = originalRequire.apply(this, arguments);
        if (knownPatches[moduleId]) {
            // Fetch the specific path of the module
            var modulePath = moduleModule._resolveFilename(moduleId, this);
            if (patchedModules.hasOwnProperty(modulePath)) {
                // This module has already been patched, no need to reapply
                return patchedModules[modulePath];
            }
            var moduleVersion = void 0;
            if (nativeModules.indexOf(moduleId) < 0) {
                try {
                    moduleVersion = originalRequire.call(this, path.join(moduleId, "package.json")).version;
                }
                catch (e) {
                    // This should only happen if moduleId is actually a path rather than a module
                    // This is not a supported scenario
                    return originalModule;
                }
            }
            else {
                // This module is implemented natively so we cannot find a package.json
                // Instead, take the version of node itself
                moduleVersion = process.version.substring(1);
            }
            var prereleaseTagIndex = moduleVersion.indexOf("-");
            if (prereleaseTagIndex >= 0) {
                // We ignore prerelease tags to avoid impossible to fix gaps in support
                // e.g. supporting console in >= 4.0.0 would otherwise not include
                // 8.0.0-pre
                moduleVersion = moduleVersion.substring(0, prereleaseTagIndex);
            }
            var modifiedModule = originalModule;
            for (var _i = 0, _a = knownPatches[moduleId]; _i < _a.length; _i++) {
                var modulePatcher = _a[_i];
                if (semver.satisfies(moduleVersion, modulePatcher.versionSpecifier)) {
                    modifiedModule = modulePatcher.patch(modifiedModule, modulePath);
                }
            }
            return patchedModules[modulePath] = modifiedModule;
        }
        return originalModule;
    };
}
exports.makePatchingRequire = makePatchingRequire;
//# sourceMappingURL=patchRequire.js.map

/***/ }),

/***/ 95408:
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),

/***/ 5422:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var shimmer = __webpack_require__(88073);
var wrap    = shimmer.wrap;
var unwrap  = shimmer.unwrap;

// Default to complaining loudly when things don't go according to plan.
// dunderscores are boring
var SYMBOL = 'wrap@before';

// Sets a property on an object, preserving its enumerability.
// This function assumes that the property is already writable.
function defineProperty(obj, name, value) {
  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: enumerable,
    writable: true,
    value: value
  });
}

function _process(self, listeners) {
  var l = listeners.length;
  for (var p = 0; p < l; p++) {
    var listener = listeners[p];
    // set up the listener so that onEmit can do whatever it needs
    var before = self[SYMBOL];
    if (typeof before === 'function') {
      before(listener);
    }
    else if (Array.isArray(before)) {
      var length = before.length;
      for (var i = 0; i < length; i++) before[i](listener);
    }
  }
}

function _listeners(self, event) {
  var listeners;
  listeners = self._events && self._events[event];
  if (!Array.isArray(listeners)) {
    if (listeners) {
      listeners = [listeners];
    }
    else {
      listeners = [];
    }
  }

  return listeners;
}

function _findAndProcess(self, event, before) {
  var after = _listeners(self, event);
  var unprocessed = after.filter(function(fn) { return before.indexOf(fn) === -1; });
  if (unprocessed.length > 0) _process(self, unprocessed);
}

function _wrap(unwrapped, visit) {
  if (!unwrapped) return;

  var wrapped = unwrapped;
  if (typeof unwrapped === 'function') {
    wrapped = visit(unwrapped);
  }
  else if (Array.isArray(unwrapped)) {
    wrapped = [];
    for (var i = 0; i < unwrapped.length; i++) {
      wrapped[i] = visit(unwrapped[i]);
    }
  }
  return wrapped;
}

module.exports = function wrapEmitter(emitter, onAddListener, onEmit) {
  if (!emitter || !emitter.on || !emitter.addListener ||
      !emitter.removeListener || !emitter.emit) {
    throw new Error("can only wrap real EEs");
  }

  if (!onAddListener) throw new Error("must have function to run on listener addition");
  if (!onEmit) throw new Error("must have function to wrap listeners when emitting");

  /* Attach a context to a listener, and make sure that this hook stays
   * attached to the emitter forevermore.
   */
  function adding(on) {
    return function added(event, listener) {
      var existing = _listeners(this, event).slice();

      try {
        var returned = on.call(this, event, listener);
        _findAndProcess(this, event, existing);
        return returned;
      }
      finally {
        // old-style streaming overwrites .on and .addListener, so rewrap
        if (!this.on.__wrapped) wrap(this, 'on', adding);
        if (!this.addListener.__wrapped) wrap(this, 'addListener', adding);
      }
    };
  }

  function emitting(emit) {
    return function emitted(event) {
      if (!this._events || !this._events[event]) return emit.apply(this, arguments);

      var unwrapped = this._events[event];

      /* Ensure that if removeListener gets called, it's working with the
       * unwrapped listeners.
       */
      function remover(removeListener) {
        return function removed() {
          this._events[event] = unwrapped;
          try {
            return removeListener.apply(this, arguments);
          }
          finally {
            unwrapped = this._events[event];
            this._events[event] = _wrap(unwrapped, onEmit);
          }
        };
      }
      wrap(this, 'removeListener', remover);

      try {
        /* At emit time, ensure that whatever else is going on, removeListener will
         * still work while at the same time running whatever hooks are necessary to
         * make sure the listener is run in the correct context.
         */
        this._events[event] = _wrap(unwrapped, onEmit);
        return emit.apply(this, arguments);
      }
      finally {
        /* Ensure that regardless of what happens when preparing and running the
         * listeners, the status quo ante is restored before continuing.
         */
        unwrap(this, 'removeListener');
        this._events[event] = unwrapped;
      }
    };
  }

  // support multiple onAddListeners
  if (!emitter[SYMBOL]) {
    defineProperty(emitter, SYMBOL, onAddListener);
  }
  else if (typeof emitter[SYMBOL] === 'function') {
    defineProperty(emitter, SYMBOL, [emitter[SYMBOL], onAddListener]);
  }
  else if (Array.isArray(emitter[SYMBOL])) {
    emitter[SYMBOL].push(onAddListener);
  }

  // only wrap the core functions once
  if (!emitter.__wrapped) {
    wrap(emitter, 'addListener', adding);
    wrap(emitter, 'on',          adding);
    wrap(emitter, 'emit',        emitting);

    defineProperty(emitter, '__unwrap', function () {
      unwrap(emitter, 'addListener');
      unwrap(emitter, 'on');
      unwrap(emitter, 'emit');
      delete emitter[SYMBOL];
      delete emitter.__wrapped;
    });
    defineProperty(emitter, '__wrapped', true);
  }
};


/***/ }),

/***/ 21904:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __nested_webpack_require_583__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_583__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_583__.m = modules;

/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_583__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_583__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_583__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __nested_webpack_require_1808__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __nested_webpack_require_1808__(1);
	var jsx_parser_1 = __nested_webpack_require_1808__(3);
	var parser_1 = __nested_webpack_require_1808__(8);
	var tokenizer_1 = __nested_webpack_require_1808__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __nested_webpack_require_1808__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.1';


/***/ },
/* 1 */
/***/ function(module, exports, __nested_webpack_require_6456__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __nested_webpack_require_6456__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __nested_webpack_require_15019__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __nested_webpack_require_15019__(4);
	var JSXNode = __nested_webpack_require_15019__(5);
	var jsx_syntax_1 = __nested_webpack_require_15019__(6);
	var Node = __nested_webpack_require_15019__(7);
	var parser_1 = __nested_webpack_require_15019__(8);
	var token_1 = __nested_webpack_require_15019__(13);
	var xhtml_entities_1 = __nested_webpack_require_15019__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __nested_webpack_require_54354__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __nested_webpack_require_54354__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __nested_webpack_require_58416__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __nested_webpack_require_58416__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __nested_webpack_require_80491__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __nested_webpack_require_80491__(9);
	var error_handler_1 = __nested_webpack_require_80491__(10);
	var messages_1 = __nested_webpack_require_80491__(11);
	var Node = __nested_webpack_require_80491__(7);
	var scanner_1 = __nested_webpack_require_80491__(12);
	var syntax_1 = __nested_webpack_require_80491__(2);
	var token_1 = __nested_webpack_require_80491__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token, lastLineStart) {
	        if (lastLineStart === void 0) { lastLineStart = 0; }
	        var column = token.start - token.lineStart;
	        var line = token.lineNumber;
	        if (column < 0) {
	            column += lastLineStart;
	            line--;
	        }
	        return {
	            index: token.start,
	            line: line,
	            column: column
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements  AssignmentTargets  AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            var lastMarker = markers.pop();
	            while (i > 1) {
	                var marker = markers.pop();
	                var lastLineStart = lastMarker && lastMarker.lineStart;
	                var node = this.startNode(marker, lastLineStart);
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	                lastMarker = marker;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = (!this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||
	            this.lookahead.type === 8 /* StringLiteral */ ||
	            this.lookahead.type === 10 /* Template */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
	                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        this.scanner.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __nested_webpack_require_226595__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __nested_webpack_require_226595__(9);
	var character_1 = __nested_webpack_require_226595__(4);
	var messages_1 = __nested_webpack_require_226595__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.isModule = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C && !this.isModule) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __nested_webpack_require_277122__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __nested_webpack_require_277122__(10);
	var scanner_1 = __nested_webpack_require_277122__(12);
	var token_1 = __nested_webpack_require_277122__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;

/***/ }),

/***/ 39837:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

//parse Empty Node as self closing node
const buildOptions = (__webpack_require__(84251).buildOptions);

const defaultOptions = {
  attributeNamePrefix: '@_',
  attrNodeName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataTagName: false,
  cdataPositionChar: '\\c',
  format: false,
  indentBy: '  ',
  supressEmptyNode: false,
  tagValueProcessor: function(a) {
    return a;
  },
  attrValueProcessor: function(a) {
    return a;
  },
};

const props = [
  'attributeNamePrefix',
  'attrNodeName',
  'textNodeName',
  'ignoreAttributes',
  'cdataTagName',
  'cdataPositionChar',
  'format',
  'indentBy',
  'supressEmptyNode',
  'tagValueProcessor',
  'attrValueProcessor',
];

function Parser(options) {
  this.options = buildOptions(options, defaultOptions, props);
  if (this.options.ignoreAttributes || this.options.attrNodeName) {
    this.isAttribute = function(/*a*/) {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }
  if (this.options.cdataTagName) {
    this.isCDATA = isCDATA;
  } else {
    this.isCDATA = function(/*a*/) {
      return false;
    };
  }
  this.replaceCDATAstr = replaceCDATAstr;
  this.replaceCDATAarr = replaceCDATAarr;

  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function() {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }

  if (this.options.supressEmptyNode) {
    this.buildTextNode = buildEmptyTextNode;
    this.buildObjNode = buildEmptyObjNode;
  } else {
    this.buildTextNode = buildTextValNode;
    this.buildObjNode = buildObjectNode;
  }

  this.buildTextValNode = buildTextValNode;
  this.buildObjectNode = buildObjectNode;
}

Parser.prototype.parse = function(jObj) {
  return this.j2x(jObj, 0).val;
};

Parser.prototype.j2x = function(jObj, level) {
  let attrStr = '';
  let val = '';
  const keys = Object.keys(jObj);
  const len = keys.length;
  for (let i = 0; i < len; i++) {
    const key = keys[i];
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node
    } else if (jObj[key] === null) {
      val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextNode(jObj[key], key, '', level);
    } else if (typeof jObj[key] !== 'object') {
      //premitive type
      const attr = this.isAttribute(key);
      if (attr) {
        attrStr += ' ' + attr + '="' + this.options.attrValueProcessor('' + jObj[key]) + '"';
      } else if (this.isCDATA(key)) {
        if (jObj[this.options.textNodeName]) {
          val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);
        } else {
          val += this.replaceCDATAstr('', jObj[key]);
        }
      } else {
        //tag value
        if (key === this.options.textNodeName) {
          if (jObj[this.options.cdataTagName]) {
            //value will added while processing cdata
          } else {
            val += this.options.tagValueProcessor('' + jObj[key]);
          }
        } else {
          val += this.buildTextNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      if (this.isCDATA(key)) {
        val += this.indentate(level);
        if (jObj[this.options.textNodeName]) {
          val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);
        } else {
          val += this.replaceCDATAarr('', jObj[key]);
        }
      } else {
        //nested nodes
        const arrLen = jObj[key].length;
        for (let j = 0; j < arrLen; j++) {
          const item = jObj[key][j];
          if (typeof item === 'undefined') {
            // supress undefined node
          } else if (item === null) {
            val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          } else if (typeof item === 'object') {
            const result = this.j2x(item, level + 1);
            val += this.buildObjNode(result.val, key, result.attrStr, level);
          } else {
            val += this.buildTextNode(item, key, '', level);
          }
        }
      }
    } else {
      //nested node
      if (this.options.attrNodeName && key === this.options.attrNodeName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += ' ' + Ks[j] + '="' + this.options.attrValueProcessor('' + jObj[key][Ks[j]]) + '"';
        }
      } else {
        const result = this.j2x(jObj[key], level + 1);
        val += this.buildObjNode(result.val, key, result.attrStr, level);
      }
    }
  }
  return {attrStr: attrStr, val: val};
};

function replaceCDATAstr(str, cdata) {
  str = this.options.tagValueProcessor('' + str);
  if (this.options.cdataPositionChar === '' || str === '') {
    return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;
  } else {
    return str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata + ']]' + this.tagEndChar);
  }
}

function replaceCDATAarr(str, cdata) {
  str = this.options.tagValueProcessor('' + str);
  if (this.options.cdataPositionChar === '' || str === '') {
    return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;
  } else {
    for (let v in cdata) {
      str = str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata[v] + ']]>');
    }
    return str + this.newLine;
  }
}

function buildObjectNode(val, key, attrStr, level) {
  if (attrStr && !val.includes('<')) {
    return (
      this.indentate(level) +
      '<' +
      key +
      attrStr +
      '>' +
      val +
      //+ this.newLine
      // + this.indentate(level)
      '</' +
      key +
      this.tagEndChar
    );
  } else {
    return (
      this.indentate(level) +
      '<' +
      key +
      attrStr +
      this.tagEndChar +
      val +
      //+ this.newLine
      this.indentate(level) +
      '</' +
      key +
      this.tagEndChar
    );
  }
}

function buildEmptyObjNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildObjectNode(val, key, attrStr, level);
  } else {
    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
    //+ this.newLine
  }
}

function buildTextValNode(val, key, attrStr, level) {
  return (
    this.indentate(level) +
    '<' +
    key +
    attrStr +
    '>' +
    this.options.tagValueProcessor(val) +
    '</' +
    key +
    this.tagEndChar
  );
}

function buildEmptyTextNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildTextValNode(val, key, attrStr, level);
  } else {
    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
  }
}

function indentate(level) {
  return this.options.indentBy.repeat(level);
}

function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix)) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

function isCDATA(name) {
  return name === this.options.cdataTagName;
}

//formatting
//indentation
//\n after each closing or self closing tag

module.exports = Parser;


/***/ }),

/***/ 60342:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const char = function(a) {
  return String.fromCharCode(a);
};

const chars = {
  nilChar: char(176),
  missingChar: char(201),
  nilPremitive: char(175),
  missingPremitive: char(200),

  emptyChar: char(178),
  emptyValue: char(177), //empty Premitive

  boundryChar: char(179),

  objStart: char(198),
  arrStart: char(204),
  arrayEnd: char(185),
};

const charsArr = [
  chars.nilChar,
  chars.nilPremitive,
  chars.missingChar,
  chars.missingPremitive,
  chars.boundryChar,
  chars.emptyChar,
  chars.emptyValue,
  chars.arrayEnd,
  chars.objStart,
  chars.arrStart,
];

const _e = function(node, e_schema, options) {
  if (typeof e_schema === 'string') {
    //premitive
    if (node && node[0] && node[0].val !== undefined) {
      return getValue(node[0].val, e_schema);
    } else {
      return getValue(node, e_schema);
    }
  } else {
    const hasValidData = hasData(node);
    if (hasValidData === true) {
      let str = '';
      if (Array.isArray(e_schema)) {
        //attributes can't be repeated. hence check in children tags only
        str += chars.arrStart;
        const itemSchema = e_schema[0];
        //var itemSchemaType = itemSchema;
        const arr_len = node.length;

        if (typeof itemSchema === 'string') {
          for (let arr_i = 0; arr_i < arr_len; arr_i++) {
            const r = getValue(node[arr_i].val, itemSchema);
            str = processValue(str, r);
          }
        } else {
          for (let arr_i = 0; arr_i < arr_len; arr_i++) {
            const r = _e(node[arr_i], itemSchema, options);
            str = processValue(str, r);
          }
        }
        str += chars.arrayEnd; //indicates that next item is not array item
      } else {
        //object
        str += chars.objStart;
        const keys = Object.keys(e_schema);
        if (Array.isArray(node)) {
          node = node[0];
        }
        for (let i in keys) {
          const key = keys[i];
          //a property defined in schema can be present either in attrsMap or children tags
          //options.textNodeName will not present in both maps, take it's value from val
          //options.attrNodeName will be present in attrsMap
          let r;
          if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {
            r = _e(node.attrsMap[key], e_schema[key], options);
          } else if (key === options.textNodeName) {
            r = _e(node.val, e_schema[key], options);
          } else {
            r = _e(node.child[key], e_schema[key], options);
          }
          str = processValue(str, r);
        }
      }
      return str;
    } else {
      return hasValidData;
    }
  }
};

const getValue = function(a /*, type*/) {
  switch (a) {
    case undefined:
      return chars.missingPremitive;
    case null:
      return chars.nilPremitive;
    case '':
      return chars.emptyValue;
    default:
      return a;
  }
};

const processValue = function(str, r) {
  if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {
    str += chars.boundryChar;
  }
  return str + r;
};

const isAppChar = function(ch) {
  return charsArr.indexOf(ch) !== -1;
};

function hasData(jObj) {
  if (jObj === undefined) {
    return chars.missingChar;
  } else if (jObj === null) {
    return chars.nilChar;
  } else if (
    jObj.child &&
    Object.keys(jObj.child).length === 0 &&
    (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)
  ) {
    return chars.emptyChar;
  } else {
    return true;
  }
}

const x2j = __webpack_require__(86831);
const buildOptions = (__webpack_require__(84251).buildOptions);

const convert2nimn = function(node, e_schema, options) {
  options = buildOptions(options, x2j.defaultOptions, x2j.props);
  return _e(node, e_schema, options);
};

exports.convert2nimn = convert2nimn;


/***/ }),

/***/ 85383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(84251);

const convertToJson = function(node, options) {
  const jObj = {};

  //when no child node or attr is present
  if ((!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {
    return util.isExist(node.val) ? node.val : '';
  } else {
    //otherwise create a textnode if node has some text
    if (util.isExist(node.val)) {
      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {
        jObj[options.textNodeName] = node.val;
      }
    }
  }

  util.merge(jObj, node.attrsMap);

  const keys = Object.keys(node.child);
  for (let index = 0; index < keys.length; index++) {
    var tagname = keys[index];
    if (node.child[tagname] && node.child[tagname].length > 1) {
      jObj[tagname] = [];
      for (var tag in node.child[tagname]) {
        jObj[tagname].push(convertToJson(node.child[tagname][tag], options));
      }
    } else {
      jObj[tagname] = convertToJson(node.child[tagname][0], options);
    }
  }

  //add value
  return jObj;
};

exports.convertToJson = convertToJson;


/***/ }),

/***/ 33827:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(84251);
const buildOptions = (__webpack_require__(84251).buildOptions);
const x2j = __webpack_require__(86831);

//TODO: do it later
const convertToJsonString = function(node, options) {
  options = buildOptions(options, x2j.defaultOptions, x2j.props);

  options.indentBy = options.indentBy || '';
  return _cToJsonStr(node, options, 0);
};

const _cToJsonStr = function(node, options, level) {
  let jObj = '{';

  //traver through all the children
  const keys = Object.keys(node.child);

  for (let index = 0; index < keys.length; index++) {
    var tagname = keys[index];
    if (node.child[tagname] && node.child[tagname].length > 1) {
      jObj += '"' + tagname + '" : [ ';
      for (var tag in node.child[tagname]) {
        jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';
      }
      jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last
    } else {
      jObj += '"' + tagname + '" : ' + _cToJsonStr(node.child[tagname][0], options) + ' ,';
    }
  }
  util.merge(jObj, node.attrsMap);
  //add attrsMap as new children
  if (util.isEmptyObject(jObj)) {
    return util.isExist(node.val) ? node.val : '';
  } else {
    if (util.isExist(node.val)) {
      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {
        jObj += '"' + options.textNodeName + '" : ' + stringval(node.val);
      }
    }
  }
  //add value
  if (jObj[jObj.length - 1] === ',') {
    jObj = jObj.substr(0, jObj.length - 2);
  }
  return jObj + '}';
};

function stringval(v) {
  if (v === true || v === false || !isNaN(v)) {
    return v;
  } else {
    return '"' + v + '"';
  }
}

function indentate(options, level) {
  return options.indentBy.repeat(level);
}

exports.convertToJsonString = convertToJsonString;


/***/ }),

/***/ 6832:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const nodeToJson = __webpack_require__(85383);
const xmlToNodeobj = __webpack_require__(86831);
const x2xmlnode = __webpack_require__(86831);
const buildOptions = (__webpack_require__(84251).buildOptions);

exports.parse = function(xmlData, options) {
  options = buildOptions(options, x2xmlnode.defaultOptions, x2xmlnode.props);
  return nodeToJson.convertToJson(xmlToNodeobj.getTraversalObj(xmlData, options), options);
};
exports.convertTonimn = __webpack_require__(60342).convert2nimn;
exports.getTraversalObj = xmlToNodeobj.getTraversalObj;
exports.convertToJson = nodeToJson.convertToJson;
exports.convertToJsonString = __webpack_require__(33827).convertToJsonString;
exports.validate = __webpack_require__(7468).validate;
exports.j2xParser = __webpack_require__(39837);
exports.parseToNimn = function(xmlData, schema, options) {
  return exports.convertTonimn(exports.getTraversalObj(xmlData, options), schema, options);
};


/***/ }),

/***/ 84251:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const getAllMatches = function(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
};

const doesMatch = function(string, regex) {
  const match = regex.exec(string);
  return !(match === null || typeof match === 'undefined');
};

const doesNotMatch = function(string, regex) {
  return !doesMatch(string, regex);
};

exports.isExist = function(v) {
  return typeof v !== 'undefined';
};

exports.isEmptyObject = function(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */
exports.merge = function(target, a) {
  if (a) {
    const keys = Object.keys(a); // will return an array of own properties
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      target[keys[i]] = a[keys[i]];
    }
  }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

exports.getValue = function(v) {
  if (exports.isExist(v)) {
    return v;
  } else {
    return '';
  }
};

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

exports.buildOptions = function(options, defaultOptions, props) {
  var newOptions = {};
  if (!options) {
    return defaultOptions; //if there are not options
  }

  for (let i = 0; i < props.length; i++) {
    if (options[props[i]] !== undefined) {
      newOptions[props[i]] = options[props[i]];
    } else {
      newOptions[props[i]] = defaultOptions[props[i]];
    }
  }
  return newOptions;
};

exports.doesMatch = doesMatch;
exports.doesNotMatch = doesNotMatch;
exports.getAllMatches = getAllMatches;


/***/ }),

/***/ 7468:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(84251);

const defaultOptions = {
  allowBooleanAttributes: false, //A tag can have attributes without any value
  localeRange: 'a-zA-Z',
};

const props = ['allowBooleanAttributes', 'localeRange'];

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function(xmlData, options) {
  options = util.buildOptions(options, defaultOptions, props);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE

  const tags = [];
  let tagFound = false;
  if (xmlData[0] === '\ufeff') {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }
  const regxAttrName = new RegExp('^[_w][\\w\\-.:]*$'.replace('_w', '_' + options.localeRange));
  const regxTagName = new RegExp('^([w]|_)[\\w.\\-_:]*'.replace('([w', '([' + options.localeRange));
  for (let i = 0; i < xmlData.length; i++) {
    if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value

      i++;
      if (xmlData[i] === '?') {
        i = readPI(xmlData, ++i);
        if (i.err) {
          return i;
        }
      } else if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        let tagName = '';
        for (
          ;
          i < xmlData.length &&
          xmlData[i] !== '>' &&
          xmlData[i] !== ' ' &&
          xmlData[i] !== '\t' &&
          xmlData[i] !== '\n' &&
          xmlData[i] !== '\r';
          i++
        ) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          continue;
        }
        if (!validateTagName(tagName, regxTagName)) {
          return {err: {code: 'InvalidTag', msg: 'Tag ' + tagName + ' is an invalid name.'}};
        }

        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return {err: {code: 'InvalidAttr', msg: 'Attributes for ' + tagName + ' have open quote'}};
        }
        let attrStr = result.value;
        i = result.index;

        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options, regxAttrName);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            return isValid;
          }
        } else if (closingTag) {
          if (attrStr.trim().length > 0) {
            return {
              err: {code: 'InvalidTag', msg: 'closing tag ' + tagName + " can't have attributes or invalid starting."},
            };
          } else {
            const otg = tags.pop();
            if (tagName !== otg) {
              return {
                err: {code: 'InvalidTag', msg: 'closing tag ' + otg + ' is expected inplace of ' + tagName + '.'},
              };
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options, regxAttrName);
          if (isValid !== true) {
            return isValid;
          }
          tags.push(tagName);
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else {
              break;
            }
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if (xmlData[i] === ' ' || xmlData[i] === '\t' || xmlData[i] === '\n' || xmlData[i] === '\r') {
        continue;
      }
      return {err: {code: 'InvalidChar', msg: 'char ' + xmlData[i] + ' is not expected .'}};
    }
  }

  if (!tagFound) {
    return {err: {code: 'InvalidXml', msg: 'Start tag expected.'}};
  } else if (tags.length > 0) {
    return {
      err: {code: 'InvalidXml', msg: 'Invalid ' + JSON.stringify(tags, null, 4).replace(/\r?\n/g, '') + ' found.'},
    };
  }

  return true;
};

/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  var start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      var tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return {err: {code: 'InvalidXml', msg: 'XML declaration allowed only at the start of the document.'}};
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}

function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (
    xmlData.length > i + 8 &&
    xmlData[i + 1] === 'D' &&
    xmlData[i + 2] === 'O' &&
    xmlData[i + 3] === 'C' &&
    xmlData[i + 4] === 'T' &&
    xmlData[i + 5] === 'Y' &&
    xmlData[i + 6] === 'P' &&
    xmlData[i + 7] === 'E'
  ) {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (
    xmlData.length > i + 9 &&
    xmlData[i + 1] === '[' &&
    xmlData[i + 2] === 'C' &&
    xmlData[i + 3] === 'D' &&
    xmlData[i + 4] === 'A' &&
    xmlData[i + 5] === 'T' &&
    xmlData[i + 6] === 'A' &&
    xmlData[i + 7] === '['
  ) {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }

  return i;
}

var doubleQuote = '"';
var singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  let attrStr = '';
  let startChar = '';
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
        continue;
      } else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }

  return {value: attrStr, index: i};
}

/**
 * Select all the attributes whether valid or invalid.
 */
const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options, regxAttrName) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};

  for (let i = 0; i < matches.length; i++) {
    //console.log(matches[i]);

    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return {err: {code: 'InvalidAttr', msg: 'attribute ' + matches[i][2] + ' has no space in starting.'}};
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return {err: {code: 'InvalidAttr', msg: 'boolean attribute ' + matches[i][2] + ' is not allowed.'}};
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    const attrName = matches[i][2];
    if (!validateAttrName(attrName, regxAttrName)) {
      return {err: {code: 'InvalidAttr', msg: 'attribute ' + attrName + ' is an invalid name.'}};
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return {err: {code: 'InvalidAttr', msg: 'attribute ' + attrName + ' is repeated.'}};
    }
  }

  return true;
}

// const validAttrRegxp = /^[_a-zA-Z][\w\-.:]*$/;

function validateAttrName(attrName, regxAttrName) {
  // const validAttrRegxp = new RegExp(regxAttrName);
  return util.doesMatch(attrName, regxAttrName);
}

//const startsWithXML = new RegExp("^[Xx][Mm][Ll]");
//  startsWith = /^([a-zA-Z]|_)[\w.\-_:]*/;

function validateTagName(tagname, regxTagName) {
  /*if(util.doesMatch(tagname,startsWithXML)) return false;
    else*/
  return !util.doesNotMatch(tagname, regxTagName);
}


/***/ }),

/***/ 94655:
/***/ ((module) => {

"use strict";


module.exports = function(tagname, parent, val) {
  this.tagname = tagname;
  this.parent = parent;
  this.child = {}; //child tags
  this.attrsMap = {}; //attributes map
  this.val = val; //text only
  this.addChild = function(child) {
    if (Array.isArray(this.child[child.tagname])) {
      //already presents
      this.child[child.tagname].push(child);
    } else {
      this.child[child.tagname] = [child];
    }
  };
};


/***/ }),

/***/ 86831:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(84251);
const buildOptions = (__webpack_require__(84251).buildOptions);
const xmlNode = __webpack_require__(94655);
const TagType = {OPENING: 1, CLOSING: 2, SELF: 3, CDATA: 4};
let regx =
  '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|(([\\w:\\-._]*:)?([\\w:\\-._]+))([^>]*)>|((\\/)(([\\w:\\-._]*:)?([\\w:\\-._]+))\\s*>))([^<]*)';

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

//polyfill
if (!Number.parseInt && window.parseInt) {
  Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
  Number.parseFloat = window.parseFloat;
}

const defaultOptions = {
  attributeNamePrefix: '@_',
  attrNodeName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  ignoreNameSpace: false,
  allowBooleanAttributes: false, //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseNodeValue: true,
  parseAttributeValue: false,
  arrayMode: false,
  trimValues: true, //Trim string values of tag and attributes
  cdataTagName: false,
  cdataPositionChar: '\\c',
  localeRange: '',
  tagValueProcessor: function(a) {
    return a;
  },
  attrValueProcessor: function(a) {
    return a;
  },
  stopNodes: []
  //decodeStrict: false,
};

exports.defaultOptions = defaultOptions;

const props = [
  'attributeNamePrefix',
  'attrNodeName',
  'textNodeName',
  'ignoreAttributes',
  'ignoreNameSpace',
  'allowBooleanAttributes',
  'parseNodeValue',
  'parseAttributeValue',
  'arrayMode',
  'trimValues',
  'cdataTagName',
  'cdataPositionChar',
  'localeRange',
  'tagValueProcessor',
  'attrValueProcessor',
  'parseTrueNumberOnly',
  'stopNodes'
];
exports.props = props;

const getTraversalObj = function(xmlData, options) {
  options = buildOptions(options, defaultOptions, props);
  //xmlData = xmlData.replace(/\r?\n/g, " ");//make it single line
  xmlData = xmlData.replace(/<!--[\s\S]*?-->/g, ''); //Remove  comments

  const xmlObj = new xmlNode('!xml');
  let currentNode = xmlObj;

  regx = regx.replace(/\[\\w/g, '[' + options.localeRange + '\\w');
  const tagsRegx = new RegExp(regx, 'g');
  let tag = tagsRegx.exec(xmlData);
  let nextTag = tagsRegx.exec(xmlData);
  while (tag) {
    const tagType = checkForTagType(tag);

    if (tagType === TagType.CLOSING) {
      //add parsed data to parent node
      if (currentNode.parent && tag[14]) {
        currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue(tag[14], options);
      }
      if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {
        currentNode.child = []
        if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {}}
        currentNode.val = xmlData.substr(currentNode.startIndex + 1, tag.index - currentNode.startIndex - 1)
      }
      currentNode = currentNode.parent;
    } else if (tagType === TagType.CDATA) {
      if (options.cdataTagName) {
        //add cdata node
        const childNode = new xmlNode(options.cdataTagName, currentNode, tag[3]);
        childNode.attrsMap = buildAttributesMap(tag[8], options);
        currentNode.addChild(childNode);
        //for backtracking
        currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;
        //add rest value to parent node
        if (tag[14]) {
          currentNode.val += processTagValue(tag[14], options);
        }
      } else {
        currentNode.val = (currentNode.val || '') + (tag[3] || '') + processTagValue(tag[14], options);
      }
    } else if (tagType === TagType.SELF) {
      if (currentNode && tag[14]) {
        currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tag[14], options);
      }

      const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, '');
      if (tag[8] && tag[8].length > 0) {
        tag[8] = tag[8].substr(0, tag[8].length - 1);
      }
      childNode.attrsMap = buildAttributesMap(tag[8], options);
      currentNode.addChild(childNode);
    } else {
      //TagType.OPENING
      const childNode = new xmlNode(
        options.ignoreNameSpace ? tag[7] : tag[5],
        currentNode,
        processTagValue(tag[14], options)
      );
      if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {
        childNode.startIndex=tag.index + tag[1].length
      }
      childNode.attrsMap = buildAttributesMap(tag[8], options);
      currentNode.addChild(childNode);
      currentNode = childNode;
    }

    tag = nextTag;
    nextTag = tagsRegx.exec(xmlData);
  }

  return xmlObj;
};

function processTagValue(val, options) {
  if (val) {
    if (options.trimValues) {
      val = val.trim();
    }
    val = options.tagValueProcessor(val);
    val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);
  }

  return val;
}

function checkForTagType(match) {
  if (match[4] === ']]>') {
    return TagType.CDATA;
  } else if (match[10] === '/') {
    return TagType.CLOSING;
  } else if (typeof match[8] !== 'undefined' && match[8].substr(match[8].length - 1) === '/') {
    return TagType.SELF;
  } else {
    return TagType.OPENING;
  }
}

function resolveNameSpace(tagname, options) {
  if (options.ignoreNameSpace) {
    const tags = tagname.split(':');
    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

function parseValue(val, shouldParse, parseTrueNumberOnly) {
  if (shouldParse && typeof val === 'string') {
    let parsed;
    if (val.trim() === '' || isNaN(val)) {
      parsed = val === 'true' ? true : val === 'false' ? false : val;
    } else {
      if (val.indexOf('0x') !== -1) {
        //support hexa decimal
        parsed = Number.parseInt(val, 16);
      } else if (val.indexOf('.') !== -1) {
        parsed = Number.parseFloat(val);
      } else {
        parsed = Number.parseInt(val, 10);
      }
      if (parseTrueNumberOnly) {
        parsed = String(parsed) === val ? parsed : val;
      }
    }
    return parsed;
  } else {
    if (util.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])(.*?)\\3)?', 'g');

function buildAttributesMap(attrStr, options) {
  if (!options.ignoreAttributes && typeof attrStr === 'string') {
    attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length; //don't make it inline
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = resolveNameSpace(matches[i][1], options);
      if (attrName.length) {
        if (matches[i][4] !== undefined) {
          if (options.trimValues) {
            matches[i][4] = matches[i][4].trim();
          }
          matches[i][4] = options.attrValueProcessor(matches[i][4]);
          attrs[options.attributeNamePrefix + attrName] = parseValue(
            matches[i][4],
            options.parseAttributeValue,
            options.parseTrueNumberOnly
          );
        } else if (options.allowBooleanAttributes) {
          attrs[options.attributeNamePrefix + attrName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (options.attrNodeName) {
      const attrCollection = {};
      attrCollection[options.attrNodeName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}

exports.getTraversalObj = getTraversalObj;


/***/ }),

/***/ 59490:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(71017);
const locatePath = __webpack_require__(34726);
const pathExists = __webpack_require__(45955);

const stop = Symbol('findUp.stop');

module.exports = async (name, options = {}) => {
	let directory = path.resolve(options.cwd || '');
	const {root} = path.parse(directory);
	const paths = [].concat(name);

	const runMatcher = async locateOptions => {
		if (typeof name !== 'function') {
			return locatePath(paths, locateOptions);
		}

		const foundPath = await name(locateOptions.cwd);
		if (typeof foundPath === 'string') {
			return locatePath([foundPath], locateOptions);
		}

		return foundPath;
	};

	// eslint-disable-next-line no-constant-condition
	while (true) {
		// eslint-disable-next-line no-await-in-loop
		const foundPath = await runMatcher({...options, cwd: directory});

		if (foundPath === stop) {
			return;
		}

		if (foundPath) {
			return path.resolve(directory, foundPath);
		}

		if (directory === root) {
			return;
		}

		directory = path.dirname(directory);
	}
};

module.exports.sync = (name, options = {}) => {
	let directory = path.resolve(options.cwd || '');
	const {root} = path.parse(directory);
	const paths = [].concat(name);

	const runMatcher = locateOptions => {
		if (typeof name !== 'function') {
			return locatePath.sync(paths, locateOptions);
		}

		const foundPath = name(locateOptions.cwd);
		if (typeof foundPath === 'string') {
			return locatePath.sync([foundPath], locateOptions);
		}

		return foundPath;
	};

	// eslint-disable-next-line no-constant-condition
	while (true) {
		const foundPath = runMatcher({...options, cwd: directory});

		if (foundPath === stop) {
			return;
		}

		if (foundPath) {
			return path.resolve(directory, foundPath);
		}

		if (directory === root) {
			return;
		}

		directory = path.dirname(directory);
	}
};

module.exports.exists = pathExists;

module.exports.sync.exists = pathExists.sync;

module.exports.stop = stop;


/***/ }),

/***/ 69177:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var EventEmitter = (__webpack_require__(82361).EventEmitter);
var fs = __webpack_require__(57147);
var path = __webpack_require__(71017);

module.exports = findit;

function findit(basedir, opts) {
  opts = opts || {};
  var followSymlinks = !!opts.followSymlinks;
  var myFs = opts.fs || fs;
  var emitter = new EventEmitter();
  var stopped = false;
  var pending = 0;
  var seen = {};

  emitter.stop = stop;
  walkPath(basedir);
  return emitter;

  function recursiveReadDir(basedir, linkPath) {
    pendStart();
    myFs.readdir(basedir, function(err, entries) {
      if (stopped) return;
      if (err) {
        handleError(err, basedir);
        pendEnd();
        return;
      }
      entries.forEach(function(entry) {
        var fullPath = path.join(basedir, entry);
        var fullLinkPath = linkPath && path.join(linkPath, entry);
        walkPath(fullPath, fullLinkPath);
      });
      pendEnd();
    });
  }

  function walkPath(fullPath, linkPath) {
    pendStart();
    myFs.lstat(fullPath, function(err, stats) {
      if (stopped) return;
      if (err) {
        handleError(err, fullPath);
        pendEnd();
        return;
      }
      emitter.emit('path', fullPath, stats, linkPath);
      var dirStopped = false;
      if (stats.isDirectory()) {
        if (seen[fullPath]) {
          err = new Error("file system loop detected");
          err.code = 'ELOOP';
          handleError(err, fullPath);
          pendEnd();
          return;
        }
        seen[fullPath] = true;

        emitter.emit('directory', fullPath, stats, stopDir, linkPath);
        if (!dirStopped) recursiveReadDir(fullPath, linkPath);
      } else if (stats.isFile()) {
        if (!seen[fullPath]) {
          seen[fullPath] = true;
          emitter.emit('file', fullPath, stats, linkPath);
        }
      } else if (stats.isSymbolicLink()) {
        emitter.emit('link', fullPath, stats, linkPath);
        if (followSymlinks) recursiveReadLink(fullPath);
      }
      pendEnd();

      function stopDir() {
        dirStopped = true;
      }
    });
  }

  function recursiveReadLink(linkPath) {
    pendStart();
    myFs.readlink(linkPath, function(err, linkString) {
      if (stopped) return;
      if (err) {
        handleError(err, linkPath);
        pendEnd();
        return;
      }
      var fullPath = path.resolve(path.dirname(linkPath), linkString);
      emitter.emit('readlink', linkPath, fullPath);
      walkPath(fullPath, linkPath);
      pendEnd();
    });
  }

  function stop() {
    if (stopped) return;
    stopped = true;
    emitter.emit('stop');
  }

  function handleError(err, errPath) {
    if (!err || stopped) return;
    err.path = errPath;
    emitter.emit('error', err);
  }

  function pendStart() {
    pending += 1;
  }

  function pendEnd() {
    if (stopped) return;
    pending -= 1;
    if (pending === 0) {
      emitter.emit('end');
    } else if (pending < 0) {
      // this should never happen; if this gets thrown we need to debug findit
      // and this stack trace will help.
      throw new Error("pendEnd called too many times");
    }
  }
}


/***/ }),

/***/ 33669:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var debug;

module.exports = function () {
  if (!debug) {
    try {
      /* eslint global-require: off */
      debug = __webpack_require__(78634)("follow-redirects");
    }
    catch (error) { /* */ }
    if (typeof debug !== "function") {
      debug = function () { /* */ };
    }
  }
  debug.apply(null, arguments);
};


/***/ }),

/***/ 36740:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var url = __webpack_require__(57310);
var URL = url.URL;
var http = __webpack_require__(13685);
var https = __webpack_require__(95687);
var Writable = (__webpack_require__(12781).Writable);
var assert = __webpack_require__(39491);
var debug = __webpack_require__(33669);

// Create handlers that pass events from native requests
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = Object.create(null);
events.forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded"
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    self._processResponse(response);
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

RedirectableRequest.prototype.abort = function () {
  abortRequest(this._currentRequest);
  this.emit("abort");
};

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!(typeof data === "string" || typeof data === "object" && ("length" in data))) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (typeof data === "function") {
    callback = data;
    data = encoding = null;
  }
  else if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  var self = this;

  // Destroys the socket on timeout
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }

  // Sets up a timer to trigger a timeout event
  function startTimer(socket) {
    if (self._timeout) {
      clearTimeout(self._timeout);
    }
    self._timeout = setTimeout(function () {
      self.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }

  // Stops a timeout from triggering
  function clearTimer() {
    // Clear the timeout
    if (self._timeout) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }

    // Clean up all attached listeners
    self.removeListener("abort", clearTimer);
    self.removeListener("error", clearTimer);
    self.removeListener("response", clearTimer);
    if (callback) {
      self.removeListener("timeout", callback);
    }
    if (!self.socket) {
      self._currentRequest.removeListener("socket", startTimer);
    }
  }

  // Attach callback if passed
  if (callback) {
    this.on("timeout", callback);
  }

  // Start the timer if or when the socket is opened
  if (this.socket) {
    startTimer(this.socket);
  }
  else {
    this._currentRequest.once("socket", startTimer);
  }

  // Clean up on events
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);

  return this;
};

// Proxy all other public ClientRequest methods
[
  "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    this.emit("error", new TypeError("Unsupported protocol " + protocol));
    return;
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.substr(0, protocol.length - 1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  this._currentUrl = url.format(this._options);

  // Set up event handlers
  request._redirectable = this;
  for (var e = 0; e < events.length; e++) {
    request.on(events[e], eventHandlers[events[e]]);
  }

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end.
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      /* istanbul ignore else */
      if (request === self._currentRequest) {
        // Report any write errors
        /* istanbul ignore if */
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          /* istanbul ignore else */
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC72316.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.
  var location = response.headers.location;
  if (location && this._options.followRedirects !== false &&
      statusCode >= 300 && statusCode < 400) {
    // Abort the current request
    abortRequest(this._currentRequest);
    // Discard the remainder of the response to avoid waiting for data
    response.destroy();

    // RFC72316.4: A client SHOULD detect and intervene
    // in cyclical redirections (i.e., "infinite" redirection loops).
    if (++this._redirectCount > this._options.maxRedirects) {
      this.emit("error", new TooManyRedirectsError());
      return;
    }

    // RFC72316.4: Automatic redirection needs to done with
    // care for methods not known to be safe, []
    // RFC72316.4.23: For historical reasons, a user agent MAY change
    // the request method from POST to GET for the subsequent request.
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
        // RFC72316.4.4: The 303 (See Other) status code indicates that
        // the server is redirecting the user agent to a different resource []
        // A user agent can perform a retrieval request targeting that URI
        // (a GET or HEAD request if using HTTP) []
        (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      // Drop a possible entity and headers related to it
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }

    // Drop the Host header, as the redirect might lead to a different host
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

    // If the redirect is relative, carry over the host of the last request
    var currentUrlParts = url.parse(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
      url.format(Object.assign(currentUrlParts, { host: currentHost }));

    // Determine the URL of the redirection
    var redirectUrl;
    try {
      redirectUrl = url.resolve(currentUrl, location);
    }
    catch (cause) {
      this.emit("error", new RedirectionError(cause));
      return;
    }

    // Create the redirected request
    debug("redirecting to", redirectUrl);
    this._isRedirect = true;
    var redirectUrlParts = url.parse(redirectUrl);
    Object.assign(this._options, redirectUrlParts);

    // Drop the confidential headers when redirecting to another domain
    if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {
      removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
    }

    // Evaluate the beforeRedirect callback
    if (typeof this._options.beforeRedirect === "function") {
      var responseDetails = { headers: response.headers };
      try {
        this._options.beforeRedirect.call(null, this._options, responseDetails);
      }
      catch (err) {
        this.emit("error", err);
        return;
      }
      this._sanitizeOptions(this._options);
    }

    // Perform the redirected request
    try {
      this._performRequest();
    }
    catch (cause) {
      this.emit("error", new RedirectionError(cause));
    }
  }
  else {
    // The response is not a redirect; return it as-is
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
  }
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    function request(input, options, callback) {
      // Parse parameters
      if (typeof input === "string") {
        var urlStr = input;
        try {
          input = urlToOptions(new URL(urlStr));
        }
        catch (err) {
          /* istanbul ignore next */
          input = url.parse(urlStr);
        }
      }
      else if (URL && (input instanceof URL)) {
        input = urlToOptions(input);
      }
      else {
        callback = options;
        options = input;
        input = { protocol: protocol };
      }
      if (typeof options === "function") {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }

    // Executes a GET request, following redirects
    function get(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }

    // Expose the properties on the wrapped protocol
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true },
    });
  });
  return exports;
}

/* istanbul ignore next */
function noop() { /* empty */ }

// from https://github.com/nodejs/node/blob/master/lib/internal/url.js
function urlToOptions(urlObject) {
  var options = {
    protocol: urlObject.protocol,
    hostname: urlObject.hostname.startsWith("[") ?
      /* istanbul ignore next */
      urlObject.hostname.slice(1, -1) :
      urlObject.hostname,
    hash: urlObject.hash,
    search: urlObject.search,
    pathname: urlObject.pathname,
    path: urlObject.pathname + urlObject.search,
    href: urlObject.href,
  };
  if (urlObject.port !== "") {
    options.port = Number(urlObject.port);
  }
  return options;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return (lastValue === null || typeof lastValue === "undefined") ?
    undefined : String(lastValue).trim();
}

function createErrorType(code, defaultMessage) {
  function CustomError(cause) {
    Error.captureStackTrace(this, this.constructor);
    if (!cause) {
      this.message = defaultMessage;
    }
    else {
      this.message = defaultMessage + ": " + cause.message;
      this.cause = cause;
    }
  }
  CustomError.prototype = new Error();
  CustomError.prototype.constructor = CustomError;
  CustomError.prototype.name = "Error [" + code + "]";
  CustomError.prototype.code = code;
  return CustomError;
}

function abortRequest(request) {
  for (var e = 0; e < events.length; e++) {
    request.removeListener(events[e], eventHandlers[events[e]]);
  }
  request.on("error", noop);
  request.abort();
}

function isSubdomainOf(subdomain, domain) {
  const dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}

// Exports
module.exports = wrap({ http: http, https: https });
module.exports.wrap = wrap;


/***/ }),

/***/ 74608:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var spin = __webpack_require__(74365)
var progressBar = __webpack_require__(8936)

module.exports = {
  activityIndicator: function (values, theme, width) {
    if (values.spun == null) return
    return spin(theme, values.spun)
  },
  progressbar: function (values, theme, width) {
    if (values.completed == null) return
    return progressBar(theme, width, values.completed)
  }
}


/***/ }),

/***/ 15591:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var util = __webpack_require__(73837)

var User = exports.User = function User (msg) {
  var err = new Error(msg)
  Error.captureStackTrace(err, User)
  err.code = 'EGAUGE'
  return err
}

exports.MissingTemplateValue = function MissingTemplateValue (item, values) {
  var err = new User(util.format('Missing template value "%s"', item.type))
  Error.captureStackTrace(err, MissingTemplateValue)
  err.template = item
  err.values = values
  return err
}

exports.Internal = function Internal (msg) {
  var err = new Error(msg)
  Error.captureStackTrace(err, Internal)
  err.code = 'EGAUGEINTERNAL'
  return err
}


/***/ }),

/***/ 18029:
/***/ ((module) => {

"use strict";


module.exports = isWin32() || isColorTerm()

function isWin32 () {
  return process.platform === 'win32'
}

function isColorTerm () {
  var termHasColor = /^screen|^xterm|^vt100|color|ansi|cygwin|linux/i
  return !!process.env.COLORTERM || termHasColor.test(process.env.TERM)
}


/***/ }),

/***/ 1757:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Plumbing = __webpack_require__(17852)
var hasUnicode = __webpack_require__(29253)
var hasColor = __webpack_require__(18029)
var onExit = __webpack_require__(40412)
var defaultThemes = __webpack_require__(62834)
var setInterval = __webpack_require__(29165)
var process = __webpack_require__(22156)
var setImmediate = __webpack_require__(48761)

module.exports = Gauge

function callWith (obj, method) {
  return function () {
    return method.call(obj)
  }
}

function Gauge (arg1, arg2) {
  var options, writeTo
  if (arg1 && arg1.write) {
    writeTo = arg1
    options = arg2 || {}
  } else if (arg2 && arg2.write) {
    writeTo = arg2
    options = arg1 || {}
  } else {
    writeTo = process.stderr
    options = arg1 || arg2 || {}
  }

  this._status = {
    spun: 0,
    section: '',
    subsection: ''
  }
  this._paused = false // are we paused for back pressure?
  this._disabled = true // are all progress bar updates disabled?
  this._showing = false // do we WANT the progress bar on screen
  this._onScreen = false // IS the progress bar on screen
  this._needsRedraw = false // should we print something at next tick?
  this._hideCursor = options.hideCursor == null ? true : options.hideCursor
  this._fixedFramerate = options.fixedFramerate == null
    ? !(/^v0\.8\./.test(process.version))
    : options.fixedFramerate
  this._lastUpdateAt = null
  this._updateInterval = options.updateInterval == null ? 50 : options.updateInterval

  this._themes = options.themes || defaultThemes
  this._theme = options.theme
  var theme = this._computeTheme(options.theme)
  var template = options.template || [
    {type: 'progressbar', length: 20},
    {type: 'activityIndicator', kerning: 1, length: 1},
    {type: 'section', kerning: 1, default: ''},
    {type: 'subsection', kerning: 1, default: ''}
  ]
  this.setWriteTo(writeTo, options.tty)
  var PlumbingClass = options.Plumbing || Plumbing
  this._gauge = new PlumbingClass(theme, template, this.getWidth())

  this._$$doRedraw = callWith(this, this._doRedraw)
  this._$$handleSizeChange = callWith(this, this._handleSizeChange)

  this._cleanupOnExit = options.cleanupOnExit == null || options.cleanupOnExit
  this._removeOnExit = null

  if (options.enabled || (options.enabled == null && this._tty && this._tty.isTTY)) {
    this.enable()
  } else {
    this.disable()
  }
}
Gauge.prototype = {}

Gauge.prototype.isEnabled = function () {
  return !this._disabled
}

Gauge.prototype.setTemplate = function (template) {
  this._gauge.setTemplate(template)
  if (this._showing) this._requestRedraw()
}

Gauge.prototype._computeTheme = function (theme) {
  if (!theme) theme = {}
  if (typeof theme === 'string') {
    theme = this._themes.getTheme(theme)
  } else if (theme && (Object.keys(theme).length === 0 || theme.hasUnicode != null || theme.hasColor != null)) {
    var useUnicode = theme.hasUnicode == null ? hasUnicode() : theme.hasUnicode
    var useColor = theme.hasColor == null ? hasColor : theme.hasColor
    theme = this._themes.getDefault({hasUnicode: useUnicode, hasColor: useColor, platform: theme.platform})
  }
  return theme
}

Gauge.prototype.setThemeset = function (themes) {
  this._themes = themes
  this.setTheme(this._theme)
}

Gauge.prototype.setTheme = function (theme) {
  this._gauge.setTheme(this._computeTheme(theme))
  if (this._showing) this._requestRedraw()
  this._theme = theme
}

Gauge.prototype._requestRedraw = function () {
  this._needsRedraw = true
  if (!this._fixedFramerate) this._doRedraw()
}

Gauge.prototype.getWidth = function () {
  return ((this._tty && this._tty.columns) || 80) - 1
}

Gauge.prototype.setWriteTo = function (writeTo, tty) {
  var enabled = !this._disabled
  if (enabled) this.disable()
  this._writeTo = writeTo
  this._tty = tty ||
    (writeTo === process.stderr && process.stdout.isTTY && process.stdout) ||
    (writeTo.isTTY && writeTo) ||
    this._tty
  if (this._gauge) this._gauge.setWidth(this.getWidth())
  if (enabled) this.enable()
}

Gauge.prototype.enable = function () {
  if (!this._disabled) return
  this._disabled = false
  if (this._tty) this._enableEvents()
  if (this._showing) this.show()
}

Gauge.prototype.disable = function () {
  if (this._disabled) return
  if (this._showing) {
    this._lastUpdateAt = null
    this._showing = false
    this._doRedraw()
    this._showing = true
  }
  this._disabled = true
  if (this._tty) this._disableEvents()
}

Gauge.prototype._enableEvents = function () {
  if (this._cleanupOnExit) {
    this._removeOnExit = onExit(callWith(this, this.disable))
  }
  this._tty.on('resize', this._$$handleSizeChange)
  if (this._fixedFramerate) {
    this.redrawTracker = setInterval(this._$$doRedraw, this._updateInterval)
    if (this.redrawTracker.unref) this.redrawTracker.unref()
  }
}

Gauge.prototype._disableEvents = function () {
  this._tty.removeListener('resize', this._$$handleSizeChange)
  if (this._fixedFramerate) clearInterval(this.redrawTracker)
  if (this._removeOnExit) this._removeOnExit()
}

Gauge.prototype.hide = function (cb) {
  if (this._disabled) return cb && process.nextTick(cb)
  if (!this._showing) return cb && process.nextTick(cb)
  this._showing = false
  this._doRedraw()
  cb && setImmediate(cb)
}

Gauge.prototype.show = function (section, completed) {
  this._showing = true
  if (typeof section === 'string') {
    this._status.section = section
  } else if (typeof section === 'object') {
    var sectionKeys = Object.keys(section)
    for (var ii = 0; ii < sectionKeys.length; ++ii) {
      var key = sectionKeys[ii]
      this._status[key] = section[key]
    }
  }
  if (completed != null) this._status.completed = completed
  if (this._disabled) return
  this._requestRedraw()
}

Gauge.prototype.pulse = function (subsection) {
  this._status.subsection = subsection || ''
  this._status.spun ++
  if (this._disabled) return
  if (!this._showing) return
  this._requestRedraw()
}

Gauge.prototype._handleSizeChange = function () {
  this._gauge.setWidth(this._tty.columns - 1)
  this._requestRedraw()
}

Gauge.prototype._doRedraw = function () {
  if (this._disabled || this._paused) return
  if (!this._fixedFramerate) {
    var now = Date.now()
    if (this._lastUpdateAt && now - this._lastUpdateAt < this._updateInterval) return
    this._lastUpdateAt = now
  }
  if (!this._showing && this._onScreen) {
    this._onScreen = false
    var result = this._gauge.hide()
    if (this._hideCursor) {
      result += this._gauge.showCursor()
    }
    return this._writeTo.write(result)
  }
  if (!this._showing && !this._onScreen) return
  if (this._showing && !this._onScreen) {
    this._onScreen = true
    this._needsRedraw = true
    if (this._hideCursor) {
      this._writeTo.write(this._gauge.hideCursor())
    }
  }
  if (!this._needsRedraw) return
  if (!this._writeTo.write(this._gauge.show(this._status))) {
    this._paused = true
    this._writeTo.on('drain', callWith(this, function () {
      this._paused = false
      this._doRedraw()
    }))
  }
}


/***/ }),

/***/ 84441:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var numberIsNan = __webpack_require__(61516);

module.exports = function (x) {
	if (numberIsNan(x)) {
		return false;
	}

	// https://github.com/nodejs/io.js/blob/cff7300a578be1b10001f2d967aaedc88aee6402/lib/readline.js#L1369

	// code points are derived from:
	// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
	if (x >= 0x1100 && (
		x <= 0x115f ||  // Hangul Jamo
		0x2329 === x || // LEFT-POINTING ANGLE BRACKET
		0x232a === x || // RIGHT-POINTING ANGLE BRACKET
		// CJK Radicals Supplement .. Enclosed CJK Letters and Months
		(0x2e80 <= x && x <= 0x3247 && x !== 0x303f) ||
		// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
		0x3250 <= x && x <= 0x4dbf ||
		// CJK Unified Ideographs .. Yi Radicals
		0x4e00 <= x && x <= 0xa4c6 ||
		// Hangul Jamo Extended-A
		0xa960 <= x && x <= 0xa97c ||
		// Hangul Syllables
		0xac00 <= x && x <= 0xd7a3 ||
		// CJK Compatibility Ideographs
		0xf900 <= x && x <= 0xfaff ||
		// Vertical Forms
		0xfe10 <= x && x <= 0xfe19 ||
		// CJK Compatibility Forms .. Small Form Variants
		0xfe30 <= x && x <= 0xfe6b ||
		// Halfwidth and Fullwidth Forms
		0xff01 <= x && x <= 0xff60 ||
		0xffe0 <= x && x <= 0xffe6 ||
		// Kana Supplement
		0x1b000 <= x && x <= 0x1b001 ||
		// Enclosed Ideographic Supplement
		0x1f200 <= x && x <= 0x1f251 ||
		// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
		0x20000 <= x && x <= 0x3fffd)) {
		return true;
	}

	return false;
}


/***/ }),

/***/ 62909:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var stripAnsi = __webpack_require__(3996);
var codePointAt = __webpack_require__(13353);
var isFullwidthCodePoint = __webpack_require__(84441);

// https://github.com/nodejs/io.js/blob/cff7300a578be1b10001f2d967aaedc88aee6402/lib/readline.js#L1345
module.exports = function (str) {
	if (typeof str !== 'string' || str.length === 0) {
		return 0;
	}

	var width = 0;

	str = stripAnsi(str);

	for (var i = 0; i < str.length; i++) {
		var code = codePointAt(str, i);

		// ignore control characters
		if (code <= 0x1f || (code >= 0x7f && code <= 0x9f)) {
			continue;
		}

		// surrogates
		if (code >= 0x10000) {
			i++;
		}

		if (isFullwidthCodePoint(code)) {
			width += 2;
		} else {
			width++;
		}
	}

	return width;
};


/***/ }),

/***/ 3996:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ansiRegex = __webpack_require__(36403)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),

/***/ 64367:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var stringWidth = __webpack_require__(20074)

exports.center = alignCenter
exports.left = alignLeft
exports.right = alignRight

// lodash's way of generating pad characters.

function createPadding (width) {
  var result = ''
  var string = ' '
  var n = width
  do {
    if (n % 2) {
      result += string;
    }
    n = Math.floor(n / 2);
    string += string;
  } while (n);

  return result;
}

function alignLeft (str, width) {
  var trimmed = str.trimRight()
  if (trimmed.length === 0 && str.length >= width) return str
  var padding = ''
  var strWidth = stringWidth(trimmed)

  if (strWidth < width) {
    padding = createPadding(width - strWidth)
  }

  return trimmed + padding
}

function alignRight (str, width) {
  var trimmed = str.trimLeft()
  if (trimmed.length === 0 && str.length >= width) return str
  var padding = ''
  var strWidth = stringWidth(trimmed)

  if (strWidth < width) {
    padding = createPadding(width - strWidth)
  }

  return padding + trimmed
}

function alignCenter (str, width) {
  var trimmed = str.trim()
  if (trimmed.length === 0 && str.length >= width) return str
  var padLeft = ''
  var padRight = ''
  var strWidth = stringWidth(trimmed)

  if (strWidth < width) {
    var padLeftBy = parseInt((width - strWidth) / 2, 10) 
    padLeft = createPadding(padLeftBy)
    padRight = createPadding(width - (strWidth + padLeftBy))
  }

  return padLeft + trimmed + padRight
}


/***/ }),

/***/ 32066:
/***/ ((module) => {

"use strict";

/* eslint-disable yoda */
module.exports = x => {
	if (Number.isNaN(x)) {
		return false;
	}

	// code points are derived from:
	// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
	if (
		x >= 0x1100 && (
			x <= 0x115f ||  // Hangul Jamo
			x === 0x2329 || // LEFT-POINTING ANGLE BRACKET
			x === 0x232a || // RIGHT-POINTING ANGLE BRACKET
			// CJK Radicals Supplement .. Enclosed CJK Letters and Months
			(0x2e80 <= x && x <= 0x3247 && x !== 0x303f) ||
			// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
			(0x3250 <= x && x <= 0x4dbf) ||
			// CJK Unified Ideographs .. Yi Radicals
			(0x4e00 <= x && x <= 0xa4c6) ||
			// Hangul Jamo Extended-A
			(0xa960 <= x && x <= 0xa97c) ||
			// Hangul Syllables
			(0xac00 <= x && x <= 0xd7a3) ||
			// CJK Compatibility Ideographs
			(0xf900 <= x && x <= 0xfaff) ||
			// Vertical Forms
			(0xfe10 <= x && x <= 0xfe19) ||
			// CJK Compatibility Forms .. Small Form Variants
			(0xfe30 <= x && x <= 0xfe6b) ||
			// Halfwidth and Fullwidth Forms
			(0xff01 <= x && x <= 0xff60) ||
			(0xffe0 <= x && x <= 0xffe6) ||
			// Kana Supplement
			(0x1b000 <= x && x <= 0x1b001) ||
			// Enclosed Ideographic Supplement
			(0x1f200 <= x && x <= 0x1f251) ||
			// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
			(0x20000 <= x && x <= 0x3fffd)
		)
	) {
		return true;
	}

	return false;
};


/***/ }),

/***/ 20074:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stripAnsi = __webpack_require__(81710);
const isFullwidthCodePoint = __webpack_require__(32066);

module.exports = str => {
	if (typeof str !== 'string' || str.length === 0) {
		return 0;
	}

	str = stripAnsi(str);

	let width = 0;

	for (let i = 0; i < str.length; i++) {
		const code = str.codePointAt(i);

		// Ignore control characters
		if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
			continue;
		}

		// Ignore combining characters
		if (code >= 0x300 && code <= 0x36F) {
			continue;
		}

		// Surrogates
		if (code > 0xFFFF) {
			i++;
		}

		width += isFullwidthCodePoint(code) ? 2 : 1;
	}

	return width;
};


/***/ }),

/***/ 81710:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ansiRegex = __webpack_require__(36403);

module.exports = input => typeof input === 'string' ? input.replace(ansiRegex(), '') : input;


/***/ }),

/***/ 17852:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var consoleControl = __webpack_require__(64034)
var renderTemplate = __webpack_require__(23595)
var validate = __webpack_require__(83666)

var Plumbing = module.exports = function (theme, template, width) {
  if (!width) width = 80
  validate('OAN', [theme, template, width])
  this.showing = false
  this.theme = theme
  this.width = width
  this.template = template
}
Plumbing.prototype = {}

Plumbing.prototype.setTheme = function (theme) {
  validate('O', [theme])
  this.theme = theme
}

Plumbing.prototype.setTemplate = function (template) {
  validate('A', [template])
  this.template = template
}

Plumbing.prototype.setWidth = function (width) {
  validate('N', [width])
  this.width = width
}

Plumbing.prototype.hide = function () {
  return consoleControl.gotoSOL() + consoleControl.eraseLine()
}

Plumbing.prototype.hideCursor = consoleControl.hideCursor

Plumbing.prototype.showCursor = consoleControl.showCursor

Plumbing.prototype.show = function (status) {
  var values = Object.create(this.theme)
  for (var key in status) {
    values[key] = status[key]
  }

  return renderTemplate(this.width, this.template, values).trim() +
         consoleControl.color('reset') +
         consoleControl.eraseLine() + consoleControl.gotoSOL()
}


/***/ }),

/***/ 22156:
/***/ ((module) => {

"use strict";

// this exists so we can replace it during testing
module.exports = process


/***/ }),

/***/ 8936:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var validate = __webpack_require__(83666)
var renderTemplate = __webpack_require__(23595)
var wideTruncate = __webpack_require__(98566)
var stringWidth = __webpack_require__(62909)

module.exports = function (theme, width, completed) {
  validate('ONN', [theme, width, completed])
  if (completed < 0) completed = 0
  if (completed > 1) completed = 1
  if (width <= 0) return ''
  var sofar = Math.round(width * completed)
  var rest = width - sofar
  var template = [
    {type: 'complete', value: repeat(theme.complete, sofar), length: sofar},
    {type: 'remaining', value: repeat(theme.remaining, rest), length: rest}
  ]
  return renderTemplate(width, template, theme)
}

// lodash's way of repeating
function repeat (string, width) {
  var result = ''
  var n = width
  do {
    if (n % 2) {
      result += string
    }
    n = Math.floor(n / 2)
    /*eslint no-self-assign: 0*/
    string += string
  } while (n && stringWidth(result) < width)

  return wideTruncate(result, width)
}


/***/ }),

/***/ 23595:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var align = __webpack_require__(64367)
var validate = __webpack_require__(83666)
var objectAssign = __webpack_require__(4439)
var wideTruncate = __webpack_require__(98566)
var error = __webpack_require__(15591)
var TemplateItem = __webpack_require__(65151)

function renderValueWithValues (values) {
  return function (item) {
    return renderValue(item, values)
  }
}

var renderTemplate = module.exports = function (width, template, values) {
  var items = prepareItems(width, template, values)
  var rendered = items.map(renderValueWithValues(values)).join('')
  return align.left(wideTruncate(rendered, width), width)
}

function preType (item) {
  var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1)
  return 'pre' + cappedTypeName
}

function postType (item) {
  var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1)
  return 'post' + cappedTypeName
}

function hasPreOrPost (item, values) {
  if (!item.type) return
  return values[preType(item)] || values[postType(item)]
}

function generatePreAndPost (baseItem, parentValues) {
  var item = objectAssign({}, baseItem)
  var values = Object.create(parentValues)
  var template = []
  var pre = preType(item)
  var post = postType(item)
  if (values[pre]) {
    template.push({value: values[pre]})
    values[pre] = null
  }
  item.minLength = null
  item.length = null
  item.maxLength = null
  template.push(item)
  values[item.type] = values[item.type]
  if (values[post]) {
    template.push({value: values[post]})
    values[post] = null
  }
  return function ($1, $2, length) {
    return renderTemplate(length, template, values)
  }
}

function prepareItems (width, template, values) {
  function cloneAndObjectify (item, index, arr) {
    var cloned = new TemplateItem(item, width)
    var type = cloned.type
    if (cloned.value == null) {
      if (!(type in values)) {
        if (cloned.default == null) {
          throw new error.MissingTemplateValue(cloned, values)
        } else {
          cloned.value = cloned.default
        }
      } else {
        cloned.value = values[type]
      }
    }
    if (cloned.value == null || cloned.value === '') return null
    cloned.index = index
    cloned.first = index === 0
    cloned.last = index === arr.length - 1
    if (hasPreOrPost(cloned, values)) cloned.value = generatePreAndPost(cloned, values)
    return cloned
  }

  var output = template.map(cloneAndObjectify).filter(function (item) { return item != null })

  var outputLength = 0
  var remainingSpace = width
  var variableCount = output.length

  function consumeSpace (length) {
    if (length > remainingSpace) length = remainingSpace
    outputLength += length
    remainingSpace -= length
  }

  function finishSizing (item, length) {
    if (item.finished) throw new error.Internal('Tried to finish template item that was already finished')
    if (length === Infinity) throw new error.Internal('Length of template item cannot be infinity')
    if (length != null) item.length = length
    item.minLength = null
    item.maxLength = null
    --variableCount
    item.finished = true
    if (item.length == null) item.length = item.getBaseLength()
    if (item.length == null) throw new error.Internal('Finished template items must have a length')
    consumeSpace(item.getLength())
  }

  output.forEach(function (item) {
    if (!item.kerning) return
    var prevPadRight = item.first ? 0 : output[item.index - 1].padRight
    if (!item.first && prevPadRight < item.kerning) item.padLeft = item.kerning - prevPadRight
    if (!item.last) item.padRight = item.kerning
  })

  // Finish any that have a fixed (literal or intuited) length
  output.forEach(function (item) {
    if (item.getBaseLength() == null) return
    finishSizing(item)
  })

  var resized = 0
  var resizing
  var hunkSize
  do {
    resizing = false
    hunkSize = Math.round(remainingSpace / variableCount)
    output.forEach(function (item) {
      if (item.finished) return
      if (!item.maxLength) return
      if (item.getMaxLength() < hunkSize) {
        finishSizing(item, item.maxLength)
        resizing = true
      }
    })
  } while (resizing && resized++ < output.length)
  if (resizing) throw new error.Internal('Resize loop iterated too many times while determining maxLength')

  resized = 0
  do {
    resizing = false
    hunkSize = Math.round(remainingSpace / variableCount)
    output.forEach(function (item) {
      if (item.finished) return
      if (!item.minLength) return
      if (item.getMinLength() >= hunkSize) {
        finishSizing(item, item.minLength)
        resizing = true
      }
    })
  } while (resizing && resized++ < output.length)
  if (resizing) throw new error.Internal('Resize loop iterated too many times while determining minLength')

  hunkSize = Math.round(remainingSpace / variableCount)
  output.forEach(function (item) {
    if (item.finished) return
    finishSizing(item, hunkSize)
  })

  return output
}

function renderFunction (item, values, length) {
  validate('OON', arguments)
  if (item.type) {
    return item.value(values, values[item.type + 'Theme'] || {}, length)
  } else {
    return item.value(values, {}, length)
  }
}

function renderValue (item, values) {
  var length = item.getBaseLength()
  var value = typeof item.value === 'function' ? renderFunction(item, values, length) : item.value
  if (value == null || value === '') return ''
  var alignWith = align[item.align] || align.left
  var leftPadding = item.padLeft ? align.left('', item.padLeft) : ''
  var rightPadding = item.padRight ? align.right('', item.padRight) : ''
  var truncated = wideTruncate(String(value), length)
  var aligned = alignWith(truncated, length)
  return leftPadding + aligned + rightPadding
}


/***/ }),

/***/ 48761:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var process = __webpack_require__(22156)
try {
  module.exports = setImmediate
} catch (ex) {
  module.exports = process.nextTick
}


/***/ }),

/***/ 29165:
/***/ ((module) => {

"use strict";

// this exists so we can replace it during testing
module.exports = setInterval


/***/ }),

/***/ 74365:
/***/ ((module) => {

"use strict";


module.exports = function spin (spinstr, spun) {
  return spinstr[spun % spinstr.length]
}


/***/ }),

/***/ 65151:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var stringWidth = __webpack_require__(62909)

module.exports = TemplateItem

function isPercent (num) {
  if (typeof num !== 'string') return false
  return num.slice(-1) === '%'
}

function percent (num) {
  return Number(num.slice(0, -1)) / 100
}

function TemplateItem (values, outputLength) {
  this.overallOutputLength = outputLength
  this.finished = false
  this.type = null
  this.value = null
  this.length = null
  this.maxLength = null
  this.minLength = null
  this.kerning = null
  this.align = 'left'
  this.padLeft = 0
  this.padRight = 0
  this.index = null
  this.first = null
  this.last = null
  if (typeof values === 'string') {
    this.value = values
  } else {
    for (var prop in values) this[prop] = values[prop]
  }
  // Realize percents
  if (isPercent(this.length)) {
    this.length = Math.round(this.overallOutputLength * percent(this.length))
  }
  if (isPercent(this.minLength)) {
    this.minLength = Math.round(this.overallOutputLength * percent(this.minLength))
  }
  if (isPercent(this.maxLength)) {
    this.maxLength = Math.round(this.overallOutputLength * percent(this.maxLength))
  }
  return this
}

TemplateItem.prototype = {}

TemplateItem.prototype.getBaseLength = function () {
  var length = this.length
  if (length == null && typeof this.value === 'string' && this.maxLength == null && this.minLength == null) {
    length = stringWidth(this.value)
  }
  return length
}

TemplateItem.prototype.getLength = function () {
  var length = this.getBaseLength()
  if (length == null) return null
  return length + this.padLeft + this.padRight
}

TemplateItem.prototype.getMaxLength = function () {
  if (this.maxLength == null) return null
  return this.maxLength + this.padLeft + this.padRight
}

TemplateItem.prototype.getMinLength = function () {
  if (this.minLength == null) return null
  return this.minLength + this.padLeft + this.padRight
}



/***/ }),

/***/ 67578:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var objectAssign = __webpack_require__(4439)

module.exports = function () {
  return ThemeSetProto.newThemeSet()
}

var ThemeSetProto = {}

ThemeSetProto.baseTheme = __webpack_require__(74608)

ThemeSetProto.newTheme = function (parent, theme) {
  if (!theme) {
    theme = parent
    parent = this.baseTheme
  }
  return objectAssign({}, parent, theme)
}

ThemeSetProto.getThemeNames = function () {
  return Object.keys(this.themes)
}

ThemeSetProto.addTheme = function (name, parent, theme) {
  this.themes[name] = this.newTheme(parent, theme)
}

ThemeSetProto.addToAllThemes = function (theme) {
  var themes = this.themes
  Object.keys(themes).forEach(function (name) {
    objectAssign(themes[name], theme)
  })
  objectAssign(this.baseTheme, theme)
}

ThemeSetProto.getTheme = function (name) {
  if (!this.themes[name]) throw this.newMissingThemeError(name)
  return this.themes[name]
}

ThemeSetProto.setDefault = function (opts, name) {
  if (name == null) {
    name = opts
    opts = {}
  }
  var platform = opts.platform == null ? 'fallback' : opts.platform
  var hasUnicode = !!opts.hasUnicode
  var hasColor = !!opts.hasColor
  if (!this.defaults[platform]) this.defaults[platform] = {true: {}, false: {}}
  this.defaults[platform][hasUnicode][hasColor] = name
}

ThemeSetProto.getDefault = function (opts) {
  if (!opts) opts = {}
  var platformName = opts.platform || process.platform
  var platform = this.defaults[platformName] || this.defaults.fallback
  var hasUnicode = !!opts.hasUnicode
  var hasColor = !!opts.hasColor
  if (!platform) throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor)
  if (!platform[hasUnicode][hasColor]) {
    if (hasUnicode && hasColor && platform[!hasUnicode][hasColor]) {
      hasUnicode = false
    } else if (hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
      hasColor = false
    } else if (hasUnicode && hasColor && platform[!hasUnicode][!hasColor]) {
      hasUnicode = false
      hasColor = false
    } else if (hasUnicode && !hasColor && platform[!hasUnicode][hasColor]) {
      hasUnicode = false
    } else if (!hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
      hasColor = false
    } else if (platform === this.defaults.fallback) {
      throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor)
    }
  }
  if (platform[hasUnicode][hasColor]) {
    return this.getTheme(platform[hasUnicode][hasColor])
  } else {
    return this.getDefault(objectAssign({}, opts, {platform: 'fallback'}))
  }
}

ThemeSetProto.newMissingThemeError = function newMissingThemeError (name) {
  var err = new Error('Could not find a gauge theme named "' + name + '"')
  Error.captureStackTrace.call(err, newMissingThemeError)
  err.theme = name
  err.code = 'EMISSINGTHEME'
  return err
}

ThemeSetProto.newMissingDefaultThemeError = function newMissingDefaultThemeError (platformName, hasUnicode, hasColor) {
  var err = new Error(
    'Could not find a gauge theme for your platform/unicode/color use combo:\n' +
    '    platform = ' + platformName + '\n' +
    '    hasUnicode = ' + hasUnicode + '\n' +
    '    hasColor = ' + hasColor)
  Error.captureStackTrace.call(err, newMissingDefaultThemeError)
  err.platform = platformName
  err.hasUnicode = hasUnicode
  err.hasColor = hasColor
  err.code = 'EMISSINGTHEME'
  return err
}

ThemeSetProto.newThemeSet = function () {
  var themeset = function (opts) {
    return themeset.getDefault(opts)
  }
  return objectAssign(themeset, ThemeSetProto, {
    themes: objectAssign({}, this.themes),
    baseTheme: objectAssign({}, this.baseTheme),
    defaults: JSON.parse(JSON.stringify(this.defaults || {}))
  })
}



/***/ }),

/***/ 62834:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var consoleControl = __webpack_require__(64034)
var ThemeSet = __webpack_require__(67578)

var themes = module.exports = new ThemeSet()

themes.addTheme('ASCII', {
  preProgressbar: '[',
  postProgressbar: ']',
  progressbarTheme: {
    complete: '#',
    remaining: '.'
  },
  activityIndicatorTheme: '-\\|/',
  preSubsection: '>'
})

themes.addTheme('colorASCII', themes.getTheme('ASCII'), {
  progressbarTheme: {
    preComplete: consoleControl.color('inverse'),
    complete: ' ',
    postComplete: consoleControl.color('stopInverse'),
    preRemaining: consoleControl.color('brightBlack'),
    remaining: '.',
    postRemaining: consoleControl.color('reset')
  }
})

themes.addTheme('brailleSpinner', {
  preProgressbar: '',
  postProgressbar: '',
  progressbarTheme: {
    complete: '',
    remaining: ''
  },
  activityIndicatorTheme: '',
  preSubsection: '>'
})

themes.addTheme('colorBrailleSpinner', themes.getTheme('brailleSpinner'), {
  progressbarTheme: {
    preComplete: consoleControl.color('inverse'),
    complete: ' ',
    postComplete: consoleControl.color('stopInverse'),
    preRemaining: consoleControl.color('brightBlack'),
    remaining: '',
    postRemaining: consoleControl.color('reset')
  }
})

themes.setDefault({}, 'ASCII')
themes.setDefault({hasColor: true}, 'colorASCII')
themes.setDefault({platform: 'darwin', hasUnicode: true}, 'brailleSpinner')
themes.setDefault({platform: 'darwin', hasUnicode: true, hasColor: true}, 'colorBrailleSpinner')


/***/ }),

/***/ 98566:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var stringWidth = __webpack_require__(62909)
var stripAnsi = __webpack_require__(3996)

module.exports = wideTruncate

function wideTruncate (str, target) {
  if (stringWidth(str) === 0) return str
  if (target <= 0) return ''
  if (stringWidth(str) <= target) return str

  // We compute the number of bytes of ansi sequences here and add
  // that to our initial truncation to ensure that we don't slice one
  // that we want to keep in half.
  var noAnsi = stripAnsi(str)
  var ansiSize = str.length + noAnsi.length
  var truncated = str.slice(0, target + ansiSize)

  // we have to shrink the result to account for our ansi sequence buffer
  // (if an ansi sequence was truncated) and double width characters.
  while (stringWidth(truncated) > target) {
    truncated = truncated.slice(0, -1)
  }
  return truncated
}


/***/ }),

/***/ 1384:
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ 24339:
/***/ ((module) => {

"use strict";

const hasOwnProp = Object.prototype.hasOwnProperty;

module.exports = (object, property) => hasOwnProp.call(object, property);


/***/ }),

/***/ 29253:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var os = __webpack_require__(22037)

var hasUnicode = module.exports = function () {
  // Recent Win32 platforms (>XP) CAN support unicode in the console but
  // don't have to, and in non-english locales often use traditional local
  // code pages. There's no way, short of windows system calls or execing
  // the chcp command line program to figure this out. As such, we default
  // this to false and encourage your users to override it via config if
  // appropriate.
  if (os.type() == "Windows_NT") { return false }

  var isUTF8 = /UTF-?8$/i
  var ctype = process.env.LC_ALL || process.env.LC_CTYPE || process.env.LANG
  return isUTF8.test(ctype)
}


/***/ }),

/***/ 20610:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ esm_i18next)
});

;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/objectSpread.js

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? Object(arguments[i]) : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(97656);
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js


function _possibleConstructorReturn(self, call) {
  if (call && (helpers_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/inherits.js

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
;// CONCATENATED MODULE: ../../node_modules/i18next/dist/esm/i18next.js











var consoleLogger = {
  type: 'logger',
  log: function log(args) {
    this.output('log', args);
  },
  warn: function warn(args) {
    this.output('warn', args);
  },
  error: function error(args) {
    this.output('error', args);
  },
  output: function output(type, args) {
    var _console;

    /* eslint no-console: 0 */
    if (console && console[type]) (_console = console)[type].apply(_console, _toConsumableArray(args));
  }
};

var Logger =
/*#__PURE__*/
function () {
  function Logger(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Logger);

    this.init(concreteLogger, options);
  }

  _createClass(Logger, [{
    key: "init",
    value: function init(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.prefix = options.prefix || 'i18next:';
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.forward(args, 'log', '', true);
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this.forward(args, 'warn', '', true);
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this.forward(args, 'error', '');
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug) return null;
      if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger(this.logger, _objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }, this.options));
    }
  }]);

  return Logger;
}();

var baseLogger = new Logger();

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    this.observers = {};
  }

  _createClass(EventEmitter, [{
    key: "on",
    value: function on(events, listener) {
      var _this = this;

      events.split(' ').forEach(function (event) {
        _this.observers[event] = _this.observers[event] || [];

        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event]) return;

      if (!listener) {
        delete this.observers[event];
        return;
      }

      this.observers[event] = this.observers[event].filter(function (l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function (observer) {
          observer.apply(void 0, args);
        });
      }

      if (this.observers['*']) {
        var _cloned = [].concat(this.observers['*']);

        _cloned.forEach(function (observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);

  return EventEmitter;
}();

// http://lea.verou.me/2016/12/resolve-promises-externally-with-this-one-weird-trick/
function defer() {
  var res;
  var rej;
  var promise = new Promise(function (resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null) return '';
  /* eslint prefer-template: 0 */

  return '' + object;
}
function copy(a, s, t) {
  a.forEach(function (m) {
    if (s[m]) t[m] = s[m];
  });
}

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
  }

  function canNotTraverseDeeper() {
    return !object || typeof object === 'string';
  }

  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty) object[key] = new Empty();
    object = object[key];
  }

  if (canNotTraverseDeeper()) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}

function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  obj[k] = newValue;
}
function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object),
      obj = _getLastOfPath2.obj,
      k = _getLastOfPath2.k;

  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);

  if (value !== undefined) {
    return value;
  } // Fallback to default values


  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  /* eslint no-restricted-syntax: 0 */
  for (var prop in source) {
    if (prop in target) {
      // If we reached a leaf string in target or source then replace with source or skip depending on the 'overwrite' switch
      if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
        if (overwrite) target[prop] = source[prop];
      } else {
        deepExtend(target[prop], source[prop], overwrite);
      }
    } else {
      target[prop] = source[prop];
    }
  }

  return target;
}
function regexEscape(str) {
  /* eslint no-useless-escape: 0 */
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
/* eslint-disable */

var _entityMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;'
};
/* eslint-enable */

function i18next_escape(data) {
  if (typeof data === 'string') {
    return data.replace(/[&<>"'\/]/g, function (s) {
      return _entityMap[s];
    });
  }

  return data;
}

var ResourceStore =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(ResourceStore, _EventEmitter);

  function ResourceStore(data) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ns: ['translation'],
      defaultNS: 'translation'
    };

    _classCallCheck(this, ResourceStore);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore).call(this));
    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

    _this.data = data || {};
    _this.options = options;

    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = '.';
    }

    return _this;
  }

  _createClass(ResourceStore, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index = this.options.ns.indexOf(ns);

      if (index > -1) {
        this.options.ns.splice(index, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
      var path = [lng, ns];
      if (key && typeof key !== 'string') path = path.concat(key);
      if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
      }

      return getPath(this.data, path);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === undefined) keySeparator = '.';
      var path = [lng, ns];
      if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
        value = ns;
        ns = path[1];
      }

      this.addNamespaces(ns);
      setPath(this.data, path, value);
      if (!options.silent) this.emit('added', lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        silent: false
      };

      /* eslint no-restricted-syntax: 0 */
      for (var m in resources) {
        if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
          silent: true
        });
      }

      if (!options.silent) this.emit('added', lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns];

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
        deep = resources;
        resources = ns;
        ns = path[1];
      }

      this.addNamespaces(ns);
      var pack = getPath(this.data, path) || {};

      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread({}, pack, resources);
      }

      setPath(this.data, path, pack);
      if (!options.silent) this.emit('added', lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }

      this.removeNamespaces(ns);
      this.emit('removed', lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== undefined;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns) ns = this.options.defaultNS; // COMPATIBILITY: remove extend in v2.1.0

      if (this.options.compatibilityAPI === 'v1') return _objectSpread({}, {}, this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);

  return ResourceStore;
}(EventEmitter);

var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;

    processors.forEach(function (processor) {
      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};

var checkedLoadedFor = {};

var Translator =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Translator, _EventEmitter);

  function Translator(services) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Translator);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator).call(this));
    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, _assertThisInitialized(_this));
    _this.options = options;

    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = '.';
    }

    _this.logger = baseLogger.create('translator');
    return _this;
  }

  _createClass(Translator, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng) this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        interpolation: {}
      };
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== undefined;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator || this.options.nsSeparator;
      if (nsSeparator === undefined) nsSeparator = ':';
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS;

      if (nsSeparator && key.indexOf(nsSeparator) > -1) {
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
        key = parts.join(keySeparator);
      }

      if (typeof namespaces === 'string') namespaces = [namespaces];
      return {
        key: key,
        namespaces: namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options) {
      var _this2 = this;

      if (_typeof(options) !== 'object' && this.options.overloadTranslationOptionHandler) {
        /* eslint prefer-rest-params: 0 */
        options = this.options.overloadTranslationOptionHandler(arguments);
      }

      if (!options) options = {}; // non valid keys handling

      if (keys === undefined || keys === null
      /* || keys === ''*/
      ) return '';
      if (!Array.isArray(keys)) keys = [String(keys)]; // separators

      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator; // get namespace(s)

      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
          key = _this$extractFromKey.key,
          namespaces = _this$extractFromKey.namespaces;

      var namespace = namespaces[namespaces.length - 1]; // return key on CIMode

      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;

      if (lng && lng.toLowerCase() === 'cimode') {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          return namespace + nsSeparator + key;
        }

        return key;
      } // resolve from store


      var resolved = this.resolve(keys, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
      var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays; // object

      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';

      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
        if (!options.returnObjects && !this.options.returnObjects) {
          this.logger.warn('accessing an object - but returnObjects options is not enabled!');
          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        } // if we got a separator we loop over children - else we just return object as is
        // as having it set to false means no hierarchy so no lookup for nested values


        if (keySeparator) {
          var resTypeIsArray = resType === '[object Array]';
          var copy$$1 = resTypeIsArray ? [] : {}; // apply child translation on a copy

          /* eslint no-restricted-syntax: 0 */

          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;

          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy$$1[m] = this.translate(deepKey, _objectSpread({}, options, {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy$$1[m] === deepKey) copy$$1[m] = res[m]; // if nothing found use orginal value as fallback
            }
          }

          res = copy$$1;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
        // array special treatment
        res = res.join(joinArrays);
        if (res) res = this.extendTranslation(res, keys, options);
      } else {
        // string, empty or null
        var usedDefault = false;
        var usedKey = false; // fallback value

        if (!this.isValidLookup(res) && options.defaultValue !== undefined) {
          usedDefault = true;

          if (options.count !== undefined) {
            var suffix = this.pluralResolver.getSuffix(lng, options.count);
            res = options["defaultValue".concat(suffix)];
          }

          if (!res) res = options.defaultValue;
        }

        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        } // save missing


        var updateMissing = options.defaultValue && options.defaultValue !== res && this.options.updateMissing;

        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? options.defaultValue : res);
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);

          if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === 'all') {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }

          var send = function send(l, k) {
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
            }

            _this2.emit('missingKey', l, namespace, k, res);
          };

          if (this.options.saveMissing) {
            var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';

            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function (l) {
                var plurals = _this2.pluralResolver.getPluralFormsOfKey(l, key);

                plurals.forEach(function (p) {
                  return send([l], p);
                });
              });
            } else {
              send(lngs, key);
            }
          }
        } // extend


        res = this.extendTranslation(res, keys, options, resolved); // append namespace if still key

        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key); // parseMissingKeyHandler

        if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
      } // return


      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved) {
      var _this3 = this;

      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved: resolved
        });
      } else if (!options.skipInterpolation) {
        // i18next.parsing
        if (options.interpolation) this.interpolator.init(_objectSpread({}, options, {
          interpolation: _objectSpread({}, this.options.interpolation, options.interpolation)
        })); // interpolate

        var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
        if (this.options.interpolation.defaultVariables) data = _objectSpread({}, this.options.interpolation.defaultVariables, data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options); // nesting

        if (options.nest !== false) res = this.interpolator.nest(res, function () {
          return _this3.translate.apply(_this3, arguments);
        }, options);
        if (options.interpolation) this.interpolator.reset();
      } // post process


      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

      if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread({
          i18nResolved: resolved
        }, options) : options, this);
      }

      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var found;
      var usedKey; // plain key

      var exactUsedKey; // key with context / plural

      var usedLng;
      var usedNS;
      if (typeof keys === 'string') keys = [keys]; // forEach possible key

      keys.forEach(function (k) {
        if (_this4.isValidLookup(found)) return;

        var extracted = _this4.extractFromKey(k, options);

        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
        var needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function (ns) {
          if (_this4.isValidLookup(found)) return;
          usedNS = ns;

          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;

            _this4.logger.warn("key \"".concat(usedKey, "\" for namespace \"").concat(usedNS, "\" for languages \"").concat(codes.join(', '), "\" won't get resolved as namespace was not yet loaded"), 'This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
          }

          codes.forEach(function (code) {
            if (_this4.isValidLookup(found)) return;
            usedLng = code;
            var finalKey = key;
            var finalKeys = [finalKey];

            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count); // fallback for plural if context not found

              if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix); // get key for context if needed

              if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options.context)); // get key for plural if needed

              if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
            } // iterate over finalKeys starting with most specific pluralkey (-> contextkey only) -> singularkey only


            var possibleKey;
            /* eslint no-cond-assign: 0 */

            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey: usedKey,
        exactUsedKey: exactUsedKey,
        usedLng: usedLng,
        usedNS: usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }]);

  return Translator;
}(EventEmitter);

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

var LanguageUtil =
/*#__PURE__*/
function () {
  function LanguageUtil(options) {
    _classCallCheck(this, LanguageUtil);

    this.options = options;
    this.whitelist = this.options.whitelist || false;
    this.logger = baseLogger.create('languageUtils');
  }

  _createClass(LanguageUtil, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf('-') < 0) return null;
      var p = code.split('-');
      if (p.length === 2) return null;
      p.pop();
      return this.formatLanguageCode(p.join('-'));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf('-') < 0) return code;
      var p = code.split('-');
      return this.formatLanguageCode(p[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      // http://www.iana.org/assignments/language-tags/language-tags.xhtml
      if (typeof code === 'string' && code.indexOf('-') > -1) {
        var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
        var p = code.split('-');

        if (this.options.lowerCaseLng) {
          p = p.map(function (part) {
            return part.toLowerCase();
          });
        } else if (p.length === 2) {
          p[0] = p[0].toLowerCase();
          p[1] = p[1].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        } else if (p.length === 3) {
          p[0] = p[0].toLowerCase(); // if lenght 2 guess it's a country

          if (p[1].length === 2) p[1] = p[1].toUpperCase();
          if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
          if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
        }

        return p.join('-');
      }

      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isWhitelisted",
    value: function isWhitelisted(code) {
      if (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist) {
        code = this.getLanguagePartFromCode(code);
      }

      return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code) > -1;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks) return [];
      if (typeof fallbacks === 'string') fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
      if (!code) return fallbacks["default"] || []; // asume we have an object defining fallbacks

      var found = fallbacks[code];
      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found) found = fallbacks[this.formatLanguageCode(code)];
      if (!found) found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this = this;

      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];

      var addCode = function addCode(c) {
        if (!c) return;

        if (_this.isWhitelisted(c)) {
          codes.push(c);
        } else {
          _this.logger.warn("rejecting non-whitelisted language code: ".concat(c));
        }
      };

      if (typeof code === 'string' && code.indexOf('-') > -1) {
        if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
        if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === 'string') {
        addCode(this.formatLanguageCode(code));
      }

      fallbackCodes.forEach(function (fc) {
        if (codes.indexOf(fc) < 0) addCode(_this.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);

  return LanguageUtil;
}();

/* eslint-disable */

var sets = [{
  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'ti', 'tr', 'uz', 'wa'],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ['ay', 'bo', 'cgg', 'fa', 'id', 'ja', 'jbo', 'ka', 'kk', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
  nr: [1],
  fc: 3
}, {
  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ['ar'],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ['cs', 'sk'],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ['csb', 'pl'],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ['cy'],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ['fr'],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ['ga'],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ['gd'],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ['is'],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ['jv'],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ['kw'],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ['lt'],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ['lv'],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ['mk'],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ['mnk'],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ['mt'],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ['or'],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ['ro'],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ['sl'],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ['he'],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _(n) {
    return Number(n != 1);
  },
  3: function _(n) {
    return 0;
  },
  4: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _(n) {
    return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _(n) {
    return Number(n >= 2);
  },
  10: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _(n) {
    return Number(n !== 0);
  },
  14: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _(n) {
    return Number(n == 1 || n % 10 == 1 ? 0 : 1);
  },
  18: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _(n) {
    return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _(n) {
    return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function _(n) {
    return Number(n === 1 ? 0 : n === 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};
/* eslint-enable */

function createRules() {
  var rules = {};
  sets.forEach(function (set) {
    set.lngs.forEach(function (l) {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}

var PluralResolver =
/*#__PURE__*/
function () {
  function PluralResolver(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PluralResolver);

    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create('pluralResolver');
    this.rules = createRules();
  }

  _createClass(PluralResolver, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var rule = this.getRule(code);
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var _this = this;

      var ret = [];
      var rule = this.getRule(code);
      if (!rule) return ret;
      rule.numbers.forEach(function (n) {
        var suffix = _this.getSuffix(code, n);

        ret.push("".concat(key).concat(suffix));
      });
      return ret;
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var _this2 = this;

      var rule = this.getRule(code);

      if (rule) {
        // if (rule.numbers.length === 1) return ''; // only singular
        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        var suffix = rule.numbers[idx]; // special treatment for lngs only having singular and plural

        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          if (suffix === 2) {
            suffix = 'plural';
          } else if (suffix === 1) {
            suffix = '';
          }
        }

        var returnSuffix = function returnSuffix() {
          return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
        }; // COMPATIBILITY JSON
        // v1


        if (this.options.compatibilityJSON === 'v1') {
          if (suffix === 1) return '';
          if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
          return returnSuffix();
        } else if (
        /* v2 */
        this.options.compatibilityJSON === 'v2') {
          return returnSuffix();
        } else if (
        /* v3 - gettext index */
        this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          return returnSuffix();
        }

        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
      }

      this.logger.warn("no plural rule found for: ".concat(code));
      return '';
    }
  }]);

  return PluralResolver;
}();

var Interpolator =
/*#__PURE__*/
function () {
  function Interpolator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Interpolator);

    this.logger = baseLogger.create('interpolator');
    this.options = options;

    this.format = options.interpolation && options.interpolation.format || function (value) {
      return value;
    };

    this.init(options);
  }
  /* eslint no-param-reassign: 0 */


  _createClass(Interpolator, [{
    key: "init",
    value: function init() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!options.interpolation) options.interpolation = {
        escapeValue: true
      };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== undefined ? iOpts.escape : i18next_escape;
      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000; // the regexp

      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options) this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      // the regexp
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, 'g');
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options) {
      var _this = this;

      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

      function regexSafe(val) {
        return val.replace(/\$/g, '$$$$');
      }

      var handleFormat = function handleFormat(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          return getPathWithDefaults(data, defaultData, key);
        }

        var p = key.split(_this.formatSeparator);
        var k = p.shift().trim();
        var f = p.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng);
      };

      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      replaces = 0; // unescape if has unescapePrefix/Suffix

      /* eslint no-cond-assign: 0 */

      while (match = this.regexpUnescape.exec(str)) {
        value = handleFormat(match[1].trim());

        if (value === undefined) {
          if (typeof missingInterpolationHandler === 'function') {
            var temp = missingInterpolationHandler(str, match, options);
            value = typeof temp === 'string' ? temp : '';
          } else {
            this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
            value = '';
          }
        } else if (typeof value !== 'string' && !this.useRawValueToEscape) {
          value = makeString(value);
        }

        str = str.replace(match[0], regexSafe(value));
        this.regexpUnescape.lastIndex = 0;
        replaces++;

        if (replaces >= this.maxReplaces) {
          break;
        }
      }

      replaces = 0; // regular escape on demand

      while (match = this.regexp.exec(str)) {
        value = handleFormat(match[1].trim());

        if (value === undefined) {
          if (typeof missingInterpolationHandler === 'function') {
            var _temp = missingInterpolationHandler(str, match, options);

            value = typeof _temp === 'string' ? _temp : '';
          } else {
            this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
            value = '';
          }
        } else if (typeof value !== 'string' && !this.useRawValueToEscape) {
          value = makeString(value);
        }

        value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
        replaces++;

        if (replaces >= this.maxReplaces) {
          break;
        }
      }

      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var match;
      var value;

      var clonedOptions = _objectSpread({}, options);

      clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup

      delete clonedOptions.defaultValue; // assert we do not get a endless loop on interpolating defaultValue again and again
      // if value is something like "myKey": "lorem $(anotherKey, { "count": {{aValueInOptions}} })"

      function handleHasOptions(key, inheritedOptions) {
        if (key.indexOf(',') < 0) return key;
        var p = key.split(',');
        key = p.shift();
        var optionsString = p.join(',');
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');

        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
        } catch (e) {
          this.logger.error("failed parsing options string in nesting for key ".concat(key), e);
        } // assert we do not get a endless loop on interpolating defaultValue again and again


        delete clonedOptions.defaultValue;
        return key;
      } // regular escape on demand


      while (match = this.nestingRegexp.exec(str)) {
        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions); // is only the nesting key (key1 = '$(key2)') return the value without stringify

        if (value && match[0] === str && typeof value !== 'string') return value; // no string to include or empty

        if (typeof value !== 'string') value = makeString(value);

        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = '';
        } // Nested keys should not be escaped by default #854
        // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);


        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }

      return str;
    }
  }]);

  return Interpolator;
}();

function remove(arr, what) {
  var found = arr.indexOf(what);

  while (found !== -1) {
    arr.splice(found, 1);
    found = arr.indexOf(what);
  }
}

var Connector =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Connector, _EventEmitter);

  function Connector(backend, store, services) {
    var _this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Connector);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector).call(this));
    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create('backendConnector');
    _this.state = {};
    _this.queue = [];

    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }

    return _this;
  }

  _createClass(Connector, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this;

      // find what needs to be loaded
      var toLoad = [];
      var pending = [];
      var toLoadLanguages = [];
      var toLoadNamespaces = [];
      languages.forEach(function (lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function (ns) {
          var name = "".concat(lng, "|").concat(ns);

          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2; // loaded
          } else if (_this2.state[name] < 0) ; else if (_this2.state[name] === 1) {
            if (pending.indexOf(name) < 0) pending.push(name);
          } else {
            _this2.state[name] = 1; // pending

            hasAllNamespaces = false;
            if (pending.indexOf(name) < 0) pending.push(name);
            if (toLoad.indexOf(name) < 0) toLoad.push(name);
            if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
          }
        });
        if (!hasAllNamespaces) toLoadLanguages.push(lng);
      });

      if (toLoad.length || pending.length) {
        this.queue.push({
          pending: pending,
          loaded: {},
          errors: [],
          callback: callback
        });
      }

      return {
        toLoad: toLoad,
        pending: pending,
        toLoadLanguages: toLoadLanguages,
        toLoadNamespaces: toLoadNamespaces
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var _name$split = name.split('|'),
          _name$split2 = _slicedToArray(_name$split, 2),
          lng = _name$split2[0],
          ns = _name$split2[1];

      if (err) this.emit('failedLoading', lng, ns, err);

      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      } // set loaded


      this.state[name] = err ? -1 : 2; // consolidated loading done in this run - only emit once for a loaded namespace

      var loaded = {}; // callback if ready

      this.queue.forEach(function (q) {
        pushPath(q.loaded, [lng], ns);
        remove(q.pending, name);
        if (err) q.errors.push(err);

        if (q.pending.length === 0 && !q.done) {
          // only do once per loaded -> this.emit('loaded', q.loaded);
          Object.keys(q.loaded).forEach(function (l) {
            if (!loaded[l]) loaded[l] = [];

            if (q.loaded[l].length) {
              q.loaded[l].forEach(function (ns) {
                if (loaded[l].indexOf(ns) < 0) loaded[l].push(ns);
              });
            }
          });
          /* eslint no-param-reassign: 0 */

          q.done = true;

          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      }); // emit consolidated loaded event

      this.emit('loaded', loaded); // remove done load requests

      this.queue = this.queue.filter(function (q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read(lng, ns, fcName) {
      var _this3 = this;

      var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;
      var callback = arguments.length > 5 ? arguments[5] : undefined;
      if (!lng.length) return callback(null, {}); // noting to load

      return this.backend[fcName](lng, ns, function (err, data) {
        if (err && data
        /* = retryFlag */
        && tried < 5) {
          setTimeout(function () {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }

        callback(err, data);
      });
    }
    /* eslint consistent-return: 0 */

  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : undefined;

      if (!this.backend) {
        this.logger.warn('No backend was added via i18next.use. Will not load resources.');
        return callback && callback();
      }

      if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === 'string') namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);

      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length) callback(); // nothing to load and no pendings...callback now

        return null; // pendings will trigger callback
      }

      toLoad.toLoad.forEach(function (name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;

      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var _name$split3 = name.split('|'),
          _name$split4 = _slicedToArray(_name$split3, 2),
          lng = _name$split4[0],
          ns = _name$split4[1];

      this.read(lng, ns, 'read', null, null, function (err, data) {
        if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);

        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn("did not save key \"".concat(key, "\" for namespace \"").concat(namespace, "\" as the namespace was not yet loaded"), 'This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
        return;
      } // ignore non valid keys


      if (key === undefined || key === null || key === '') return;

      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null
        /* unused callback */
        , _objectSpread({}, options, {
          isUpdate: isUpdate
        }));
      } // write to store to avoid resending


      if (!languages || !languages[0]) return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);

  return Connector;
}(EventEmitter);

function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ['translation'],
    defaultNS: ['translation'],
    fallbackLng: ['dev'],
    fallbackNS: false,
    // string or array of namespaces
    whitelist: false,
    // array with whitelisted languages
    nonExplicitWhitelist: false,
    load: 'all',
    // | currentOnly | languageOnly
    preload: false,
    // array with preload languages
    simplifyPluralSuffix: true,
    keySeparator: '.',
    nsSeparator: ':',
    pluralSeparator: '_',
    contextSeparator: '_',
    partialBundledLanguages: false,
    // allow bundling certain languages that are not remotely fetched
    saveMissing: false,
    // enable to send missing values
    updateMissing: false,
    // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
    saveMissingTo: 'fallback',
    // 'current' || 'all'
    saveMissingPlurals: true,
    // will save all forms not only singular key
    missingKeyHandler: false,
    // function(lng, ns, key, fallbackValue) -> override if prefer on handling
    missingInterpolationHandler: false,
    // function(str, match)
    postProcess: false,
    // string or array of postProcessor names
    postProcessPassResolved: false,
    // pass resolved object into 'options.i18nResolved' for postprocessor
    returnNull: true,
    // allows null value as valid translation
    returnEmptyString: true,
    // allows empty string value as valid translation
    returnObjects: false,
    joinArrays: false,
    // or string to join array
    returnedObjectHandler: false,
    // function(key, value, options) triggered if key returns object but returnObjects is set to false
    parseMissingKeyHandler: false,
    // function(key) parsed a key that was not found in t() before returning
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      var ret = {};
      if (_typeof(args[1]) === 'object') ret = args[1];
      if (typeof args[1] === 'string') ret.defaultValue = args[1];
      if (typeof args[2] === 'string') ret.tDescription = args[2];

      if (_typeof(args[2]) === 'object' || _typeof(args[3]) === 'object') {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function (key) {
          ret[key] = options[key];
        });
      }

      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng) {
        return value;
      },
      prefix: '{{',
      suffix: '}}',
      formatSeparator: ',',
      // prefixEscaped: '{{',
      // suffixEscaped: '}}',
      // unescapeSuffix: '',
      unescapePrefix: '-',
      nestingPrefix: '$t(',
      nestingSuffix: ')',
      // nestingPrefixEscaped: '$t(',
      // nestingSuffixEscaped: ')',
      // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
      maxReplaces: 1000 // max replaces to prevent endless loop

    }
  };
}
/* eslint no-param-reassign: 0 */

function transformOptions(options) {
  // create namespace object if namespace is passed in as string
  if (typeof options.ns === 'string') options.ns = [options.ns];
  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS]; // extend whitelist with cimode

  if (options.whitelist && options.whitelist.indexOf('cimode') < 0) {
    options.whitelist = options.whitelist.concat(['cimode']);
  }

  return options;
}

function noop() {}

var I18n =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(I18n, _EventEmitter);

  function I18n() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : undefined;

    _classCallCheck(this, I18n);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n).call(this));
    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };

    if (callback && !_this.isInitialized && !options.isClone) {
      // https://github.com/i18next/i18next/issues/879
      if (!_this.options.initImmediate) {
        _this.init(options, callback);

        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }

      setTimeout(function () {
        _this.init(options, callback);
      }, 0);
    }

    return _this;
  }

  _createClass(I18n, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      this.options = _objectSpread({}, get(), this.options, transformOptions(options));
      this.format = this.options.interpolation.format;
      if (!callback) callback = noop;

      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject) return null;
        if (typeof ClassOrObject === 'function') return new ClassOrObject();
        return ClassOrObject;
      } // init services


      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }

        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options); // pipe events from backendConnector

        s.backendConnector.on('*', function (event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          _this2.emit.apply(_this2, [event].concat(args));
        });

        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }

        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init) s.i18nFormat.init(this);
        }

        this.translator = new Translator(this.services, this.options); // pipe events from translator

        this.translator.on('*', function (event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function (m) {
          if (m.init) m.init(_this2);
        });
      } // append api


      var storeApi = ['getResource', 'addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
      storeApi.forEach(function (fcName) {
        _this2[fcName] = function () {
          var _this2$store;

          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var deferred = defer();

      var load = function load() {
        _this2.changeLanguage(_this2.options.lng, function (err, t) {
          _this2.isInitialized = true;

          _this2.logger.log('initialized', _this2.options);

          _this2.emit('initialized', _this2.options);

          deferred.resolve(t); // not rejecting on err (as err is only a loading translation failed warning)

          callback(err, t);
        });
      };

      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }

      return deferred;
    }
    /* eslint consistent-return: 0 */

  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
      var usedCallback = callback;
      var usedLng = typeof language === 'string' ? language : this.language;
      if (typeof language === 'function') usedCallback = language;

      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback(); // avoid loading resources for cimode

        var toLoad = [];

        var append = function append(lng) {
          if (!lng) return;

          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);

          lngs.forEach(function (l) {
            if (toLoad.indexOf(l) < 0) toLoad.push(l);
          });
        };

        if (!usedLng) {
          // at least load fallbacks in this case
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function (l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }

        if (this.options.preload) {
          this.options.preload.forEach(function (l) {
            return append(l);
          });
        }

        this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs) lngs = this.languages;
      if (!ns) ns = this.options.ns;
      if (!callback) callback = noop;
      this.services.backendConnector.reload(lngs, ns, function (err) {
        deferred.resolve(); // not rejecting on err (as err is only a loading translation failed warning)

        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (module.type === 'backend') {
        this.modules.backend = module;
      }

      if (module.type === 'logger' || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }

      if (module.type === 'languageDetector') {
        this.modules.languageDetector = module;
      }

      if (module.type === 'i18nFormat') {
        this.modules.i18nFormat = module;
      }

      if (module.type === 'postProcessor') {
        postProcessor.addPostProcessor(module);
      }

      if (module.type === '3rdParty') {
        this.modules.external.push(module);
      }

      return this;
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;

      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit('languageChanging', lng);

      var done = function done(err, l) {
        if (l) {
          _this4.language = l;
          _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);

          _this4.translator.changeLanguage(l);

          _this4.isLanguageChangingTo = undefined;

          _this4.emit('languageChanged', l);

          _this4.logger.log('languageChanged', l);
        } else {
          _this4.isLanguageChangingTo = undefined;
        }

        deferred.resolve(function () {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback) callback(err, function () {
          return _this4.t.apply(_this4, arguments);
        });
      };

      var setLng = function setLng(l) {
        if (l) {
          if (!_this4.language) {
            _this4.language = l;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
          }

          if (!_this4.translator.language) _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
        }

        _this4.loadResources(l, function (err) {
          done(err, l);
        });
      };

      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }

      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns) {
      var _this5 = this;

      var fixedT = function fixedT(key, opts) {
        var options;

        if (_typeof(opts) !== 'object') {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }

          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread({}, opts);
        }

        options.lng = options.lng || fixedT.lng;
        options.lngs = options.lngs || fixedT.lngs;
        options.ns = options.ns || fixedT.ns;
        return _this5.t(key, options);
      };

      if (typeof lng === 'string') {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }

      fixedT.ns = ns;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t() {
      var _this$translator;

      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;

      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace(ns) {
      var _this6 = this;

      if (!this.isInitialized) {
        this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
        return false;
      }

      if (!this.languages || !this.languages.length) {
        this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
        return false;
      }

      var lng = this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1]; // we're in cimode so this shall pass

      if (lng.toLowerCase() === 'cimode') return true;

      var loadNotPending = function loadNotPending(l, n) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];

        return loadState === -1 || loadState === 2;
      }; // loaded -> SUCCESS


      if (this.hasResourceBundle(lng, ns)) return true; // were not loading at all -> SEMI SUCCESS

      if (!this.services.backendConnector.backend) return true; // failed loading ns - but at least fallback is not pending -> SEMI SUCCESS

      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces(ns, callback) {
      var _this7 = this;

      var deferred = defer();

      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }

      if (typeof ns === 'string') ns = [ns];
      ns.forEach(function (n) {
        if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);
      });
      this.loadResources(function (err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === 'string') lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function (lng) {
        return preloaded.indexOf(lng) < 0;
      }); // Exit early if all given languages are already preloaded

      if (!newLngs.length) {
        if (callback) callback();
        return Promise.resolve();
      }

      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function (err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
      if (!lng) return 'rtl';
      var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam'];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';
    }
    /* eslint class-methods-use-this: 0 */

  }, {
    key: "createInstance",
    value: function createInstance() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;
      return new I18n(options, callback);
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

      var mergedOptions = _objectSpread({}, this.options, options, {
        isClone: true
      });

      var clone = new I18n(mergedOptions);
      var membersToCopy = ['store', 'services', 'language'];
      membersToCopy.forEach(function (m) {
        clone[m] = _this8[m];
      });
      clone.translator = new Translator(clone.services, clone.options);
      clone.translator.on('*', function (event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        clone.emit.apply(clone, [event].concat(args));
      });
      clone.init(mergedOptions, callback);
      clone.translator.options = clone.options; // sync options

      return clone;
    }
  }]);

  return I18n;
}(EventEmitter);

var i18next = new I18n();

/* harmony default export */ const esm_i18next = (i18next);


/***/ }),

/***/ 15822:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(73837);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(19105);
}


/***/ }),

/***/ 19105:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 35836:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(57147);

let isDocker;

function hasDockerEnv() {
	try {
		fs.statSync('/.dockerenv');
		return true;
	} catch (_) {
		return false;
	}
}

function hasDockerCGroup() {
	try {
		return fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
	} catch (_) {
		return false;
	}
}

module.exports = () => {
	if (isDocker === undefined) {
		isDocker = hasDockerEnv() || hasDockerCGroup();
	}

	return isDocker;
};


/***/ }),

/***/ 39295:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(22037);
const fs = __webpack_require__(57147);
const isDocker = __webpack_require__(35836);

const isWsl = () => {
	if (process.platform !== 'linux') {
		return false;
	}

	if (os.release().toLowerCase().includes('microsoft')) {
		if (isDocker()) {
			return false;
		}

		return true;
	}

	try {
		return fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') ?
			!isDocker() : false;
	} catch (_) {
		return false;
	}
};

if (process.env.__IS_WSL_TEST__) {
	module.exports = isWsl;
} else {
	module.exports = isWsl();
}


/***/ }),

/***/ 48617:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "applyEdits": () => (/* binding */ applyEdits),
  "createScanner": () => (/* binding */ main_createScanner),
  "findNodeAtLocation": () => (/* binding */ main_findNodeAtLocation),
  "findNodeAtOffset": () => (/* binding */ main_findNodeAtOffset),
  "format": () => (/* binding */ main_format),
  "getLocation": () => (/* binding */ main_getLocation),
  "getNodePath": () => (/* binding */ main_getNodePath),
  "getNodeValue": () => (/* binding */ main_getNodeValue),
  "modify": () => (/* binding */ modify),
  "parse": () => (/* binding */ main_parse),
  "parseTree": () => (/* binding */ main_parseTree),
  "printParseErrorCode": () => (/* binding */ printParseErrorCode),
  "stripComments": () => (/* binding */ main_stripComments),
  "visit": () => (/* binding */ main_visit)
});

;// CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/scanner.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */
function createScanner(text, ignoreTrivia) {
    if (ignoreTrivia === void 0) { ignoreTrivia = false; }
    var len = text.length;
    var pos = 0, value = '', tokenOffset = 0, token = 16 /* Unknown */, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* None */;
    function scanHexDigits(count, exact) {
        var digits = 0;
        var value = 0;
        while (digits < count || !exact) {
            var ch = text.charCodeAt(pos);
            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                value = value * 16 + ch - 48 /* _0 */;
            }
            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                value = value * 16 + ch - 65 /* A */ + 10;
            }
            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                value = value * 16 + ch - 97 /* a */ + 10;
            }
            else {
                break;
            }
            pos++;
            digits++;
        }
        if (digits < count) {
            value = -1;
        }
        return value;
    }
    function setPosition(newPosition) {
        pos = newPosition;
        value = '';
        tokenOffset = 0;
        token = 16 /* Unknown */;
        scanError = 0 /* None */;
    }
    function scanNumber() {
        var start = pos;
        if (text.charCodeAt(pos) === 48 /* _0 */) {
            pos++;
        }
        else {
            pos++;
            while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
            }
        }
        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {
            pos++;
            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            else {
                scanError = 3 /* UnexpectedEndOfNumber */;
                return text.substring(start, pos);
            }
        }
        var end = pos;
        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {
            pos++;
            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {
                pos++;
            }
            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
                end = pos;
            }
            else {
                scanError = 3 /* UnexpectedEndOfNumber */;
            }
        }
        return text.substring(start, end);
    }
    function scanString() {
        var result = '', start = pos;
        while (true) {
            if (pos >= len) {
                result += text.substring(start, pos);
                scanError = 2 /* UnexpectedEndOfString */;
                break;
            }
            var ch = text.charCodeAt(pos);
            if (ch === 34 /* doubleQuote */) {
                result += text.substring(start, pos);
                pos++;
                break;
            }
            if (ch === 92 /* backslash */) {
                result += text.substring(start, pos);
                pos++;
                if (pos >= len) {
                    scanError = 2 /* UnexpectedEndOfString */;
                    break;
                }
                var ch2 = text.charCodeAt(pos++);
                switch (ch2) {
                    case 34 /* doubleQuote */:
                        result += '\"';
                        break;
                    case 92 /* backslash */:
                        result += '\\';
                        break;
                    case 47 /* slash */:
                        result += '/';
                        break;
                    case 98 /* b */:
                        result += '\b';
                        break;
                    case 102 /* f */:
                        result += '\f';
                        break;
                    case 110 /* n */:
                        result += '\n';
                        break;
                    case 114 /* r */:
                        result += '\r';
                        break;
                    case 116 /* t */:
                        result += '\t';
                        break;
                    case 117 /* u */:
                        var ch3 = scanHexDigits(4, true);
                        if (ch3 >= 0) {
                            result += String.fromCharCode(ch3);
                        }
                        else {
                            scanError = 4 /* InvalidUnicode */;
                        }
                        break;
                    default:
                        scanError = 5 /* InvalidEscapeCharacter */;
                }
                start = pos;
                continue;
            }
            if (ch >= 0 && ch <= 0x1f) {
                if (isLineBreak(ch)) {
                    result += text.substring(start, pos);
                    scanError = 2 /* UnexpectedEndOfString */;
                    break;
                }
                else {
                    scanError = 6 /* InvalidCharacter */;
                    // mark as error but continue with string
                }
            }
            pos++;
        }
        return result;
    }
    function scanNext() {
        value = '';
        scanError = 0 /* None */;
        tokenOffset = pos;
        lineStartOffset = lineNumber;
        prevTokenLineStartOffset = tokenLineStartOffset;
        if (pos >= len) {
            // at the end
            tokenOffset = len;
            return token = 17 /* EOF */;
        }
        var code = text.charCodeAt(pos);
        // trivia: whitespace
        if (isWhiteSpace(code)) {
            do {
                pos++;
                value += String.fromCharCode(code);
                code = text.charCodeAt(pos);
            } while (isWhiteSpace(code));
            return token = 15 /* Trivia */;
        }
        // trivia: newlines
        if (isLineBreak(code)) {
            pos++;
            value += String.fromCharCode(code);
            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                pos++;
                value += '\n';
            }
            lineNumber++;
            tokenLineStartOffset = pos;
            return token = 14 /* LineBreakTrivia */;
        }
        switch (code) {
            // tokens: []{}:,
            case 123 /* openBrace */:
                pos++;
                return token = 1 /* OpenBraceToken */;
            case 125 /* closeBrace */:
                pos++;
                return token = 2 /* CloseBraceToken */;
            case 91 /* openBracket */:
                pos++;
                return token = 3 /* OpenBracketToken */;
            case 93 /* closeBracket */:
                pos++;
                return token = 4 /* CloseBracketToken */;
            case 58 /* colon */:
                pos++;
                return token = 6 /* ColonToken */;
            case 44 /* comma */:
                pos++;
                return token = 5 /* CommaToken */;
            // strings
            case 34 /* doubleQuote */:
                pos++;
                value = scanString();
                return token = 10 /* StringLiteral */;
            // comments
            case 47 /* slash */:
                var start = pos - 1;
                // Single-line comment
                if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                    pos += 2;
                    while (pos < len) {
                        if (isLineBreak(text.charCodeAt(pos))) {
                            break;
                        }
                        pos++;
                    }
                    value = text.substring(start, pos);
                    return token = 12 /* LineCommentTrivia */;
                }
                // Multi-line comment
                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                    pos += 2;
                    var safeLength = len - 1; // For lookahead.
                    var commentClosed = false;
                    while (pos < safeLength) {
                        var ch = text.charCodeAt(pos);
                        if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                            pos += 2;
                            commentClosed = true;
                            break;
                        }
                        pos++;
                        if (isLineBreak(ch)) {
                            if (ch === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                                pos++;
                            }
                            lineNumber++;
                            tokenLineStartOffset = pos;
                        }
                    }
                    if (!commentClosed) {
                        pos++;
                        scanError = 1 /* UnexpectedEndOfComment */;
                    }
                    value = text.substring(start, pos);
                    return token = 13 /* BlockCommentTrivia */;
                }
                // just a single slash
                value += String.fromCharCode(code);
                pos++;
                return token = 16 /* Unknown */;
            // numbers
            case 45 /* minus */:
                value += String.fromCharCode(code);
                pos++;
                if (pos === len || !isDigit(text.charCodeAt(pos))) {
                    return token = 16 /* Unknown */;
                }
            // found a minus, followed by a number so
            // we fall through to proceed with scanning
            // numbers
            case 48 /* _0 */:
            case 49 /* _1 */:
            case 50 /* _2 */:
            case 51 /* _3 */:
            case 52 /* _4 */:
            case 53 /* _5 */:
            case 54 /* _6 */:
            case 55 /* _7 */:
            case 56 /* _8 */:
            case 57 /* _9 */:
                value += scanNumber();
                return token = 11 /* NumericLiteral */;
            // literals and unknown symbols
            default:
                // is a literal? Read the full word.
                while (pos < len && isUnknownContentCharacter(code)) {
                    pos++;
                    code = text.charCodeAt(pos);
                }
                if (tokenOffset !== pos) {
                    value = text.substring(tokenOffset, pos);
                    // keywords: true, false, null
                    switch (value) {
                        case 'true': return token = 8 /* TrueKeyword */;
                        case 'false': return token = 9 /* FalseKeyword */;
                        case 'null': return token = 7 /* NullKeyword */;
                    }
                    return token = 16 /* Unknown */;
                }
                // some
                value += String.fromCharCode(code);
                pos++;
                return token = 16 /* Unknown */;
        }
    }
    function isUnknownContentCharacter(code) {
        if (isWhiteSpace(code) || isLineBreak(code)) {
            return false;
        }
        switch (code) {
            case 125 /* closeBrace */:
            case 93 /* closeBracket */:
            case 123 /* openBrace */:
            case 91 /* openBracket */:
            case 34 /* doubleQuote */:
            case 58 /* colon */:
            case 44 /* comma */:
            case 47 /* slash */:
                return false;
        }
        return true;
    }
    function scanNextNonTrivia() {
        var result;
        do {
            result = scanNext();
        } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);
        return result;
    }
    return {
        setPosition: setPosition,
        getPosition: function () { return pos; },
        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
        getToken: function () { return token; },
        getTokenValue: function () { return value; },
        getTokenOffset: function () { return tokenOffset; },
        getTokenLength: function () { return pos - tokenOffset; },
        getTokenStartLine: function () { return lineStartOffset; },
        getTokenStartCharacter: function () { return tokenOffset - prevTokenLineStartOffset; },
        getTokenError: function () { return scanError; },
    };
}
function isWhiteSpace(ch) {
    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||
        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||
        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
}
function isLineBreak(ch) {
    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;
}
function isDigit(ch) {
    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
}

;// CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/format.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function format(documentText, range, options) {
    var initialIndentLevel;
    var formatText;
    var formatTextStart;
    var rangeStart;
    var rangeEnd;
    if (range) {
        rangeStart = range.offset;
        rangeEnd = rangeStart + range.length;
        formatTextStart = rangeStart;
        while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
            formatTextStart--;
        }
        var endOffset = rangeEnd;
        while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
            endOffset++;
        }
        formatText = documentText.substring(formatTextStart, endOffset);
        initialIndentLevel = computeIndentLevel(formatText, options);
    }
    else {
        formatText = documentText;
        initialIndentLevel = 0;
        formatTextStart = 0;
        rangeStart = 0;
        rangeEnd = documentText.length;
    }
    var eol = getEOL(options, documentText);
    var lineBreak = false;
    var indentLevel = 0;
    var indentValue;
    if (options.insertSpaces) {
        indentValue = repeat(' ', options.tabSize || 4);
    }
    else {
        indentValue = '\t';
    }
    var scanner = createScanner(formatText, false);
    var hasError = false;
    function newLineAndIndent() {
        return eol + repeat(indentValue, initialIndentLevel + indentLevel);
    }
    function scanNext() {
        var token = scanner.scan();
        lineBreak = false;
        while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {
            lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);
            token = scanner.scan();
        }
        hasError = token === 16 /* Unknown */ || scanner.getTokenError() !== 0 /* None */;
        return token;
    }
    var editOperations = [];
    function addEdit(text, startOffset, endOffset) {
        if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {
            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });
        }
    }
    var firstToken = scanNext();
    if (firstToken !== 17 /* EOF */) {
        var firstTokenStart = scanner.getTokenOffset() + formatTextStart;
        var initialIndent = repeat(indentValue, initialIndentLevel);
        addEdit(initialIndent, formatTextStart, firstTokenStart);
    }
    while (firstToken !== 17 /* EOF */) {
        var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
        var secondToken = scanNext();
        var replaceContent = '';
        while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
            // comments on the same line: keep them on the same line, but ignore them otherwise
            var commentTokenStart = scanner.getTokenOffset() + formatTextStart;
            addEdit(' ', firstTokenEnd, commentTokenStart);
            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
            replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';
            secondToken = scanNext();
        }
        if (secondToken === 2 /* CloseBraceToken */) {
            if (firstToken !== 1 /* OpenBraceToken */) {
                indentLevel--;
                replaceContent = newLineAndIndent();
            }
        }
        else if (secondToken === 4 /* CloseBracketToken */) {
            if (firstToken !== 3 /* OpenBracketToken */) {
                indentLevel--;
                replaceContent = newLineAndIndent();
            }
        }
        else {
            switch (firstToken) {
                case 3 /* OpenBracketToken */:
                case 1 /* OpenBraceToken */:
                    indentLevel++;
                    replaceContent = newLineAndIndent();
                    break;
                case 5 /* CommaToken */:
                case 12 /* LineCommentTrivia */:
                    replaceContent = newLineAndIndent();
                    break;
                case 13 /* BlockCommentTrivia */:
                    if (lineBreak) {
                        replaceContent = newLineAndIndent();
                    }
                    else {
                        // symbol following comment on the same line: keep on same line, separate with ' '
                        replaceContent = ' ';
                    }
                    break;
                case 6 /* ColonToken */:
                    replaceContent = ' ';
                    break;
                case 10 /* StringLiteral */:
                    if (secondToken === 6 /* ColonToken */) {
                        replaceContent = '';
                        break;
                    }
                // fall through
                case 7 /* NullKeyword */:
                case 8 /* TrueKeyword */:
                case 9 /* FalseKeyword */:
                case 11 /* NumericLiteral */:
                case 2 /* CloseBraceToken */:
                case 4 /* CloseBracketToken */:
                    if (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */) {
                        replaceContent = ' ';
                    }
                    else if (secondToken !== 5 /* CommaToken */ && secondToken !== 17 /* EOF */) {
                        hasError = true;
                    }
                    break;
                case 16 /* Unknown */:
                    hasError = true;
                    break;
            }
            if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
                replaceContent = newLineAndIndent();
            }
        }
        var secondTokenStart = scanner.getTokenOffset() + formatTextStart;
        addEdit(replaceContent, firstTokenEnd, secondTokenStart);
        firstToken = secondToken;
    }
    return editOperations;
}
function repeat(s, count) {
    var result = '';
    for (var i = 0; i < count; i++) {
        result += s;
    }
    return result;
}
function computeIndentLevel(content, options) {
    var i = 0;
    var nChars = 0;
    var tabSize = options.tabSize || 4;
    while (i < content.length) {
        var ch = content.charAt(i);
        if (ch === ' ') {
            nChars++;
        }
        else if (ch === '\t') {
            nChars += tabSize;
        }
        else {
            break;
        }
        i++;
    }
    return Math.floor(nChars / tabSize);
}
function getEOL(options, text) {
    for (var i = 0; i < text.length; i++) {
        var ch = text.charAt(i);
        if (ch === '\r') {
            if (i + 1 < text.length && text.charAt(i + 1) === '\n') {
                return '\r\n';
            }
            return '\r';
        }
        else if (ch === '\n') {
            return '\n';
        }
    }
    return (options && options.eol) || '\n';
}
function isEOL(text, offset) {
    return '\r\n'.indexOf(text.charAt(offset)) !== -1;
}

;// CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/parser.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


var ParseOptions;
(function (ParseOptions) {
    ParseOptions.DEFAULT = {
        allowTrailingComma: false
    };
})(ParseOptions || (ParseOptions = {}));
/**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */
function getLocation(text, position) {
    var segments = []; // strings or numbers
    var earlyReturnException = new Object();
    var previousNode = undefined;
    var previousNodeInst = {
        value: {},
        offset: 0,
        length: 0,
        type: 'object',
        parent: undefined
    };
    var isAtPropertyKey = false;
    function setPreviousNode(value, offset, length, type) {
        previousNodeInst.value = value;
        previousNodeInst.offset = offset;
        previousNodeInst.length = length;
        previousNodeInst.type = type;
        previousNodeInst.colonOffset = undefined;
        previousNode = previousNodeInst;
    }
    try {
        visit(text, {
            onObjectBegin: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                isAtPropertyKey = position > offset;
                segments.push(''); // push a placeholder (will be replaced)
            },
            onObjectProperty: function (name, offset, length) {
                if (position < offset) {
                    throw earlyReturnException;
                }
                setPreviousNode(name, offset, length, 'property');
                segments[segments.length - 1] = name;
                if (position <= offset + length) {
                    throw earlyReturnException;
                }
            },
            onObjectEnd: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                segments.pop();
            },
            onArrayBegin: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                segments.push(0);
            },
            onArrayEnd: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                segments.pop();
            },
            onLiteralValue: function (value, offset, length) {
                if (position < offset) {
                    throw earlyReturnException;
                }
                setPreviousNode(value, offset, length, getNodeType(value));
                if (position <= offset + length) {
                    throw earlyReturnException;
                }
            },
            onSeparator: function (sep, offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                if (sep === ':' && previousNode && previousNode.type === 'property') {
                    previousNode.colonOffset = offset;
                    isAtPropertyKey = false;
                    previousNode = undefined;
                }
                else if (sep === ',') {
                    var last = segments[segments.length - 1];
                    if (typeof last === 'number') {
                        segments[segments.length - 1] = last + 1;
                    }
                    else {
                        isAtPropertyKey = true;
                        segments[segments.length - 1] = '';
                    }
                    previousNode = undefined;
                }
            }
        });
    }
    catch (e) {
        if (e !== earlyReturnException) {
            throw e;
        }
    }
    return {
        path: segments,
        previousNode: previousNode,
        isAtPropertyKey: isAtPropertyKey,
        matches: function (pattern) {
            var k = 0;
            for (var i = 0; k < pattern.length && i < segments.length; i++) {
                if (pattern[k] === segments[i] || pattern[k] === '*') {
                    k++;
                }
                else if (pattern[k] !== '**') {
                    return false;
                }
            }
            return k === pattern.length;
        }
    };
}
/**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore always check the errors list to find out if the input was valid.
 */
function parse(text, errors, options) {
    if (errors === void 0) { errors = []; }
    if (options === void 0) { options = ParseOptions.DEFAULT; }
    var currentProperty = null;
    var currentParent = [];
    var previousParents = [];
    function onValue(value) {
        if (Array.isArray(currentParent)) {
            currentParent.push(value);
        }
        else if (currentProperty !== null) {
            currentParent[currentProperty] = value;
        }
    }
    var visitor = {
        onObjectBegin: function () {
            var object = {};
            onValue(object);
            previousParents.push(currentParent);
            currentParent = object;
            currentProperty = null;
        },
        onObjectProperty: function (name) {
            currentProperty = name;
        },
        onObjectEnd: function () {
            currentParent = previousParents.pop();
        },
        onArrayBegin: function () {
            var array = [];
            onValue(array);
            previousParents.push(currentParent);
            currentParent = array;
            currentProperty = null;
        },
        onArrayEnd: function () {
            currentParent = previousParents.pop();
        },
        onLiteralValue: onValue,
        onError: function (error, offset, length) {
            errors.push({ error: error, offset: offset, length: length });
        }
    };
    visit(text, visitor, options);
    return currentParent[0];
}
/**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */
function parseTree(text, errors, options) {
    if (errors === void 0) { errors = []; }
    if (options === void 0) { options = ParseOptions.DEFAULT; }
    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root
    function ensurePropertyComplete(endOffset) {
        if (currentParent.type === 'property') {
            currentParent.length = endOffset - currentParent.offset;
            currentParent = currentParent.parent;
        }
    }
    function onValue(valueNode) {
        currentParent.children.push(valueNode);
        return valueNode;
    }
    var visitor = {
        onObjectBegin: function (offset) {
            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });
        },
        onObjectProperty: function (name, offset, length) {
            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });
            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });
        },
        onObjectEnd: function (offset, length) {
            ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete
            currentParent.length = offset + length - currentParent.offset;
            currentParent = currentParent.parent;
            ensurePropertyComplete(offset + length);
        },
        onArrayBegin: function (offset, length) {
            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });
        },
        onArrayEnd: function (offset, length) {
            currentParent.length = offset + length - currentParent.offset;
            currentParent = currentParent.parent;
            ensurePropertyComplete(offset + length);
        },
        onLiteralValue: function (value, offset, length) {
            onValue({ type: getNodeType(value), offset: offset, length: length, parent: currentParent, value: value });
            ensurePropertyComplete(offset + length);
        },
        onSeparator: function (sep, offset, length) {
            if (currentParent.type === 'property') {
                if (sep === ':') {
                    currentParent.colonOffset = offset;
                }
                else if (sep === ',') {
                    ensurePropertyComplete(offset);
                }
            }
        },
        onError: function (error, offset, length) {
            errors.push({ error: error, offset: offset, length: length });
        }
    };
    visit(text, visitor, options);
    var result = currentParent.children[0];
    if (result) {
        delete result.parent;
    }
    return result;
}
/**
 * Finds the node at the given path in a JSON DOM.
 */
function findNodeAtLocation(root, path) {
    if (!root) {
        return undefined;
    }
    var node = root;
    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
        var segment = path_1[_i];
        if (typeof segment === 'string') {
            if (node.type !== 'object' || !Array.isArray(node.children)) {
                return undefined;
            }
            var found = false;
            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {
                var propertyNode = _b[_a];
                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
                    node = propertyNode.children[1];
                    found = true;
                    break;
                }
            }
            if (!found) {
                return undefined;
            }
        }
        else {
            var index = segment;
            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
                return undefined;
            }
            node = node.children[index];
        }
    }
    return node;
}
/**
 * Gets the JSON path of the given JSON DOM node
 */
function getNodePath(node) {
    if (!node.parent || !node.parent.children) {
        return [];
    }
    var path = getNodePath(node.parent);
    if (node.parent.type === 'property') {
        var key = node.parent.children[0].value;
        path.push(key);
    }
    else if (node.parent.type === 'array') {
        var index = node.parent.children.indexOf(node);
        if (index !== -1) {
            path.push(index);
        }
    }
    return path;
}
/**
 * Evaluates the JavaScript object of the given JSON DOM node
 */
function getNodeValue(node) {
    switch (node.type) {
        case 'array':
            return node.children.map(getNodeValue);
        case 'object':
            var obj = Object.create(null);
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var prop = _a[_i];
                var valueNode = prop.children[1];
                if (valueNode) {
                    obj[prop.children[0].value] = getNodeValue(valueNode);
                }
            }
            return obj;
        case 'null':
        case 'string':
        case 'number':
        case 'boolean':
            return node.value;
        default:
            return undefined;
    }
}
function contains(node, offset, includeRightBound) {
    if (includeRightBound === void 0) { includeRightBound = false; }
    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));
}
/**
 * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */
function findNodeAtOffset(node, offset, includeRightBound) {
    if (includeRightBound === void 0) { includeRightBound = false; }
    if (contains(node, offset, includeRightBound)) {
        var children = node.children;
        if (Array.isArray(children)) {
            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {
                var item = findNodeAtOffset(children[i], offset, includeRightBound);
                if (item) {
                    return item;
                }
            }
        }
        return node;
    }
    return undefined;
}
/**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */
function visit(text, visitor, options) {
    if (options === void 0) { options = ParseOptions.DEFAULT; }
    var _scanner = createScanner(text, false);
    function toNoArgVisit(visitFunction) {
        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };
    }
    function toOneArgVisit(visitFunction) {
        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };
    }
    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
    var disallowComments = options && options.disallowComments;
    var allowTrailingComma = options && options.allowTrailingComma;
    function scanNext() {
        while (true) {
            var token = _scanner.scan();
            switch (_scanner.getTokenError()) {
                case 4 /* InvalidUnicode */:
                    handleError(14 /* InvalidUnicode */);
                    break;
                case 5 /* InvalidEscapeCharacter */:
                    handleError(15 /* InvalidEscapeCharacter */);
                    break;
                case 3 /* UnexpectedEndOfNumber */:
                    handleError(13 /* UnexpectedEndOfNumber */);
                    break;
                case 1 /* UnexpectedEndOfComment */:
                    if (!disallowComments) {
                        handleError(11 /* UnexpectedEndOfComment */);
                    }
                    break;
                case 2 /* UnexpectedEndOfString */:
                    handleError(12 /* UnexpectedEndOfString */);
                    break;
                case 6 /* InvalidCharacter */:
                    handleError(16 /* InvalidCharacter */);
                    break;
            }
            switch (token) {
                case 12 /* LineCommentTrivia */:
                case 13 /* BlockCommentTrivia */:
                    if (disallowComments) {
                        handleError(10 /* InvalidCommentToken */);
                    }
                    else {
                        onComment();
                    }
                    break;
                case 16 /* Unknown */:
                    handleError(1 /* InvalidSymbol */);
                    break;
                case 15 /* Trivia */:
                case 14 /* LineBreakTrivia */:
                    break;
                default:
                    return token;
            }
        }
    }
    function handleError(error, skipUntilAfter, skipUntil) {
        if (skipUntilAfter === void 0) { skipUntilAfter = []; }
        if (skipUntil === void 0) { skipUntil = []; }
        onError(error);
        if (skipUntilAfter.length + skipUntil.length > 0) {
            var token = _scanner.getToken();
            while (token !== 17 /* EOF */) {
                if (skipUntilAfter.indexOf(token) !== -1) {
                    scanNext();
                    break;
                }
                else if (skipUntil.indexOf(token) !== -1) {
                    break;
                }
                token = scanNext();
            }
        }
    }
    function parseString(isValue) {
        var value = _scanner.getTokenValue();
        if (isValue) {
            onLiteralValue(value);
        }
        else {
            onObjectProperty(value);
        }
        scanNext();
        return true;
    }
    function parseLiteral() {
        switch (_scanner.getToken()) {
            case 11 /* NumericLiteral */:
                var tokenValue = _scanner.getTokenValue();
                var value = Number(tokenValue);
                if (isNaN(value)) {
                    handleError(2 /* InvalidNumberFormat */);
                    value = 0;
                }
                onLiteralValue(value);
                break;
            case 7 /* NullKeyword */:
                onLiteralValue(null);
                break;
            case 8 /* TrueKeyword */:
                onLiteralValue(true);
                break;
            case 9 /* FalseKeyword */:
                onLiteralValue(false);
                break;
            default:
                return false;
        }
        scanNext();
        return true;
    }
    function parseProperty() {
        if (_scanner.getToken() !== 10 /* StringLiteral */) {
            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            return false;
        }
        parseString(false);
        if (_scanner.getToken() === 6 /* ColonToken */) {
            onSeparator(':');
            scanNext(); // consume colon
            if (!parseValue()) {
                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            }
        }
        else {
            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
        }
        return true;
    }
    function parseObject() {
        onObjectBegin();
        scanNext(); // consume open brace
        var needsComma = false;
        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {
            if (_scanner.getToken() === 5 /* CommaToken */) {
                if (!needsComma) {
                    handleError(4 /* ValueExpected */, [], []);
                }
                onSeparator(',');
                scanNext(); // consume comma
                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {
                    break;
                }
            }
            else if (needsComma) {
                handleError(6 /* CommaExpected */, [], []);
            }
            if (!parseProperty()) {
                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            }
            needsComma = true;
        }
        onObjectEnd();
        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {
            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);
        }
        else {
            scanNext(); // consume close brace
        }
        return true;
    }
    function parseArray() {
        onArrayBegin();
        scanNext(); // consume open bracket
        var needsComma = false;
        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {
            if (_scanner.getToken() === 5 /* CommaToken */) {
                if (!needsComma) {
                    handleError(4 /* ValueExpected */, [], []);
                }
                onSeparator(',');
                scanNext(); // consume comma
                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {
                    break;
                }
            }
            else if (needsComma) {
                handleError(6 /* CommaExpected */, [], []);
            }
            if (!parseValue()) {
                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);
            }
            needsComma = true;
        }
        onArrayEnd();
        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {
            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);
        }
        else {
            scanNext(); // consume close bracket
        }
        return true;
    }
    function parseValue() {
        switch (_scanner.getToken()) {
            case 3 /* OpenBracketToken */:
                return parseArray();
            case 1 /* OpenBraceToken */:
                return parseObject();
            case 10 /* StringLiteral */:
                return parseString(true);
            default:
                return parseLiteral();
        }
    }
    scanNext();
    if (_scanner.getToken() === 17 /* EOF */) {
        if (options.allowEmptyContent) {
            return true;
        }
        handleError(4 /* ValueExpected */, [], []);
        return false;
    }
    if (!parseValue()) {
        handleError(4 /* ValueExpected */, [], []);
        return false;
    }
    if (_scanner.getToken() !== 17 /* EOF */) {
        handleError(9 /* EndOfFileExpected */, [], []);
    }
    return true;
}
/**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */
function stripComments(text, replaceCh) {
    var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;
    do {
        pos = _scanner.getPosition();
        kind = _scanner.scan();
        switch (kind) {
            case 12 /* LineCommentTrivia */:
            case 13 /* BlockCommentTrivia */:
            case 17 /* EOF */:
                if (offset !== pos) {
                    parts.push(text.substring(offset, pos));
                }
                if (replaceCh !== undefined) {
                    parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
                }
                offset = _scanner.getPosition();
                break;
        }
    } while (kind !== 17 /* EOF */);
    return parts.join('');
}
function getNodeType(value) {
    switch (typeof value) {
        case 'boolean': return 'boolean';
        case 'number': return 'number';
        case 'string': return 'string';
        case 'object': {
            if (!value) {
                return 'null';
            }
            else if (Array.isArray(value)) {
                return 'array';
            }
            return 'object';
        }
        default: return 'null';
    }
}

;// CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/edit.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



function removeProperty(text, path, options) {
    return setProperty(text, path, void 0, options);
}
function setProperty(text, originalPath, value, options) {
    var _a;
    var path = originalPath.slice();
    var errors = [];
    var root = parseTree(text, errors);
    var parent = void 0;
    var lastSegment = void 0;
    while (path.length > 0) {
        lastSegment = path.pop();
        parent = findNodeAtLocation(root, path);
        if (parent === void 0 && value !== void 0) {
            if (typeof lastSegment === 'string') {
                value = (_a = {}, _a[lastSegment] = value, _a);
            }
            else {
                value = [value];
            }
        }
        else {
            break;
        }
    }
    if (!parent) {
        // empty document
        if (value === void 0) { // delete
            throw new Error('Can not delete in empty document');
        }
        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);
    }
    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {
        var existing = findNodeAtLocation(parent, [lastSegment]);
        if (existing !== void 0) {
            if (value === void 0) { // delete
                if (!existing.parent) {
                    throw new Error('Malformed AST');
                }
                var propertyIndex = parent.children.indexOf(existing.parent);
                var removeBegin = void 0;
                var removeEnd = existing.parent.offset + existing.parent.length;
                if (propertyIndex > 0) {
                    // remove the comma of the previous node
                    var previous = parent.children[propertyIndex - 1];
                    removeBegin = previous.offset + previous.length;
                }
                else {
                    removeBegin = parent.offset + 1;
                    if (parent.children.length > 1) {
                        // remove the comma of the next node
                        var next = parent.children[1];
                        removeEnd = next.offset;
                    }
                }
                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, options);
            }
            else {
                // set value of existing property
                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);
            }
        }
        else {
            if (value === void 0) { // delete
                return []; // property does not exist, nothing to do
            }
            var newProperty = JSON.stringify(lastSegment) + ": " + JSON.stringify(value);
            var index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;
            var edit = void 0;
            if (index > 0) {
                var previous = parent.children[index - 1];
                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
            }
            else if (parent.children.length === 0) {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty };
            }
            else {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };
            }
            return withFormatting(text, edit, options);
        }
    }
    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {
        var insertIndex = lastSegment;
        if (insertIndex === -1) {
            // Insert
            var newProperty = "" + JSON.stringify(value);
            var edit = void 0;
            if (parent.children.length === 0) {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty };
            }
            else {
                var previous = parent.children[parent.children.length - 1];
                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
            }
            return withFormatting(text, edit, options);
        }
        else if (value === void 0 && parent.children.length >= 0) {
            // Removal
            var removalIndex = lastSegment;
            var toRemove = parent.children[removalIndex];
            var edit = void 0;
            if (parent.children.length === 1) {
                // only item
                edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };
            }
            else if (parent.children.length - 1 === removalIndex) {
                // last item
                var previous = parent.children[removalIndex - 1];
                var offset = previous.offset + previous.length;
                var parentEndOffset = parent.offset + parent.length;
                edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };
            }
            else {
                edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };
            }
            return withFormatting(text, edit, options);
        }
        else if (value !== void 0) {
            var edit = void 0;
            var newProperty = "" + JSON.stringify(value);
            if (!options.isArrayInsertion && parent.children.length > lastSegment) {
                var toModify = parent.children[lastSegment];
                edit = { offset: toModify.offset, length: toModify.length, content: newProperty };
            }
            else if (parent.children.length === 0 || lastSegment === 0) {
                edit = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + ',' };
            }
            else {
                var index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
                var previous = parent.children[index - 1];
                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
            }
            return withFormatting(text, edit, options);
        }
        else {
            throw new Error("Can not " + (value === void 0 ? 'remove' : (options.isArrayInsertion ? 'insert' : 'modify')) + " Array index " + insertIndex + " as length is not sufficient");
        }
    }
    else {
        throw new Error("Can not add " + (typeof lastSegment !== 'number' ? 'index' : 'property') + " to parent of type " + parent.type);
    }
}
function withFormatting(text, edit, options) {
    if (!options.formattingOptions) {
        return [edit];
    }
    // apply the edit
    var newText = applyEdit(text, edit);
    // format the new text
    var begin = edit.offset;
    var end = edit.offset + edit.content.length;
    if (edit.length === 0 || edit.content.length === 0) { // insert or remove
        while (begin > 0 && !isEOL(newText, begin - 1)) {
            begin--;
        }
        while (end < newText.length && !isEOL(newText, end)) {
            end++;
        }
    }
    var edits = format(newText, { offset: begin, length: end - begin }, options.formattingOptions);
    // apply the formatting edits and track the begin and end offsets of the changes
    for (var i = edits.length - 1; i >= 0; i--) {
        var edit_1 = edits[i];
        newText = applyEdit(newText, edit_1);
        begin = Math.min(begin, edit_1.offset);
        end = Math.max(end, edit_1.offset + edit_1.length);
        end += edit_1.content.length - edit_1.length;
    }
    // create a single edit with all changes
    var editLength = text.length - (newText.length - end) - begin;
    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
}
function applyEdit(text, edit) {
    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);
}
function isWS(text, offset) {
    return '\r\n \t'.indexOf(text.charAt(offset)) !== -1;
}

;// CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/main.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





/**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */
var main_createScanner = createScanner;
/**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */
var main_getLocation = getLocation;
/**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore, always check the errors list to find out if the input was valid.
 */
var main_parse = parse;
/**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */
var main_parseTree = parseTree;
/**
 * Finds the node at the given path in a JSON DOM.
 */
var main_findNodeAtLocation = findNodeAtLocation;
/**
 * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */
var main_findNodeAtOffset = findNodeAtOffset;
/**
 * Gets the JSON path of the given JSON DOM node
 */
var main_getNodePath = getNodePath;
/**
 * Evaluates the JavaScript object of the given JSON DOM node
 */
var main_getNodeValue = getNodeValue;
/**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */
var main_visit = visit;
/**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */
var main_stripComments = stripComments;
function printParseErrorCode(code) {
    switch (code) {
        case 1 /* InvalidSymbol */: return 'InvalidSymbol';
        case 2 /* InvalidNumberFormat */: return 'InvalidNumberFormat';
        case 3 /* PropertyNameExpected */: return 'PropertyNameExpected';
        case 4 /* ValueExpected */: return 'ValueExpected';
        case 5 /* ColonExpected */: return 'ColonExpected';
        case 6 /* CommaExpected */: return 'CommaExpected';
        case 7 /* CloseBraceExpected */: return 'CloseBraceExpected';
        case 8 /* CloseBracketExpected */: return 'CloseBracketExpected';
        case 9 /* EndOfFileExpected */: return 'EndOfFileExpected';
        case 10 /* InvalidCommentToken */: return 'InvalidCommentToken';
        case 11 /* UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';
        case 12 /* UnexpectedEndOfString */: return 'UnexpectedEndOfString';
        case 13 /* UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';
        case 14 /* InvalidUnicode */: return 'InvalidUnicode';
        case 15 /* InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';
        case 16 /* InvalidCharacter */: return 'InvalidCharacter';
    }
    return '<unknown ParseErrorCode>';
}
/**
 * Computes the edits needed to format a JSON document.
 *
 * @param documentText The input text
 * @param range The range to format or `undefined` to format the full content
 * @param options The formatting options
 * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or
 * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of
 * text in the original document. However, multiple edits can have
 * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.
 * To apply edits to an input, you can use `applyEdits`.
 */
function main_format(documentText, range, options) {
    return format(documentText, range, options);
}
/**
 * Computes the edits needed to modify a value in the JSON document.
 *
 * @param documentText The input text
 * @param path The path of the value to change. The path represents either to the document root, a property or an array item.
 * If the path points to an non-existing property or item, it will be created.
 * @param value The new value for the specified property or item. If the value is undefined,
 * the property or item will be removed.
 * @param options Options
 * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or
 * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of
 * text in the original document. However, multiple edits can have
 * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.
 * To apply edits to an input, you can use `applyEdits`.
 */
function modify(text, path, value, options) {
    return setProperty(text, path, value, options);
}
/**
 * Applies edits to a input string.
 */
function applyEdits(text, edits) {
    for (var i = edits.length - 1; i >= 0; i--) {
        text = applyEdit(text, edits[i]);
    }
    return text;
}


/***/ }),

/***/ 34726:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(71017);
const fs = __webpack_require__(57147);
const {promisify} = __webpack_require__(73837);
const pLocate = __webpack_require__(36985);

const fsStat = promisify(fs.stat);
const fsLStat = promisify(fs.lstat);

const typeMappings = {
	directory: 'isDirectory',
	file: 'isFile'
};

function checkType({type}) {
	if (type in typeMappings) {
		return;
	}

	throw new Error(`Invalid type specified: ${type}`);
}

const matchType = (type, stat) => type === undefined || stat[typeMappings[type]]();

module.exports = async (paths, options) => {
	options = {
		cwd: process.cwd(),
		type: 'file',
		allowSymlinks: true,
		...options
	};
	checkType(options);
	const statFn = options.allowSymlinks ? fsStat : fsLStat;

	return pLocate(paths, async path_ => {
		try {
			const stat = await statFn(path.resolve(options.cwd, path_));
			return matchType(options.type, stat);
		} catch (_) {
			return false;
		}
	}, options);
};

module.exports.sync = (paths, options) => {
	options = {
		cwd: process.cwd(),
		allowSymlinks: true,
		type: 'file',
		...options
	};
	checkType(options);
	const statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;

	for (const path_ of paths) {
		try {
			const stat = statFn(path.resolve(options.cwd, path_));

			if (matchType(options.type, stat)) {
				return path_;
			}
		} catch (_) {
		}
	}
};


/***/ }),

/***/ 40180:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else {}
}.call(this));


/***/ }),

/***/ 571:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 61457:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

var Progress = __webpack_require__(62426)
var Gauge = __webpack_require__(1757)
var EE = (__webpack_require__(82361).EventEmitter)
var log = exports = module.exports = new EE()
var util = __webpack_require__(73837)

var setBlocking = __webpack_require__(10241)
var consoleControl = __webpack_require__(64034)

setBlocking(true)
var stream = process.stderr
Object.defineProperty(log, 'stream', {
  set: function (newStream) {
    stream = newStream
    if (this.gauge) this.gauge.setWriteTo(stream, stream)
  },
  get: function () {
    return stream
  }
})

// by default, decide based on tty-ness.
var colorEnabled
log.useColor = function () {
  return colorEnabled != null ? colorEnabled : stream.isTTY
}

log.enableColor = function () {
  colorEnabled = true
  this.gauge.setTheme({hasColor: colorEnabled, hasUnicode: unicodeEnabled})
}
log.disableColor = function () {
  colorEnabled = false
  this.gauge.setTheme({hasColor: colorEnabled, hasUnicode: unicodeEnabled})
}

// default level
log.level = 'info'

log.gauge = new Gauge(stream, {
  enabled: false, // no progress bars unless asked
  theme: {hasColor: log.useColor()},
  template: [
    {type: 'progressbar', length: 20},
    {type: 'activityIndicator', kerning: 1, length: 1},
    {type: 'section', default: ''},
    ':',
    {type: 'logline', kerning: 1, default: ''}
  ]
})

log.tracker = new Progress.TrackerGroup()

// we track this separately as we may need to temporarily disable the
// display of the status bar for our own loggy purposes.
log.progressEnabled = log.gauge.isEnabled()

var unicodeEnabled

log.enableUnicode = function () {
  unicodeEnabled = true
  this.gauge.setTheme({hasColor: this.useColor(), hasUnicode: unicodeEnabled})
}

log.disableUnicode = function () {
  unicodeEnabled = false
  this.gauge.setTheme({hasColor: this.useColor(), hasUnicode: unicodeEnabled})
}

log.setGaugeThemeset = function (themes) {
  this.gauge.setThemeset(themes)
}

log.setGaugeTemplate = function (template) {
  this.gauge.setTemplate(template)
}

log.enableProgress = function () {
  if (this.progressEnabled) return
  this.progressEnabled = true
  this.tracker.on('change', this.showProgress)
  if (this._pause) return
  this.gauge.enable()
}

log.disableProgress = function () {
  if (!this.progressEnabled) return
  this.progressEnabled = false
  this.tracker.removeListener('change', this.showProgress)
  this.gauge.disable()
}

var trackerConstructors = ['newGroup', 'newItem', 'newStream']

var mixinLog = function (tracker) {
  // mixin the public methods from log into the tracker
  // (except: conflicts and one's we handle specially)
  Object.keys(log).forEach(function (P) {
    if (P[0] === '_') return
    if (trackerConstructors.filter(function (C) { return C === P }).length) return
    if (tracker[P]) return
    if (typeof log[P] !== 'function') return
    var func = log[P]
    tracker[P] = function () {
      return func.apply(log, arguments)
    }
  })
  // if the new tracker is a group, make sure any subtrackers get
  // mixed in too
  if (tracker instanceof Progress.TrackerGroup) {
    trackerConstructors.forEach(function (C) {
      var func = tracker[C]
      tracker[C] = function () { return mixinLog(func.apply(tracker, arguments)) }
    })
  }
  return tracker
}

// Add tracker constructors to the top level log object
trackerConstructors.forEach(function (C) {
  log[C] = function () { return mixinLog(this.tracker[C].apply(this.tracker, arguments)) }
})

log.clearProgress = function (cb) {
  if (!this.progressEnabled) return cb && process.nextTick(cb)
  this.gauge.hide(cb)
}

log.showProgress = function (name, completed) {
  if (!this.progressEnabled) return
  var values = {}
  if (name) values.section = name
  var last = log.record[log.record.length - 1]
  if (last) {
    values.subsection = last.prefix
    var disp = log.disp[last.level] || last.level
    var logline = this._format(disp, log.style[last.level])
    if (last.prefix) logline += ' ' + this._format(last.prefix, this.prefixStyle)
    logline += ' ' + last.message.split(/\r?\n/)[0]
    values.logline = logline
  }
  values.completed = completed || this.tracker.completed()
  this.gauge.show(values)
}.bind(log) // bind for use in tracker's on-change listener

// temporarily stop emitting, but don't drop
log.pause = function () {
  this._paused = true
  if (this.progressEnabled) this.gauge.disable()
}

log.resume = function () {
  if (!this._paused) return
  this._paused = false

  var b = this._buffer
  this._buffer = []
  b.forEach(function (m) {
    this.emitLog(m)
  }, this)
  if (this.progressEnabled) this.gauge.enable()
}

log._buffer = []

var id = 0
log.record = []
log.maxRecordSize = 10000
log.log = function (lvl, prefix, message) {
  var l = this.levels[lvl]
  if (l === undefined) {
    return this.emit('error', new Error(util.format(
      'Undefined log level: %j', lvl)))
  }

  var a = new Array(arguments.length - 2)
  var stack = null
  for (var i = 2; i < arguments.length; i++) {
    var arg = a[i - 2] = arguments[i]

    // resolve stack traces to a plain string.
    if (typeof arg === 'object' && arg &&
        (arg instanceof Error) && arg.stack) {

      Object.defineProperty(arg, 'stack', {
        value: stack = arg.stack + '',
        enumerable: true,
        writable: true
      })
    }
  }
  if (stack) a.unshift(stack + '\n')
  message = util.format.apply(util, a)

  var m = { id: id++,
            level: lvl,
            prefix: String(prefix || ''),
            message: message,
            messageRaw: a }

  this.emit('log', m)
  this.emit('log.' + lvl, m)
  if (m.prefix) this.emit(m.prefix, m)

  this.record.push(m)
  var mrs = this.maxRecordSize
  var n = this.record.length - mrs
  if (n > mrs / 10) {
    var newSize = Math.floor(mrs * 0.9)
    this.record = this.record.slice(-1 * newSize)
  }

  this.emitLog(m)
}.bind(log)

log.emitLog = function (m) {
  if (this._paused) {
    this._buffer.push(m)
    return
  }
  if (this.progressEnabled) this.gauge.pulse(m.prefix)
  var l = this.levels[m.level]
  if (l === undefined) return
  if (l < this.levels[this.level]) return
  if (l > 0 && !isFinite(l)) return

  // If 'disp' is null or undefined, use the lvl as a default
  // Allows: '', 0 as valid disp
  var disp = log.disp[m.level] != null ? log.disp[m.level] : m.level
  this.clearProgress()
  m.message.split(/\r?\n/).forEach(function (line) {
    if (this.heading) {
      this.write(this.heading, this.headingStyle)
      this.write(' ')
    }
    this.write(disp, log.style[m.level])
    var p = m.prefix || ''
    if (p) this.write(' ')
    this.write(p, this.prefixStyle)
    this.write(' ' + line + '\n')
  }, this)
  this.showProgress()
}

log._format = function (msg, style) {
  if (!stream) return

  var output = ''
  if (this.useColor()) {
    style = style || {}
    var settings = []
    if (style.fg) settings.push(style.fg)
    if (style.bg) settings.push('bg' + style.bg[0].toUpperCase() + style.bg.slice(1))
    if (style.bold) settings.push('bold')
    if (style.underline) settings.push('underline')
    if (style.inverse) settings.push('inverse')
    if (settings.length) output += consoleControl.color(settings)
    if (style.beep) output += consoleControl.beep()
  }
  output += msg
  if (this.useColor()) {
    output += consoleControl.color('reset')
  }
  return output
}

log.write = function (msg, style) {
  if (!stream) return

  stream.write(this._format(msg, style))
}

log.addLevel = function (lvl, n, style, disp) {
  // If 'disp' is null or undefined, use the lvl as a default
  if (disp == null) disp = lvl
  this.levels[lvl] = n
  this.style[lvl] = style
  if (!this[lvl]) {
    this[lvl] = function () {
      var a = new Array(arguments.length + 1)
      a[0] = lvl
      for (var i = 0; i < arguments.length; i++) {
        a[i + 1] = arguments[i]
      }
      return this.log.apply(this, a)
    }.bind(this)
  }
  this.disp[lvl] = disp
}

log.prefixStyle = { fg: 'magenta' }
log.headingStyle = { fg: 'white', bg: 'black' }

log.style = {}
log.levels = {}
log.disp = {}
log.addLevel('silly', -Infinity, { inverse: true }, 'sill')
log.addLevel('verbose', 1000, { fg: 'blue', bg: 'black' }, 'verb')
log.addLevel('info', 2000, { fg: 'green' })
log.addLevel('timing', 2500, { fg: 'green', bg: 'black' })
log.addLevel('http', 3000, { fg: 'green', bg: 'black' })
log.addLevel('notice', 3500, { fg: 'blue', bg: 'black' })
log.addLevel('warn', 4000, { fg: 'black', bg: 'yellow' }, 'WARN')
log.addLevel('error', 5000, { fg: 'red', bg: 'black' }, 'ERR!')
log.addLevel('silent', Infinity)

// allow 'error' prefix
log.on('error', function () {})


/***/ }),

/***/ 62426:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.TrackerGroup = __webpack_require__(33041)
exports.Tracker = __webpack_require__(16039)
exports.TrackerStream = __webpack_require__(93606)


/***/ }),

/***/ 19810:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var EventEmitter = (__webpack_require__(82361).EventEmitter)
var util = __webpack_require__(73837)

var trackerId = 0
var TrackerBase = module.exports = function (name) {
  EventEmitter.call(this)
  this.id = ++trackerId
  this.name = name
}
util.inherits(TrackerBase, EventEmitter)


/***/ }),

/***/ 33041:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var util = __webpack_require__(73837)
var TrackerBase = __webpack_require__(19810)
var Tracker = __webpack_require__(16039)
var TrackerStream = __webpack_require__(93606)

var TrackerGroup = module.exports = function (name) {
  TrackerBase.call(this, name)
  this.parentGroup = null
  this.trackers = []
  this.completion = {}
  this.weight = {}
  this.totalWeight = 0
  this.finished = false
  this.bubbleChange = bubbleChange(this)
}
util.inherits(TrackerGroup, TrackerBase)

function bubbleChange (trackerGroup) {
  return function (name, completed, tracker) {
    trackerGroup.completion[tracker.id] = completed
    if (trackerGroup.finished) return
    trackerGroup.emit('change', name || trackerGroup.name, trackerGroup.completed(), trackerGroup)
  }
}

TrackerGroup.prototype.nameInTree = function () {
  var names = []
  var from = this
  while (from) {
    names.unshift(from.name)
    from = from.parentGroup
  }
  return names.join('/')
}

TrackerGroup.prototype.addUnit = function (unit, weight) {
  if (unit.addUnit) {
    var toTest = this
    while (toTest) {
      if (unit === toTest) {
        throw new Error(
          'Attempted to add tracker group ' +
          unit.name + ' to tree that already includes it ' +
          this.nameInTree(this))
      }
      toTest = toTest.parentGroup
    }
    unit.parentGroup = this
  }
  this.weight[unit.id] = weight || 1
  this.totalWeight += this.weight[unit.id]
  this.trackers.push(unit)
  this.completion[unit.id] = unit.completed()
  unit.on('change', this.bubbleChange)
  if (!this.finished) this.emit('change', unit.name, this.completion[unit.id], unit)
  return unit
}

TrackerGroup.prototype.completed = function () {
  if (this.trackers.length === 0) return 0
  var valPerWeight = 1 / this.totalWeight
  var completed = 0
  for (var ii = 0; ii < this.trackers.length; ii++) {
    var trackerId = this.trackers[ii].id
    completed += valPerWeight * this.weight[trackerId] * this.completion[trackerId]
  }
  return completed
}

TrackerGroup.prototype.newGroup = function (name, weight) {
  return this.addUnit(new TrackerGroup(name), weight)
}

TrackerGroup.prototype.newItem = function (name, todo, weight) {
  return this.addUnit(new Tracker(name, todo), weight)
}

TrackerGroup.prototype.newStream = function (name, todo, weight) {
  return this.addUnit(new TrackerStream(name, todo), weight)
}

TrackerGroup.prototype.finish = function () {
  this.finished = true
  if (!this.trackers.length) this.addUnit(new Tracker(), 1, true)
  for (var ii = 0; ii < this.trackers.length; ii++) {
    var tracker = this.trackers[ii]
    tracker.finish()
    tracker.removeListener('change', this.bubbleChange)
  }
  this.emit('change', this.name, 1, this)
}

var buffer = '                                  '
TrackerGroup.prototype.debug = function (depth) {
  depth = depth || 0
  var indent = depth ? buffer.substr(0, depth) : ''
  var output = indent + (this.name || 'top') + ': ' + this.completed() + '\n'
  this.trackers.forEach(function (tracker) {
    if (tracker instanceof TrackerGroup) {
      output += tracker.debug(depth + 1)
    } else {
      output += indent + ' ' + tracker.name + ': ' + tracker.completed() + '\n'
    }
  })
  return output
}


/***/ }),

/***/ 93606:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var util = __webpack_require__(73837)
var stream = __webpack_require__(48295)
var delegate = __webpack_require__(16285)
var Tracker = __webpack_require__(16039)

var TrackerStream = module.exports = function (name, size, options) {
  stream.Transform.call(this, options)
  this.tracker = new Tracker(name, size)
  this.name = name
  this.id = this.tracker.id
  this.tracker.on('change', delegateChange(this))
}
util.inherits(TrackerStream, stream.Transform)

function delegateChange (trackerStream) {
  return function (name, completion, tracker) {
    trackerStream.emit('change', name, completion, trackerStream)
  }
}

TrackerStream.prototype._transform = function (data, encoding, cb) {
  this.tracker.completeWork(data.length ? data.length : 1)
  this.push(data)
  cb()
}

TrackerStream.prototype._flush = function (cb) {
  this.tracker.finish()
  cb()
}

delegate(TrackerStream.prototype, 'tracker')
  .method('completed')
  .method('addWork')
  .method('finish')


/***/ }),

/***/ 16039:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var util = __webpack_require__(73837)
var TrackerBase = __webpack_require__(19810)

var Tracker = module.exports = function (name, todo) {
  TrackerBase.call(this, name)
  this.workDone = 0
  this.workTodo = todo || 0
}
util.inherits(Tracker, TrackerBase)

Tracker.prototype.completed = function () {
  return this.workTodo === 0 ? 0 : this.workDone / this.workTodo
}

Tracker.prototype.addWork = function (work) {
  this.workTodo += work
  this.emit('change', this.name, this.completed(), this)
}

Tracker.prototype.completeWork = function (work) {
  this.workDone += work
  if (this.workDone > this.workTodo) this.workDone = this.workTodo
  this.emit('change', this.name, this.completed(), this)
}

Tracker.prototype.finish = function () {
  this.workTodo = this.workDone = 1
  this.emit('change', this.name, 1, this)
}


/***/ }),

/***/ 61516:
/***/ ((module) => {

"use strict";

module.exports = Number.isNaN || function (x) {
	return x !== x;
};


/***/ }),

/***/ 4439:
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ 36985:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const pLimit = __webpack_require__(32042);

class EndError extends Error {
	constructor(value) {
		super();
		this.value = value;
	}
}

// The input can also be a promise, so we await it
const testElement = async (element, tester) => tester(await element);

// The input can also be a promise, so we `Promise.all()` them both
const finder = async element => {
	const values = await Promise.all(element);
	if (values[1] === true) {
		throw new EndError(values[0]);
	}

	return false;
};

const pLocate = async (iterable, tester, options) => {
	options = {
		concurrency: Infinity,
		preserveOrder: true,
		...options
	};

	const limit = pLimit(options.concurrency);

	// Start all the promises concurrently with optional limit
	const items = [...iterable].map(element => [element, limit(testElement, element, tester)]);

	// Check the promises either serially or concurrently
	const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);

	try {
		await Promise.all(items.map(element => checkLimit(finder, element)));
	} catch (error) {
		if (error instanceof EndError) {
			return error.value;
		}

		throw error;
	}
};

module.exports = pLocate;
// TODO: Remove this for the next major release
module.exports["default"] = pLocate;


/***/ }),

/***/ 32042:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const pTry = __webpack_require__(66001);

const pLimit = concurrency => {
	if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
		return Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'));
	}

	const queue = [];
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.length > 0) {
			queue.shift()();
		}
	};

	const run = (fn, resolve, ...args) => {
		activeCount++;

		const result = pTry(fn, ...args);

		resolve(result);

		result.then(next, next);
	};

	const enqueue = (fn, resolve, ...args) => {
		if (activeCount < concurrency) {
			run(fn, resolve, ...args);
		} else {
			queue.push(run.bind(null, fn, resolve, ...args));
		}
	};

	const generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));
	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount
		},
		pendingCount: {
			get: () => queue.length
		},
		clearQueue: {
			value: () => {
				queue.length = 0;
			}
		}
	});

	return generator;
};

module.exports = pLimit;
module.exports["default"] = pLimit;


/***/ }),

/***/ 66001:
/***/ ((module) => {

"use strict";


const pTry = (fn, ...arguments_) => new Promise(resolve => {
	resolve(fn(...arguments_));
});

module.exports = pTry;
// TODO: remove this in the next major version
module.exports["default"] = pTry;


/***/ }),

/***/ 45955:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(57147);
const {promisify} = __webpack_require__(73837);

const pAccess = promisify(fs.access);

module.exports = async path => {
	try {
		await pAccess(path);
		return true;
	} catch (_) {
		return false;
	}
};

module.exports.sync = path => {
	try {
		fs.accessSync(path);
		return true;
	} catch (_) {
		return false;
	}
};


/***/ }),

/***/ 26899:
/***/ (function(module) {

// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);



/***/ }),

/***/ 61053:
/***/ (function(module) {

/* global define */

(function (root, pluralize) {
  /* istanbul ignore else */
  if (true) {
    // Node.
    module.exports = pluralize();
  } else {}
})(this, function () {
  // Rule storage - pluralize and singularize need to be run sequentially,
  // while other rules can be optimized using an object for instant lookups.
  var pluralRules = [];
  var singularRules = [];
  var uncountables = {};
  var irregularPlurals = {};
  var irregularSingles = {};

  /**
   * Sanitize a pluralization rule to a usable regular expression.
   *
   * @param  {(RegExp|string)} rule
   * @return {RegExp}
   */
  function sanitizeRule (rule) {
    if (typeof rule === 'string') {
      return new RegExp('^' + rule + '$', 'i');
    }

    return rule;
  }

  /**
   * Pass in a word token to produce a function that can replicate the case on
   * another word.
   *
   * @param  {string}   word
   * @param  {string}   token
   * @return {Function}
   */
  function restoreCase (word, token) {
    // Tokens are an exact match.
    if (word === token) return token;

    // Lower cased words. E.g. "hello".
    if (word === word.toLowerCase()) return token.toLowerCase();

    // Upper cased words. E.g. "WHISKY".
    if (word === word.toUpperCase()) return token.toUpperCase();

    // Title cased words. E.g. "Title".
    if (word[0] === word[0].toUpperCase()) {
      return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
    }

    // Lower cased words. E.g. "test".
    return token.toLowerCase();
  }

  /**
   * Interpolate a regexp string.
   *
   * @param  {string} str
   * @param  {Array}  args
   * @return {string}
   */
  function interpolate (str, args) {
    return str.replace(/\$(\d{1,2})/g, function (match, index) {
      return args[index] || '';
    });
  }

  /**
   * Replace a word using a rule.
   *
   * @param  {string} word
   * @param  {Array}  rule
   * @return {string}
   */
  function replace (word, rule) {
    return word.replace(rule[0], function (match, index) {
      var result = interpolate(rule[1], arguments);

      if (match === '') {
        return restoreCase(word[index - 1], result);
      }

      return restoreCase(match, result);
    });
  }

  /**
   * Sanitize a word by passing in the word and sanitization rules.
   *
   * @param  {string}   token
   * @param  {string}   word
   * @param  {Array}    rules
   * @return {string}
   */
  function sanitizeWord (token, word, rules) {
    // Empty string or doesn't need fixing.
    if (!token.length || uncountables.hasOwnProperty(token)) {
      return word;
    }

    var len = rules.length;

    // Iterate over the sanitization rules and use the first one to match.
    while (len--) {
      var rule = rules[len];

      if (rule[0].test(word)) return replace(word, rule);
    }

    return word;
  }

  /**
   * Replace a word with the updated word.
   *
   * @param  {Object}   replaceMap
   * @param  {Object}   keepMap
   * @param  {Array}    rules
   * @return {Function}
   */
  function replaceWord (replaceMap, keepMap, rules) {
    return function (word) {
      // Get the correct token and case restoration functions.
      var token = word.toLowerCase();

      // Check against the keep object map.
      if (keepMap.hasOwnProperty(token)) {
        return restoreCase(word, token);
      }

      // Check against the replacement map for a direct word replacement.
      if (replaceMap.hasOwnProperty(token)) {
        return restoreCase(word, replaceMap[token]);
      }

      // Run all the rules against the word.
      return sanitizeWord(token, word, rules);
    };
  }

  /**
   * Check if a word is part of the map.
   */
  function checkWord (replaceMap, keepMap, rules, bool) {
    return function (word) {
      var token = word.toLowerCase();

      if (keepMap.hasOwnProperty(token)) return true;
      if (replaceMap.hasOwnProperty(token)) return false;

      return sanitizeWord(token, token, rules) === token;
    };
  }

  /**
   * Pluralize or singularize a word based on the passed in count.
   *
   * @param  {string}  word      The word to pluralize
   * @param  {number}  count     How many of the word exist
   * @param  {boolean} inclusive Whether to prefix with the number (e.g. 3 ducks)
   * @return {string}
   */
  function pluralize (word, count, inclusive) {
    var pluralized = count === 1
      ? pluralize.singular(word) : pluralize.plural(word);

    return (inclusive ? count + ' ' : '') + pluralized;
  }

  /**
   * Pluralize a word.
   *
   * @type {Function}
   */
  pluralize.plural = replaceWord(
    irregularSingles, irregularPlurals, pluralRules
  );

  /**
   * Check if a word is plural.
   *
   * @type {Function}
   */
  pluralize.isPlural = checkWord(
    irregularSingles, irregularPlurals, pluralRules
  );

  /**
   * Singularize a word.
   *
   * @type {Function}
   */
  pluralize.singular = replaceWord(
    irregularPlurals, irregularSingles, singularRules
  );

  /**
   * Check if a word is singular.
   *
   * @type {Function}
   */
  pluralize.isSingular = checkWord(
    irregularPlurals, irregularSingles, singularRules
  );

  /**
   * Add a pluralization rule to the collection.
   *
   * @param {(string|RegExp)} rule
   * @param {string}          replacement
   */
  pluralize.addPluralRule = function (rule, replacement) {
    pluralRules.push([sanitizeRule(rule), replacement]);
  };

  /**
   * Add a singularization rule to the collection.
   *
   * @param {(string|RegExp)} rule
   * @param {string}          replacement
   */
  pluralize.addSingularRule = function (rule, replacement) {
    singularRules.push([sanitizeRule(rule), replacement]);
  };

  /**
   * Add an uncountable word rule.
   *
   * @param {(string|RegExp)} word
   */
  pluralize.addUncountableRule = function (word) {
    if (typeof word === 'string') {
      uncountables[word.toLowerCase()] = true;
      return;
    }

    // Set singular and plural references for the word.
    pluralize.addPluralRule(word, '$0');
    pluralize.addSingularRule(word, '$0');
  };

  /**
   * Add an irregular word definition.
   *
   * @param {string} single
   * @param {string} plural
   */
  pluralize.addIrregularRule = function (single, plural) {
    plural = plural.toLowerCase();
    single = single.toLowerCase();

    irregularSingles[single] = plural;
    irregularPlurals[plural] = single;
  };

  /**
   * Irregular rules.
   */
  [
    // Pronouns.
    ['I', 'we'],
    ['me', 'us'],
    ['he', 'they'],
    ['she', 'they'],
    ['them', 'them'],
    ['myself', 'ourselves'],
    ['yourself', 'yourselves'],
    ['itself', 'themselves'],
    ['herself', 'themselves'],
    ['himself', 'themselves'],
    ['themself', 'themselves'],
    ['is', 'are'],
    ['was', 'were'],
    ['has', 'have'],
    ['this', 'these'],
    ['that', 'those'],
    // Words ending in with a consonant and `o`.
    ['echo', 'echoes'],
    ['dingo', 'dingoes'],
    ['volcano', 'volcanoes'],
    ['tornado', 'tornadoes'],
    ['torpedo', 'torpedoes'],
    // Ends with `us`.
    ['genus', 'genera'],
    ['viscus', 'viscera'],
    // Ends with `ma`.
    ['stigma', 'stigmata'],
    ['stoma', 'stomata'],
    ['dogma', 'dogmata'],
    ['lemma', 'lemmata'],
    ['schema', 'schemata'],
    ['anathema', 'anathemata'],
    // Other irregular rules.
    ['ox', 'oxen'],
    ['axe', 'axes'],
    ['die', 'dice'],
    ['yes', 'yeses'],
    ['foot', 'feet'],
    ['eave', 'eaves'],
    ['goose', 'geese'],
    ['tooth', 'teeth'],
    ['quiz', 'quizzes'],
    ['human', 'humans'],
    ['proof', 'proofs'],
    ['carve', 'carves'],
    ['valve', 'valves'],
    ['looey', 'looies'],
    ['thief', 'thieves'],
    ['groove', 'grooves'],
    ['pickaxe', 'pickaxes'],
    ['passerby', 'passersby']
  ].forEach(function (rule) {
    return pluralize.addIrregularRule(rule[0], rule[1]);
  });

  /**
   * Pluralization rules.
   */
  [
    [/s?$/i, 's'],
    [/[^\u0000-\u007F]$/i, '$0'],
    [/([^aeiou]ese)$/i, '$1'],
    [/(ax|test)is$/i, '$1es'],
    [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, '$1es'],
    [/(e[mn]u)s?$/i, '$1s'],
    [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, '$1'],
    [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1i'],
    [/(alumn|alg|vertebr)(?:a|ae)$/i, '$1ae'],
    [/(seraph|cherub)(?:im)?$/i, '$1im'],
    [/(her|at|gr)o$/i, '$1oes'],
    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, '$1a'],
    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, '$1a'],
    [/sis$/i, 'ses'],
    [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, '$1$2ves'],
    [/([^aeiouy]|qu)y$/i, '$1ies'],
    [/([^ch][ieo][ln])ey$/i, '$1ies'],
    [/(x|ch|ss|sh|zz)$/i, '$1es'],
    [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, '$1ices'],
    [/\b((?:tit)?m|l)(?:ice|ouse)$/i, '$1ice'],
    [/(pe)(?:rson|ople)$/i, '$1ople'],
    [/(child)(?:ren)?$/i, '$1ren'],
    [/eaux$/i, '$0'],
    [/m[ae]n$/i, 'men'],
    ['thou', 'you']
  ].forEach(function (rule) {
    return pluralize.addPluralRule(rule[0], rule[1]);
  });

  /**
   * Singularization rules.
   */
  [
    [/s$/i, ''],
    [/(ss)$/i, '$1'],
    [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, '$1fe'],
    [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, '$1f'],
    [/ies$/i, 'y'],
    [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, '$1ie'],
    [/\b(mon|smil)ies$/i, '$1ey'],
    [/\b((?:tit)?m|l)ice$/i, '$1ouse'],
    [/(seraph|cherub)im$/i, '$1'],
    [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, '$1'],
    [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, '$1sis'],
    [/(movie|twelve|abuse|e[mn]u)s$/i, '$1'],
    [/(test)(?:is|es)$/i, '$1is'],
    [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1us'],
    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, '$1um'],
    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, '$1on'],
    [/(alumn|alg|vertebr)ae$/i, '$1a'],
    [/(cod|mur|sil|vert|ind)ices$/i, '$1ex'],
    [/(matr|append)ices$/i, '$1ix'],
    [/(pe)(rson|ople)$/i, '$1rson'],
    [/(child)ren$/i, '$1'],
    [/(eau)x?$/i, '$1'],
    [/men$/i, 'man']
  ].forEach(function (rule) {
    return pluralize.addSingularRule(rule[0], rule[1]);
  });

  /**
   * Uncountable rules.
   */
  [
    // Singular words with no plurals.
    'adulthood',
    'advice',
    'agenda',
    'aid',
    'aircraft',
    'alcohol',
    'ammo',
    'analytics',
    'anime',
    'athletics',
    'audio',
    'bison',
    'blood',
    'bream',
    'buffalo',
    'butter',
    'carp',
    'cash',
    'chassis',
    'chess',
    'clothing',
    'cod',
    'commerce',
    'cooperation',
    'corps',
    'debris',
    'diabetes',
    'digestion',
    'elk',
    'energy',
    'equipment',
    'excretion',
    'expertise',
    'firmware',
    'flounder',
    'fun',
    'gallows',
    'garbage',
    'graffiti',
    'hardware',
    'headquarters',
    'health',
    'herpes',
    'highjinks',
    'homework',
    'housework',
    'information',
    'jeans',
    'justice',
    'kudos',
    'labour',
    'literature',
    'machinery',
    'mackerel',
    'mail',
    'media',
    'mews',
    'moose',
    'music',
    'mud',
    'manga',
    'news',
    'only',
    'personnel',
    'pike',
    'plankton',
    'pliers',
    'police',
    'pollution',
    'premises',
    'rain',
    'research',
    'rice',
    'salmon',
    'scissors',
    'series',
    'sewage',
    'shambles',
    'shrimp',
    'software',
    'species',
    'staff',
    'swine',
    'tennis',
    'traffic',
    'transportation',
    'trout',
    'tuna',
    'wealth',
    'welfare',
    'whiting',
    'wildebeest',
    'wildlife',
    'you',
    /pok[e]mon$/i,
    // Regexes.
    /[^aeiou]ese$/i, // "chinese", "japanese"
    /deer$/i, // "deer", "reindeer"
    /fish$/i, // "fish", "blowfish", "angelfish"
    /measles$/i,
    /o[iu]s$/i, // "carnivorous"
    /pox$/i, // "chickpox", "smallpox"
    /sheep$/i
  ].forEach(pluralize.addUncountableRule);

  return pluralize;
});


/***/ }),

/***/ 65552:
/***/ ((module) => {

"use strict";


if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}



/***/ }),

/***/ 55101:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(65552);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(__webpack_require__(22862));
util.inherits = __webpack_require__(15822);
/*</replacement>*/

var Readable = __webpack_require__(6246);
var Writable = __webpack_require__(90609);

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ 17153:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(16889);

/*<replacement>*/
var util = Object.create(__webpack_require__(22862));
util.inherits = __webpack_require__(15822);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ 6246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(65552);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(1538);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = (__webpack_require__(82361).EventEmitter);

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(4804);
/*</replacement>*/

/*<replacement>*/

var Buffer = (__webpack_require__(60682).Buffer);
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(__webpack_require__(22862));
util.inherits = __webpack_require__(15822);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(73837);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(75335);
var destroyImpl = __webpack_require__(16946);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(55101);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(68234)/* .StringDecoder */ .s);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(55101);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(68234)/* .StringDecoder */ .s);
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),

/***/ 16889:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(55101);

/*<replacement>*/
var util = Object.create(__webpack_require__(22862));
util.inherits = __webpack_require__(15822);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ 90609:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(65552);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(__webpack_require__(22862));
util.inherits = __webpack_require__(15822);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(58767)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(4804);
/*</replacement>*/

/*<replacement>*/

var Buffer = (__webpack_require__(60682).Buffer);
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(16946);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(55101);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(55101);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

/***/ }),

/***/ 75335:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = (__webpack_require__(60682).Buffer);
var util = __webpack_require__(73837);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ 16946:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(65552);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ 4804:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(12781);


/***/ }),

/***/ 1538:
/***/ ((module) => {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ 60682:
/***/ ((module, exports, __webpack_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(14300)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 68234:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(60682).Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 48295:
/***/ ((module, exports, __webpack_require__) => {

var Stream = __webpack_require__(12781);
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
  exports = module.exports = Stream.Readable;
  exports.Readable = Stream.Readable;
  exports.Writable = Stream.Writable;
  exports.Duplex = Stream.Duplex;
  exports.Transform = Stream.Transform;
  exports.PassThrough = Stream.PassThrough;
  exports.Stream = Stream;
} else {
  exports = module.exports = __webpack_require__(6246);
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __webpack_require__(90609);
  exports.Duplex = __webpack_require__(55101);
  exports.Transform = __webpack_require__(16889);
  exports.PassThrough = __webpack_require__(17153);
}


/***/ }),

/***/ 92775:
/***/ (() => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ 27947:
/***/ ((module) => {

"use strict";
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */



/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

module.exports = repeat;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  } else if (res.length >= max) {
    return res.substr(0, max);
  }

  while (max > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    str += str;
  }

  res += str;
  res = res.substr(0, max);
  return res;
}


/***/ }),

/***/ 10241:
/***/ ((module) => {

module.exports = function (blocking) {
  [process.stdout, process.stderr].forEach(function (stream) {
    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {
      stream._handle.setBlocking(blocking)
    }
  })
}


/***/ }),

/***/ 88073:
/***/ ((module) => {

"use strict";


function isFunction (funktion) {
  return typeof funktion === 'function'
}

// Default to complaining loudly when things don't go according to plan.
var logger = console.error.bind(console)

// Sets a property on an object, preserving its enumerability.
// This function assumes that the property is already writable.
function defineProperty (obj, name, value) {
  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name)
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: enumerable,
    writable: true,
    value: value
  })
}

// Keep initialization idempotent.
function shimmer (options) {
  if (options && options.logger) {
    if (!isFunction(options.logger)) logger("new logger isn't a function, not replacing")
    else logger = options.logger
  }
}

function wrap (nodule, name, wrapper) {
  if (!nodule || !nodule[name]) {
    logger('no original function ' + name + ' to wrap')
    return
  }

  if (!wrapper) {
    logger('no wrapper function')
    logger((new Error()).stack)
    return
  }

  if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
    logger('original object and wrapper must be functions')
    return
  }

  var original = nodule[name]
  var wrapped = wrapper(original, name)

  defineProperty(wrapped, '__original', original)
  defineProperty(wrapped, '__unwrap', function () {
    if (nodule[name] === wrapped) defineProperty(nodule, name, original)
  })
  defineProperty(wrapped, '__wrapped', true)

  defineProperty(nodule, name, wrapped)
  return wrapped
}

function massWrap (nodules, names, wrapper) {
  if (!nodules) {
    logger('must provide one or more modules to patch')
    logger((new Error()).stack)
    return
  } else if (!Array.isArray(nodules)) {
    nodules = [nodules]
  }

  if (!(names && Array.isArray(names))) {
    logger('must provide one or more functions to wrap on modules')
    return
  }

  nodules.forEach(function (nodule) {
    names.forEach(function (name) {
      wrap(nodule, name, wrapper)
    })
  })
}

function unwrap (nodule, name) {
  if (!nodule || !nodule[name]) {
    logger('no function to unwrap.')
    logger((new Error()).stack)
    return
  }

  if (!nodule[name].__unwrap) {
    logger('no original to unwrap to -- has ' + name + ' already been unwrapped?')
  } else {
    return nodule[name].__unwrap()
  }
}

function massUnwrap (nodules, names) {
  if (!nodules) {
    logger('must provide one or more modules to patch')
    logger((new Error()).stack)
    return
  } else if (!Array.isArray(nodules)) {
    nodules = [nodules]
  }

  if (!(names && Array.isArray(names))) {
    logger('must provide one or more functions to unwrap on modules')
    return
  }

  nodules.forEach(function (nodule) {
    names.forEach(function (name) {
      unwrap(nodule, name)
    })
  })
}

shimmer.wrap = wrap
shimmer.massWrap = massWrap
shimmer.unwrap = unwrap
shimmer.massUnwrap = massUnwrap

module.exports = shimmer


/***/ }),

/***/ 40412:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
var assert = __webpack_require__(39491)
var signals = __webpack_require__(86884)
var isWin = /^win/i.test(process.platform)

var EE = __webpack_require__(82361)
/* istanbul ignore if */
if (typeof EE !== 'function') {
  EE = EE.EventEmitter
}

var emitter
if (process.__signal_exit_emitter__) {
  emitter = process.__signal_exit_emitter__
} else {
  emitter = process.__signal_exit_emitter__ = new EE()
  emitter.count = 0
  emitter.emitted = {}
}

// Because this emitter is a global, we have to check to see if a
// previous version of this library failed to enable infinite listeners.
// I know what you're about to say.  But literally everything about
// signal-exit is a compromise with evil.  Get used to it.
if (!emitter.infinite) {
  emitter.setMaxListeners(Infinity)
  emitter.infinite = true
}

module.exports = function (cb, opts) {
  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')

  if (loaded === false) {
    load()
  }

  var ev = 'exit'
  if (opts && opts.alwaysLast) {
    ev = 'afterexit'
  }

  var remove = function () {
    emitter.removeListener(ev, cb)
    if (emitter.listeners('exit').length === 0 &&
        emitter.listeners('afterexit').length === 0) {
      unload()
    }
  }
  emitter.on(ev, cb)

  return remove
}

module.exports.unload = unload
function unload () {
  if (!loaded) {
    return
  }
  loaded = false

  signals.forEach(function (sig) {
    try {
      process.removeListener(sig, sigListeners[sig])
    } catch (er) {}
  })
  process.emit = originalProcessEmit
  process.reallyExit = originalProcessReallyExit
  emitter.count -= 1
}

function emit (event, code, signal) {
  if (emitter.emitted[event]) {
    return
  }
  emitter.emitted[event] = true
  emitter.emit(event, code, signal)
}

// { <signal>: <listener fn>, ... }
var sigListeners = {}
signals.forEach(function (sig) {
  sigListeners[sig] = function listener () {
    // If there are no other listeners, an exit is coming!
    // Simplest way: remove us and then re-send the signal.
    // We know that this will kill the process, so we can
    // safely emit now.
    var listeners = process.listeners(sig)
    if (listeners.length === emitter.count) {
      unload()
      emit('exit', null, sig)
      /* istanbul ignore next */
      emit('afterexit', null, sig)
      /* istanbul ignore next */
      if (isWin && sig === 'SIGHUP') {
        // "SIGHUP" throws an `ENOSYS` error on Windows,
        // so use a supported signal instead
        sig = 'SIGINT'
      }
      process.kill(process.pid, sig)
    }
  }
})

module.exports.signals = function () {
  return signals
}

module.exports.load = load

var loaded = false

function load () {
  if (loaded) {
    return
  }
  loaded = true

  // This is the number of onSignalExit's that are in play.
  // It's important so that we can count the correct number of
  // listeners on signals, and don't wait for the other one to
  // handle it instead of us.
  emitter.count += 1

  signals = signals.filter(function (sig) {
    try {
      process.on(sig, sigListeners[sig])
      return true
    } catch (er) {
      return false
    }
  })

  process.emit = processEmit
  process.reallyExit = processReallyExit
}

var originalProcessReallyExit = process.reallyExit
function processReallyExit (code) {
  process.exitCode = code || 0
  emit('exit', process.exitCode, null)
  /* istanbul ignore next */
  emit('afterexit', process.exitCode, null)
  /* istanbul ignore next */
  originalProcessReallyExit.call(process, process.exitCode)
}

var originalProcessEmit = process.emit
function processEmit (ev, arg) {
  if (ev === 'exit') {
    if (arg !== undefined) {
      process.exitCode = arg
    }
    var ret = originalProcessEmit.apply(this, arguments)
    emit('exit', process.exitCode, null)
    /* istanbul ignore next */
    emit('afterexit', process.exitCode, null)
    return ret
  } else {
    return originalProcessEmit.apply(this, arguments)
  }
}


/***/ }),

/***/ 86884:
/***/ ((module) => {

// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
module.exports = [
  'SIGABRT',
  'SIGALRM',
  'SIGHUP',
  'SIGINT',
  'SIGTERM'
]

if (process.platform !== 'win32') {
  module.exports.push(
    'SIGVTALRM',
    'SIGXCPU',
    'SIGXFSZ',
    'SIGUSR2',
    'SIGTRAP',
    'SIGSYS',
    'SIGQUIT',
    'SIGIOT'
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
  )
}

if (process.platform === 'linux') {
  module.exports.push(
    'SIGIO',
    'SIGPOLL',
    'SIGPWR',
    'SIGSTKFLT',
    'SIGUNUSED'
  )
}


/***/ }),

/***/ 99965:
/***/ ((module) => {

// Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function FormatErrorString(error) {
  try {
    return Error.prototype.toString.call(error);
  } catch (e) {
    try {
      return "<error: " + e + ">";
    } catch (ee) {
      return "<error>";
    }
  }
}

module.exports = function FormatStackTrace(error, frames) {
  var lines = [];
  lines.push(FormatErrorString(error));
  for (var i = 0; i < frames.length; i++) {
    var frame = frames[i];
    var line;
    try {
      line = frame.toString();
    } catch (e) {
      try {
        line = "<error: " + e + ">";
      } catch (ee) {
        // Any code that reaches this point is seriously nasty!
        line = "<error>";
      }
    }
    lines.push("    at " + line);
  }
  return lines.join("\n");
};


/***/ }),

/***/ 33705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// If a another copy (same version or not) of stack-chain exists it will result
// in wrong stack traces (most likely dublicate callSites).
if (global._stackChain) {
  // In case the version match, we can simply return the first initialized copy
  if (global._stackChain.version === (__webpack_require__(53412)/* .version */ .i8)) {
    module.exports = global._stackChain;
  }
  // The version don't match, this is really bad. Lets just throw
  else {
    throw new Error('Conflicting version of stack-chain found');
  }
}
// Yay, no other stack-chain copy exists, yet :/
else {
  module.exports = global._stackChain = __webpack_require__(4419);
}


/***/ }),

/***/ 4419:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


// use a already existing formater or fallback to the default v8 formater
var defaultFormater = __webpack_require__(99965);

// public define API
function stackChain() {
  this.extend = new TraceModifier();
  this.filter = new TraceModifier();
  this.format = new StackFormater();
  this.version = (__webpack_require__(53412)/* .version */ .i8);
}


var SHORTCIRCUIT_CALLSITE = false;
stackChain.prototype.callSite = function collectCallSites(options) {
  if (!options) options = {};

  // Get CallSites
  SHORTCIRCUIT_CALLSITE = true;
  var obj = {};
  Error.captureStackTrace(obj, collectCallSites);
  var callSites = obj.stack;
  SHORTCIRCUIT_CALLSITE = false;

  // Slice
  callSites = callSites.slice(options.slice || 0);

  // Modify CallSites
  if (options.extend) callSites = this.extend._modify(obj, callSites);
  if (options.filter) callSites = this.filter._modify(obj, callSites);

  // Done
  return callSites;
};

var chain = new stackChain();

function TraceModifier() {
  this._modifiers = [];
}

TraceModifier.prototype._modify = function (error, frames) {
  for (var i = 0, l = this._modifiers.length; i < l; i++) {
    frames = this._modifiers[i](error, frames);
  }

  return frames;
};

TraceModifier.prototype.attach = function (modifier) {
  this._modifiers.push(modifier);
};

TraceModifier.prototype.deattach = function (modifier) {
  var index = this._modifiers.indexOf(modifier);

  if (index === -1) return false;

  this._modifiers.splice(index, 1);
  return true;
};

function StackFormater() {
  this._formater = defaultFormater;
  this._previous = undefined;
}

StackFormater.prototype.replace = function (formater) {
  if (formater) {
    this._formater = formater;
  } else {
    this.restore();
  }
};

StackFormater.prototype.restore  = function () {
  this._formater = defaultFormater;
  this._previous = undefined;
};

StackFormater.prototype._backup = function () {
  this._previous = this._formater;
};

StackFormater.prototype._roolback = function () {
  if (this._previous === defaultFormater) {
    this.replace(undefined);
  } else {
    this.replace(this._previous);
  }

  this._previous = undefined;
};


//
// Set Error.prepareStackTrace thus allowing stack-chain
// to take control of the Error().stack formating.
//

// If there already is a custom stack formater, then set
// that as the stack-chain formater.
if (Error.prepareStackTrace) {
    chain.format.replace(Error.prepareStackTrace);
}

var SHORTCIRCUIT_FORMATER = false;
function prepareStackTrace(error, originalFrames) {
  if (SHORTCIRCUIT_CALLSITE) return originalFrames;
  if (SHORTCIRCUIT_FORMATER) return defaultFormater(error, originalFrames);

  // Make a loss copy of originalFrames
  var frames = originalFrames.concat();

  // extend frames
  frames = chain.extend._modify(error, frames);

  // filter frames
  frames = chain.filter._modify(error, frames);

  // reduce frames to match Error.stackTraceLimit
  frames = frames.slice(0, Error.stackTraceLimit);

  // Set the callSite property
  // But only if it hasn't been explicitly set, otherwise
  // error.stack would have unintended side effects. Check also for
  // non-extensible/sealed objects, such as those from Google's Closure Library
  if (Object.isExtensible(error) &&
      (Object.getOwnPropertyDescriptor(error, "callSite") === undefined)) {
    error.callSite = {
      original: originalFrames,
      mutated: frames
    };
  }

  // format frames
  SHORTCIRCUIT_FORMATER = true;
  var format = chain.format._formater(error, frames);
  SHORTCIRCUIT_FORMATER = false;

  return format;
}

// Replace the v8 stack trace creator
Object.defineProperty(Error, 'prepareStackTrace', {
  'get': function () {
    return prepareStackTrace;
  },

  'set': function (formater) {
    // If formater is prepareStackTrace it means that someone ran
    // var old = Error.prepareStackTrace;
    // Error.prepareStackTrace = custom
    // new Error().stack
    // Error.prepareStackTrace = old;
    // The effect of this, should be that the old behaviour is restored.
    if (formater === prepareStackTrace) {
      chain.format._roolback();
    }
    // Error.prepareStackTrace was set, this means that someone is
    // trying to take control of the Error().stack format. Make
    // them belive they succeeded by setting them up as the stack-chain
    // formater.
    else {
      chain.format._backup();
      chain.format.replace(formater);
    }
  }
});

//
// Manage call site storeage
//
function callSiteGetter() {
  // calculate call site object
  this.stack;

  // return call site object
  return this.callSite;
}

Object.defineProperty(Error.prototype, 'callSite', {
  'get': callSiteGetter,

  'set': function (frames) {
    // In case callSite was set before [[getter]], just set
    // the value
    Object.defineProperty(this, 'callSite', {
        value: frames,
        writable: true,
        configurable: true
    });
  },

  configurable: true
});

module.exports = chain;


/***/ }),

/***/ 82035:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(22037);
const tty = __webpack_require__(76224);
const hasFlag = __webpack_require__(1384);

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ 58767:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __webpack_require__(73837).deprecate;


/***/ }),

/***/ 61096:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextDocument": () => (/* binding */ TextDocument)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (changes, version) {
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
            var change = changes_1[_i];
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                var range = getWellformedRange(change.range);
                // update content
                var startOffset = this.offsetAt(range.start);
                var endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                var startLine = Math.max(range.start.line, 0);
                var endLine = Math.max(range.end.line, 0);
                var lineOffsets = this._lineOffsets;
                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                }
                else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));
                    }
                    else { // avoid too many arguments for splice
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                var diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            }
            else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            }
            else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return { line: line, character: offset - lineOffsets[line] };
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.isIncremental = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    };
    FullTextDocument.isFull = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    };
    return FullTextDocument;
}());
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifing its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
        }
        else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = 0;
        var spans = [];
        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
            var e = sortedEdits_1[_i];
            var startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
                throw new Error('Overlapping edit');
            }
            else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
                spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join('');
    }
    TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    var p = (data.length / 2) | 0;
    var left = data.slice(0, p);
    var right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        var ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset) {
    if (textOffset === void 0) { textOffset = 0; }
    var result = isAtLineStart ? [textOffset] : [];
    for (var i = 0; i < text.length; i++) {
        var ch = text.charCodeAt(i);
        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function getWellformedRange(range) {
    var start = range.start;
    var end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    var range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range: range };
    }
    return textEdit;
}


/***/ }),

/***/ 24227:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Generated by CoffeeScript 1.12.4
var Dumper, Inline, Utils;

Utils = __webpack_require__(66622);

Inline = __webpack_require__(33658);

Dumper = (function() {
  function Dumper() {}

  Dumper.indentation = 4;

  Dumper.prototype.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    var i, key, len, output, prefix, value, willBeInlined;
    if (inline == null) {
      inline = 0;
    }
    if (indent == null) {
      indent = 0;
    }
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectEncoder == null) {
      objectEncoder = null;
    }
    output = '';
    prefix = (indent ? Utils.strRepeat(' ', indent) : '');
    if (inline <= 0 || typeof input !== 'object' || input instanceof Date || Utils.isEmpty(input)) {
      output += prefix + Inline.dump(input, exceptionOnInvalidType, objectEncoder);
    } else {
      if (input instanceof Array) {
        for (i = 0, len = input.length; i < len; i++) {
          value = input[i];
          willBeInlined = inline - 1 <= 0 || typeof value !== 'object' || Utils.isEmpty(value);
          output += prefix + '-' + (willBeInlined ? ' ' : "\n") + this.dump(value, inline - 1, (willBeInlined ? 0 : indent + this.indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : '');
        }
      } else {
        for (key in input) {
          value = input[key];
          willBeInlined = inline - 1 <= 0 || typeof value !== 'object' || Utils.isEmpty(value);
          output += prefix + Inline.dump(key, exceptionOnInvalidType, objectEncoder) + ':' + (willBeInlined ? ' ' : "\n") + this.dump(value, inline - 1, (willBeInlined ? 0 : indent + this.indentation), exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : '');
        }
      }
    }
    return output;
  };

  return Dumper;

})();

module.exports = Dumper;


/***/ }),

/***/ 96279:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Generated by CoffeeScript 1.12.4
var Escaper, Pattern;

Pattern = __webpack_require__(42801);

Escaper = (function() {
  var ch;

  function Escaper() {}

  Escaper.LIST_ESCAPEES = ['\\', '\\\\', '\\"', '"', "\x00", "\x01", "\x02", "\x03", "\x04", "\x05", "\x06", "\x07", "\x08", "\x09", "\x0a", "\x0b", "\x0c", "\x0d", "\x0e", "\x0f", "\x10", "\x11", "\x12", "\x13", "\x14", "\x15", "\x16", "\x17", "\x18", "\x19", "\x1a", "\x1b", "\x1c", "\x1d", "\x1e", "\x1f", (ch = String.fromCharCode)(0x0085), ch(0x00A0), ch(0x2028), ch(0x2029)];

  Escaper.LIST_ESCAPED = ['\\\\', '\\"', '\\"', '\\"', "\\0", "\\x01", "\\x02", "\\x03", "\\x04", "\\x05", "\\x06", "\\a", "\\b", "\\t", "\\n", "\\v", "\\f", "\\r", "\\x0e", "\\x0f", "\\x10", "\\x11", "\\x12", "\\x13", "\\x14", "\\x15", "\\x16", "\\x17", "\\x18", "\\x19", "\\x1a", "\\e", "\\x1c", "\\x1d", "\\x1e", "\\x1f", "\\N", "\\_", "\\L", "\\P"];

  Escaper.MAPPING_ESCAPEES_TO_ESCAPED = (function() {
    var i, j, mapping, ref;
    mapping = {};
    for (i = j = 0, ref = Escaper.LIST_ESCAPEES.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      mapping[Escaper.LIST_ESCAPEES[i]] = Escaper.LIST_ESCAPED[i];
    }
    return mapping;
  })();

  Escaper.PATTERN_CHARACTERS_TO_ESCAPE = new Pattern('[\\x00-\\x1f]|\xc2\x85|\xc2\xa0|\xe2\x80\xa8|\xe2\x80\xa9');

  Escaper.PATTERN_MAPPING_ESCAPEES = new Pattern(Escaper.LIST_ESCAPEES.join('|').split('\\').join('\\\\'));

  Escaper.PATTERN_SINGLE_QUOTING = new Pattern('[\\s\'":{}[\\],&*#?]|^[-?|<>=!%@`]');

  Escaper.requiresDoubleQuoting = function(value) {
    return this.PATTERN_CHARACTERS_TO_ESCAPE.test(value);
  };

  Escaper.escapeWithDoubleQuotes = function(value) {
    var result;
    result = this.PATTERN_MAPPING_ESCAPEES.replace(value, (function(_this) {
      return function(str) {
        return _this.MAPPING_ESCAPEES_TO_ESCAPED[str];
      };
    })(this));
    return '"' + result + '"';
  };

  Escaper.requiresSingleQuoting = function(value) {
    return this.PATTERN_SINGLE_QUOTING.test(value);
  };

  Escaper.escapeWithSingleQuotes = function(value) {
    return "'" + value.replace(/'/g, "''") + "'";
  };

  return Escaper;

})();

module.exports = Escaper;


/***/ }),

/***/ 41334:
/***/ ((module) => {

// Generated by CoffeeScript 1.12.4
var DumpException,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

DumpException = (function(superClass) {
  extend(DumpException, superClass);

  function DumpException(message, parsedLine, snippet) {
    this.message = message;
    this.parsedLine = parsedLine;
    this.snippet = snippet;
  }

  DumpException.prototype.toString = function() {
    if ((this.parsedLine != null) && (this.snippet != null)) {
      return '<DumpException> ' + this.message + ' (line ' + this.parsedLine + ': \'' + this.snippet + '\')';
    } else {
      return '<DumpException> ' + this.message;
    }
  };

  return DumpException;

})(Error);

module.exports = DumpException;


/***/ }),

/***/ 36898:
/***/ ((module) => {

// Generated by CoffeeScript 1.12.4
var ParseException,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ParseException = (function(superClass) {
  extend(ParseException, superClass);

  function ParseException(message, parsedLine, snippet) {
    this.message = message;
    this.parsedLine = parsedLine;
    this.snippet = snippet;
  }

  ParseException.prototype.toString = function() {
    if ((this.parsedLine != null) && (this.snippet != null)) {
      return '<ParseException> ' + this.message + ' (line ' + this.parsedLine + ': \'' + this.snippet + '\')';
    } else {
      return '<ParseException> ' + this.message;
    }
  };

  return ParseException;

})(Error);

module.exports = ParseException;


/***/ }),

/***/ 85468:
/***/ ((module) => {

// Generated by CoffeeScript 1.12.4
var ParseMore,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ParseMore = (function(superClass) {
  extend(ParseMore, superClass);

  function ParseMore(message, parsedLine, snippet) {
    this.message = message;
    this.parsedLine = parsedLine;
    this.snippet = snippet;
  }

  ParseMore.prototype.toString = function() {
    if ((this.parsedLine != null) && (this.snippet != null)) {
      return '<ParseMore> ' + this.message + ' (line ' + this.parsedLine + ': \'' + this.snippet + '\')';
    } else {
      return '<ParseMore> ' + this.message;
    }
  };

  return ParseMore;

})(Error);

module.exports = ParseMore;


/***/ }),

/***/ 33658:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Generated by CoffeeScript 1.12.4
var DumpException, Escaper, Inline, ParseException, ParseMore, Pattern, Unescaper, Utils,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Pattern = __webpack_require__(42801);

Unescaper = __webpack_require__(50440);

Escaper = __webpack_require__(96279);

Utils = __webpack_require__(66622);

ParseException = __webpack_require__(36898);

ParseMore = __webpack_require__(85468);

DumpException = __webpack_require__(41334);

Inline = (function() {
  function Inline() {}

  Inline.REGEX_QUOTED_STRING = '(?:"(?:[^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|\'(?:[^\']*(?:\'\'[^\']*)*)\')';

  Inline.PATTERN_TRAILING_COMMENTS = new Pattern('^\\s*#.*$');

  Inline.PATTERN_QUOTED_SCALAR = new Pattern('^' + Inline.REGEX_QUOTED_STRING);

  Inline.PATTERN_THOUSAND_NUMERIC_SCALAR = new Pattern('^(-|\\+)?[0-9,]+(\\.[0-9]+)?$');

  Inline.PATTERN_SCALAR_BY_DELIMITERS = {};

  Inline.settings = {};

  Inline.configure = function(exceptionOnInvalidType, objectDecoder) {
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = null;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
    this.settings.objectDecoder = objectDecoder;
  };

  Inline.parse = function(value, exceptionOnInvalidType, objectDecoder) {
    var context, result;
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
    this.settings.objectDecoder = objectDecoder;
    if (value == null) {
      return '';
    }
    value = Utils.trim(value);
    if (0 === value.length) {
      return '';
    }
    context = {
      exceptionOnInvalidType: exceptionOnInvalidType,
      objectDecoder: objectDecoder,
      i: 0
    };
    switch (value.charAt(0)) {
      case '[':
        result = this.parseSequence(value, context);
        ++context.i;
        break;
      case '{':
        result = this.parseMapping(value, context);
        ++context.i;
        break;
      default:
        result = this.parseScalar(value, null, ['"', "'"], context);
    }
    if (this.PATTERN_TRAILING_COMMENTS.replace(value.slice(context.i), '') !== '') {
      throw new ParseException('Unexpected characters near "' + value.slice(context.i) + '".');
    }
    return result;
  };

  Inline.dump = function(value, exceptionOnInvalidType, objectEncoder) {
    var ref, result, type;
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectEncoder == null) {
      objectEncoder = null;
    }
    if (value == null) {
      return 'null';
    }
    type = typeof value;
    if (type === 'object') {
      if (value instanceof Date) {
        return value.toISOString();
      } else if (objectEncoder != null) {
        result = objectEncoder(value);
        if (typeof result === 'string' || (result != null)) {
          return result;
        }
      }
      return this.dumpObject(value);
    }
    if (type === 'boolean') {
      return (value ? 'true' : 'false');
    }
    if (Utils.isDigits(value)) {
      return (type === 'string' ? "'" + value + "'" : String(parseInt(value)));
    }
    if (Utils.isNumeric(value)) {
      return (type === 'string' ? "'" + value + "'" : String(parseFloat(value)));
    }
    if (type === 'number') {
      return (value === 2e308 ? '.Inf' : (value === -2e308 ? '-.Inf' : (isNaN(value) ? '.NaN' : value)));
    }
    if (Escaper.requiresDoubleQuoting(value)) {
      return Escaper.escapeWithDoubleQuotes(value);
    }
    if (Escaper.requiresSingleQuoting(value)) {
      return Escaper.escapeWithSingleQuotes(value);
    }
    if ('' === value) {
      return '""';
    }
    if (Utils.PATTERN_DATE.test(value)) {
      return "'" + value + "'";
    }
    if ((ref = value.toLowerCase()) === 'null' || ref === '~' || ref === 'true' || ref === 'false') {
      return "'" + value + "'";
    }
    return value;
  };

  Inline.dumpObject = function(value, exceptionOnInvalidType, objectSupport) {
    var j, key, len1, output, val;
    if (objectSupport == null) {
      objectSupport = null;
    }
    if (value instanceof Array) {
      output = [];
      for (j = 0, len1 = value.length; j < len1; j++) {
        val = value[j];
        output.push(this.dump(val));
      }
      return '[' + output.join(', ') + ']';
    } else {
      output = [];
      for (key in value) {
        val = value[key];
        output.push(this.dump(key) + ': ' + this.dump(val));
      }
      return '{' + output.join(', ') + '}';
    }
  };

  Inline.parseScalar = function(scalar, delimiters, stringDelimiters, context, evaluate) {
    var i, joinedDelimiters, match, output, pattern, ref, ref1, strpos, tmp;
    if (delimiters == null) {
      delimiters = null;
    }
    if (stringDelimiters == null) {
      stringDelimiters = ['"', "'"];
    }
    if (context == null) {
      context = null;
    }
    if (evaluate == null) {
      evaluate = true;
    }
    if (context == null) {
      context = {
        exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
        objectDecoder: this.settings.objectDecoder,
        i: 0
      };
    }
    i = context.i;
    if (ref = scalar.charAt(i), indexOf.call(stringDelimiters, ref) >= 0) {
      output = this.parseQuotedScalar(scalar, context);
      i = context.i;
      if (delimiters != null) {
        tmp = Utils.ltrim(scalar.slice(i), ' ');
        if (!(ref1 = tmp.charAt(0), indexOf.call(delimiters, ref1) >= 0)) {
          throw new ParseException('Unexpected characters (' + scalar.slice(i) + ').');
        }
      }
    } else {
      if (!delimiters) {
        output = scalar.slice(i);
        i += output.length;
        strpos = output.indexOf(' #');
        if (strpos !== -1) {
          output = Utils.rtrim(output.slice(0, strpos));
        }
      } else {
        joinedDelimiters = delimiters.join('|');
        pattern = this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters];
        if (pattern == null) {
          pattern = new Pattern('^(.+?)(' + joinedDelimiters + ')');
          this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters] = pattern;
        }
        if (match = pattern.exec(scalar.slice(i))) {
          output = match[1];
          i += output.length;
        } else {
          throw new ParseException('Malformed inline YAML string (' + scalar + ').');
        }
      }
      if (evaluate) {
        output = this.evaluateScalar(output, context);
      }
    }
    context.i = i;
    return output;
  };

  Inline.parseQuotedScalar = function(scalar, context) {
    var i, match, output;
    i = context.i;
    if (!(match = this.PATTERN_QUOTED_SCALAR.exec(scalar.slice(i)))) {
      throw new ParseMore('Malformed inline YAML string (' + scalar.slice(i) + ').');
    }
    output = match[0].substr(1, match[0].length - 2);
    if ('"' === scalar.charAt(i)) {
      output = Unescaper.unescapeDoubleQuotedString(output);
    } else {
      output = Unescaper.unescapeSingleQuotedString(output);
    }
    i += match[0].length;
    context.i = i;
    return output;
  };

  Inline.parseSequence = function(sequence, context) {
    var e, i, isQuoted, len, output, ref, value;
    output = [];
    len = sequence.length;
    i = context.i;
    i += 1;
    while (i < len) {
      context.i = i;
      switch (sequence.charAt(i)) {
        case '[':
          output.push(this.parseSequence(sequence, context));
          i = context.i;
          break;
        case '{':
          output.push(this.parseMapping(sequence, context));
          i = context.i;
          break;
        case ']':
          return output;
        case ',':
        case ' ':
        case "\n":
          break;
        default:
          isQuoted = ((ref = sequence.charAt(i)) === '"' || ref === "'");
          value = this.parseScalar(sequence, [',', ']'], ['"', "'"], context);
          i = context.i;
          if (!isQuoted && typeof value === 'string' && (value.indexOf(': ') !== -1 || value.indexOf(":\n") !== -1)) {
            try {
              value = this.parseMapping('{' + value + '}');
            } catch (error) {
              e = error;
            }
          }
          output.push(value);
          --i;
      }
      ++i;
    }
    throw new ParseMore('Malformed inline YAML string ' + sequence);
  };

  Inline.parseMapping = function(mapping, context) {
    var done, i, key, len, output, shouldContinueWhileLoop, value;
    output = {};
    len = mapping.length;
    i = context.i;
    i += 1;
    shouldContinueWhileLoop = false;
    while (i < len) {
      context.i = i;
      switch (mapping.charAt(i)) {
        case ' ':
        case ',':
        case "\n":
          ++i;
          context.i = i;
          shouldContinueWhileLoop = true;
          break;
        case '}':
          return output;
      }
      if (shouldContinueWhileLoop) {
        shouldContinueWhileLoop = false;
        continue;
      }
      key = this.parseScalar(mapping, [':', ' ', "\n"], ['"', "'"], context, false);
      i = context.i;
      done = false;
      while (i < len) {
        context.i = i;
        switch (mapping.charAt(i)) {
          case '[':
            value = this.parseSequence(mapping, context);
            i = context.i;
            if (output[key] === void 0) {
              output[key] = value;
            }
            done = true;
            break;
          case '{':
            value = this.parseMapping(mapping, context);
            i = context.i;
            if (output[key] === void 0) {
              output[key] = value;
            }
            done = true;
            break;
          case ':':
          case ' ':
          case "\n":
            break;
          default:
            value = this.parseScalar(mapping, [',', '}'], ['"', "'"], context);
            i = context.i;
            if (output[key] === void 0) {
              output[key] = value;
            }
            done = true;
            --i;
        }
        ++i;
        if (done) {
          break;
        }
      }
    }
    throw new ParseMore('Malformed inline YAML string ' + mapping);
  };

  Inline.evaluateScalar = function(scalar, context) {
    var cast, date, exceptionOnInvalidType, firstChar, firstSpace, firstWord, objectDecoder, raw, scalarLower, subValue, trimmedScalar;
    scalar = Utils.trim(scalar);
    scalarLower = scalar.toLowerCase();
    switch (scalarLower) {
      case 'null':
      case '':
      case '~':
        return null;
      case 'true':
        return true;
      case 'false':
        return false;
      case '.inf':
        return 2e308;
      case '.nan':
        return 0/0;
      case '-.inf':
        return 2e308;
      default:
        firstChar = scalarLower.charAt(0);
        switch (firstChar) {
          case '!':
            firstSpace = scalar.indexOf(' ');
            if (firstSpace === -1) {
              firstWord = scalarLower;
            } else {
              firstWord = scalarLower.slice(0, firstSpace);
            }
            switch (firstWord) {
              case '!':
                if (firstSpace !== -1) {
                  return parseInt(this.parseScalar(scalar.slice(2)));
                }
                return null;
              case '!str':
                return Utils.ltrim(scalar.slice(4));
              case '!!str':
                return Utils.ltrim(scalar.slice(5));
              case '!!int':
                return parseInt(this.parseScalar(scalar.slice(5)));
              case '!!bool':
                return Utils.parseBoolean(this.parseScalar(scalar.slice(6)), false);
              case '!!float':
                return parseFloat(this.parseScalar(scalar.slice(7)));
              case '!!timestamp':
                return Utils.stringToDate(Utils.ltrim(scalar.slice(11)));
              default:
                if (context == null) {
                  context = {
                    exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
                    objectDecoder: this.settings.objectDecoder,
                    i: 0
                  };
                }
                objectDecoder = context.objectDecoder, exceptionOnInvalidType = context.exceptionOnInvalidType;
                if (objectDecoder) {
                  trimmedScalar = Utils.rtrim(scalar);
                  firstSpace = trimmedScalar.indexOf(' ');
                  if (firstSpace === -1) {
                    return objectDecoder(trimmedScalar, null);
                  } else {
                    subValue = Utils.ltrim(trimmedScalar.slice(firstSpace + 1));
                    if (!(subValue.length > 0)) {
                      subValue = null;
                    }
                    return objectDecoder(trimmedScalar.slice(0, firstSpace), subValue);
                  }
                }
                if (exceptionOnInvalidType) {
                  throw new ParseException('Custom object support when parsing a YAML file has been disabled.');
                }
                return null;
            }
            break;
          case '0':
            if ('0x' === scalar.slice(0, 2)) {
              return Utils.hexDec(scalar);
            } else if (Utils.isDigits(scalar)) {
              return Utils.octDec(scalar);
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else {
              return scalar;
            }
            break;
          case '+':
            if (Utils.isDigits(scalar)) {
              raw = scalar;
              cast = parseInt(raw);
              if (raw === String(cast)) {
                return cast;
              } else {
                return raw;
              }
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }
            return scalar;
          case '-':
            if (Utils.isDigits(scalar.slice(1))) {
              if ('0' === scalar.charAt(1)) {
                return -Utils.octDec(scalar.slice(1));
              } else {
                raw = scalar.slice(1);
                cast = parseInt(raw);
                if (raw === String(cast)) {
                  return -cast;
                } else {
                  return -raw;
                }
              }
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }
            return scalar;
          default:
            if (date = Utils.stringToDate(scalar)) {
              return date;
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }
            return scalar;
        }
    }
  };

  return Inline;

})();

module.exports = Inline;


/***/ }),

/***/ 63671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Generated by CoffeeScript 1.12.4
var Inline, ParseException, ParseMore, Parser, Pattern, Utils;

Inline = __webpack_require__(33658);

Pattern = __webpack_require__(42801);

Utils = __webpack_require__(66622);

ParseException = __webpack_require__(36898);

ParseMore = __webpack_require__(85468);

Parser = (function() {
  Parser.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern('^(?:(?<type>![^\\|>]*)\\s+)?(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$');

  Parser.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern('(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$');

  Parser.prototype.PATTERN_SEQUENCE_ITEM = new Pattern('^\\-((?<leadspaces>\\s+)(?<value>.+?))?\\s*$');

  Parser.prototype.PATTERN_ANCHOR_VALUE = new Pattern('^&(?<ref>[^ ]+) *(?<value>.*)');

  Parser.prototype.PATTERN_COMPACT_NOTATION = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \'"\\{\\[].*?) *\\:(\\s+(?<value>.+?))?\\s*$');

  Parser.prototype.PATTERN_MAPPING_ITEM = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \'"\\[\\{].*?) *\\:(\\s+(?<value>.+?))?\\s*$');

  Parser.prototype.PATTERN_DECIMAL = new Pattern('\\d+');

  Parser.prototype.PATTERN_INDENT_SPACES = new Pattern('^ +');

  Parser.prototype.PATTERN_TRAILING_LINES = new Pattern('(\n*)$');

  Parser.prototype.PATTERN_YAML_HEADER = new Pattern('^\\%YAML[: ][\\d\\.]+.*\n', 'm');

  Parser.prototype.PATTERN_LEADING_COMMENTS = new Pattern('^(\\#.*?\n)+', 'm');

  Parser.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern('^\\-\\-\\-.*?\n', 'm');

  Parser.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern('^\\.\\.\\.\\s*$', 'm');

  Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};

  Parser.prototype.CONTEXT_NONE = 0;

  Parser.prototype.CONTEXT_SEQUENCE = 1;

  Parser.prototype.CONTEXT_MAPPING = 2;

  function Parser(offset) {
    this.offset = offset != null ? offset : 0;
    this.lines = [];
    this.currentLineNb = -1;
    this.currentLine = '';
    this.refs = {};
  }

  Parser.prototype.parse = function(value, exceptionOnInvalidType, objectDecoder) {
    var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    this.currentLineNb = -1;
    this.currentLine = '';
    this.lines = this.cleanup(value).split("\n");
    data = null;
    context = this.CONTEXT_NONE;
    allowOverwrite = false;
    while (this.moveToNextLine()) {
      if (this.isCurrentLineEmpty()) {
        continue;
      }
      if ("\t" === this.currentLine[0]) {
        throw new ParseException('A YAML file cannot contain tabs as indentation.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
      isRef = mergeNode = false;
      if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {
        if (this.CONTEXT_MAPPING === context) {
          throw new ParseException('You cannot define a sequence item when in a mapping');
        }
        context = this.CONTEXT_SEQUENCE;
        if (data == null) {
          data = [];
        }
        if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
          isRef = matches.ref;
          values.value = matches.value;
        }
        if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {
          if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {
            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));
          } else {
            data.push(null);
          }
        } else {
          if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {
            c = this.getRealCurrentLineNb();
            parser = new Parser(c);
            parser.refs = this.refs;
            block = values.value;
            indent = this.getCurrentLineIndentation();
            if (this.isNextLineIndented(false)) {
              block += "\n" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);
            }
            data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));
          } else {
            data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));
          }
        }
      } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(' #') === -1) {
        if (this.CONTEXT_SEQUENCE === context) {
          throw new ParseException('You cannot define a mapping item when in a sequence');
        }
        context = this.CONTEXT_MAPPING;
        if (data == null) {
          data = {};
        }
        Inline.configure(exceptionOnInvalidType, objectDecoder);
        try {
          key = Inline.parseScalar(values.key);
        } catch (error) {
          e = error;
          e.parsedLine = this.getRealCurrentLineNb() + 1;
          e.snippet = this.currentLine;
          throw e;
        }
        if ('<<' === key) {
          mergeNode = true;
          allowOverwrite = true;
          if (((ref1 = values.value) != null ? ref1.indexOf('*') : void 0) === 0) {
            refName = values.value.slice(1);
            if (this.refs[refName] == null) {
              throw new ParseException('Reference "' + refName + '" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }
            refValue = this.refs[refName];
            if (typeof refValue !== 'object') {
              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }
            if (refValue instanceof Array) {
              for (i = j = 0, len = refValue.length; j < len; i = ++j) {
                value = refValue[i];
                if (data[name = String(i)] == null) {
                  data[name] = value;
                }
              }
            } else {
              for (key in refValue) {
                value = refValue[key];
                if (data[key] == null) {
                  data[key] = value;
                }
              }
            }
          } else {
            if ((values.value != null) && values.value !== '') {
              value = values.value;
            } else {
              value = this.getNextEmbedBlock();
            }
            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            parsed = parser.parse(value, exceptionOnInvalidType);
            if (typeof parsed !== 'object') {
              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }
            if (parsed instanceof Array) {
              for (l = 0, len1 = parsed.length; l < len1; l++) {
                parsedItem = parsed[l];
                if (typeof parsedItem !== 'object') {
                  throw new ParseException('Merge items must be objects.', this.getRealCurrentLineNb() + 1, parsedItem);
                }
                if (parsedItem instanceof Array) {
                  for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {
                    value = parsedItem[i];
                    k = String(i);
                    if (!data.hasOwnProperty(k)) {
                      data[k] = value;
                    }
                  }
                } else {
                  for (key in parsedItem) {
                    value = parsedItem[key];
                    if (!data.hasOwnProperty(key)) {
                      data[key] = value;
                    }
                  }
                }
              }
            } else {
              for (key in parsed) {
                value = parsed[key];
                if (!data.hasOwnProperty(key)) {
                  data[key] = value;
                }
              }
            }
          }
        } else if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
          isRef = matches.ref;
          values.value = matches.value;
        }
        if (mergeNode) {

        } else if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {
          if (!(this.isNextLineIndented()) && !(this.isNextLineUnIndentedCollection())) {
            if (allowOverwrite || data[key] === void 0) {
              data[key] = null;
            }
          } else {
            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);
            if (allowOverwrite || data[key] === void 0) {
              data[key] = val;
            }
          }
        } else {
          val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);
          if (allowOverwrite || data[key] === void 0) {
            data[key] = val;
          }
        }
      } else {
        lineCount = this.lines.length;
        if (1 === lineCount || (2 === lineCount && Utils.isEmpty(this.lines[1]))) {
          try {
            value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);
          } catch (error) {
            e = error;
            e.parsedLine = this.getRealCurrentLineNb() + 1;
            e.snippet = this.currentLine;
            throw e;
          }
          if (typeof value === 'object') {
            if (value instanceof Array) {
              first = value[0];
            } else {
              for (key in value) {
                first = value[key];
                break;
              }
            }
            if (typeof first === 'string' && first.indexOf('*') === 0) {
              data = [];
              for (n = 0, len3 = value.length; n < len3; n++) {
                alias = value[n];
                data.push(this.refs[alias.slice(1)]);
              }
              value = data;
            }
          }
          return value;
        } else if ((ref2 = Utils.ltrim(value).charAt(0)) === '[' || ref2 === '{') {
          try {
            return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
          } catch (error) {
            e = error;
            e.parsedLine = this.getRealCurrentLineNb() + 1;
            e.snippet = this.currentLine;
            throw e;
          }
        }
        throw new ParseException('Unable to parse.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
      if (isRef) {
        if (data instanceof Array) {
          this.refs[isRef] = data[data.length - 1];
        } else {
          lastKey = null;
          for (key in data) {
            lastKey = key;
          }
          this.refs[isRef] = data[lastKey];
        }
      }
    }
    if (Utils.isEmpty(data)) {
      return null;
    } else {
      return data;
    }
  };

  Parser.prototype.getRealCurrentLineNb = function() {
    return this.currentLineNb + this.offset;
  };

  Parser.prototype.getCurrentLineIndentation = function() {
    return this.currentLine.length - Utils.ltrim(this.currentLine, ' ').length;
  };

  Parser.prototype.getNextEmbedBlock = function(indentation, includeUnindentedCollection) {
    var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;
    if (indentation == null) {
      indentation = null;
    }
    if (includeUnindentedCollection == null) {
      includeUnindentedCollection = false;
    }
    this.moveToNextLine();
    if (indentation == null) {
      newIndent = this.getCurrentLineIndentation();
      unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);
      if (!(this.isCurrentLineEmpty()) && 0 === newIndent && !unindentedEmbedBlock) {
        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
    } else {
      newIndent = indentation;
    }
    data = [this.currentLine.slice(newIndent)];
    if (!includeUnindentedCollection) {
      isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);
    }
    removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;
    removeComments = !removeCommentsPattern.test(this.currentLine);
    while (this.moveToNextLine()) {
      indent = this.getCurrentLineIndentation();
      if (indent === newIndent) {
        removeComments = !removeCommentsPattern.test(this.currentLine);
      }
      if (removeComments && this.isCurrentLineComment()) {
        continue;
      }
      if (this.isCurrentLineBlank()) {
        data.push(this.currentLine.slice(newIndent));
        continue;
      }
      if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {
        this.moveToPreviousLine();
        break;
      }
      if (indent >= newIndent) {
        data.push(this.currentLine.slice(newIndent));
      } else if (Utils.ltrim(this.currentLine).charAt(0) === '#') {

      } else if (0 === indent) {
        this.moveToPreviousLine();
        break;
      } else {
        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
    }
    return data.join("\n");
  };

  Parser.prototype.moveToNextLine = function() {
    if (this.currentLineNb >= this.lines.length - 1) {
      return false;
    }
    this.currentLine = this.lines[++this.currentLineNb];
    return true;
  };

  Parser.prototype.moveToPreviousLine = function() {
    this.currentLine = this.lines[--this.currentLineNb];
  };

  Parser.prototype.parseValue = function(value, exceptionOnInvalidType, objectDecoder) {
    var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;
    if (0 === value.indexOf('*')) {
      pos = value.indexOf('#');
      if (pos !== -1) {
        value = value.substr(1, pos - 2);
      } else {
        value = value.slice(1);
      }
      if (this.refs[value] === void 0) {
        throw new ParseException('Reference "' + value + '" does not exist.', this.currentLine);
      }
      return this.refs[value];
    }
    if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {
      modifiers = (ref = matches.modifiers) != null ? ref : '';
      foldedIndent = Math.abs(parseInt(modifiers));
      if (isNaN(foldedIndent)) {
        foldedIndent = 0;
      }
      val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ''), foldedIndent);
      if (matches.type != null) {
        Inline.configure(exceptionOnInvalidType, objectDecoder);
        return Inline.parseScalar(matches.type + ' ' + val);
      } else {
        return val;
      }
    }
    if ((ref1 = value.charAt(0)) === '[' || ref1 === '{' || ref1 === '"' || ref1 === "'") {
      while (true) {
        try {
          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
        } catch (error) {
          e = error;
          if (e instanceof ParseMore && this.moveToNextLine()) {
            value += "\n" + Utils.trim(this.currentLine, ' ');
          } else {
            e.parsedLine = this.getRealCurrentLineNb() + 1;
            e.snippet = this.currentLine;
            throw e;
          }
        }
      }
    } else {
      if (this.isNextLineIndented()) {
        value += "\n" + this.getNextEmbedBlock();
      }
      return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
    }
  };

  Parser.prototype.parseFoldedScalar = function(separator, indicator, indentation) {
    var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;
    if (indicator == null) {
      indicator = '';
    }
    if (indentation == null) {
      indentation = 0;
    }
    notEOF = this.moveToNextLine();
    if (!notEOF) {
      return '';
    }
    isCurrentLineBlank = this.isCurrentLineBlank();
    text = '';
    while (notEOF && isCurrentLineBlank) {
      if (notEOF = this.moveToNextLine()) {
        text += "\n";
        isCurrentLineBlank = this.isCurrentLineBlank();
      }
    }
    if (0 === indentation) {
      if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {
        indentation = matches[0].length;
      }
    }
    if (indentation > 0) {
      pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];
      if (pattern == null) {
        pattern = new Pattern('^ {' + indentation + '}(.*)$');
        Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;
      }
      while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {
        if (isCurrentLineBlank) {
          text += this.currentLine.slice(indentation);
        } else {
          text += matches[1];
        }
        if (notEOF = this.moveToNextLine()) {
          text += "\n";
          isCurrentLineBlank = this.isCurrentLineBlank();
        }
      }
    } else if (notEOF) {
      text += "\n";
    }
    if (notEOF) {
      this.moveToPreviousLine();
    }
    if ('>' === separator) {
      newText = '';
      ref = text.split("\n");
      for (j = 0, len = ref.length; j < len; j++) {
        line = ref[j];
        if (line.length === 0 || line.charAt(0) === ' ') {
          newText = Utils.rtrim(newText, ' ') + line + "\n";
        } else {
          newText += line + ' ';
        }
      }
      text = newText;
    }
    if ('+' !== indicator) {
      text = Utils.rtrim(text);
    }
    if ('' === indicator) {
      text = this.PATTERN_TRAILING_LINES.replace(text, "\n");
    } else if ('-' === indicator) {
      text = this.PATTERN_TRAILING_LINES.replace(text, '');
    }
    return text;
  };

  Parser.prototype.isNextLineIndented = function(ignoreComments) {
    var EOF, currentIndentation, ret;
    if (ignoreComments == null) {
      ignoreComments = true;
    }
    currentIndentation = this.getCurrentLineIndentation();
    EOF = !this.moveToNextLine();
    if (ignoreComments) {
      while (!EOF && this.isCurrentLineEmpty()) {
        EOF = !this.moveToNextLine();
      }
    } else {
      while (!EOF && this.isCurrentLineBlank()) {
        EOF = !this.moveToNextLine();
      }
    }
    if (EOF) {
      return false;
    }
    ret = false;
    if (this.getCurrentLineIndentation() > currentIndentation) {
      ret = true;
    }
    this.moveToPreviousLine();
    return ret;
  };

  Parser.prototype.isCurrentLineEmpty = function() {
    var trimmedLine;
    trimmedLine = Utils.trim(this.currentLine, ' ');
    return trimmedLine.length === 0 || trimmedLine.charAt(0) === '#';
  };

  Parser.prototype.isCurrentLineBlank = function() {
    return '' === Utils.trim(this.currentLine, ' ');
  };

  Parser.prototype.isCurrentLineComment = function() {
    var ltrimmedLine;
    ltrimmedLine = Utils.ltrim(this.currentLine, ' ');
    return ltrimmedLine.charAt(0) === '#';
  };

  Parser.prototype.cleanup = function(value) {
    var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;
    if (value.indexOf("\r") !== -1) {
      value = value.split("\r\n").join("\n").split("\r").join("\n");
    }
    count = 0;
    ref = this.PATTERN_YAML_HEADER.replaceAll(value, ''), value = ref[0], count = ref[1];
    this.offset += count;
    ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, '', 1), trimmedValue = ref1[0], count = ref1[1];
    if (count === 1) {
      this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
      value = trimmedValue;
    }
    ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, '', 1), trimmedValue = ref2[0], count = ref2[1];
    if (count === 1) {
      this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
      value = trimmedValue;
      value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, '');
    }
    lines = value.split("\n");
    smallestIndent = -1;
    for (j = 0, len = lines.length; j < len; j++) {
      line = lines[j];
      if (Utils.trim(line, ' ').length === 0) {
        continue;
      }
      indent = line.length - Utils.ltrim(line).length;
      if (smallestIndent === -1 || indent < smallestIndent) {
        smallestIndent = indent;
      }
    }
    if (smallestIndent > 0) {
      for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {
        line = lines[i];
        lines[i] = line.slice(smallestIndent);
      }
      value = lines.join("\n");
    }
    return value;
  };

  Parser.prototype.isNextLineUnIndentedCollection = function(currentIndentation) {
    var notEOF, ret;
    if (currentIndentation == null) {
      currentIndentation = null;
    }
    if (currentIndentation == null) {
      currentIndentation = this.getCurrentLineIndentation();
    }
    notEOF = this.moveToNextLine();
    while (notEOF && this.isCurrentLineEmpty()) {
      notEOF = this.moveToNextLine();
    }
    if (false === notEOF) {
      return false;
    }
    ret = false;
    if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {
      ret = true;
    }
    this.moveToPreviousLine();
    return ret;
  };

  Parser.prototype.isStringUnIndentedCollectionItem = function() {
    return this.currentLine === '-' || this.currentLine.slice(0, 2) === '- ';
  };

  return Parser;

})();

module.exports = Parser;


/***/ }),

/***/ 42801:
/***/ ((module) => {

// Generated by CoffeeScript 1.12.4
var Pattern;

Pattern = (function() {
  Pattern.prototype.regex = null;

  Pattern.prototype.rawRegex = null;

  Pattern.prototype.cleanedRegex = null;

  Pattern.prototype.mapping = null;

  function Pattern(rawRegex, modifiers) {
    var _char, capturingBracketNumber, cleanedRegex, i, len, mapping, name, part, subChar;
    if (modifiers == null) {
      modifiers = '';
    }
    cleanedRegex = '';
    len = rawRegex.length;
    mapping = null;
    capturingBracketNumber = 0;
    i = 0;
    while (i < len) {
      _char = rawRegex.charAt(i);
      if (_char === '\\') {
        cleanedRegex += rawRegex.slice(i, +(i + 1) + 1 || 9e9);
        i++;
      } else if (_char === '(') {
        if (i < len - 2) {
          part = rawRegex.slice(i, +(i + 2) + 1 || 9e9);
          if (part === '(?:') {
            i += 2;
            cleanedRegex += part;
          } else if (part === '(?<') {
            capturingBracketNumber++;
            i += 2;
            name = '';
            while (i + 1 < len) {
              subChar = rawRegex.charAt(i + 1);
              if (subChar === '>') {
                cleanedRegex += '(';
                i++;
                if (name.length > 0) {
                  if (mapping == null) {
                    mapping = {};
                  }
                  mapping[name] = capturingBracketNumber;
                }
                break;
              } else {
                name += subChar;
              }
              i++;
            }
          } else {
            cleanedRegex += _char;
            capturingBracketNumber++;
          }
        } else {
          cleanedRegex += _char;
        }
      } else {
        cleanedRegex += _char;
      }
      i++;
    }
    this.rawRegex = rawRegex;
    this.cleanedRegex = cleanedRegex;
    this.regex = new RegExp(this.cleanedRegex, 'g' + modifiers.replace('g', ''));
    this.mapping = mapping;
  }

  Pattern.prototype.exec = function(str) {
    var index, matches, name, ref;
    this.regex.lastIndex = 0;
    matches = this.regex.exec(str);
    if (matches == null) {
      return null;
    }
    if (this.mapping != null) {
      ref = this.mapping;
      for (name in ref) {
        index = ref[name];
        matches[name] = matches[index];
      }
    }
    return matches;
  };

  Pattern.prototype.test = function(str) {
    this.regex.lastIndex = 0;
    return this.regex.test(str);
  };

  Pattern.prototype.replace = function(str, replacement) {
    this.regex.lastIndex = 0;
    return str.replace(this.regex, replacement);
  };

  Pattern.prototype.replaceAll = function(str, replacement, limit) {
    var count;
    if (limit == null) {
      limit = 0;
    }
    this.regex.lastIndex = 0;
    count = 0;
    while (this.regex.test(str) && (limit === 0 || count < limit)) {
      this.regex.lastIndex = 0;
      str = str.replace(this.regex, replacement);
      count++;
    }
    return [str, count];
  };

  return Pattern;

})();

module.exports = Pattern;


/***/ }),

/***/ 50440:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Generated by CoffeeScript 1.12.4
var Pattern, Unescaper, Utils;

Utils = __webpack_require__(66622);

Pattern = __webpack_require__(42801);

Unescaper = (function() {
  function Unescaper() {}

  Unescaper.PATTERN_ESCAPED_CHARACTER = new Pattern('\\\\([0abt\tnvfre "\\/\\\\N_LP]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})');

  Unescaper.unescapeSingleQuotedString = function(value) {
    return value.replace(/\'\'/g, '\'');
  };

  Unescaper.unescapeDoubleQuotedString = function(value) {
    if (this._unescapeCallback == null) {
      this._unescapeCallback = (function(_this) {
        return function(str) {
          return _this.unescapeCharacter(str);
        };
      })(this);
    }
    return this.PATTERN_ESCAPED_CHARACTER.replace(value, this._unescapeCallback);
  };

  Unescaper.unescapeCharacter = function(value) {
    var ch;
    ch = String.fromCharCode;
    switch (value.charAt(1)) {
      case '0':
        return ch(0);
      case 'a':
        return ch(7);
      case 'b':
        return ch(8);
      case 't':
        return "\t";
      case "\t":
        return "\t";
      case 'n':
        return "\n";
      case 'v':
        return ch(11);
      case 'f':
        return ch(12);
      case 'r':
        return ch(13);
      case 'e':
        return ch(27);
      case ' ':
        return ' ';
      case '"':
        return '"';
      case '/':
        return '/';
      case '\\':
        return '\\';
      case 'N':
        return ch(0x0085);
      case '_':
        return ch(0x00A0);
      case 'L':
        return ch(0x2028);
      case 'P':
        return ch(0x2029);
      case 'x':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 2)));
      case 'u':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 4)));
      case 'U':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 8)));
      default:
        return '';
    }
  };

  return Unescaper;

})();

module.exports = Unescaper;


/***/ }),

/***/ 66622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Generated by CoffeeScript 1.12.4
var Pattern, Utils,
  hasProp = {}.hasOwnProperty;

Pattern = __webpack_require__(42801);

Utils = (function() {
  function Utils() {}

  Utils.REGEX_LEFT_TRIM_BY_CHAR = {};

  Utils.REGEX_RIGHT_TRIM_BY_CHAR = {};

  Utils.REGEX_SPACES = /\s+/g;

  Utils.REGEX_DIGITS = /^\d+$/;

  Utils.REGEX_OCTAL = /[^0-7]/gi;

  Utils.REGEX_HEXADECIMAL = /[^a-f0-9]/gi;

  Utils.PATTERN_DATE = new Pattern('^' + '(?<year>[0-9][0-9][0-9][0-9])' + '-(?<month>[0-9][0-9]?)' + '-(?<day>[0-9][0-9]?)' + '(?:(?:[Tt]|[ \t]+)' + '(?<hour>[0-9][0-9]?)' + ':(?<minute>[0-9][0-9])' + ':(?<second>[0-9][0-9])' + '(?:\.(?<fraction>[0-9]*))?' + '(?:[ \t]*(?<tz>Z|(?<tz_sign>[-+])(?<tz_hour>[0-9][0-9]?)' + '(?::(?<tz_minute>[0-9][0-9]))?))?)?' + '$', 'i');

  Utils.LOCAL_TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1000;

  Utils.trim = function(str, _char) {
    var regexLeft, regexRight;
    if (_char == null) {
      _char = '\\s';
    }
    regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
    if (regexLeft == null) {
      this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp('^' + _char + '' + _char + '*');
    }
    regexLeft.lastIndex = 0;
    regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
    if (regexRight == null) {
      this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + '' + _char + '*$');
    }
    regexRight.lastIndex = 0;
    return str.replace(regexLeft, '').replace(regexRight, '');
  };

  Utils.ltrim = function(str, _char) {
    var regexLeft;
    if (_char == null) {
      _char = '\\s';
    }
    regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
    if (regexLeft == null) {
      this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp('^' + _char + '' + _char + '*');
    }
    regexLeft.lastIndex = 0;
    return str.replace(regexLeft, '');
  };

  Utils.rtrim = function(str, _char) {
    var regexRight;
    if (_char == null) {
      _char = '\\s';
    }
    regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
    if (regexRight == null) {
      this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + '' + _char + '*$');
    }
    regexRight.lastIndex = 0;
    return str.replace(regexRight, '');
  };

  Utils.isEmpty = function(value) {
    return !value || value === '' || value === '0' || (value instanceof Array && value.length === 0) || this.isEmptyObject(value);
  };

  Utils.isEmptyObject = function(value) {
    var k;
    return value instanceof Object && ((function() {
      var results;
      results = [];
      for (k in value) {
        if (!hasProp.call(value, k)) continue;
        results.push(k);
      }
      return results;
    })()).length === 0;
  };

  Utils.subStrCount = function(string, subString, start, length) {
    var c, i, j, len, ref, sublen;
    c = 0;
    string = '' + string;
    subString = '' + subString;
    if (start != null) {
      string = string.slice(start);
    }
    if (length != null) {
      string = string.slice(0, length);
    }
    len = string.length;
    sublen = subString.length;
    for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (subString === string.slice(i, sublen)) {
        c++;
        i += sublen - 1;
      }
    }
    return c;
  };

  Utils.isDigits = function(input) {
    this.REGEX_DIGITS.lastIndex = 0;
    return this.REGEX_DIGITS.test(input);
  };

  Utils.octDec = function(input) {
    this.REGEX_OCTAL.lastIndex = 0;
    return parseInt((input + '').replace(this.REGEX_OCTAL, ''), 8);
  };

  Utils.hexDec = function(input) {
    this.REGEX_HEXADECIMAL.lastIndex = 0;
    input = this.trim(input);
    if ((input + '').slice(0, 2) === '0x') {
      input = (input + '').slice(2);
    }
    return parseInt((input + '').replace(this.REGEX_HEXADECIMAL, ''), 16);
  };

  Utils.utf8chr = function(c) {
    var ch;
    ch = String.fromCharCode;
    if (0x80 > (c %= 0x200000)) {
      return ch(c);
    }
    if (0x800 > c) {
      return ch(0xC0 | c >> 6) + ch(0x80 | c & 0x3F);
    }
    if (0x10000 > c) {
      return ch(0xE0 | c >> 12) + ch(0x80 | c >> 6 & 0x3F) + ch(0x80 | c & 0x3F);
    }
    return ch(0xF0 | c >> 18) + ch(0x80 | c >> 12 & 0x3F) + ch(0x80 | c >> 6 & 0x3F) + ch(0x80 | c & 0x3F);
  };

  Utils.parseBoolean = function(input, strict) {
    var lowerInput;
    if (strict == null) {
      strict = true;
    }
    if (typeof input === 'string') {
      lowerInput = input.toLowerCase();
      if (!strict) {
        if (lowerInput === 'no') {
          return false;
        }
      }
      if (lowerInput === '0') {
        return false;
      }
      if (lowerInput === 'false') {
        return false;
      }
      if (lowerInput === '') {
        return false;
      }
      return true;
    }
    return !!input;
  };

  Utils.isNumeric = function(input) {
    this.REGEX_SPACES.lastIndex = 0;
    return typeof input === 'number' || typeof input === 'string' && !isNaN(input) && input.replace(this.REGEX_SPACES, '') !== '';
  };

  Utils.stringToDate = function(str) {
    var date, day, fraction, hour, info, minute, month, second, tz_hour, tz_minute, tz_offset, year;
    if (!(str != null ? str.length : void 0)) {
      return null;
    }
    info = this.PATTERN_DATE.exec(str);
    if (!info) {
      return null;
    }
    year = parseInt(info.year, 10);
    month = parseInt(info.month, 10) - 1;
    day = parseInt(info.day, 10);
    if (info.hour == null) {
      date = new Date(Date.UTC(year, month, day));
      return date;
    }
    hour = parseInt(info.hour, 10);
    minute = parseInt(info.minute, 10);
    second = parseInt(info.second, 10);
    if (info.fraction != null) {
      fraction = info.fraction.slice(0, 3);
      while (fraction.length < 3) {
        fraction += '0';
      }
      fraction = parseInt(fraction, 10);
    } else {
      fraction = 0;
    }
    if (info.tz != null) {
      tz_hour = parseInt(info.tz_hour, 10);
      if (info.tz_minute != null) {
        tz_minute = parseInt(info.tz_minute, 10);
      } else {
        tz_minute = 0;
      }
      tz_offset = (tz_hour * 60 + tz_minute) * 60000;
      if ('-' === info.tz_sign) {
        tz_offset *= -1;
      }
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (tz_offset) {
      date.setTime(date.getTime() - tz_offset);
    }
    return date;
  };

  Utils.strRepeat = function(str, number) {
    var i, res;
    res = '';
    i = 0;
    while (i < number) {
      res += str;
      i++;
    }
    return res;
  };

  Utils.getStringFromFile = function(path, callback) {
    var data, fs, j, len1, name, ref, req, xhr;
    if (callback == null) {
      callback = null;
    }
    xhr = null;
    if (typeof window !== "undefined" && window !== null) {
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else if (window.ActiveXObject) {
        ref = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Msxml2.XMLHTTP", "Microsoft.XMLHTTP"];
        for (j = 0, len1 = ref.length; j < len1; j++) {
          name = ref[j];
          try {
            xhr = new ActiveXObject(name);
          } catch (error) {}
        }
      }
    }
    if (xhr != null) {
      if (callback != null) {
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if (xhr.status === 200 || xhr.status === 0) {
              return callback(xhr.responseText);
            } else {
              return callback(null);
            }
          }
        };
        xhr.open('GET', path, true);
        return xhr.send(null);
      } else {
        xhr.open('GET', path, false);
        xhr.send(null);
        if (xhr.status === 200 || xhr.status === 0) {
          return xhr.responseText;
        }
        return null;
      }
    } else {
      req = undefined;
      fs = __webpack_require__(57147);
      if (callback != null) {
        return fs.readFile(path, function(err, data) {
          if (err) {
            return callback(null);
          } else {
            return callback(String(data));
          }
        });
      } else {
        data = fs.readFileSync(path);
        if (data != null) {
          return String(data);
        }
        return null;
      }
    }
  };

  return Utils;

})();

module.exports = Utils;


/***/ }),

/***/ 86916:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.4
var Dumper, Parser, Utils, Yaml;

Parser = __webpack_require__(63671);

Dumper = __webpack_require__(24227);

Utils = __webpack_require__(66622);

Yaml = (function() {
  function Yaml() {}

  Yaml.parse = function(input, exceptionOnInvalidType, objectDecoder) {
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    return new Parser().parse(input, exceptionOnInvalidType, objectDecoder);
  };

  Yaml.parseFile = function(path, callback, exceptionOnInvalidType, objectDecoder) {
    var input;
    if (callback == null) {
      callback = null;
    }
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectDecoder == null) {
      objectDecoder = null;
    }
    if (callback != null) {
      return Utils.getStringFromFile(path, (function(_this) {
        return function(input) {
          var result;
          result = null;
          if (input != null) {
            result = _this.parse(input, exceptionOnInvalidType, objectDecoder);
          }
          callback(result);
        };
      })(this));
    } else {
      input = Utils.getStringFromFile(path);
      if (input != null) {
        return this.parse(input, exceptionOnInvalidType, objectDecoder);
      }
      return null;
    }
  };

  Yaml.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    var yaml;
    if (inline == null) {
      inline = 2;
    }
    if (indent == null) {
      indent = 4;
    }
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }
    if (objectEncoder == null) {
      objectEncoder = null;
    }
    yaml = new Dumper();
    yaml.indentation = indent;
    return yaml.dump(input, inline, 0, exceptionOnInvalidType, objectEncoder);
  };

  Yaml.stringify = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    return this.dump(input, inline, indent, exceptionOnInvalidType, objectEncoder);
  };

  Yaml.load = function(path, callback, exceptionOnInvalidType, objectDecoder) {
    return this.parseFile(path, callback, exceptionOnInvalidType, objectDecoder);
  };

  return Yaml;

})();

if (typeof window !== "undefined" && window !== null) {
  window.YAML = Yaml;
}

if (typeof window === "undefined" || window === null) {
  this.YAML = Yaml;
}

module.exports = Yaml;


/***/ }),

/***/ 1100:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Enumeration of environment variables used in AppStudio
 */
var ENV;
(function (ENV) {
    ENV["PROXY_URL"] = "HTTP_PROXY";
    ENV["H2O_URL"] = "H2O_URL";
})(ENV = exports.ENV || (exports.ENV = {}));
function isAppStudio() {
    return !!process.env[ENV.H2O_URL];
}
exports.isAppStudio = isAppStudio;
function getAppStudioBaseURL() {
    return process.env[ENV.H2O_URL];
}
exports.getAppStudioBaseURL = getAppStudioBaseURL;
function getAppStudioProxyURL() {
    return process.env[ENV.PROXY_URL];
}
exports.getAppStudioProxyURL = getAppStudioProxyURL;


/***/ }),

/***/ 68093:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const path_1 = __importDefault(__webpack_require__(71017));
function toPosixPath(dirPath) {
    return path_1.default
        .normalize(dirPath)
        .split(/[\\/]/g)
        .join(path_1.default.posix.sep);
}
exports.toPosixPath = toPosixPath;


/***/ }),

/***/ 59859:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const os_1 = __webpack_require__(22037);
const path_1 = __importDefault(__webpack_require__(71017));
var appStudio_1 = __webpack_require__(1100);
exports.isAppStudio = appStudio_1.isAppStudio;
exports.getAppStudioBaseURL = appStudio_1.getAppStudioBaseURL;
exports.getAppStudioProxyURL = appStudio_1.getAppStudioProxyURL;
__export(__webpack_require__(68093));
__export(__webpack_require__(37039));
__export(__webpack_require__(65678));
var FioriToolsSettings;
(function (FioriToolsSettings) {
    FioriToolsSettings["dir"] = ".fioritools";
})(FioriToolsSettings = exports.FioriToolsSettings || (exports.FioriToolsSettings = {}));
exports.getFioriToolsDirectory = () => {
    return path_1.default.join(os_1.homedir(), FioriToolsSettings.dir);
};


/***/ }),

/***/ 37039:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Returns a promise with the result (resolved/rejected) of all the promises passed in
 * Typescript 3.8 includes this. Can be removed after we upgrade from 3.7.5
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled
 * @param promises
 */
function allSettled(promises) {
    if (!promises || promises.length === 0) {
        return Promise.resolve([]);
    }
    const results = Array(promises.length);
    let count = 0;
    return new Promise((resolve) => {
        promises.forEach(async (promise, index) => {
            try {
                const result = await Promise.resolve(promise);
                results[index] = { status: 'fulfilled', value: result };
                count++;
                if (count === promises.length) {
                    resolve(results);
                }
            }
            catch (err) {
                results[index] = { status: 'rejected', reason: err };
                count++;
                if (count === promises.length) {
                    resolve(results);
                }
            }
        });
    });
}
exports.allSettled = allSettled;


/***/ }),

/***/ 65678:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Escape any special RegExp character that we want to use literally
 *
 * From here :https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping
 */
function escapeRegExp(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
exports.escapeRegExp = escapeRegExp;


/***/ }),

/***/ 90446:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let vscode = undefined;
// Dynamically load vscode if available
try {
    vscode = __webpack_require__(66828);
}
catch (e) {
    // Vscode not available. normal in cli.
}
const extensionConfigKeys = {
    // from packages/{app area}/ide-extension/package.json - contributes.configuration.id
    AnnotationModeler: 'sap.ux.annotationModeler',
    AppGenerator: 'sap.ux.appGenerator',
    ApplicationModeler: 'sap.ux.applicationModeler',
    Help: 'sap.ux.help',
    RequirementsGathering: 'sap.ux.requirementsGathering',
    ServiceModeler: 'sap.ux.serviceModeler',
    Internal: 'sap.ux.internal'
};
const tokenToggleGuid = {
    'dummy.test.testBetaFeatures.someTokenFeature': '77e0469d-1448-42bf-8d47-0944896dd9ed',
    'sap.ux.applicationModeler.testBetaFeatures.enableV4': '2f393e27-d486-40dc-a82d-3e879ae801b4',
    'sap.ux.help.testBetaFeatures.enableAppStudioGDContribution': 'c8c52f0b-0d7d-4697-997a-d6f29814f42e',
    'sap.ux.help.testBetaFeatures.enableAbapCdsSupport': '794cae98-3456-491a-ae20-3215a98b56df',
    'sap.ux.help.testBetaFeatures.showTestGuides': 'fbb03f42-0a86-4fd5-9fc4-8c9b38a4d1a3'
};
exports.FeatureToggleKey = 'testBetaFeatures';
exports.ExperimentalFeatures = 'sap.ux.applicationModeler.enableExperimentalFeatures';
class FeatureToggleAccess {
    static getFeatureToggle(feature) {
        var _a;
        let toggleConfigValue;
        if ((feature.includes(exports.FeatureToggleKey) || feature === exports.ExperimentalFeatures) && FeatureToggleAccess.vscode) {
            const toggleKey = feature.slice(0, feature.lastIndexOf('.'));
            const toggleId = feature.slice(feature.lastIndexOf('.') + 1, feature.length);
            toggleConfigValue = (_a = FeatureToggleAccess.vscode.workspace.getConfiguration(toggleKey)) === null || _a === void 0 ? void 0 : _a.get(toggleId);
        }
        else {
            toggleConfigValue = false;
        }
        // if TOOLSUITE_FEATURES env is set check if the feature is enabled there.
        if (process.env.TOOLSUITE_FEATURES) {
            const envFeatures = process.env.TOOLSUITE_FEATURES.split(',');
            toggleConfigValue = envFeatures.includes(feature) ? true : toggleConfigValue;
        }
        // Toggle token matches so set to true
        if (tokenToggleGuid[feature]) {
            if (tokenToggleGuid[feature] === toggleConfigValue) {
                toggleConfigValue = true;
            }
            else {
                // It is a token toggle, but the token does not match
                toggleConfigValue = false;
            }
        }
        const featureToggle = {
            feature: feature,
            isEnabled: toggleConfigValue === true ? toggleConfigValue : false
        };
        return featureToggle;
    }
    static getAllFeatureToggles() {
        const definedToggles = [];
        if (FeatureToggleAccess.vscode) {
            Object.keys(extensionConfigKeys).forEach((toggleConfigKey) => {
                const toggleKey = `${extensionConfigKeys[toggleConfigKey]}.${exports.FeatureToggleKey}`;
                let toggles = {};
                try {
                    toggles = JSON.parse(JSON.stringify(FeatureToggleAccess.vscode.workspace.getConfiguration(toggleKey)));
                }
                catch (e) {
                    // Not valid toggles. Skip.
                }
                Object.keys(toggles).forEach((toggleId) => {
                    // get full toggle value
                    const toggleConfigValue = FeatureToggleAccess.vscode.workspace
                        .getConfiguration(`${toggleKey}`)
                        .get(`${toggleId}`);
                    const toggle = {
                        feature: `${toggleKey}.${toggleId}`,
                        isEnabled: toggleConfigValue ? toggleConfigValue : false
                    };
                    definedToggles.push(toggle);
                });
            });
        }
        return definedToggles;
    }
}
exports.FeatureToggleAccess = FeatureToggleAccess;
FeatureToggleAccess.vscode = vscode;
/**
 * Enables a feature without a vscode reference
 * @param feature
 */
function enableFeature(feature) {
    let envFeatures = [];
    if (process.env.TOOLSUITE_FEATURES) {
        envFeatures = process.env.TOOLSUITE_FEATURES.split(',');
        if (!envFeatures.includes(feature)) {
            envFeatures.push(feature);
        }
    }
    else {
        envFeatures.push(feature);
    }
    process.env.TOOLSUITE_FEATURES = envFeatures.join();
}
exports.enableFeature = enableFeature;
function isFeatureEnabled(feature) {
    return FeatureToggleAccess.getFeatureToggle(feature).isEnabled;
}
exports.isFeatureEnabled = isFeatureEnabled;
/**
 * Returns true if the internal enablement extension's sap.ux.internal.enableInternalFeatures config setting is active.
 *
 * @returns {boolean}
 */
function isInternalFeaturesSettingEnabled() {
    var _a;
    const enableInternalFeaturesSetting = 'sap.ux.internal.enableInternalFeatures';
    let internalEnabled = false;
    if (FeatureToggleAccess.vscode) {
        const internalSetting = FeatureToggleAccess.vscode.workspace
            ? (_a = FeatureToggleAccess.vscode.workspace.getConfiguration()) === null || _a === void 0 ? void 0 : _a.get(enableInternalFeaturesSetting) : false;
        internalEnabled = internalSetting === true ? true : false;
    }
    if (process.env.TOOLSUITE_INTERNAL && process.env.TOOLSUITE_INTERNAL === 'true') {
        internalEnabled = true;
    }
    return internalEnabled;
}
exports.isInternalFeaturesSettingEnabled = isInternalFeaturesSettingEnabled;


/***/ }),

/***/ 69513:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var featureToggle_1 = __webpack_require__(90446);
exports.FeatureToggleAccess = featureToggle_1.FeatureToggleAccess;
exports.FeatureToggleKey = featureToggle_1.FeatureToggleKey;
exports.isFeatureEnabled = featureToggle_1.isFeatureEnabled;
exports.isInternalFeaturesSettingEnabled = featureToggle_1.isInternalFeaturesSettingEnabled;
exports.enableFeature = featureToggle_1.enableFeature;
exports.ExperimentalFeatures = featureToggle_1.ExperimentalFeatures;


/***/ }),

/***/ 76241:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const i18next_1 = __importDefault(__webpack_require__(20610));
const i18n_json_1 = __importDefault(__webpack_require__(97992));
exports.i18n = i18next_1.default.createInstance();
/**
 * Initialize i18next of "@sap/ux-i18n-properties"
 */
async function initI18n() {
    await exports.i18n.init({
        resources: {
            en: {
                translation: i18n_json_1.default
            }
        },
        lng: 'en',
        fallbackLng: 'en',
        joinArrays: '\n\n'
    });
}
exports.initI18n = initI18n;


/***/ }),

/***/ 55203:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
var properties_1 = __webpack_require__(47753);
exports.geI18ntDocumentation = properties_1.geI18ntDocumentation;
exports.loadPropertiesTexts = properties_1.loadPropertiesTexts;
exports.printPropertiesFileI18nEntry = properties_1.printPropertiesFileI18nEntry;
exports.printPropertiesFileI18nAnnotation = properties_1.printPropertiesFileI18nAnnotation;
var lineOffsets_1 = __webpack_require__(4787);
exports.getLineOffsets = lineOffsets_1.getLineOffsets;
var text_1 = __webpack_require__(79910);
exports.getI18nMaxLength = text_1.getI18nMaxLength;
exports.getI18nTextType = text_1.getI18nTextType;
var key_1 = __webpack_require__(75502);
exports.extractI18nKey = key_1.extractI18nKey;
exports.getI18nUniqueKey = key_1.getI18nUniqueKey;
var textConverters_1 = __webpack_require__(83525);
exports.convertToCamelCase = textConverters_1.convertToCamelCase;
exports.convertToPascalCase = textConverters_1.convertToPascalCase;
var position_1 = __webpack_require__(63787);
exports.Position = position_1.Position;
exports.Range = position_1.Range;
var positionAt_1 = __webpack_require__(72372);
exports.positionAt = positionAt_1.positionAt;
exports.rangeAt = positionAt_1.rangeAt;
__export(__webpack_require__(69338));
var i18n_1 = __webpack_require__(76241);
exports.initI18n = i18n_1.initI18n;
exports.i18n = i18n_1.i18n;
const i18n_2 = __webpack_require__(76241);
// init i18n
(async () => {
    await i18n_2.initI18n();
})();


/***/ }),

/***/ 75502:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Extract i18n key
 */
exports.extractI18nKey = (input, withoutAt) => {
    if (withoutAt) {
        const result = input
            .replace(/{i18n>|{i18n&gt;/, '')
            .replace('}', '')
            .trim();
        return result;
    }
    const result = input
        .replace(/{@i18n>|{@i18n&gt;/, '')
        .replace('}', '')
        .trim();
    return result;
};
/**
 * Get unique key
 *
 * If the key is not unique, it increment key by one and recheck
 *
 * @param key new key and it is incremented
 * @param i18nData I18n entries
 * @param originalKey original key without any index increment
 * @param counter counter for increment
 */
exports.getI18nUniqueKey = (key, i18nData, originalKey = key, counter = 1) => {
    const uniqueKey = key;
    let keyExists = false;
    if (Array.isArray(i18nData)) {
        keyExists = i18nData.findIndex((item) => item.key.value === key) !== -1;
    }
    else {
        keyExists = i18nData[key] !== undefined;
    }
    if (keyExists) {
        key = `${originalKey}${counter}`;
        counter++;
        return exports.getI18nUniqueKey(key, i18nData, originalKey, counter);
    }
    return uniqueKey;
};


/***/ }),

/***/ 4787:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Computes line offsets for the given string
 * @param text
 */
function getLineOffsets(text) {
    const lineOffsets = [0];
    for (let index = 0; index < text.length; index++) {
        const character = text[index];
        if (character === '\n') {
            lineOffsets.push(index + 1);
        }
        else if (character === '\r') {
            if (index + 1 < text.length && text[index + 1] === '\n') {
                index++;
            }
            lineOffsets.push(index + 1);
        }
    }
    return lineOffsets;
}
exports.getLineOffsets = getLineOffsets;


/***/ }),

/***/ 63787:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Position = {
    create(line, character) {
        return {
            line,
            character
        };
    }
};
function createRange(one, two, three, four) {
    if (typeof one === 'number' &&
        !isNaN(one) &&
        typeof two === 'number' &&
        !isNaN(two) &&
        typeof three === 'number' &&
        !isNaN(three) &&
        typeof four === 'number' &&
        !isNaN(four)) {
        return {
            start: exports.Position.create(one, two),
            end: exports.Position.create(three, four)
        };
    }
    else if (typeof one === 'object' && typeof two === 'object') {
        return {
            start: one,
            end: two
        };
    }
    throw new Error(`Range#create called with invalid arguments ${one}, ${two}, ${three}, ${four}`);
}
exports.Range = {
    create: createRange
};


/***/ }),

/***/ 72372:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const position_1 = __webpack_require__(63787);
/**
 *
 * @param lineOffsets Array of indices with line start offsets.
 * e.g [0] represents a document with one line that starts at offset 0.
 * @param offset
 * @param textLength
 */
function positionAt(lineOffsets, offset, textLength) {
    const target = Math.max(Math.min(offset, textLength), 0);
    let low = 0;
    let high = lineOffsets.length;
    if (high === 0) {
        return position_1.Position.create(0, target);
    }
    while (low < high) {
        const mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > target) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    const line = low - 1;
    return position_1.Position.create(line, target - lineOffsets[line]);
}
exports.positionAt = positionAt;
function rangeAt(lineOffsets, start, end, textLength) {
    return position_1.Range.create(positionAt(lineOffsets, start, textLength), positionAt(lineOffsets, end, textLength));
}
exports.rangeAt = rangeAt;


/***/ }),

/***/ 47753:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const i18n_1 = __webpack_require__(76241);
const position_1 = __webpack_require__(63787);
const propertiesParser_1 = __webpack_require__(86334);
const text_1 = __webpack_require__(79910);
const COMMENT_REGEX = /\s*(:?#|!)|[^\n\r]*/;
/**
 * Get abstract syntax tree for i18n.properties file
 * @param content
 * @param filePath
 */
exports.loadPropertiesTexts = (content, filePath = '') => {
    const i18nEntries = [];
    const lines = propertiesParser_1.parseProperties(content);
    for (let i = 0; lines.length > i; i++) {
        const line = lines[i];
        if (line.type === 'key-element-line') {
            const commentLine = lines[i - 1];
            const entry = {
                filePath,
                key: {
                    value: line.key.value,
                    range: line.key.range
                },
                value: {
                    value: line.element.value,
                    range: line.element.range
                }
            };
            if ((commentLine === null || commentLine === void 0 ? void 0 : commentLine.type) === 'comment-line' && COMMENT_REGEX.test(commentLine.value)) {
                const { start } = commentLine.range;
                const commaIndex = commentLine.value.indexOf(',');
                const colonIndex = commentLine.value.indexOf(':');
                entry.annotation = {
                    textType: toTextTypeNode(commentLine, commaIndex, colonIndex)
                };
                if (commaIndex !== -1) {
                    entry.annotation.maxLength = {
                        value: parseInt(commentLine.value.slice(commaIndex + 1, colonIndex === -1 ? undefined : colonIndex)),
                        range: position_1.Range.create(start.line, start.character + commaIndex + 1, start.line, start.character + (colonIndex === -1 ? commentLine.value.length : colonIndex))
                    };
                }
                if (colonIndex !== -1) {
                    entry.annotation.note = {
                        value: commentLine.value.slice(colonIndex + 1),
                        range: position_1.Range.create(start.line, start.character + colonIndex + 1, start.line, start.character + commentLine.value.length)
                    };
                }
            }
            i18nEntries.push(entry);
        }
    }
    return i18nEntries;
};
function toTextTypeNode(comment, commaIndex, colonIndex) {
    const { start } = comment.range;
    // Comments can only be single line, so start and end lines will be equal
    if (commaIndex !== -1) {
        return {
            value: comment.value.slice(1, commaIndex),
            range: position_1.Range.create(start.line, start.character, start.line, start.character + commaIndex)
        };
    }
    else if (colonIndex !== -1) {
        return {
            value: comment.value.slice(1, colonIndex),
            range: position_1.Range.create(start.line, start.character + 1, start.line, start.character + colonIndex)
        };
    }
    return {
        value: comment.value.slice(1),
        range: position_1.Range.create(start.line, start.character, start.line, start.character + comment.value.length)
    };
}
/**
 * Creates annotation text in .properties file format.
 * If no annotation is not provided, default one is generated based on text.
 * @param text
 * @param annotation Context information for the text
 */
function printPropertiesFileI18nAnnotation(text, annotation) {
    if (!annotation) {
        const maxLen = text_1.getI18nMaxLength(text);
        const textType = text_1.getI18nTextType(maxLen);
        return `${textType},${maxLen}`;
    }
    if (typeof annotation === 'string') {
        const prefix = text.length <= 120 ? 'X' : 'Y';
        return `${prefix}${annotation}`;
    }
    if (typeof annotation === 'object') {
        const { textType, note, maxLength } = annotation;
        const fragments = [textType];
        if (maxLength !== undefined) {
            fragments.push(',', maxLength.toString());
        }
        if (note) {
            fragments.push(':', ' ', note.trim());
        }
        return fragments.join('');
    }
    return '';
}
exports.printPropertiesFileI18nAnnotation = printPropertiesFileI18nAnnotation;
/**
 * Creates text for i18n entry in .properties file format.
 * If no annotation is not present, generic default one will be generated based on the text.
 * @param key
 * @param text
 * @param annotation Context information for the text
 */
function printPropertiesFileI18nEntry(key, text, annotation) {
    const annotationText = printPropertiesFileI18nAnnotation(text, annotation);
    const comment = `#${annotationText}`;
    const keyValue = `${key}=${text}`;
    const i18nEntry = `\n${comment}\n${keyValue}\n`;
    return i18nEntry;
}
exports.printPropertiesFileI18nEntry = printPropertiesFileI18nEntry;
/**
 * Get documentation for i18n entry
 */
exports.geI18ntDocumentation = (entry) => {
    var _a, _b;
    const documentation = [];
    const key = `**${i18n_1.i18n.t('Text_Key')}:** ${entry.key.value}`;
    const value = `**${i18n_1.i18n.t('Text_Value')}:** ${entry.value.value}`;
    documentation.push(key, value);
    if (entry.annotation) {
        const annotationText = printPropertiesFileI18nAnnotation(entry.value.value, {
            maxLength: (_a = entry.annotation.maxLength) === null || _a === void 0 ? void 0 : _a.value,
            textType: entry.annotation.textType.value,
            note: (_b = entry.annotation.note) === null || _b === void 0 ? void 0 : _b.value
        });
        documentation.push(`**${i18n_1.i18n.t('Additional_Information')}:** ${annotationText}`);
    }
    return documentation.join('\n\n');
};


/***/ }),

/***/ 86334:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const lineOffsets_1 = __webpack_require__(4787);
const position_1 = __webpack_require__(63787);
const positionAt_1 = __webpack_require__(72372);
/**
 * Implements reading files Java properties files as described in https://docs.oracle.com/javase/10/docs/api/java/util/Properties.html
 */
function parseProperties(text) {
    const tokens = tokenize(text);
    const lineOffsets = lineOffsets_1.getLineOffsets(text);
    const contentLength = text.length;
    let i = 0;
    const peek = (count) => (count ? tokens[i + count] : tokens[i]);
    const consume = () => tokens[i++];
    const eof = () => i >= tokens.length;
    function parseComment() {
        const comment = consume();
        return {
            type: 'comment-line',
            value: comment.image,
            range: positionAt_1.rangeAt(lineOffsets, comment.start, comment.end, contentLength)
        };
    }
    function parseKeyElement() {
        var _a, _b, _c, _d, _e, _f;
        const keyToken = consume();
        const key = {
            type: 'text',
            value: keyToken.image,
            range: positionAt_1.rangeAt(lineOffsets, keyToken.start, keyToken.end, contentLength)
        };
        let resetStartOffset = true;
        let start;
        let end;
        if (peek().type === 'whitespace') {
            consume();
        }
        if (peek().type === 'separator') {
            const separator = consume();
            start = end = separator.end;
            if (peek().type === 'whitespace') {
                consume();
            }
        }
        let concatenatedValue = '';
        while (!eof() && ((_a = peek()) === null || _a === void 0 ? void 0 : _a.type) !== 'end-of-line') {
            while (!eof() && ((_b = peek()) === null || _b === void 0 ? void 0 : _b.type) !== 'end-of-line' && ((_c = peek()) === null || _c === void 0 ? void 0 : _c.type) !== 'continuation-line-marker') {
                if (((_d = peek()) === null || _d === void 0 ? void 0 : _d.type) === 'text' || ((_e = peek()) === null || _e === void 0 ? void 0 : _e.type) === 'whitespace') {
                    const valueToken = consume();
                    if (resetStartOffset) {
                        start = valueToken.start;
                        resetStartOffset = false;
                    }
                    end = valueToken.end;
                    concatenatedValue += valueToken.image;
                }
            }
            if (((_f = peek()) === null || _f === void 0 ? void 0 : _f.type) === 'continuation-line-marker') {
                consume();
                if (peek().type === 'whitespace') {
                    consume();
                }
            }
        }
        const element = {
            type: 'text',
            value: concatenatedValue,
            range: positionAt_1.rangeAt(lineOffsets, start !== null && start !== void 0 ? start : 0, end !== null && end !== void 0 ? end : 0, contentLength)
        };
        return {
            type: 'key-element-line',
            key,
            element,
            range: position_1.Range.create(key.range.start, element.range.end)
        };
    }
    function parseList() {
        var _a, _b;
        const list = [];
        while (!eof()) {
            const next = peek();
            if (next.type === 'comment') {
                list.push(parseComment());
            }
            else if (next.type === 'text') {
                list.push(parseKeyElement());
            }
            if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.type) === 'end-of-line' || ((_b = peek()) === null || _b === void 0 ? void 0 : _b.type) === 'whitespace') {
                consume();
            }
        }
        return list;
    }
    return parseList();
}
exports.parseProperties = parseProperties;
const SEPARATOR = /=|:/;
const COMMENT_START = /#|!/;
const END_OF_LINE = /\r|\n|\r\n/;
const WHITESPACE = /[ \t\f]+/;
const HEX_DIGIT = /[0-9a-fA-F]/;
const ELEMENT_ESCAPE_MAPPING = {
    '\\\\': '\\',
    '\\f': '\f',
    '\\n': '\n',
    '\\r': '\r',
    '\\t': '\t'
};
const KEY_ESCAPE_MAPPING = {
    ...ELEMENT_ESCAPE_MAPPING,
    '\\=': '=',
    '\\:': ':'
};
const UNICODE_CHARACTER_LENGTH = 4;
function createToken(type, image, start, end) {
    return {
        type,
        image,
        start,
        end
    };
}
exports.createToken = createToken;
function tokenize(text) {
    const tokens = [];
    let i = 0;
    let image = '';
    let start = 0;
    while (i < text.length) {
        let character = text[i];
        if (character === '\n') {
            tokens.push(createToken('end-of-line', '\n', start, i + 1));
            start = i + 1;
        }
        else if (character === '\r') {
            if (i + 1 < text.length && text[i + 1] === '\n') {
                tokens.push(createToken('end-of-line', character + text[i + 1], i, i + 2));
                start = i + 2;
                i++;
            }
            else {
                tokens.push({
                    type: 'end-of-line',
                    image: character,
                    start: i,
                    end: i + 1
                });
                start = i + 1;
            }
        }
        else if (COMMENT_START.test(character)) {
            image += character;
            while (i + 1 < text.length) {
                const next = text[i + 1];
                if (END_OF_LINE.test(next)) {
                    break;
                }
                image += next;
                i++;
            }
            tokens.push(createToken('comment', image, start, i + 1));
            image = '';
            start = i + 1;
        }
        else if (WHITESPACE.test(character)) {
            image += character;
            while (i + 1 < text.length) {
                const next = text[i + 1];
                if (!WHITESPACE.test(next) || END_OF_LINE.test(next)) {
                    break;
                }
                image += next;
                i++;
            }
            tokens.push(createToken('whitespace', image, start, i + 1));
            image = '';
            start = i + 1;
        }
        else {
            // key-element pair
            while (i < text.length) {
                character = text[i];
                if (character === '\\') {
                    const next = text[i + 1];
                    if (next !== undefined) {
                        const mappedValue = KEY_ESCAPE_MAPPING[character + next];
                        if (mappedValue !== undefined) {
                            image += mappedValue;
                            i += 2;
                        }
                        else if (character + next === '\\u') {
                            const unicodeEscapeEnd = i + UNICODE_CHARACTER_LENGTH + 1;
                            let unicodeCharacterCode = '';
                            for (let index = i + 2; index <= unicodeEscapeEnd; index++) {
                                const c = text[index];
                                if (HEX_DIGIT.test(c)) {
                                    unicodeCharacterCode += c;
                                }
                                else {
                                    break;
                                }
                            }
                            if (unicodeCharacterCode.length === 4) {
                                image += String.fromCharCode(parseInt(unicodeCharacterCode, 16));
                                i += 2 + UNICODE_CHARACTER_LENGTH;
                            }
                            else {
                                // partial unicode escape sequence
                                image += '\\u' + unicodeCharacterCode;
                                i += 2 + unicodeCharacterCode.length;
                            }
                        }
                        else {
                            i++;
                        }
                    }
                    continue;
                }
                if (WHITESPACE.test(character) || SEPARATOR.test(character) || END_OF_LINE.test(character)) {
                    break;
                }
                image += character;
                i++;
            }
            tokens.push(createToken('text', image, start, i));
            image = '';
            start = i;
            if (WHITESPACE.test(character)) {
                image += character;
                while (i + 1 < text.length) {
                    const next = text[i + 1];
                    if (!WHITESPACE.test(next) || END_OF_LINE.test(next)) {
                        break;
                    }
                    image += next;
                    i++;
                }
                tokens.push(createToken('whitespace', image, start, i + 1));
                image = '';
                start = i + 1;
                i++;
                character = text[i];
            }
            if (SEPARATOR.test(character)) {
                tokens.push(createToken('separator', character, start, i + 1));
                start = i + 1;
                i++;
                character = text[i];
            }
            if (WHITESPACE.test(character)) {
                image = character;
                while (i + 1 < text.length) {
                    const next = text[i + 1];
                    if (WHITESPACE.test(next) === false || END_OF_LINE.test(next)) {
                        break;
                    }
                    image += next;
                    i++;
                }
                tokens.push(createToken('whitespace', image, start, i + 1));
                image = '';
                start = i + 1;
                i++;
                character = text[i];
            }
            if (character === '\n') {
                tokens.push(createToken('end-of-line', '\n', start, i + 1));
                start = i + 1;
            }
            else if (character === '\r') {
                if (i + 1 < text.length && text[i + 1] === '\n') {
                    tokens.push(createToken('end-of-line', character + text[i + 1], i, i + 2));
                    start = i + 2;
                    i++;
                }
                else {
                    tokens.push({
                        type: 'end-of-line',
                        image: character,
                        start: i,
                        end: i + 1
                    });
                    start = i + 1;
                }
            }
            else {
                while (i < text.length) {
                    character = text[i];
                    if (character === '\\') {
                        const next = text[i + 1];
                        if (next !== undefined) {
                            const mappedValue = ELEMENT_ESCAPE_MAPPING[character + next];
                            if (mappedValue !== undefined) {
                                image += mappedValue;
                                i += 2;
                            }
                            else if (character + next === '\\u') {
                                const unicodeEscapeEnd = i + UNICODE_CHARACTER_LENGTH + 1;
                                let unicodeCharacterCode = '';
                                for (let index = i + 2; index <= unicodeEscapeEnd; index++) {
                                    const c = text[index];
                                    if (HEX_DIGIT.test(c)) {
                                        unicodeCharacterCode += c;
                                    }
                                    else {
                                        break;
                                    }
                                }
                                if (unicodeCharacterCode.length === 4) {
                                    image += String.fromCharCode(parseInt(unicodeCharacterCode, 16));
                                    i += 2 + UNICODE_CHARACTER_LENGTH;
                                }
                                else {
                                    // partial unicode escape sequence
                                    image += '\\u' + unicodeCharacterCode;
                                    i += 2 + unicodeCharacterCode.length;
                                }
                            }
                            else if (next === '\n') {
                                tokens.push(createToken('text', image, start, i));
                                tokens.push(createToken('continuation-line-marker', '\\\n', i, i + 2));
                                start = i + 2;
                                i += 2;
                                image = '';
                            }
                            else if (next === '\r') {
                                if (i + 1 < text.length && text[i + 2] === '\n') {
                                    tokens.push(createToken('text', image, start, i));
                                    tokens.push(createToken('continuation-line-marker', '\\\r\n', i, i + 3));
                                    start = i + 3;
                                    i += 3;
                                    image = '';
                                }
                                else {
                                    tokens.push(createToken('text', image, start, i));
                                    tokens.push(createToken('continuation-line-marker', '\\\r', i, i + 2));
                                    start = i + 2;
                                    i += 2;
                                    image = '';
                                }
                            }
                            else {
                                i++;
                            }
                        }
                        continue;
                    }
                    if (WHITESPACE.test(character)) {
                        if (image) {
                            tokens.push(createToken('text', image, start, i));
                            image = '';
                            start = i;
                        }
                        image = character;
                        while (i + 1 < text.length) {
                            const next = text[i + 1];
                            if (WHITESPACE.test(next) === false || END_OF_LINE.test(next)) {
                                break;
                            }
                            image += next;
                            i++;
                        }
                        tokens.push(createToken('whitespace', image, start, i + 1));
                        image = '';
                        start = i + 1;
                        i++;
                        character = text[i];
                        continue;
                    }
                    if (END_OF_LINE.test(character)) {
                        break;
                    }
                    image += character;
                    i++;
                }
                tokens.push(createToken('text', image, start, i));
                image = '';
                start = i;
                if (END_OF_LINE.test(character)) {
                    continue;
                }
            }
        }
        i++;
    }
    return tokens;
}
exports.tokenize = tokenize;


/***/ }),

/***/ 79910:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const types_1 = __webpack_require__(69338);
/**
 * Get the calculated maximum text length for an i18n property value.
 *
 * (The algorithm considers the current UI5 specification)
 *
 * @param value - Value of the i18n property
 */
exports.getI18nMaxLength = (value) => {
    const iLength = value.length;
    const iMaxLength = iLength < 8 ? iLength * 5 : iLength <= 30 ? iLength * 3 : iLength * 1.5;
    return iMaxLength;
};
/**
 * Get a suitable textType for an i18n property.
 *
 * The textType is derived from the maximum text length maxLength of the property value.
 *
 * @param maxLength - Maximum text length of the i18n property value
 */
exports.getI18nTextType = (maxLength) => {
    if (maxLength <= 120) {
        return types_1.SapShortTextType.Label;
    }
    return types_1.SapLongTextType.MessageText;
};


/***/ }),

/***/ 83525:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Convert to camel case
 *
 * It gets input like 'product details info' and convert it
 * to 'productDetailsInfo'
 *
 */
exports.convertToCamelCase = (input = '', maxWord = 4) => {
    let output = '';
    const parts = input
        .replace(/[^a-zA-Z0-9 ]/g, '')
        .trim()
        .split(' ');
    const len = parts.length >= maxWord ? maxWord : parts.length;
    for (let i = 0; len > i; i++) {
        const part = parts[i];
        if (i === 0) {
            output += part.toLowerCase();
        }
        else {
            const initial = part.charAt(0).toUpperCase();
            const rest = part.substr(1).toLowerCase();
            output += `${initial}${rest}`;
        }
    }
    return output;
};
/**
 * Convert to pascal case
 *
 * It gets input like 'product details info' and convert it
 * to 'ProductDetailsInfo'
 */
exports.convertToPascalCase = (input, maxWord = 4) => {
    let output = '';
    const parts = input
        .replace(/[^a-zA-Z0-9 ]/g, '')
        .trim()
        .split(' ');
    const len = parts.length >= maxWord ? maxWord : parts.length;
    for (let i = 0; len > i; i++) {
        const part = parts[i];
        const initial = part.charAt(0).toUpperCase();
        const rest = part.substr(1).toLowerCase();
        output += `${initial}${rest}`;
    }
    return output;
};


/***/ }),

/***/ 69338:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Text types for texts that are less than 120 characters long
 * https://openui5.hana.ondemand.com/topic/831039835e7c4da3a8a0b49567573afe
 */
var SapShortTextType;
(function (SapShortTextType) {
    SapShortTextType["Accessibility"] = "XACT";
    SapShortTextType["AlternativeText"] = "XALT";
    SapShortTextType["BreadcrumbStep"] = "XBCB";
    SapShortTextType["BulletListItemText"] = "XBLI";
    SapShortTextType["ButtonText"] = "XBUT";
    SapShortTextType["Caption"] = "XCAP";
    SapShortTextType["Cell"] = "XCEL";
    SapShortTextType["Checkbox"] = "XCKL";
    SapShortTextType["ColumnHeader"] = "XCOL";
    SapShortTextType["Tabstrip"] = "XCRD";
    SapShortTextType["DataNavigationText"] = "XDAT";
    SapShortTextType["Label"] = "XFLD";
    SapShortTextType["Frame"] = "XFRM";
    SapShortTextType["Term"] = "XGLS";
    SapShortTextType["GroupTitle"] = "XGRP";
    SapShortTextType["Heading"] = "XHED";
    SapShortTextType["LegendText"] = "XLGD";
    SapShortTextType["HyperlinkText"] = "XLNK";
    SapShortTextType["LogEntry"] = "XLOG";
    SapShortTextType["ListBoxItem"] = "XLST";
    SapShortTextType["MenuHeader"] = "XMEN";
    SapShortTextType["MenuItem"] = "XMIT";
    SapShortTextType["MessageText"] = "XMSG";
    SapShortTextType["RadioButton"] = "XRBL";
    SapShortTextType["RoadmapStep"] = "XRMP";
    SapShortTextType["TableRowHeading"] = "XROW";
    SapShortTextType["SelectionText"] = "XSEL";
    SapShortTextType["TabStripText"] = "XTBS";
    SapShortTextType["TableTitle"] = "XTIT";
    SapShortTextType["TreeNodeText"] = "XTND";
    SapShortTextType["QuickInfoText"] = "XTOL";
    SapShortTextType["GeneralText"] = "XTXT";
})(SapShortTextType = exports.SapShortTextType || (exports.SapShortTextType = {}));
/**
 * Text types for texts that are more than 120 characters long
 * https://openui5.hana.ondemand.com/topic/831039835e7c4da3a8a0b49567573afe
 */
var SapLongTextType;
(function (SapLongTextType) {
    SapLongTextType["Accessibility"] = "YACT";
    SapLongTextType["BulletListItemText"] = "YBLI";
    SapLongTextType["Definition"] = "YDEF";
    SapLongTextType["Description"] = "YDES";
    SapLongTextType["Explanation"] = "YEXP";
    SapLongTextType["FaqAnswer"] = "YFAA";
    SapLongTextType["Faq"] = "YFAQ";
    SapLongTextType["GlossaryDefinition"] = "YGLS";
    SapLongTextType["Information"] = "YINF";
    SapLongTextType["Instruction"] = "YINS";
    SapLongTextType["LogEntry"] = "YLOG";
    SapLongTextType["ErrorMessage"] = "YMSE";
    SapLongTextType["MessageText"] = "YMSG";
    SapLongTextType["InformationMessageLong"] = "YMSI";
    SapLongTextType["WarningMessage"] = "YMSW";
    SapLongTextType["TechnicalText"] = "YTEC";
    SapLongTextType["Ticker"] = "YTIC";
    SapLongTextType["GeneralTextLong"] = "YTXT";
})(SapLongTextType = exports.SapLongTextType || (exports.SapLongTextType = {}));
exports.NOT_RELEVANT_FOR_TRANSLATION = 'NOTR';


/***/ }),

/***/ 52136:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const config_1 = __webpack_require__(69180);
const ux_store_1 = __webpack_require__(16493);
const constants_1 = __webpack_require__(60704);
async function getApiHubApiKey(log = console) {
    const keyStore = ux_store_1.getSecureStore(log);
    const apiHubServiceName = config_1.ServiceName.ApiHub;
    const apiHubApiKey = await keyStore.retrieve(apiHubServiceName, constants_1.API_HUB_API_KEY);
    if (apiHubApiKey) {
        log.info('Retrieved stored API hub key');
    }
    return apiHubApiKey;
}
exports.getApiHubApiKey = getApiHubApiKey;
async function saveApiHubApiKey(val, log = console) {
    const keyStore = ux_store_1.getSecureStore(log);
    const apiHubServiceName = config_1.ServiceName.ApiHub;
    const existingKey = await getApiHubApiKey(log);
    if (existingKey !== undefined) {
        await keyStore.delete(apiHubServiceName, constants_1.API_HUB_API_KEY);
    }
    return keyStore.save(apiHubServiceName, constants_1.API_HUB_API_KEY, val);
}
exports.saveApiHubApiKey = saveApiHubApiKey;


/***/ }),

/***/ 40552:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils_1 = __webpack_require__(3283);
const oDataClient_1 = __webpack_require__(90211);
const common_1 = __webpack_require__(77659);
/**
 * Responsible for ATO Catalog retrieval and parsing
 */
class AtoCatalog {
    static async getATOData({ system, credentials, log = console, connection = undefined, systemInstance }) {
        // Override system config and credentials with the  system instance details, if passed in
        let systemConfig;
        let creds;
        if (systemInstance) {
            systemConfig = { ...systemInstance.config, service: common_1.ATO_CATALOG_URL_PATH };
            const sys = systemInstance.serialize();
            creds = {
                username: sys.username,
                password: sys.password,
                serviceKeysContents: sys.serviceKeys
            };
        }
        else {
            systemConfig = { ...system, service: common_1.ATO_CATALOG_URL_PATH };
            if (credentials) {
                creds = credentials;
            }
        }
        const atoDataXml = await new oDataClient_1.ODataClient({
            system: systemConfig,
            credentials: creds,
            log,
            connection,
            autoAddTrailingSlash: false
        }).get();
        return this.getAtoData(atoDataXml);
    }
    static getAtoData(atoDataXml) {
        const atoData = utils_1.xmlToJson(atoDataXml);
        const settings = atoData['settings'];
        const atoSettings = {
            tenantType: settings.tenantType,
            operationsType: settings.operationsType,
            isExtensibilityDevSystem: settings.isExtensibilityDevelopmentSystem === true,
            devPackage: settings.developmentPackage,
            devPrefix: settings.developmentPrefix
        };
        return atoSettings;
    }
}
exports.AtoCatalog = AtoCatalog;


/***/ }),

/***/ 77659:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const oDataClient_1 = __webpack_require__(90211);
exports.V2_CATALOG_URL_PATH = '/sap/opu/odata/IWFND/CATALOGSERVICE;v=2';
exports.V4_CATALOG_URL_PATH_DEV = '/sap/opu/odata4/iwfnd/config/default/iwfnd/catalog/0001';
exports.V4_CATALOG_URL_PATH_PROD = '/sap/opu/odata4/iwfnd/config/default/iwfnd/catalog/0002';
exports.V2_SERVICES_PATH = '/ServiceCollection';
exports.V2_RECOMMENDED_SERVICES_PATH = '/RecommendedServiceCollection';
exports.V4_SERVICES_PATH_DEV = `/ServiceGroups('%2FIWBEP%2FALL')?$expand=Systems($expand=Services)`;
exports.V4_SERVICES_PATH_PROD = `/ServiceGroups?$expand=DefaultSystem($expand=Services)`;
exports.V4_RECOMMENDED_SERVICES_PATH_PROD = `/ServiceGroups?$expand=DefaultSystem($expand=RecommendedServices)`;
exports.V2_ODATA_CATALOG_FILTER_FOR_S4_HANA_SERVICES = '?%24filter=((IsSapService%20eq%20true)and(ReleaseStatus%20eq%20%27RELEASED%27))or((IsSapService%20eq%20false))';
exports.ATO_CATALOG_URL_PATH = '/sap/bc/adt/ato/settings';
exports.ODATA_COUNT_QUERY = '$count=true';
exports.ODATA_SKIP_QUERY = '$skiptoken';
/**
 * OData versions supported by the catalog service
 */
var ODataVersion;
(function (ODataVersion) {
    ODataVersion["v2"] = "2";
    ODataVersion["v4"] = "4";
})(ODataVersion = exports.ODataVersion || (exports.ODataVersion = {}));
class Catalog extends oDataClient_1.ODataClient {
}
exports.Catalog = Catalog;
var CATALOG_REQ_TYPE;
(function (CATALOG_REQ_TYPE) {
    CATALOG_REQ_TYPE[CATALOG_REQ_TYPE["RECOMMENDED"] = 0] = "RECOMMENDED";
    CATALOG_REQ_TYPE[CATALOG_REQ_TYPE["LEGACY"] = 1] = "LEGACY";
})(CATALOG_REQ_TYPE = exports.CATALOG_REQ_TYPE || (exports.CATALOG_REQ_TYPE = {}));


/***/ }),

/***/ 2593:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const __1 = __webpack_require__(41513);
__export(__webpack_require__(77659));
__export(__webpack_require__(40552));
__export(__webpack_require__(70308));
__export(__webpack_require__(11593));
__export(__webpack_require__(41554));
function getCatalog(options) {
    return options.odataVersion === __1.ODataVersion.v4 ? new __1.V4Catalog(options) : new __1.V2Catalog(options);
}
exports.getCatalog = getCatalog;


/***/ }),

/***/ 41554:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Checks the ato settings properties that chaacterrise an S4 Cloud system
 * @param atoSettings
 * @returns  boolean
 */
function isS4HanaCloudSystem(atoSettings) {
    return (atoSettings.tenantType === 'CUSTOMER' &&
        atoSettings.operationsType === 'C' &&
        atoSettings.isExtensibilityDevSystem === true &&
        atoSettings.devPrefix !== '' &&
        atoSettings.devPackage !== '');
}
exports.isS4HanaCloudSystem = isS4HanaCloudSystem;


/***/ }),

/***/ 70308:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const uaaOauth_1 = __webpack_require__(33593);
const atoCatalog_1 = __webpack_require__(40552);
const common_1 = __webpack_require__(77659);
const utils_1 = __webpack_require__(41554);
/**
 * Extension of the generic OData client simplifying the consumption of the SAP OData Catalog service
 */
class V2Catalog extends common_1.Catalog {
    constructor({ system, credentials = undefined, log = console, connection = undefined, postConnectionCallback }) {
        var _a, _b;
        if ((credentials === null || credentials === void 0 ? void 0 : credentials.serviceKeys) || (credentials === null || credentials === void 0 ? void 0 : credentials.serviceKeysContents)) {
            const serviceInfo = uaaOauth_1.getServiceInfo(credentials);
            credentials.serviceInfo = serviceInfo;
            system.url = serviceInfo.url;
            if ((_b = (_a = serviceInfo.catalogs) === null || _a === void 0 ? void 0 : _a.abap) === null || _b === void 0 ? void 0 : _b.path) {
                system.service = serviceInfo.catalogs.abap.path;
            }
        }
        else if (!system.service) {
            system.service = common_1.V2_CATALOG_URL_PATH;
        }
        super({ system, credentials, log, connection, postConnectionCallback });
    }
    /**
     * List all available Services
     */
    async listServices(recommended = false) {
        if (recommended) {
            return this.get(common_1.V2_RECOMMENDED_SERVICES_PATH);
        }
        else {
            let isS4C = false;
            try {
                await this.getConnection();
                isS4C = utils_1.isS4HanaCloudSystem(await atoCatalog_1.AtoCatalog.getATOData({
                    system: this.system,
                    connection: this.connection,
                    log: this.log,
                    credentials: this.credentials
                }));
            }
            catch (error) {
                // @todo display as debug level error
                // `Cannot read ATO Catalog. Could not determine if system is S4C.`;
            }
            return this.get(isS4C ? common_1.V2_SERVICES_PATH + common_1.V2_ODATA_CATALOG_FILTER_FOR_S4_HANA_SERVICES : common_1.V2_SERVICES_PATH);
        }
    }
    /**
     * Find a specific service by title
     * @param title service title
     */
    async findService({ title, path }) {
        if (!title) {
            title = path
                .replace(/\/$/, '')
                .split('/')
                .pop();
            if (!title) {
                throw new Error(`Cannot determine service title from path: ${path}`);
            }
        }
        title = title.toUpperCase(); // Same as WebIDE. #6368 for details.
        // TODO: use ServiceUrl instead of title extraction
        // filter += '$filter=' + encodeURIComponent(`ServiceUrl eq "${encodeURIComponent(this.system.url + path)}"`);
        const services = await this.get(`/ServiceCollection/?$filter=Title%20eq%20%27${title}%27&$format=json`);
        if (services.length > 1) {
            // #14793: Fix for user created multi namespaces for the same service
            const servicesWithSameNameSpace = services.filter((service) => { var _a; return (_a = service.ServiceUrl) === null || _a === void 0 ? void 0 : _a.toUpperCase().includes(path.toUpperCase()); });
            if (servicesWithSameNameSpace.length > 1) {
                this.log.warn('Service filter was not sufficient to identify one service.');
            }
            else if (servicesWithSameNameSpace.length > 0) {
                this.log.info(`Service filter chose service: ${servicesWithSameNameSpace[0].TechnicalServiceName}`);
                return servicesWithSameNameSpace[0];
            }
        }
        return services.length > 0 ? services[0] : undefined;
    }
    /**
     * Get all annotations available for the service matching one of the below filter options
     * @param id service id
     * @param title sevice title
     * @param path service path
     */
    async getAnnotations({ id, title, path }) {
        if (!id && !title && !path) {
            throw new Error('No filter parameters passed in');
        }
        const serviceAnnotations = await this.getServiceAnnotations({ id, title, path });
        const annotations = [];
        if (serviceAnnotations) {
            for (const service of serviceAnnotations) {
                const _path = `/Annotations(TechnicalName='${encodeURIComponent(service.TechnicalName)}',Version='${service.Version}')/$value/`;
                const annotDefs = await this.get(_path);
                if (annotDefs) {
                    annotations.push({
                        TechnicalName: service.TechnicalName,
                        Version: service.Version,
                        Definitions: annotDefs,
                        Uri: this.system.service + _path
                    });
                }
                else {
                    this.log.warn(`No annotations found for TechnicalName=${service.TechnicalName}, Version=${service.Version}`);
                }
            }
        }
        return annotations;
    }
    async getServiceAnnotations({ id, title, path }) {
        if (!id) {
            const serviceInfo = await this.findService({ title, path });
            if (serviceInfo) {
                id = serviceInfo.ID;
            }
        }
        if (id) {
            return this.get(`/ServiceCollection('${encodeURIComponent(id)}')/Annotations?$format=json`);
        }
        else {
            return undefined;
        }
    }
}
exports.V2Catalog = V2Catalog;


/***/ }),

/***/ 11593:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const uaaOauth_1 = __webpack_require__(33593);
const common_1 = __webpack_require__(77659);
/**
 * Extension of the generic OData client simplifying the consumption of the SAP OData Catalog service
 */
class V4Catalog extends common_1.Catalog {
    constructor({ system, credentials = undefined, log = console, connection = undefined, postConnectionCallback }) {
        if ((credentials === null || credentials === void 0 ? void 0 : credentials.serviceKeys) || (credentials === null || credentials === void 0 ? void 0 : credentials.serviceKeysContents)) {
            const serviceInfo = uaaOauth_1.getServiceInfo(credentials);
            credentials.serviceInfo = serviceInfo;
            system.url = serviceInfo.url;
        }
        system.service = common_1.V4_CATALOG_URL_PATH_PROD;
        super({ system, credentials, log, connection, postConnectionCallback });
    }
    parseServiceData(serviceGroups, recommended) {
        if (serviceGroups && Array.isArray(serviceGroups)) {
            const servicePropName = recommended ? 'RecommendedServices' : 'Services';
            const services = [];
            serviceGroups.forEach(({ DefaultSystem, GroupId }) => {
                services.push(...DefaultSystem[servicePropName].map((service) => Object.assign(service, { GroupId })));
            });
            return services;
        }
        return [];
    }
    /**
     * List all available Services
     */
    async listServices(recommended = false) {
        var _a, _b;
        if (!this.services) {
            const servicePath = recommended ? common_1.V4_RECOMMENDED_SERVICES_PATH_PROD : common_1.V4_SERVICES_PATH_PROD;
            this.services = [];
            const respValues = await this.get(`${servicePath}&${common_1.ODATA_COUNT_QUERY}`);
            this.services = this.services.concat(this.parseServiceData(respValues.value, recommended));
            // Using sequential paging
            if (respValues['@odata.nextLink']) {
                let skipval = parseInt((_a = respValues['@odata.nextLink']) === null || _a === void 0 ? void 0 : _a.split('skiptoken=')[1]);
                while (!isNaN(skipval) && skipval > 0) {
                    const groupsResp = await this.get(`${servicePath}&${common_1.ODATA_SKIP_QUERY}=${skipval}`);
                    this.services.push(...this.parseServiceData(groupsResp.value, recommended));
                    skipval = parseInt((_b = groupsResp['@odata.nextLink']) === null || _b === void 0 ? void 0 : _b.split('skiptoken=')[1]);
                }
            }
        }
        return this.services;
    }
    /**
     * Get all annotations available for the service matching one of the below filter options
     * @param id service id
     * @param title sevice title
     * @param path service path
     */
    async getAnnotations() {
        return Promise.resolve([]);
    }
}
exports.V4Catalog = V4Catalog;


/***/ }),

/***/ 9623:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const axios_1 = __importDefault(__webpack_require__(61674));
const connection_1 = __webpack_require__(9322);
const https_1 = __importDefault(__webpack_require__(95687));
const url_1 = __webpack_require__(57310);
async function newHttpClient({ system, credentials, log, existingConnection, autoAddTrailingSlash = true, timeout, ignoreCertError, postConnectionCallback }) {
    const connection = existingConnection ||
        (await connection_1.connect({
            target: system,
            credentials,
            log,
            autoAddTrailingSlash,
            timeout,
            ignoreCertError,
            postConnectionCallback
        }));
    const headers = {
        Cookie: connection.cookies.toString(),
        common: {
            Accept: 'application/json,application/xml,text/plain,*/*'
        }
    };
    if (connection.xsrfToken) {
        headers['x-csrf-token'] = connection.xsrfToken;
    }
    const config = {
        baseURL: new url_1.URL(system.service, system.url).toString(),
        headers,
        withCredentials: true,
        httpsAgent: new https_1.default.Agent({
            rejectUnauthorized: !ignoreCertError
        })
    };
    if (connection === null || connection === void 0 ? void 0 : connection.auth) {
        config.auth = connection.auth;
    }
    const httpClient = axios_1.default.create(config);
    return { connection, httpClient };
}
exports.newHttpClient = newHttpClient;


/***/ }),

/***/ 41513:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(90211));
__export(__webpack_require__(85120));
__export(__webpack_require__(2593));
__export(__webpack_require__(78948));
__export(__webpack_require__(16878));


/***/ }),

/***/ 78948:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const chalk_1 = __importDefault(__webpack_require__(11424));
/**
 * Log a Gateway response
 * @param msg message returned from gateway
 * @param log logger to be used
 */
function prettyPrintMessage(msg, log, url) {
    logLevel(msg.severity, msg.message, log);
    if (msg.longtextUrl && url) {
        let fullLongTextUrl = url.concat(msg.longtextUrl);
        fullLongTextUrl = fullLongTextUrl.replace(/'/g, '%27'); // to make entire link clickable
        log.info(fullLongTextUrl);
    }
    if (msg.details) {
        msg.details.forEach((entry) => {
            logLevel(entry.severity, entry.message, log);
        });
    }
}
exports.prettyPrintMessage = prettyPrintMessage;
function logLevel(severity, msg, log, error = false) {
    if (severity) {
        severity = severity === null || severity === void 0 ? void 0 : severity.toLowerCase();
        if (severity === 'success') {
            log.info(chalk_1.default.greenBright(msg));
        }
        else {
            if (severity === 'warning') {
                severity = 'warn';
            }
            log[severity](msg);
        }
    }
    else {
        error ? log.error(msg) : log.info(msg);
    }
}
/**
 * Log a Gateway error
 * @param msg error message returned from gateway
 * @param log logger to be used
 */
function prettyPrintError(error, log) {
    var _a;
    if (error) {
        log.error((_a = error.message) === null || _a === void 0 ? void 0 : _a.value);
        if (error.innererror) {
            if (error.innererror.errordetails) {
                printErrorDetails(error.innererror.errordetails, log);
            }
            if (error.innererror.Error_Resolution) {
                for (const key in error.innererror.Error_Resolution) {
                    log.error(`${key}: ${error.innererror.Error_Resolution[key]}`);
                }
            }
        }
    }
}
exports.prettyPrintError = prettyPrintError;
function printErrorDetails(errors, log) {
    if (errors) {
        errors.forEach((entry) => {
            if (!entry.message.startsWith('<![CDATA')) {
                logLevel(entry.severity, entry.message, log, true);
            }
        });
    }
}
exports.printErrorDetails = printErrorDetails;


/***/ }),

/***/ 90211:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const ux_common_utils_1 = __webpack_require__(59859);
const httpClient_1 = __webpack_require__(9623);
const message_1 = __webpack_require__(78948);
const destination_1 = __webpack_require__(1543);
const patchTls_1 = __webpack_require__(16878);
const __1 = __webpack_require__(24951);
const error_1 = __webpack_require__(38633);
/**
 * Generic OData client that can be used to send requests to any OData service.
 */
class ODataClient {
    constructor({ system, credentials = undefined, log = console, connection = undefined, autoAddTrailingSlash = true, timeout, ignoreCertError, postConnectionCallback }) {
        this.autoAddTrailingSlash = true;
        this.system = system;
        this.credentials = credentials;
        this.log = log;
        this.connection = connection;
        this.autoAddTrailingSlash = autoAddTrailingSlash;
        this.timeout = timeout;
        this.ignoreCertError = ignoreCertError;
        this.postConnectionCallback = postConnectionCallback;
        // monkey patch TLS to trust SAPs root certificate
        if (system && patchTls_1.TlsPatch.isPatchRequired(system.url)) {
            patchTls_1.TlsPatch.apply();
        }
        this.validateSysAuthType(system, credentials);
    }
    /**
     *
     * Validate system authentication type, if provided
     * Else work it out using credentials passed in
     * Will throw an error if authentication type is not recognized
     * @param credentials
     */
    validateSysAuthType(system, credentials) {
        system.authenticationType = system.authenticationType || __1.guessAuthType({ credentials, fallback: true });
        if (!Object.values(__1.AuthenticationType).includes(system.authenticationType)) {
            throw new error_1.UnknownSystemAuthenticationType(system.authenticationType);
        }
    }
    /**
     * Log errors more user friendly if it is a standard Gateway error
     * @param e error thrown by Axios after sending a request
     */
    logError(e) {
        this.log.error(e.message);
        if (e.isAxiosError && e.response.data['error']) {
            message_1.prettyPrintError(e.response.data['error'], this.log);
        }
    }
    /**
     * Get an AxiosInstance after connecting to the endpoint
     */
    async getClient() {
        if (!this.client) {
            // Check if we run in app studio
            if (ux_common_utils_1.isAppStudio()) {
                await destination_1.updateSystemConfig(this.system);
            }
            const { connection, httpClient } = await httpClient_1.newHttpClient({
                system: this.system,
                credentials: this.credentials,
                log: this.log,
                existingConnection: this.connection,
                autoAddTrailingSlash: this.autoAddTrailingSlash,
                timeout: this.timeout,
                ignoreCertError: this.ignoreCertError,
                updateUserInfo: this.updateUserInfo,
                postConnectionCallback: this.postConnectionCallback
            });
            this.connection = connection;
            this.client = httpClient;
        }
        return this.client;
    }
    async getConnection() {
        if (!this.connection) {
            await this.getClient();
        }
        return this.connection;
    }
    /**
     * Request the metadata of the odata service
     */
    async metadata() {
        var _a;
        const metadataPath = ((_a = this.system.service) === null || _a === void 0 ? void 0 : _a.endsWith('/')) ? '$metadata' : '/$metadata';
        return this.get(metadataPath, { Accept: 'application/xml' });
    }
    /**
     * Get any data from an OData service
     * @param path service specific entity path
     * @param headers - axios headers (optional)
     */
    async get(path, headers) {
        var _a, _b;
        const httpClient = await this.getClient();
        let response;
        if (headers === undefined) {
            response = await httpClient.get(path);
        }
        else {
            response = await httpClient.get(path, { headers });
        }
        if ((_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.d) {
            if (response.data.d.results) {
                return response.data.d.results;
            }
            else {
                return response.data.d;
            }
        }
        // Used for v4 Service Groups
        if ((_b = response === null || response === void 0 ? void 0 : response.data) === null || _b === void 0 ? void 0 : _b.value) {
            return response.data;
        }
        // Allow consumer to process
        return response === null || response === void 0 ? void 0 : response.data;
    }
}
exports.ODataClient = ODataClient;


/***/ }),

/***/ 16878:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tls_1 = __importDefault(__webpack_require__(26821));
const static_1 = __webpack_require__(48479);
class TlsPatch {
    static get isPatched() {
        return TlsPatch._patched;
    }
    static isPatchRequired(url) {
        return !TlsPatch.isPatched && url && url.includes('.sap.corp');
    }
    /**
     * Monkey patching the secure context to also support SAPs root CA
     */
    static apply() {
        if (TlsPatch.isPatched) {
            return;
        }
        const origCreateSecureContext = tls_1.default.createSecureContext;
        tls_1.default.createSecureContext = (options) => {
            const context = origCreateSecureContext(options);
            const pem = static_1.globalRootCaPem.replace(/\r\n/g, '\n');
            const certs = pem.match(/-----BEGIN CERTIFICATE-----\n[\s\S]+?\n-----END CERTIFICATE-----/g);
            certs.forEach((cert) => {
                context.context.addCACert(cert.trim());
            });
            return context;
        };
        TlsPatch._patched = true;
    }
}
exports.TlsPatch = TlsPatch;


/***/ }),

/***/ 85120:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const oDataClient_1 = __webpack_require__(90211);
const fs_1 = __webpack_require__(57147);
const message_1 = __webpack_require__(78948);
const constants_1 = __webpack_require__(60704);
/**
 * Extension of the generic OData client simplifying the consumption of the UI5 repository service
 */
class Ui5AbapRepository extends oDataClient_1.ODataClient {
    constructor({ system, credentials = undefined, log = console, connection = undefined, ignoreCertError, postConnectionCallback }) {
        var _a;
        system.service = (_a = system.service) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_SERVICE_PATH;
        super({ system, credentials, log, connection, ignoreCertError, postConnectionCallback });
    }
    /**
     * Get information about a deployed application. Returns undefined if the application cannot be found.
     * @param app application id (BSP application name)
     */
    async getInfo(app) {
        try {
            return await this.get(`/Repositories('${encodeURIComponent(app)}')`);
        }
        catch (error) {
            return undefined;
        }
    }
    /**
     * Deploy the given archive either by creating a new BSP or updating an existing one
     * @param archivePath path to a zip archive containing the application files
     * @param app application configuration
     * @param testMode if set to true, all requests will be sent, the service checks them, but no actual deployment will happen
     */
    async deploy(archivePath, app, testMode = false) {
        var _a, _b, _c;
        const httpClient = await this.getClient();
        const info = await this.getInfo(app.name);
        const payload = this.createPayload(archivePath, app.name, app.description || 'Deployed with SAP Fiori tools', info ? info.Package : app.package, httpClient);
        const config = this.createConfig(app.transport, testMode);
        try {
            const response = await this.updateRepoRequest(!!info, app.name, httpClient, payload, config);
            // An app can be successfully deployed after a timeout exception, no value in showing exception headers
            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a['sap-message']) {
                const message = JSON.parse(response.headers['sap-message']);
                message['longtextUrl'] = message['longtext_url'];
                const frontendUrl = this.getAbapFrontendUrl(this.system.originalUrl || this.system.url);
                message_1.prettyPrintMessage(message, this.log, frontendUrl);
                // log url of created/updated app
                const path = '/sap/bc/ui5_ui5' + (!app.name.startsWith('/') ? '/sap/' : '') + app.name.toLowerCase();
                const query = this.system.client ? '?sap-client=' + this.system.client : '';
                this.log.info(`App available at ${frontendUrl}${path}${query}`);
            }
            else if (testMode) {
                message_1.printErrorDetails((_c = (_b = response === null || response === void 0 ? void 0 : response.data.error) === null || _b === void 0 ? void 0 : _b.innererror) === null || _c === void 0 ? void 0 : _c.errordetails, this.log);
            }
            return response;
        }
        catch (error) {
            this.logError(error);
            throw error;
        }
    }
    async undeploy(app, testMode = false) {
        var _a;
        const httpClient = await this.getClient();
        const config = this.createConfig(app.transport, testMode);
        try {
            const response = await this.deleteRepoRequest(app.name, httpClient, config);
            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a['sap-message']) {
                const message = JSON.parse(response.headers['sap-message']);
                message_1.prettyPrintMessage(message, this.log);
            }
            return response;
        }
        catch (error) {
            this.logError(error);
            throw error;
        }
    }
    /**
     * Translate the technical SCP ABAP URL to the frontend URL
     *
     * @param technicalUrl Technical URL of the ABAP system from service keys
     */
    getAbapFrontendUrl(technicalUrl) {
        constants_1.abapUrlReplaceMap.forEach((value, key) => {
            technicalUrl = technicalUrl.replace(key, value);
        });
        return technicalUrl;
    }
    /**
     * Internal helper method to generate a request configuration (headers, parameters)
     * @param transport optional transport request id
     * @param testMode test mode enabled or not
     */
    createConfig(transport, testMode) {
        const headers = {
            'Content-Type': 'application/atom+xml',
            type: 'entry',
            charset: 'UTF8'
        };
        const params = {
            CodePage: "'UTF8'",
            CondenseMessagesInHttpResponseHeader: 'X',
            format: 'json'
        };
        if (transport) {
            params.TransportRequest = transport;
        }
        if (testMode) {
            params.TestMode = true;
        }
        // `axios` does not properly pass the default values of `maxBodyLength` and `maxContentLength`
        // to `follow-redirects`: https://github.com/axios/axios/issues/4263
        // Without this `follow-redirects` limits the max body length to 10MB and fails with the following
        // message: Request body larger than maxBodyLength limit.
        // Set both to infinity. It's the backend's responsibilty to reject messages sizes it cannot handle
        const maxBodyLength = Infinity;
        const maxContentLength = Infinity;
        return { headers, params, maxBodyLength, maxContentLength };
    }
    /**
     * Create the request payload for a deploy request
     * @param archive archive file path
     * @param name application name
     * @param description description for the deployed app
     * @param abapPackage ABAP package containing the app
     */
    createPayload(archive, name, description, abapPackage, httpClient) {
        const base64Data = fs_1.readFileSync(archive, { encoding: 'base64' });
        const time = new Date().toISOString();
        return (`<entry xmlns="http://www.w3.org/2005/Atom"` +
            `       xmlns:m="http://schemas.microsoft.com/ado/2007/08/dataservices/metadata"` +
            `       xmlns:d="http://schemas.microsoft.com/ado/2007/08/dataservices"` +
            `       xml:base="${httpClient.defaults.baseURL}">` +
            `  <id>${httpClient.defaults.baseURL}/Repositories('${name}')</id>` +
            `  <title type="text">Repositories('${name}')</title>` +
            `  <updated>${time}</updated>` +
            `  <category term="/UI5/ABAP_REPOSITORY_SRV.Repository" scheme="http://schemas.microsoft.com/ado/2007/08/dataservices/scheme"/>` +
            `  <link href="Repositories('${name}')" rel="edit" title="Repository"/>` +
            `  <content type="application/xml">` +
            `    <m:properties>` +
            `      <d:Name>${name}</d:Name>` +
            `      <d:Package>${abapPackage === null || abapPackage === void 0 ? void 0 : abapPackage.toUpperCase()}</d:Package>` +
            `      <d:Description>${description}</d:Description>` +
            `      <d:ZipArchive>${base64Data}</d:ZipArchive>` +
            `      <d:Info/>` +
            `    </m:properties>` +
            `  </content>` +
            `</entry>`);
    }
    /**
     * Sometimes a repo request fails with a known timeout issue
     *
     * @param isExisting - app has already been deployed
     * @param appName
     * @param httpClient
     * @param payload
     * @param config
     * @param tryCount
     * @protected
     */
    async updateRepoRequest(isExisting, appName, httpClient, payload, config, tryCount = 1) {
        var _a, _b;
        try {
            // Was the app deployed after the first failed attempt?
            if (tryCount === 2) {
                this.log.warn('Warning: The application was deployed despite a time out response from the backend. Increasing the value of the HTML5.Timeout property for the destination may solve the issue');
            }
            // If its already deployed, then dont try to create it again
            if (tryCount !== 1 && !isExisting && (await this.getInfo(appName)) !== undefined) {
                // We've nothing to return as we dont want to show the exception to the user!
                return;
            }
            return isExisting
                ? await httpClient.put(`/Repositories('${encodeURIComponent(appName)}')`, payload, config)
                : await httpClient.post('/Repositories', payload, config);
        }
        catch (error) {
            if (((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status) === 504) {
                // Kill the flow after three attempts
                if (tryCount >= 3) {
                    throw error;
                }
                return await this.updateRepoRequest(isExisting, appName, httpClient, payload, config, ++tryCount);
            }
            else if ((_b = config === null || config === void 0 ? void 0 : config.params) === null || _b === void 0 ? void 0 : _b.TestMode) {
                return error.response;
            }
            else {
                throw error;
            }
        }
    }
    /**
     * Sometimes a repo request fails with a known 400 bad request issue,
     * but succeeds in the retry
     *
     * @param appName
     * @param httpClient
     * @param config
     * @param tryCount
     * @protected
     */
    async deleteRepoRequest(appName, httpClient, config, tryCount = 1) {
        var _a;
        try {
            if (tryCount === 2) {
                this.log.warn('Warning: retry undeploy to handle a backend rejection...');
            }
            return await httpClient.delete(`/Repositories('${appName}')`, config);
        }
        catch (error) {
            if (((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status) === 400) {
                // Kill the flow after 1 attempt
                if (tryCount >= 2) {
                    throw error;
                }
                return await this.deleteRepoRequest(appName, httpClient, config, ++tryCount);
            }
            else {
                throw error;
            }
        }
    }
}
exports.Ui5AbapRepository = Ui5AbapRepository;


/***/ }),

/***/ 69180:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Service names used in secure storage
 */
var ServiceName;
(function (ServiceName) {
    ServiceName["SystemInfo"] = "fiori/system/info";
    ServiceName["RefreshToken"] = "fiori/system/refreshToken";
    ServiceName["ApiHub"] = "fiori/system/apiHub";
})(ServiceName = exports.ServiceName || (exports.ServiceName = {}));
var ux_store_1 = __webpack_require__(16493);
exports.AuthenticationType = ux_store_1.AuthenticationType;
var DestinationProperties;
(function (DestinationProperties) {
    DestinationProperties["WebIDEUsage"] = "WebIDEUsage";
    DestinationProperties["WebIDEEnabled"] = "WebIDEEnabled";
    DestinationProperties["WebIDESystem"] = "WebIDESystem";
    DestinationProperties["SapClient"] = "sap-client";
    DestinationProperties["WebIDEAdditionalData"] = "WebIDEAdditionalData";
    DestinationProperties["HTML5ForwardAuthToken"] = "HTML5.ForwardAuthToken";
    DestinationProperties["HTML5Timeout"] = "HTML5.Timeout";
    DestinationProperties["HTML5PreserveHostHeader"] = "HTML5.PreserveHostHeader";
    DestinationProperties["HTML5DynamicDestination"] = "HTML5.DynamicDestination";
    DestinationProperties["HTML5SetXForwardedHeaders"] = "HTML5.SetXForwardedHeaders";
    DestinationProperties["TrustAll"] = "TrustAll";
})(DestinationProperties = exports.DestinationProperties || (exports.DestinationProperties = {}));
exports.DestinationAttributeProperty = {
    ODATA_GENERIC: 'odata_gen',
    FULL_URL: 'full_url',
    ODATA_ABAP: 'odata_abap',
    DEV_ABAP: 'dev_abap',
    ABAP_CLOUD: 'abap_cloud'
};
exports.destinationPropertyId = Object.keys(exports.DestinationAttributeProperty);
/**
 * Determine if the destination attributes are configured as a full service url
 * @param systemConfig
 */
function hasDestinationAttrib(destinationProperty, destinationAttributeProperty, destinationAttribs = {}) {
    var _a, _b;
    return ((_b = (destinationAttribs && ((_a = destinationAttribs[destinationProperty]) === null || _a === void 0 ? void 0 : _a.includes(destinationAttributeProperty)))) !== null && _b !== void 0 ? _b : false);
}
exports.hasDestinationAttrib = hasDestinationAttrib;
function hasFullUrlDestAttribute(destinationAttribs) {
    var _a, _b;
    return ((_b = (destinationAttribs && ((_a = destinationAttribs["WebIDEAdditionalData" /* WebIDEAdditionalData */]) === null || _a === void 0 ? void 0 : _a.includes(exports.DestinationAttributeProperty.FULL_URL)))) !== null && _b !== void 0 ? _b : false);
}
exports.hasFullUrlDestAttribute = hasFullUrlDestAttribute;


/***/ }),

/***/ 56838:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var CSRF;
(function (CSRF) {
    CSRF["requestHeaderName"] = "X-Csrf-Token";
    CSRF["requestHeaderValue"] = "Fetch";
    CSRF["responseHeaderName"] = "x-csrf-token";
})(CSRF = exports.CSRF || (exports.CSRF = {}));


/***/ }),

/***/ 30349:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const axios_1 = __importDefault(__webpack_require__(61674));
const common_1 = __webpack_require__(56838);
const express_1 = __importDefault(__webpack_require__(10146));
const http_1 = __importDefault(__webpack_require__(13685));
const https_1 = __importDefault(__webpack_require__(95687));
const error_1 = __webpack_require__(71012);
const utils_1 = __webpack_require__(11512);
const static_1 = __webpack_require__(48479);
const _1 = __webpack_require__(9322);
const open = __webpack_require__(35024);
class ABAPSystem {
    /***
     * Removes a `-api` suffix in the first label of the hostname, if any
     */
    static uiHostname(hostname) {
        const [first, ...rest] = hostname.split('.');
        return [first.replace('-api', ''), ...rest].join('.');
    }
    /**
     *
     * Adds a `-api` suffix to the first label of the hostname
     */
    static apiHostname(hostname) {
        const [first, ...rest] = hostname.split('.');
        return !first.match(/.*-api$/) ? [first + '-api', ...rest].join('.') : hostname;
    }
    static logoffUrl(hostname) {
        return this.uiHostname(hostname) + '/sap/public/bc/icf/logoff';
    }
}
async function connectWithReentranceTicket({ target, ignoreCertError = false, logger = console }) {
    const reentranceTicket = await getReentranceTicket({ backendUrl: target.url, logger });
    // Make a call to backend to get cookies & CSRF token
    const response = await axios_1.default.get(ABAPSystem.apiHostname(target.url) + target.service + '/', {
        params: {},
        headers: {
            MYSAPSSO2: reentranceTicket,
            [common_1.CSRF.requestHeaderName]: common_1.CSRF.requestHeaderValue
        },
        httpsAgent: new https_1.default.Agent({
            rejectUnauthorized: !ignoreCertError
        })
    });
    return {
        cookies: new _1.Cookies().setCookie(response),
        xsrfToken: response.headers[common_1.CSRF.responseHeaderName]
    };
}
exports.connectWithReentranceTicket = connectWithReentranceTicket;
const ADT_REENTRANCE_ENDPOINT = '/sap/bc/adt/core/http/reentranceticket';
/**
 *
 * Open a browser pointing to the ADT endpoint and pass in a redirection URL.
 * Start a local server at the redirection URL.
 * Browser takes care of the SAML authentication and returns a 'reentrance ticket'.
 *
 * Info about reentrance tickets: https://wiki.wdf.sap.corp/wiki/display/ABAPSec/SAP+re-entrance+tickets
 * The logon procedure in more detail: https://wiki.wdf.sap.corp/wiki/display/aie/Discussion+concerning+technical+flow
 */
async function getReentranceTicket({ backendUrl, logger, timeout = utils_1.timeoutMs }) {
    return new Promise((resolve, reject) => {
        // Start local server to listen to redirect call, with timeout
        const app = express_1.default();
        const server = http_1.default.createServer(app);
        const handleTimeout = () => {
            server.close();
            reject(new error_1.TimeoutError(`Timeout. Did not get a response within ${utils_1.timeString(timeout)}`));
        };
        class Redirect {
            static url(port) {
                return 'http://localhost:' + port + Redirect.path;
            }
        }
        Redirect.path = '/redirect';
        const timer = setTimeout(handleTimeout, timeout);
        app.get(Redirect.path, (req, res) => {
            var _a;
            const reentranceTicket = (_a = req.query['reentrance-ticket']) === null || _a === void 0 ? void 0 : _a.toString();
            logger.info('Got reentrance ticket: ' + reentranceTicket);
            res.set('Content-Type', 'text/html');
            res.send(Buffer.from(static_1.redirectSuccessHtml(ABAPSystem.logoffUrl(backendUrl))));
            if (timer) {
                clearTimeout(timer);
            }
            server.close();
            resolve(reentranceTicket);
        });
        server.listen();
        const redirectPort = server.address().port;
        // Open browser to handle SAML flow
        const url = `${ABAPSystem.uiHostname(backendUrl)}${ADT_REENTRANCE_ENDPOINT}?redirect-url=${Redirect.url(redirectPort)}`;
        open(url);
    });
}


/***/ }),

/***/ 33143:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Helper class for managing cookies.
 */
class Cookies {
    constructor() {
        this.cookies = {};
    }
    /**
     * Update the cookies based on 'set-cookie' headers of a response.
     * @param response http response containing a headers object
     */
    setCookie(response) {
        var _a;
        if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a['set-cookie']) {
            response.headers['set-cookie'].forEach((cookieString) => this.addCookie(cookieString));
        }
        return this;
    }
    /**
     * Update cookies based on a string representing a cookie
     * @param cookieString string representing a cookie
     */
    addCookie(cookieString) {
        const cookie = cookieString.split(';');
        const [, key, value] = cookie[0].match(/(.*?)=(.*)/);
        if (cookieString.indexOf('Max-Age=0') >= 0) {
            delete this.cookies[key];
        }
        else {
            if (key && value) {
                this.cookies[key] = value;
            }
        }
        return this;
    }
    /**
     * Serialize all cookies as string formatted for the 'Cookie' header.
     */
    toString() {
        const cookies = [];
        Object.keys(this.cookies).forEach((key) => {
            cookies.push(`${key}=${this.cookies[key]}`);
        });
        return cookies.join('; ');
    }
}
exports.Cookies = Cookies;


/***/ }),

/***/ 1543:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const axios_1 = __importDefault(__webpack_require__(61674));
const config_1 = __webpack_require__(69180);
const ux_common_utils_1 = __webpack_require__(59859);
const cf_tools_1 = __webpack_require__(47213);
const DEST = '.dest';
/**
 * Fetch a list of available destinations from an instance of an SCP destination service
 * @param log optional log output
 */
async function fetchDestinations() {
    var _a;
    const destinations = {};
    await axios_1.default.get(ux_common_utils_1.getAppStudioProxyURL() + '/reload');
    const response = await axios_1.default.get(ux_common_utils_1.getAppStudioBaseURL() + '/api/listDestinations');
    (_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.forEach((destination) => {
        if (destination.WebIDEEnabled) {
            destinations[destination.Name] = destination;
        }
    });
    return destinations;
}
/**
 * Creates a URL to be used when doing requests against instance based destinations
 *
 * @param destination name of the destination
 * @param destinationInstance name of the destination instance as provided in the mta.yaml
 */
async function getUrlForInstanceBasedDest(destination, destinationInstance) {
    var _a, _b;
    try {
        const credentials = await cf_tools_1.apiGetInstanceCredentials(destinationInstance);
        const clientId = ((_a = credentials.uaa) === null || _a === void 0 ? void 0 : _a.clientid) || credentials.clientid;
        const clientSecret = ((_b = credentials.uaa) === null || _b === void 0 ? void 0 : _b.clientsecret) || credentials.clientsecret;
        const base64Host = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
        return `https://${base64Host}@${destination}${DEST}`;
    }
    catch (error) {
        throw new Error(`An error occurred while retrieving service key for the destination instance ${destinationInstance}: ${error}`);
    }
}
/**
 * If running on SCP, return available destinations otherwise return an empty object
 * @param log optional log output
 */
async function listDestinations() {
    if (ux_common_utils_1.isAppStudio()) {
        return fetchDestinations();
    }
    else {
        return {};
    }
}
exports.listDestinations = listDestinations;
/**
 * Replaces the system URL with the destination URL for the respective system
 *
 * @param system system configuration
 * @param destinationName name of the destination
 * @param destinationInstance name of the destination instance as provided in the mta.yaml
 */
async function replaceUrlForAppStudio(systemConfig, destinationName, destinationInstance) {
    var _a, _b;
    systemConfig.originalUrl = systemConfig.url;
    if (destinationName && destinationInstance) {
        systemConfig.url = await getUrlForInstanceBasedDest(destinationName, destinationInstance);
    }
    else {
        systemConfig.url = ux_common_utils_1.getAppStudioBaseURL();
        // Create destination service path ensuring the service has a leading '/' path sep between dest name and service path
        systemConfig.service = `/destinations/${destinationName !== null && destinationName !== void 0 ? destinationName : systemConfig.destination}${(_b = (_a = systemConfig.service) === null || _a === void 0 ? void 0 : _a.replace(/^\/?/, '/')) !== null && _b !== void 0 ? _b : ''}`;
        // system.url = `https://${destination}${DEST}`; // todo: update url format once we can assess the impact
    }
    delete systemConfig.scp;
    delete systemConfig.client;
}
exports.replaceUrlForAppStudio = replaceUrlForAppStudio;
/**
 * If running on SCP, fetch available destination and check overwrite the system.url with the matching destination url
 * @param system System configuration that is to be updated
 * @param log optional log output
 */
async function updateSystemConfig(system) {
    if (ux_common_utils_1.isAppStudio() && system.destination) {
        if (system.destinationInstance) {
            await replaceUrlForAppStudio(system, system.destination, system.destinationInstance);
        }
        else {
            const destinations = await fetchDestinations();
            if (destinations[system.destination]) {
                const dest = destinations[system.destination];
                system.destinationAuthType = dest.Authentication;
                if (config_1.hasFullUrlDestAttribute({
                    ["WebIDEAdditionalData" /* WebIDEAdditionalData */]: dest["WebIDEAdditionalData" /* WebIDEAdditionalData */]
                })) {
                    system.isDestinationFullUrl = true;
                    system.destinationServiceUrl = new URL(dest.Host).pathname;
                }
                // Reset the service property, as it will get appended to the pathname causing a 404
                if (system.isDestinationFullUrl) {
                    delete system.service;
                }
                await replaceUrlForAppStudio(system, dest.Name);
            }
        }
    }
}
exports.updateSystemConfig = updateSystemConfig;


/***/ }),

/***/ 71012:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const error_1 = __webpack_require__(38633);
class ConnectionError extends error_1.BaseError {
    constructor(message, cause) {
        super(message, cause);
        this.name = this.constructor.name;
    }
}
exports.ConnectionError = ConnectionError;
class TimeoutError extends error_1.BaseError {
    constructor(message, cause) {
        super(message, cause);
        this.name = this.constructor.name;
    }
}
exports.TimeoutError = TimeoutError;
class UAATimeoutError extends TimeoutError {
    constructor(message, cause) {
        super(message, cause);
        this.name = this.constructor.name;
    }
}
exports.UAATimeoutError = UAATimeoutError;


/***/ }),

/***/ 9322:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const axios_1 = __importDefault(__webpack_require__(61674));
const cookies_1 = __webpack_require__(33143);
exports.Cookies = cookies_1.Cookies;
const ux_common_utils_1 = __webpack_require__(59859);
const uaaOauth_1 = __webpack_require__(33593);
const https_1 = __importDefault(__webpack_require__(95687));
const url_1 = __webpack_require__(57310);
const common_1 = __webpack_require__(56838);
const __1 = __webpack_require__(24951);
const connectWithReentranceTicket_1 = __webpack_require__(30349);
exports.SAP_CLIENT = 'sap-client';
/**
 * Implementation of basic authentication to SAP systems
 * @param target system that is to be connected to
 * @param credentials username/password required for BasicAuth
 * @param autoAddTrailingSlash
 */
async function connectWithBasicAuth({ target, credentials, autoAddTrailingSlash = true, timeout, ignoreCertError = false, logger = console }) {
    var _a;
    const url = new url_1.URL(target.service, target.url).toString();
    const hasCredentials = !!((_a = credentials === null || credentials === void 0 ? void 0 : credentials.username) === null || _a === void 0 ? void 0 : _a.length);
    const config = {
        params: {},
        headers: {
            [common_1.CSRF.requestHeaderName]: common_1.CSRF.requestHeaderValue
        },
        withCredentials: hasCredentials,
        httpsAgent: new https_1.default.Agent({
            rejectUnauthorized: !ignoreCertError
        })
    };
    if (hasCredentials) {
        config.auth = credentials;
    }
    if (typeof timeout === 'number' && timeout > 0) {
        const CancelToken = axios_1.default.CancelToken;
        const source = CancelToken.source();
        setTimeout(() => {
            source.cancel('CONNECT_TIMEOUT');
        }, timeout);
        config.cancelToken = source.token;
    }
    if (target.params) {
        Object.assign(config.params, target.params);
    }
    if (target.client) {
        config.params[exports.SAP_CLIENT] = target.client;
    }
    const isTargetDestOnAppStudio = ux_common_utils_1.isAppStudio() && target.destination;
    if (isTargetDestOnAppStudio) {
        // We can't handle the SAML login redirects
        // @TODO - add a warning message that is not confusing
        config.params.saml2 = 'disabled';
    }
    const urlPath = !(url === null || url === void 0 ? void 0 : url.endsWith('/')) && autoAddTrailingSlash ? `${url}/` : url;
    if ((config === null || config === void 0 ? void 0 : config.auth) && Object.keys(config.auth).length > 0) {
        config.withCredentials = true;
    }
    else {
        delete config.auth;
        config.withCredentials = false;
    }
    let response = await axios_1.default.get(urlPath, config);
    // For on-prem, retry with disabling SAML if required
    if (!isTargetDestOnAppStudio && isSamlLogonNeeded(response)) {
        // @TODO - add i18n support
        logger.warn('Disabling SAML2. Falling back to basic authentication');
        config.params.saml2 = 'disabled';
        response = await axios_1.default.get(urlPath, config);
    }
    throwIfHtmlLoginForm(response);
    return {
        auth: config.auth,
        cookies: new cookies_1.Cookies().setCookie(response),
        xsrfToken: response.headers[common_1.CSRF.responseHeaderName]
    };
}
/**
 *
 * SAP systems can choose to respond with a 200 and an HTML login page
 * Transform that to a 401
 */
function throwIfHtmlLoginForm(response) {
    var _a;
    if ((response === null || response === void 0 ? void 0 : response.status) === 200 && ((_a = response.headers['content-type']) === null || _a === void 0 ? void 0 : _a.toLowerCase().startsWith('text/html')) &&
        (response['sap-err-id'] === 'ICFLOGONREQUIRED' ||
            (typeof response.data === 'string' && !!(response === null || response === void 0 ? void 0 : response.data.match(/login/i))))) {
        const err = new Error();
        err.response = { status: 401 };
        err.isAxiosError = true;
        err.toJSON = () => {
            return { status: 401 };
        };
        throw err;
    }
}
/**
 *
 * Did we get a SAML login form?
 */
function isSamlLogonNeeded(response) {
    var _a;
    return ((response === null || response === void 0 ? void 0 : response.status) === 200 && ((_a = response.headers['content-type']) === null || _a === void 0 ? void 0 : _a.toLowerCase().startsWith('text/html')) &&
        typeof response.data === 'string' &&
        !!(response === null || response === void 0 ? void 0 : response.data.match(/saml/i)));
}
/**
 * Generic connect method that will be used as abstraction of different authentication methods.
 * @param target system that is to be connected to
 * @param credentials optional required credentials
 * @param log optional logger that is used for any kind of log message
 * @param autoAddTrailingSlash
 */
async function connect({ target, credentials, log, autoAddTrailingSlash = true, timeout, ignoreCertError = false, postConnectionCallback }) {
    const targetAuthType = target.authenticationType;
    if (targetAuthType === __1.AuthenticationType.OAuth2RefreshToken) {
        return uaaOauth_1.connectUsingUaa({ target, credentials, log, postConnectionCallback });
    }
    else if (targetAuthType === __1.AuthenticationType.OAuth2ClientCredential) {
        return uaaOauth_1.connectUsingUaaClientCredential({ target, credentials, log });
    }
    else if (targetAuthType === __1.AuthenticationType.ReentranceTicket) {
        return connectWithReentranceTicket_1.connectWithReentranceTicket({ target, logger: log, ignoreCertError });
    }
    else {
        // Default to basic authentication
        return connectWithBasicAuth({
            target,
            credentials,
            autoAddTrailingSlash,
            timeout,
            ignoreCertError,
            logger: log
        });
    }
}
exports.connect = connect;
__export(__webpack_require__(1543));
__export(__webpack_require__(71012));


/***/ }),

/***/ 33593:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* eslint-disable @typescript-eslint/camelcase */
const open = __webpack_require__(35024);
const http_1 = __importDefault(__webpack_require__(13685));
const axios_1 = __importDefault(__webpack_require__(61674));
const express_1 = __importDefault(__webpack_require__(10146));
const fs_1 = __webpack_require__(57147);
const _1 = __webpack_require__(9322);
const common_1 = __webpack_require__(56838);
const static_1 = __webpack_require__(48479);
const error_1 = __webpack_require__(71012);
const qs_1 = __importDefault(__webpack_require__(67750));
const utils_1 = __webpack_require__(11512);
class Redirect {
    constructor(port) {
        this.port = port;
    }
    url() {
        return `http://localhost:${this.port}${Redirect.path}`;
    }
}
Redirect.path = '/oauth/client/redirect';
function getAuthCode({ uaa, log, timeout = utils_1.timeoutMs }) {
    return new Promise((resolve, reject) => {
        const app = express_1.default();
        const server = http_1.default.createServer(app);
        // eslint-disable-next-line prefer-const
        let redirect;
        const handleTimeout = () => {
            server.close();
            reject(new error_1.UAATimeoutError(`Timeout. Did not get a response within ${utils_1.timeString(timeout)}`));
        };
        const timer = setTimeout(handleTimeout, timeout);
        app.get(Redirect.path, (req, res) => {
            res.set('Content-Type', 'text/html');
            res.send(Buffer.from(static_1.redirectSuccessHtml(uaa.logoutUrl, uaa.systemId)));
            log.info('Got authCode');
            resolve({ authCode: req.query.code + '', redirect });
            if (timer) {
                clearTimeout(timer);
            }
            server.close();
        });
        // Start listening. Let the OS assign an available port
        server.listen();
        redirect = new Redirect(server.address().port);
        const oauthUrl = uaa.getAuthCodeUrl({ redirectUri: redirect.url() });
        open(oauthUrl);
    });
}
async function getAccessToken({ uaa, log, postConnectionCallback, refreshToken }) {
    var _a;
    let response;
    let startFreshLogin = false;
    let newRefreshToken;
    if (refreshToken) {
        log.info('Refresh token passed in');
        const tokenRequest = uaa.getTokenRequestForRefreshToken(refreshToken);
        try {
            response = await axios_1.default.request(tokenRequest);
            // Has refresh token expired?
            if (response.status === 401 || response.data.error === 'invalid_token') {
                startFreshLogin = true;
                log.warn('Cannot use stored refresh token. Starting fresh request');
            }
            else {
                if (refreshToken !== response.data.refresh_token) {
                    log.info('New refresh token issued');
                    newRefreshToken = response.data.refresh_token;
                }
            }
        }
        catch (e) {
            startFreshLogin = true;
        }
    }
    if (!refreshToken || startFreshLogin) {
        const { authCode, redirect } = await getAuthCode({ uaa, log });
        const tokenRequest = uaa.getTokenRequestForAuthCode({
            redirectUri: redirect.url(),
            authCode
        });
        response = await axios_1.default.request(tokenRequest);
        log.info('Storing refresh token');
        newRefreshToken = response.data.refresh_token;
    }
    if (postConnectionCallback) {
        await runPostConnectionCallback({
            log,
            uaa,
            accessToken: response.data.access_token,
            postConnectionCallback,
            newRefreshToken
        });
    }
    log.info('Got access token successfully');
    return (_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.access_token;
}
async function getAccessTokenByUaaClientCredential({ uaa, log }) {
    try {
        const tokenRequest = uaa.getAccessTokenRequestUsingClientCredential();
        const response = await axios_1.default.request(tokenRequest);
        log.info('Receiving response from OAuth2 Client Credential grant type');
        return response.data.access_token;
    }
    catch (e) {
        if (e instanceof error_1.ConnectionError) {
            throw e;
        }
        throw new error_1.ConnectionError(e.message, e);
    }
}
/** Run post connection callback - sync or async depends on the callback properties
 */
async function runPostConnectionCallback({ log, uaa, accessToken, postConnectionCallback: cb, newRefreshToken }) {
    if (cb.sync) {
        try {
            let userDisplayName;
            if (cb.updateUserInfo) {
                userDisplayName = await getUserInfo(uaa, accessToken);
            }
            cb.fn({ user: userDisplayName, refreshToken: newRefreshToken });
        }
        catch (e) {
            log.warn(e);
        }
    }
    else {
        return processCallbackAsync({
            log,
            uaa,
            accessToken,
            updateFunction: cb.fn,
            fetchUserInfo: cb.updateUserInfo,
            newRefreshToken
        });
    }
}
async function getUserInfo(uaa, accessToken) {
    var _a, _b;
    const userInfoResp = await axios_1.default.request(uaa.getUserinfoRequest(accessToken));
    const userDisplayName = ((_a = userInfoResp === null || userInfoResp === void 0 ? void 0 : userInfoResp.data) === null || _a === void 0 ? void 0 : _a.email) || ((_b = userInfoResp === null || userInfoResp === void 0 ? void 0 : userInfoResp.data) === null || _b === void 0 ? void 0 : _b.name);
    return userDisplayName;
}
/** Gets user information from UAA. Will call the callback function passed in. Will swallow errors and only log them
 * If we don't succeed, we try again later
 */
async function processCallbackAsync({ log, uaa, accessToken, updateFunction, newRefreshToken, fetchUserInfo }) {
    if (newRefreshToken) {
        // Don't need to wait to fetch user info, try saving refresh token
        log.info('Trying to save refreshToken');
        try {
            await updateFunction({ refreshToken: newRefreshToken });
        }
        catch (e) {
            log.warn(e.message);
        }
    }
    if (fetchUserInfo) {
        log.info('Scheduling user info fetch');
        // Let's let the execution move on in the current iteration of the event loop and schedule
        // this for the next tick
        setTimeout(async () => {
            try {
                log.info('Fetching user info');
                const userDisplayName = await getUserInfo(uaa, accessToken);
                log.info(`Username: [${userDisplayName}]`);
                if (userDisplayName) {
                    log.info('Trying to update user name in system details');
                    await updateFunction({ user: userDisplayName });
                }
            }
            catch (e) {
                log.warn(e.message);
            }
        }, 1);
    }
}
class Uaa {
    constructor(serviceInfo) {
        this.validatePropertyExists(serviceInfo.uaa.clientid, 'Client ID missing');
        this.validatePropertyExists(serviceInfo.uaa.clientsecret, 'Client Secret missing');
        this.validatePropertyExists(serviceInfo.uaa.url, 'UAA URL missing');
        this.serviceInfo = serviceInfo;
    }
    validatePropertyExists(property, errMsg) {
        if (!property) {
            throw Error(errMsg);
        }
    }
    get url() {
        return this.serviceInfo.uaa.url;
    }
    get clientid() {
        return this.serviceInfo.uaa.clientid;
    }
    get clientsecret() {
        return this.serviceInfo.uaa.clientsecret;
    }
    get username() {
        return this.serviceInfo.uaa.username;
    }
    get password() {
        return this.serviceInfo.uaa.password;
    }
    get logoutUrl() {
        return this.url + '/logout.do';
    }
    get systemId() {
        return this.serviceInfo.systemid;
    }
    getAuthCodeUrl({ redirectUri }) {
        return (this.url +
            '/oauth/authorize?' +
            qs_1.default.stringify({
                response_type: 'code',
                redirect_uri: redirectUri,
                client_id: this.clientid
            }));
    }
    getTokenRequestForAuthCode({ redirectUri, authCode }) {
        return {
            url: this.url + '/oauth/token',
            auth: { username: this.clientid, password: this.clientsecret },
            method: 'POST',
            data: qs_1.default.stringify({
                code: authCode,
                grant_type: 'authorization_code',
                redirect_uri: redirectUri,
                response_type: 'token'
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json'
            }
        };
    }
    getAccessTokenRequestUsingClientCredential() {
        return {
            url: this.url,
            method: 'POST',
            data: qs_1.default.stringify({
                grant_type: 'password',
                username: this.username,
                password: this.password
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json',
                Authorization: `Basic ${Buffer.from(this.clientid + ':' + this.clientsecret).toString('base64')}`
            }
        };
    }
    getTokenRequestForRefreshToken(refreshToken) {
        return {
            url: this.url + '/oauth/token',
            auth: { username: this.clientid, password: this.clientsecret },
            method: 'POST',
            data: qs_1.default.stringify({
                grant_type: 'refresh_token',
                refresh_token: refreshToken
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json'
            }
        };
    }
    getUserinfoRequest(accessToken) {
        return {
            url: this.url + '/userinfo',
            method: 'GET',
            headers: {
                authorization: `bearer ${accessToken}`
            }
        };
    }
}
async function newConnection(target, accessToken) {
    var _a;
    const url = `${target.url}${target.service}${target.client ? '?sap-client=' + target.client : ''}`;
    const response = await axios_1.default.get(url, {
        headers: {
            authorization: `bearer ${accessToken}`,
            [common_1.CSRF.requestHeaderName]: common_1.CSRF.requestHeaderValue
        }
    });
    return {
        cookies: new _1.Cookies().setCookie(response),
        xsrfToken: (_a = response.headers) === null || _a === void 0 ? void 0 : _a[common_1.CSRF.responseHeaderName]
    };
}
function getServiceInfo(credentials) {
    try {
        if (credentials.serviceKeysContents) {
            return typeof credentials.serviceKeyContents === 'string'
                ? JSON.parse(credentials.serviceKeysContents)
                : credentials.serviceKeysContents;
        }
        return JSON.parse(fs_1.readFileSync(credentials.serviceKeys, 'utf-8'));
    }
    catch (e) {
        throw new Error('Error parsing service keys');
    }
}
exports.getServiceInfo = getServiceInfo;
exports.defaultUtils = {
    serviceInfo: getServiceInfo,
    connection: newConnection,
    accessToken: getAccessToken,
    accessTokenByUaaClientCredential: getAccessTokenByUaaClientCredential
};
async function connectUsingUaa({ target, credentials, log = console, uaaUtils = exports.defaultUtils, postConnectionCallback }) {
    try {
        const uaa = new Uaa(credentials.serviceInfo || uaaUtils.serviceInfo(credentials));
        const token = await uaaUtils.accessToken({
            uaa,
            log,
            postConnectionCallback,
            refreshToken: credentials.refreshToken
        });
        return await uaaUtils.connection(target, token);
    }
    catch (e) {
        log.error(e.message);
        if (e instanceof error_1.ConnectionError) {
            throw e;
        }
        throw new error_1.ConnectionError(e.message, e);
    }
}
exports.connectUsingUaa = connectUsingUaa;
async function connectUsingUaaClientCredential({ target, credentials, log = console, uaaUtils = exports.defaultUtils }) {
    let accessToken;
    try {
        const uaa = new Uaa(credentials.serviceInfo);
        accessToken = await uaaUtils.accessTokenByUaaClientCredential({
            uaa,
            log
        });
    }
    catch (e) {
        log.error(`Failed to obtain OAuth2 access token: ${e.message}`);
        if (e instanceof error_1.ConnectionError) {
            throw e;
        }
        throw new error_1.ConnectionError(e.message, e);
    }
    try {
        return await uaaUtils.connection(target, accessToken);
    }
    catch (e) {
        log.error(e.message);
        if (e instanceof error_1.ConnectionError) {
            throw e;
        }
        throw new error_1.ConnectionError(e.message, e);
    }
}
exports.connectUsingUaaClientCredential = connectUsingUaaClientCredential;


/***/ }),

/***/ 11512:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/** Connection timeout. Should be made configurable */
exports.timeoutMs = 60 * 1000; // 1 minute
/** Print a user friendly error message */
exports.timeString = (ms = exports.timeoutMs) => {
    const min = ms / 60 / 1000;
    if (min > 1) {
        return `${min} minutes`;
    }
    else if (min === 1) {
        return '1 minute';
    }
    else {
        return `${ms / 1000} seconds`;
    }
};


/***/ }),

/***/ 60704:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.API_HUB_API_KEY = 'API_HUB_API_KEY';
exports.abapUrlReplaceMap = new Map([
    [/\.abap\./, '.abap-web.'],
    [/-api.s4hana.ondemand.com/, '.s4hana.ondemand.com'],
    [/-api.saps4hanacloud.cn/, '.saps4hanacloud.cn']
]);
// DEFAULT path of the UI5 Repository service
exports.DEFAULT_SERVICE_PATH = '/sap/opu/odata/UI5/ABAP_REPOSITORY_SRV';


/***/ }),

/***/ 38633:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/** Wraps `Error`. Used as base class for other specific errors */
class BaseError extends Error {
    constructor(message, cause) {
        super(message);
        this.cause = cause;
    }
}
exports.BaseError = BaseError;
class UnknownSystemAuthenticationType extends BaseError {
    constructor(authType, cause) {
        // @todo: Add i18n support
        super(`Unknown authenication type: [${authType}]`, cause);
        this.name = this.constructor.name;
    }
}
exports.UnknownSystemAuthenticationType = UnknownSystemAuthenticationType;


/***/ }),

/***/ 24951:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(41513));
__export(__webpack_require__(3283));
__export(__webpack_require__(69180));
__export(__webpack_require__(9322));
__export(__webpack_require__(52136));
__export(__webpack_require__(95629));


/***/ }),

/***/ 48479:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globalRootCaPem = `
-----BEGIN CERTIFICATE-----
MIIGTDCCBDSgAwIBAgIQXQPZPTFhXY9Iizlwx48bmTANBgkqhkiG9w0BAQsFADBO
MQswCQYDVQQGEwJERTERMA8GA1UEBwwIV2FsbGRvcmYxDzANBgNVBAoMBlNBUCBB
RzEbMBkGA1UEAwwSU0FQIEdsb2JhbCBSb290IENBMB4XDTEyMDQyNjE1NDE1NVoX
DTMyMDQyNjE1NDYyN1owTjELMAkGA1UEBhMCREUxETAPBgNVBAcMCFdhbGxkb3Jm
MQ8wDQYDVQQKDAZTQVAgQUcxGzAZBgNVBAMMElNBUCBHbG9iYWwgUm9vdCBDQTCC
AiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAOrxJKFFA1eTrZg1Ux8ax6n/
LQRHZlgLc2FZpfyAgwvkt71wLkPLiTOaRb3Bd1dyydpKcwJLy0dzGkunzNkPRSFz
bKy2IPS0RS45hUCCPzhGnqQM6TcDYWeWpSUvygqujgb/cAG0mSJpvzAD3SMDQ+VJ
Az5Ryq4IrP7LkfCb63LKZxLsHEkEcNKoGPsSsd4LTwuEIyM3ZHcCoA97m6hvgLWV
GLzLIQMEblkswqX29z7JZH+zJopoqZB6eEogE2YpExkw52PufytEslDY3dyVubjp
GlvD4T03F2zm6CYleMwgWbATLVYvk2I9WfqPAP+ln2IU9DZzegSMTWHCE+jizaiq
b5f5s7m8f+cz7ndHSrz8KD/S9iNdWpuSlknHDrh+3lFTX/uWNBRs5mC/cdejcqS1
v6erflyIfqPWWO6PxhIs49NL9Lix3ou6opJo+m8K757T5uP/rQ9KYALIXvl2uFP7
0CqI+VGfossMlSXa1keagraW8qfplz6ffeSJQWO/+zifbfsf0tzUAC72zBuO0qvN
E7rSbqAfpav/o010nKP132gbkb4uOkUfZwCuvZjA8ddsQ4udIBRj0hQlqnPLJOR1
PImrAFC3PW3NgaDEo9QAJBEp5jEJmQghNvEsmzXgABebwLdI9u0VrDz4mSb6TYQC
XTUaSnH3zvwAv8oMx7q7AgMBAAGjggEkMIIBIDAOBgNVHQ8BAf8EBAMCAQYwEgYD
VR0TAQH/BAgwBgEB/wIBATAdBgNVHQ4EFgQUg8dB/Q4mTynBuHmOhnrhv7XXagMw
gdoGA1UdIASB0jCBzzCBzAYKKwYBBAGFNgRkATCBvTAmBggrBgEFBQcCARYaaHR0
cDovL3d3dy5wa2kuY28uc2FwLmNvbS8wgZIGCCsGAQUFBwICMIGFHoGCAEMAZQBy
AHQAaQBmAGkAYwBhAHQAZQAgAFAAbwBsAGkAYwB5ACAAYQBuAGQAIABDAGUAcgB0
AGkAZgBpAGMAYQB0AGkAbwBuACAAUAByAGEAYwB0AGkAYwBlACAAUwB0AGEAdABl
AG0AZQBuAHQAIABvAGYAIABTAEEAUAAgAEEARzANBgkqhkiG9w0BAQsFAAOCAgEA
0HpCIaC36me6ShB3oHDexA2a3UFcU149nZTABPKT+yUCnCQPzvK/6nJUc5I4xPfv
2Q8cIlJjPNRoh9vNSF7OZGRmWQOFFrPWeqX5JA7HQPsRVURjJMeYgZWMpy4t1Tof
lF13u6OY6xV6A5kQZIISFj/dOYLT3+O7wME5SItL+YsNh6BToNU0xAZt71Z8JNdY
VJb2xSPMzn6bNXY8ioGzHlVxfEvzMqebV0KY7BTXR3y/Mh+v/RjXGmvZU6L/gnU7
8mTRPgekYKY8JX2CXTqgfuW6QSnJ+88bHHMhMP7nPwv+YkPcsvCPBSY08ykzFATw
SNoKP1/QFtERVUwrUXt3Cufz9huVysiy23dEyfAglgCCRWA+ZlaaXfieKkUWCJaE
Kw/2Jqz02HDc7uXkFLS1BMYjr3WjShg1a+ulYvrBhNtseRoZT833SStlS/jzZ8Bi
c1dt7UOiIZCGUIODfcZhO8l4mtjh034hdARLF0sUZhkVlosHPml5rlxh+qn8yJiJ
GJ7CUQtNCDBVGksVlwew/+XnesITxrDjUMu+2297at7wjBwCnO93zr1/wsx1e2Um
Xn+IfM6K/pbDar/y6uI9rHlyWu4iJ6cg7DAPJ2CCklw/YHJXhDHGwheO/qSrKtgz
PGHZoN9jcvvvWDLUGtJkEotMgdFpEA2XWR83H4fVFVc=
-----END CERTIFICATE-----
`;
exports.redirectSuccessHtml = (logoutUrl, systemId) => `
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=windows-1252">
    <title>${systemId ? systemId + ': ' : ''}Authentication Successful</title>
    <style>
        body {
            background: #ffffff;
            text-align: center;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .content {
            display: table;
            position: absolute;
            width: 100%;
            height: 80%;
        }

        .valigned {
            display: table-cell;
            vertical-align: middle;
        }

        .lowerCenter {
            display: table-cell;
            vertical-align: bottom;
        }

        .footer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: -1;
        }

        .footerLeft {
            float: left;
            margin-left: 20px;
        }

        .footerRight {
            float: right;
            margin-right: 20px;
            position: absolute;
            bottom: 0px;
            right: 0px;
        }

        .centerText {
            font-style: normal;
            font-family: Arial;
            font-size: 26px;
            color: #444444;
            z-index: 1;
        }
        .centerLink {
            font-style: normal;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 18px;
            text-decoration: none;
            color: #224679;
        }

        .errorTextHeader {
            font-style: normal;
            font-family: Arial;
            font-size: 40px;
            color: #444444;
        }

        .bottomText {
            align: center;
            font-style: normal;
            font-family: Arial;
            font-size: 14px;
            color: #444444;
        }

        .biggerBottomText {
            align: center;
            font-style: normal;
            font-family: Arial;
            font-size: 16px;
            color: #444444;
        }

        .detailTable {
            align: bottom;
            vertical-align: middle;
            margin-left: auto;
            margin-right: auto;
            font-style: normal;
            font-family: Arial;
            font-size: 16px;
            color: #444444;
        }
    </style>
</head>

<body>
    <div class="content">
        <div class="valigned">
            <p class="centerText"><span class="errorTextHeader">You can close this tab now.</span></p>
            ${logoutUrl
    ? '<a class="centerLink" href="' + logoutUrl + '">(Click here to log off the current user)</a>'
    : ''}
        </div>
    </div>
    <div class="footer">
        <div class="footerLeft"><img width='150' height='80' title='' alt='SAP logo'
                src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAABQCAYAAAGMt7zdAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAFhpJREFUeNpiZEAAJiBmZCAd/IdhmGYWhu0ffzNQAjz5mVigTGa291/JNudXlBQHA5K32P////8DWQHv9LsMnzOVGWTm3mf4+OsfmI0sBwNfslQ4gdRPkDeZkA24/OoHg1DHFTCGaX6SrMjA+vE7mA0SBwEQH4SRDUI2h120+sx/GDh67xOYhokhy8H4QD0cuCKMfcXJl/8lCo7+xwYevf0BpkHyIIzPIFiYYQDp9AP/Vx17jsLHZxBMkE02cc9PQrH2eL4L1jBCN4wZaiMzDlv/gVIAFP/HZRlAADEi0YzUyAGMYFdt//iNgtTPCiT/sMAMIzcHAFM/PzQY4BlcCDkWeabdwcqG8WEYqE8AGs5wg+AAlvphKR6W2mFyM868BecMaOoXBAp/BuK/DGhFD4rLPnz/8x8fQHcRA7zogQLJwmNg+nm/FQM/B4Y6uPyLCdZYXYTTZbDUDsJoqR+rixjQ0hc/MAe8J5D68boI2TA2UP7EkWj/Qw34gc8gEAAIIEY07zJBvcHEQF/wD4r/wnITC5IDQWwO5vWvPzIMAPgbKMqNFKIMLGjRAKyjILn9W6IcXJPFxhcMl979gvN3eorD2e7bX2IVP/TiB0PrecJ+/J4kLwiN2t/QUPuPHJWgqAOVIdzAxPkWpsl79SOGLEMhBm8VHgb+/ptgsUwjQYYOezEUw2FyHwvVwfSRJ98Y5PhYwRhdDQx8KtLA6iCMfIkNbA2FhJpI00UGmBUwR4HE3tTpg9k5WjwMM0++gesLmHcbTMPkwSXPZ0j9/rbeAK+DsOVzUE4SEi898R+G8QGQfPeuJyh8bODjtz9gOWj5gK++wporsUYluUA65zCc/WyqHUkhhCsq/8um7qc4h4F8+WSOE1kOQnfYf6jm30y//1LkqEcLXQWg7RCyHIStgIUVGeQ2tpE9+J9cB8EAQAAx4mgHMVDgOFI9gt6GQnEAclXESMcC/z9SVfQPvSpiBjbufjIMFPDkZ8daPzL/+DUg7vm/ZbbsP7RcCG9LM3//TXcH/V3dpfRv/YR3yDkWucxiZP4BcdQsW2GGGBVuMHvzo+8M4XtfoxgEq5g3P/zGMOXaZ4zKGgQW3/7CsOQO/ub579VtKn+3z3yNrbJmhHVjgM3sz8idT/ROKrhfmaTIwM/OhCGOSx96JxYGfq7vUvm9e9ZLaNfoD3ofAQ6QDc7c+RyM4Qp//AFjZAchiyMDUAsCGSiwMcLVgfCvNe04HYS39bDy/FsUGlfr+1GWCoNi/3UUMb8l98D0uwodMD3dVZzBb9l9SJTdO+34a99cnA5iwNc8BhkIwlM9pRiYfv0FY5gl4Ab+B0hO5WdnBsuhGApVD1f7/ieY//fmCccvs5PO4HMQA1pzmQd92AB9CAEGZh59gcLHpw8mLxAzwwFkB7QTwkSomoEndGBb6DO8LNMWZJgfrwZX+PH7XwZ+TkgkSpSdhHTQuswJZnmQ2l+Pzjm+X5lFVAhhOEqi4OhnWSF2hsfvEAU7qOdIKoD1KsG97yfnHN+tySXaQRgJfWKEMkOYuTjlbStoM+jn0/OO7zbkk+QgDEcx/sPe4vj0/Q8DHydEqUzGQRS5JzPsMYP/zz+Gv19e5b4lw0EY0SeTsu8zVaoOoIOer4hYQI6D0Fug/xn//qPcQV+BDloVRbaDYI6CxdlfXNFHtIO+vcl5thruoL/kOAi9kccM7eGwkDgC9x9p3OAvNHTIdhC2gRBqDAmS3WmAAYAAYsST+LGxhzNA7vCgszGKKka0mGRGGt5iwtH5GcoBgzEYjTSk9g8tJf7H1qpCHvtjYdr87jPDCAP/962Q+t+f9RaaILAOYKGnGnBgDUQ3Z6DA33X9Cv9WdLxFGlX+j6/FwIiOB6qjSk/wewWwy7dt+hukWukvUjbEWWZhFPSwntS1CBkGeV4Woix/+PkPg9W6ZwwffiFqQj1hNobjQVJY1XPPfoAh9jVVgWjPHn7+g8FjywvSA2ktsNe3c9ZbaCD9YUAb/seWshixDKPB2g9sDz/+eos8SE0MaD/5jqH9FOrA6qdcVZzqL7/5yWC9/BHR6vEBvsm3Car5ualL5deeOSQFEjEpiwFbQAn0XMeqFtTHB6m//PonSk/vQ4kmXsfrirAz2ImxMRx5jH8yFN1ebOZ2WgkzVO5/iVX/j609Kj8PzCMrkAh253EBkCNBeJmfNIMg4z8G5p9/wPjLp18M1558hfNBGKQGHVTtfoYhtiVcHkUfNoAsD8IzTr3BUKMHDHh0df9uHHf8WKolCAwoUCj+gDbhfyMFGNGNVbzZUKTu3NvXjYZEB2TX/ucM3Qcg5YeOBCfD/kwNDDWi9ecZPDX4GRZFKmGVAwFsdh598AVuLrZpYBAw6r8KH5P59eCM46dFaRcoSUkkBZZYBaLwkRVgZ9ibr43TochArfEcw616Iwxx8crTcPbLdlPMEbOzbxjy1tzHKkeMnR9//GX49eis44dlmVQNJKICS6LoON4pMNAQzqlqQwZqAtPW8wynCZh59dlXhh1X3jP07HyCKLifnHN8vyqbJoFEVAHP+Ocvw7OJ1nD+7IPPGHZeegfnz0vRoHq7B1dASeUfxRrToDGyt+vyaBpIRKUsakyugoBl7SmGx28hU9CWagIMVx9/AQ+NgYfBptkRZYZM1iHUdtKb2wGvVqccpEcgEZOy/sumHQAztGV5GOrDVcAexcgSQI+nTLvC8AQYGKtKDDDkn7z5wfDk5Td4rJy49g4llrQLjjDMydIhHKt//iFGypaFL6FnIBFKWaBAZJNN2vtu0PTdgIH0bGXkgAQStjFS9OEKiocnqRNIr3Ofro5cjDSqSPdAwpUNYWM6IEf9///rW/t/0JrD//+YGP6jrMClIWD8z8AItPL394tP10RtRurY/mVAXZVA95hkxDFKir7kgtwhXUoG5v5jCZwBCSRCI56MBAKU1qOXuEY0BxQABCDnbGPiKMI4/hy2VbHF3oEGUoRaWzTUQqvYKi8lUioRIaZqDLSiidooUWPsB0Pa2jQxIlXAGotNq1ibmFJiNNE2FkrsBxUuMVYjLEZrscLdQSkv5a5SetzerTdz3b293ZnZO3p3e+k9yeRgdmZ297czz8zO/GcNMQJKt4nRUB7OPI3eMZ4WK4DQzAXWTCkQfFXCdQ6M5iNBa6ZUhKMM11MtEygjAOHqvVGnbeZRB6cnZEL9eDLB0wvlxjzwr+5Iqzy0BYuEBN4df6A8nl7P4ynrQnk3xE3PEG+w3O4+91Op+aGM4KXmmODyxBEonnNVLymkDH6ZS2G4KcZNzfKCmq3JKFI4dkGrZgX0cnHhs3ieu/L8netBvbhKfLWizWcZxPkj0SozboYda26FHNOCgPjB/3ho6b8kCYFJhsTENSsWquLlu31EUwqJledC4ccRJ94RdG01ysXNbF1eTABFXe0xEMZXeC4r8eC5KXSgKO0m6KhIDfoa3jRPQgvnCIijrTBXnbyAFdfBpKXZQ18PQ+/EbMigLtdmFYN/bswtm/bx0F53qOuGqBm+mr0oJFDIco3zcV55oNnRR24POi3NkCzg4PpkVTm0YHA65wSKCQs1wz0FySFffG3XeZxXDG1lbL2sPK2y6QdrW+5eBDneh6QsSxWcs9z0a/fMCRQTVlt5GjH+SL8db/JDocE8Dnan/wY3f2tTXWDFsoXMG93+gFET1pDDheX9Som/3LqrMjRAOblLb2TPGRTLwcNjd6lvcv/pyQAtQffgNDR0+3Z/1OWnwHdnHAFd6qrbbtSsFXUPpkDDT2PMNEe4KWjo8S/X195ngndL1DWWKh32+ih7Xe41gWLWLGITu98EmbfcQPQF7/0wqoo7XpUZVLlaPgutBcjTHPh5TLMcyUe5eHs4QDFhcaPk9+jfa7Pwfo/qlYu9T1JgBrQHRGkkQccXT2RIecjvbOqyiVCVaXi3fWp7zrJwgGLCqmk/x8zYUpkOEztW4VCYnoibgDy8nGdS5UGijZ0dNlV8eVaSlI8IQRACyt5XsYQCS3YNPG+/+NbqsIFi+izrhBO48zNYtaJl3zzn26MlqmCQvVOmvqFn2/6hAkH+DZ2PZNW5JijI9PnQgqX0DkMqW/DYx9/OCyso9tDBe+KSfX/A+6eGgy4MSYVYNaTfNo2PHf1VrQpAEiRavjsWL8CQWKA2tf4l1ahIgNKEhUJjlw1LhZAcKBj7e+dqOLxZrb1CciCxzF3HBolA5roRhhu5DD1nHUjIYh+rXxsRUEHBEsPr7QN4q1nWrtPQ/gu9q0f6rUezjar4xpNWqSzHNFkyXrUm9EEwepilH/RhUBf2rIsYKOa7Yeo285RWZqTNQhqtaFvPgAOaOq3410dAsI8250cUFNPBg8d3jq9euReebOGISTr6JmFrcVrE4TR1WKCx00I+KHhBfVgYcVBMWGgguHfLCshfnoQ3ZaJNmk0nhsB6dbNmWY4pKqDEWyWKVLygRj4qigooNiyvb3l6rf+DLqi5IXh6mDjOUoIa/rg4aqCYsPY+kxW2k4iqPbQJFgnjzGd87rAsNxlaX1oZRM0SVDXLtj+6oJi9YfOxf0MqqPn4IDF+95cD+HUFBdQLmv+8KP3f+dt40M1QzIOCF1RytEGxR/BjMyDKJLdVLoUXNqRDUqI6eev3VtjdfhanEWtMwPEuC3MJm5RHdS3jM1LNsn7ysC6gWEOH+ekvntLls15MaJ+W6AZKWbMEZW8YS2b5bIOuoGjN0LcEJMQOLMuhUt1BkWBJq7CGGGE19HmpCQK39OsCilazfGtnMVCzhg5vNMoA6QqK5LOkXegCf6VewCplj09Z4/uN+PATKZXRNVjbNtWDX6UsVyrrAkreG4p/6yVmUyrt5GConw7QG5Z8GKGXTFKpZFGKNWJG2h0LAlzWVzt0daSxJO0OSWath/0vQHvnAtPUFcbxr4ibBge4IauCj/meyEx0m8NFo9lDdGbrTJzC5syyIU50btMQM7vFbOiyqWTL1IE6dUF8MB9RAR9xusWo+IAxKD6CKAIFRbAtFIb09t71HKSW9j7O7W0L9N4vOWnpfZ/74zvfPe33/1QS6OPb3t9/Cu5vxhCOJaTb8QJAIlKqEgGbYt0HLIbwlROuQIK5CHAaFwNYxktVJwwHinlvKGVTEuPaRgUEWU58UDknHgawwCUUlCmgdf7wxhfQcjXaaRuVEFyBBPGUI0RtmRc5BrNy3+SCJ10EeblvMinzDWKg5RsK2VKlcQugaKXD/Z4nazFzancss+lz4yOPpRLzxEmiSucCl8piVXreX42miukjm2fRu1IMIEEUIlAg/mHzXCpZZmz6u4eyUjrrgQ1v0wftZR1ogtiLc2gkCd5dlquUodB/zGrRUfvXv2M9utEArt910O5ARTLdwPqZ2OTWKeperJ8jvVfHgmOK+dAoSkcd/FFD5aYhoJzzUZ1fub4nck/KlQsutuA95IkASIoKhg9GBsHgPoGSrhkVTEWpmrtKm7AIMKldnRtBfGx0jAEZlUTrNn082KP3FKWQnr3bAht1jVBhpnzuoVoPrddQx9P5PBTbl46ivjbiml1nexrs0d6C0srseRFJ0SFYm9fbFpVZgZOiuSx9aj+cmSnGssubYd4JYeVqc+JQr1/f2isGWJtv8CJQlK718AaN5eQWoSGPlgKUJLD6bCytnxzRG3I1EV7vcJQdG5VR3iFL1tneHx0Maa+Fu7X/RX/WQub1Bt51GpOG+8yhfH/5Aay99MCzQB1N1bSe2uoToCSBtehkTf2vb6i93skoHTp6B3+q46DgQCj+SJpHid5xy3Ysbm9oWjYSfGk5ZWaIz66WtA/GNuQ9zPlJ03p6m0+BkgSWscVa71wCj93bWGFWVgUU1wqXjkQFet8a/hTER4Xgv5F8PtpWMF5JGAZi6x+wAfzC1jLO5cblZKrRSH/AMdXdDn9IT1gZE2a/NhJbfLwGaxuIn4ey6FqO/ax5eOa3TgHK3eAdtFptCAlU+IaZLDgjiiTLMvdGA25JOXreR1NH2zRzgGSo2rxeT9g8XQ1JudK8hIpmWK8V9QG6LtT+TRyBQROy+DHBsKdIRMzF0KbWwmPTmvcm3+lMoNpNdM2KlJQU4n+j6PBeUL5sNBiSx8DmGf1tT2w9bB1v9UhDHR8/NlTwHIrvteAmeCNt+0L7ZDsWubdgBM+bFBY8XJD0BUWZrKV504wro4faoEJxA+XUHOWVrYSAgc89FrK0i3WwaGKYqG3iovvi5uqlTLiZWsgnXQeF9oRNsyKJ1l1ypG04/TtBOE5C+zx/uxEqjO5V+cJpkBQj0A+hhB5IaF+0yVKer2nc/klRV/BQHgFLe6wKd2LiK/0kHXzmqGDcAAbaP0MFYlYd13PKXyA7Mn8Y0f7T8+5Dib7Z/p7kfDPmDIGpaTfcuyCOoRDJhqyJjeBVoXAJDa6ZOEKINqAafl/YJYGSFLyHafPxPBYSbPhl9mCY8XyoV07u3G0zLNhdhtUy2g0dj0TsAYncjN/QUSLg5qpxREWC0i/Ugjb3cU2a+9+N9+lT4Tmb19RsL3WJoSwVBRpTRmKXBsrtGAuT56DysSDjJoR/dQUmrCuCvQV1Hj25V5/rg2FInqrGx4sb15dYQUSbXeGicPJ1dgXRtokx4diT8mnoeMtQH7679YaDMpPVRN26PK1uzUtDbVAVdpUYyiseKzz5omCdIlRBPXZMX1xdHTWptv6UHla8TjYhi8uLZd1iXbbzwxHE5zNydT6uBn/vh5e9fiN01c0we8s1fLxHLJhaKws0xj2Lu4WH8ghYz67Ic7sAFhqKEiarYeHk/hDcu4fXLqzBdoN01U0dY50BQaKOiSSAZqddg7vrJnrl/JAu1JazNVBpaO04bVD1j8awL6lbAiUJLPUX5z1SWS1hSn/4VjMEurIhjanl0yOJ1+WUXRJ+CsRAPdi/pFsDJempsF0IAykcXfxmgv3zrEu1uCHpOCGLigiCFYQ3rDNtuZhzZBESIprY1Bdq6g8s9QugJIJFQ+TTvTpAhQzJajlKa8nOMFg04apMG1CHPvMroCSBhcQw81a/2KUuZNsZPS5YGjsuzAb9kzDwGfYfF6J1Sqqa4EKpEWJGhNrW99xPftDcHlgZwSHvYbUNqMPL/BIoSTGWp6rXespKqswwfU2BW9teTZ2ENfQ8Yak5dzhl6JBZzbVL7+6as9ufgZLisZiBiX/hN5E2r/DeJDXMiVHj91LtRGEdrM66CTGjQiF1AXkdalRRmHQIcrYvd16HbZ+O9UxvcgyFVJMNqMy5sgDKXY+FXyMTTgv+Eg2BhoYj/BrWUQm9pLIRGpopIv3D7mzIQ9XsmScroIQ8FgOuv1phHgfvwjvW32/BjZRqvwIKlQDfK0+g+MByLAepYl3OMKAYB1D74mQNFBtYXF7KpakUsFxiqOqseAUokcG7q+qIAtYjD1W3VP9HXCbwp0/JCiiSGMv5b9r/u4MQqP/qk/RZ8zKd4GGDSXZA8cXPctPHYgiW8+lIcaWhyxIoIARArop+fNKJXJCxLZetj1c0SMVBJkabU9ZBg6KaLH6IZET+rYDlwfX9GSyp68rC/gcKtRRHC4+EWgAAAABJRU5ErkJggg=='>
        </div>
        <div class="footerRight">
            <p class="bottomText"><span class="biggerBottomText">&copy;</span>2020 SAP SE, All rights reserved.</p>
        </div>
    </div>
</body>

</html>
`;


/***/ }),

/***/ 95629:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const connection_1 = __webpack_require__(9322);
const ux_common_utils_1 = __webpack_require__(59859);
const sapSystem_1 = __webpack_require__(35328);
exports.SapSystem = sapSystem_1.SapSystem;
const systemStore_1 = __webpack_require__(17038);
const url_1 = __webpack_require__(57310);
const __1 = __webpack_require__(24951);
/**
 * Returns a list of available SapSystems
 */
async function listSAPSystems() {
    if (ux_common_utils_1.isAppStudio()) {
        const systems = {};
        const destinations = await connection_1.listDestinations();
        Object.values(destinations)
            .sort((a, b) => a.Name.localeCompare(b.Name, undefined, { numeric: true, caseFirst: 'lower' }))
            .forEach((destination) => {
            var _a, _b;
            systems[destination.Name] = new sapSystem_1.SapSystem(destination.Name, {
                url: destination.Host,
                destination: destination.Name,
                destinationAuthType: destination.Authentication,
                scp: (_b = (_a = destination.WebIDEUsage) === null || _a === void 0 ? void 0 : _a.includes('abap_cloud')) !== null && _b !== void 0 ? _b : false,
                destinationAttributes: Object.assign({}, destination),
                client: destination['sap-client']
            });
        });
        return systems;
    }
    else {
        const store = await systemStore_1.getSystemStore();
        return postGetAll({ systems: await store.getAll(), store });
    }
}
exports.listSAPSystems = listSAPSystems;
/**
 * When we fetch the systems from the store, we may not have all the information.
 * For example, we may not have the user's display name.
 * This will populate any fields whose value can be computed.
 * Will fire off async update, if required
 * @param systems
 */
function postGetAll({ systems, store }) {
    const systemsForUpdate = [];
    Object.values(systems).forEach((sys) => {
        if (sys.isScp()) {
            sys.postConnectionCallbackCreator = postConnectionCallbackCreator;
        }
        else {
            if (!sys.userDisplayName && sys.username) {
                // We have to update the user's display name in the store
                sys.setUserDisplayName(sys.username);
                systemsForUpdate.push(sys);
            }
        }
    });
    if (systemsForUpdate.length > 0) {
        // Fire and forget! Not much we can do here, dont block the user thou!
        updateUserDisplayNameFor({ systems: systemsForUpdate, store }).catch();
    }
    return systems;
}
/**
 * Asynchronously update the user info property of systems, if required
 * @param param0
 */
async function updateUserDisplayNameFor({ systems, store }) {
    return new Promise((resolve) => setTimeout(async () => {
        const updates = [];
        for (const sys of systems) {
            updates.push(store.partialUpdate({
                url: sys.url,
                client: sys.client,
                update: { userDisplayName: sys.userDisplayName }
            }));
        }
        await ux_common_utils_1.allSettled(updates);
        resolve();
    }, 0));
}
/**
 * Return a `PostConnectionCallback`
 * This is used to update system information that is available once a connection can be made
 */
function postConnectionCallbackCreator(system) {
    // We only do this for BTP systems for now
    if (!system.isScp()) {
        return undefined;
    }
    let cb;
    if (system.unSaved) {
        cb = {
            sync: true,
            updateUserInfo: !system.userDisplayName,
            fn: ({ user, refreshToken }) => {
                // Only add if not falsy. Don't want to set the prop to falsy in the store by mistake
                !!user && system.setUserDisplayName.bind(system)(user);
                !!refreshToken && system.setRefreshToken.bind(system)(refreshToken);
            }
        };
    }
    else {
        cb = {
            sync: false,
            updateUserInfo: !system.userDisplayName,
            fn: async ({ user, refreshToken }) => {
                if (user || refreshToken) {
                    const update = {};
                    // Only add if not falsy. Don't want to set the prop to falsy in the store by mistake
                    !!user && (update.userDisplayName = user);
                    !!refreshToken && (update.refreshToken = refreshToken);
                    return (await systemStore_1.getSystemStore()).partialUpdate({
                        url: system.url,
                        client: system.client,
                        update
                    });
                }
            }
        };
    }
    return cb;
}
/**
 * Check if the system name is already in use
 *
 * @param name
 * @param scp
 */
async function isSystemNameInUse(name) {
    const systems = await (await systemStore_1.getSystemStore()).getAll();
    const sys = name.trim();
    // Find a system with given name. Also take into account systems stored with display name
    return (Object.values(systems).findIndex((system) => system.name === sys ||
        // `<name> (SCP)` used to stored and not computed before
        system.bareName === sapSystem_1.stripOldSCPSuffix(sys)) !== -1);
}
exports.isSystemNameInUse = isSystemNameInUse;
/**
 * Returns the credentials for the given system. If there are no credentials, then undefined is returned.
 * @param url pointing to the root of an on-premise ABAP system
 * @param client (optional) SAP client
 */
async function getSapSystem(url, client) {
    if (ux_common_utils_1.isAppStudio()) {
        throw Error('Not supported in AppStudio.');
    }
    else {
        return (await systemStore_1.getSystemStore()).get(url, client);
    }
}
exports.getSapSystem = getSapSystem;
/**
 * Create an SapSystem instance
 * @param name unique name/id of the SapSystem
 * @param url pointing to the root of an on-premise ABAP system
 * @param client (optional) SAP client
 */
function newSapSystem(name, url, client, credentials, unSaved = false) {
    const userDisplayName = unSaved ? credentials === null || credentials === void 0 ? void 0 : credentials.username : undefined;
    return new sapSystem_1.SapSystem(name, { url, client }, credentials, userDisplayName, unSaved, postConnectionCallbackCreator);
}
exports.newSapSystem = newSapSystem;
/**
 * Create an SapSystem instance extract the path of the provided service url
 * @param urlString url pointing to any service with option sap-client parameter
 */
function newSapSystemForServiceUrl(urlString) {
    const url = new url_1.URL(urlString);
    return {
        system: newSapSystem('temp', url.origin, url.searchParams.get('sap-client')),
        servicePath: url.pathname,
        search: url.search
    };
}
exports.newSapSystemForServiceUrl = newSapSystemForServiceUrl;
/**
 * Create an SapSystem instance pointing to a Steampunk service
 * @param name unique name/id of the SapSystem
 * @param serviceKey serviceKey as string or ServiceInfo object
 * @param usSaved indicate if it's an unsaved (new) system or not. Defaults to `false`
 */
function newSapSystemForSteampunk(name, serviceKey, unSaved = false) {
    // todo: if string load from filesystem or parse
    const service = typeof serviceKey === 'string' ? JSON.parse(serviceKey) : serviceKey;
    const config = {
        url: service.url,
        scp: true
    };
    return new sapSystem_1.SapSystem(name, config, { serviceKeysContents: service }, undefined, unSaved, postConnectionCallbackCreator);
}
exports.newSapSystemForSteampunk = newSapSystemForSteampunk;
/**
 *
 * Create a new S/4HANA Cloud system instance
 */
function newS4HCSystem({ name, url, unSaved = false }) {
    return new sapSystem_1.SapSystem(name, { url, authenticationType: __1.AuthenticationType.ReentranceTicket }, undefined, undefined, unSaved, postConnectionCallbackCreator);
}
exports.newS4HCSystem = newS4HCSystem;
function newSapSystemForDestinaton({ destination, destinationInstance, destinationAuthType, credentials }) {
    return new sapSystem_1.SapSystem(destination, { destination, destinationAuthType, destinationInstance }, credentials, undefined, false);
}
exports.newSapSystemForDestinaton = newSapSystemForDestinaton;
/**
 * Save an SAP System to the local system store
 * @param system
 */
async function saveSapSystem(system) {
    const store = await systemStore_1.getSystemStore();
    await store.save(system);
}
exports.saveSapSystem = saveSapSystem;
/**
 * Delete an SAP System from the local system store
 * @param system
 */
async function deleteSapSystem(system) {
    const store = await systemStore_1.getSystemStore();
    return store.delete(system);
}
exports.deleteSapSystem = deleteSapSystem;


/***/ }),

/***/ 35328:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const ux_store_1 = __webpack_require__(16493);
const __1 = __webpack_require__(24951);
const client_1 = __webpack_require__(41513);
const config_1 = __webpack_require__(69180);
const ux_common_utils_1 = __webpack_require__(59859);
const NEW_SCP_SUFFIX = ' (BTP)';
/**
 *  DO NOT directly create instances of this class outside of odata-client
 *
 * Please use the functions: newSapSystem, newSapSystemForServiceUrl, newSapSystemForSteampunk,
 * newSapSystemForDestinaton
 *
 */
class SapSystem {
    /**
     *  DO NOT directly create instances of this class outside of odata-client
     *
     * Please use the functions newSapSystem, newSapSystemForServiceUrl, newSapSystemForSteampunk
     * newSapSystemForDestinaton
     *
     */
    constructor(name, config, credentials = {}, userDisplayName, unSaved = false, postConnectionCallbackCreator) {
        this.config = config;
        this.credentials = credentials;
        this._unSaved = false;
        this.postConnectionCallbackInitialized = false;
        this._name = name;
        // If `config.scp` is not passed in, infer from the presence of serviceKeys
        if (this.config.scp === void 0) {
            this.config.scp = !!(credentials === null || credentials === void 0 ? void 0 : credentials.serviceKeysContents) || !!(credentials === null || credentials === void 0 ? void 0 : credentials.serviceKeys);
        }
        this._unSaved = unSaved;
        this._userDisplayName = userDisplayName;
        this._postConnectionCallbackCreator = postConnectionCallbackCreator;
    }
    postConnectionCallback() {
        var _a;
        if (!this.postConnectionCallbackInitialized) {
            this._postConnectionCallback = (_a = this._postConnectionCallbackCreator) === null || _a === void 0 ? void 0 : _a.call(this, this);
            this.postConnectionCallbackInitialized = true;
        }
        return this._postConnectionCallback;
    }
    static fromSerialized(s) {
        const credentials = s.serviceKeys || s.username || s.password
            ? {
                serviceKeysContents: s.serviceKeys,
                username: s.username,
                password: s.password,
                refreshToken: s.refreshToken
            }
            : undefined;
        const authenticationType = Object.values(ux_store_1.AuthenticationType).find((v) => v === s.authenticationType) ||
            __1.guessAuthType({ credentials, fallback: false });
        return new SapSystem(s.name, { url: s.url, client: s.client, authenticationType }, credentials, s.userDisplayName);
    }
    clone() {
        return SapSystem.fromSerialized(this.serialize());
    }
    get refreshToken() {
        var _a;
        return (_a = this.credentials) === null || _a === void 0 ? void 0 : _a.refreshToken;
    }
    set refreshToken(value) {
        this.credentials = Object.assign(this.credentials || {}, { refreshToken: value });
    }
    get name() {
        return this._name;
    }
    set name(newName) {
        this._name = newName;
    }
    get username() {
        var _a;
        return (_a = this.credentials) === null || _a === void 0 ? void 0 : _a.username;
    }
    get password() {
        var _a;
        return (_a = this.credentials) === null || _a === void 0 ? void 0 : _a.password;
    }
    get unSaved() {
        return this._unSaved;
    }
    set unSaved(val) {
        this._unSaved = val;
    }
    get url() {
        return this.config.url;
    }
    get client() {
        return this.config.client;
    }
    get userDisplayName() {
        return this._userDisplayName;
    }
    set postConnectionCallbackCreator(cbCreator) {
        this._postConnectionCallbackCreator = cbCreator;
        this.postConnectionCallbackInitialized = false;
        this._postConnectionCallback = undefined;
    }
    get postConnectionCallbackCreator() {
        return this._postConnectionCallbackCreator;
    }
    /**
     * Returns system display name.
     * Will include `<name> (SCP)` if it's an SCP system.
     * Else will add `<name> (S4HC)` for S4/HANA Cloud systems
     * Just the name in all other cases
     *
     * By default will also add username to the end
     */
    getDisplayName({ includeUserName } = { includeUserName: true }) {
        const userDisplayName = includeUserName && this.userDisplayName ? ` [${this.userDisplayName}]` : '';
        let systemDisplayName;
        if (this.isScp()) {
            systemDisplayName = toSCPSystemName(this.name);
        }
        else if (this.isS4HC()) {
            systemDisplayName = this.addS4HCSuffix(this.name);
        }
        else {
            systemDisplayName = this.name;
        }
        return systemDisplayName + userDisplayName;
    }
    // @todo: this class clearly needs to be refactored into classes representing OnPrem, BTP, S4HC and Destinations
    isOnPremSystem() {
        var _a;
        return (((_a = this.config) === null || _a === void 0 ? void 0 : _a.authenticationType) === ux_store_1.AuthenticationType.Basic ||
            (Object.keys(this.credentials).length !== 0 && !(this.isScp() || this.isS4HC())));
    }
    isS4HC() {
        var _a;
        return ((_a = this.config) === null || _a === void 0 ? void 0 : _a.authenticationType) === ux_store_1.AuthenticationType.ReentranceTicket;
    }
    addS4HCSuffix(name) {
        const S4HC_SUFFIX = ' (S4HC)';
        return (name === null || name === void 0 ? void 0 : name.trim().match(`${ux_common_utils_1.escapeRegExp(S4HC_SUFFIX)}$`)) ? name : name + S4HC_SUFFIX;
    }
    /**
     * System name with any `(SCP)` suffix stripped
     */
    get bareName() {
        return stripOldSCPSuffix(this.name);
    }
    isScp() {
        return this.config.scp;
    }
    /**
     * A destination configured as generic odata without the 'full_url' attribute
     * are considered partial url destinations
     * @returns true, if this destination is generic odata and 'full_url' attribute is not set
     */
    isPartialUrlDest() {
        return (!config_1.hasDestinationAttrib("WebIDEAdditionalData" /* WebIDEAdditionalData */, config_1.DestinationAttributeProperty.FULL_URL, this.config.destinationAttributes) && this.isGenericODataDest());
    }
    /**
     * Checks if the destination attributes WebIDEUsage is configured with odata_gen, and not odata_abap
     * We want to maintain existing destinations, perhaps accidentally configured with both, continue
     * working as abap catalogs
     */
    isGenericODataDest() {
        return this.config.destination
            ? config_1.hasDestinationAttrib("WebIDEUsage" /* WebIDEUsage */, config_1.DestinationAttributeProperty.ODATA_GENERIC, this.config.destinationAttributes) &&
                !config_1.hasDestinationAttrib("WebIDEUsage" /* WebIDEUsage */, config_1.DestinationAttributeProperty.ODATA_ABAP, this.config.destinationAttributes)
            : false;
    }
    isFullUrlDest() {
        return this.config.destination
            ? config_1.hasDestinationAttrib("WebIDEAdditionalData" /* WebIDEAdditionalData */, config_1.DestinationAttributeProperty.FULL_URL, this.config.destinationAttributes) && this.isGenericODataDest()
            : false;
    }
    isAbapCatalogDest() {
        return this.config.destination
            ? config_1.hasDestinationAttrib("WebIDEUsage" /* WebIDEUsage */, config_1.DestinationAttributeProperty.ODATA_ABAP, this.config.destinationAttributes) && !this.isFullUrlDest()
            : false;
    }
    toString() {
        var _a;
        const urlString = () => {
            var _a, _b, _c;
            const url = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.url) === null || _b === void 0 ? void 0 : _b.trim();
            if (url) {
                const client = ((_c = this.config) === null || _c === void 0 ? void 0 : _c.client) ? `?sap-client=${this.config.client}` : '';
                return url + client;
            }
            else {
                return undefined;
            }
        };
        return ((_a = this.config) === null || _a === void 0 ? void 0 : _a.destination) || urlString() || this.getDisplayName() || '';
    }
    serialize() {
        var _a, _b, _c, _d, _e, _f;
        return new ux_store_1.BackendSystem({
            name: this._name,
            url: (_a = this.config) === null || _a === void 0 ? void 0 : _a.url,
            client: (_b = this.config) === null || _b === void 0 ? void 0 : _b.client,
            authenticationType: (_c = this.config) === null || _c === void 0 ? void 0 : _c.authenticationType,
            serviceKeys: (_d = this.credentials) === null || _d === void 0 ? void 0 : _d.serviceKeysContents,
            refreshToken: this.refreshToken,
            username: (_e = this.credentials) === null || _e === void 0 ? void 0 : _e.username,
            password: (_f = this.credentials) === null || _f === void 0 ? void 0 : _f.password,
            userDisplayName: this.userDisplayName
        });
    }
    async getService(path) {
        const system = deepClone(this.config);
        system.service = path;
        if (this.connection) {
            return new client_1.ODataClient({
                system,
                connection: this.connection,
                postConnectionCallback: this.postConnectionCallback()
            });
        }
        else {
            const client = new client_1.ODataClient({
                system,
                credentials: this.credentials,
                postConnectionCallback: this.postConnectionCallback()
            });
            this.connection = await client.getConnection();
            return client;
        }
    }
    setUserDisplayName(u) {
        this._userDisplayName = u;
    }
    setRefreshToken(r) {
        this.refreshToken = r;
    }
    async getCatalog(odataVersion) {
        const system = deepClone(this.config);
        if (this.connection) {
            return client_1.getCatalog({
                system,
                connection: this.connection,
                odataVersion,
                postConnectionCallback: this.postConnectionCallback()
            });
        }
        else {
            const catalog = client_1.getCatalog({
                system,
                credentials: this.credentials,
                odataVersion,
                postConnectionCallback: this.postConnectionCallback()
            });
            this.connection = await catalog.getConnection();
            return catalog;
        }
    }
    async getUi5Repository(log = console, ignoreCertError) {
        const system = deepClone(this.config);
        if (this.connection) {
            return new client_1.Ui5AbapRepository({
                system,
                connection: this.connection,
                log,
                ignoreCertError,
                postConnectionCallback: this.postConnectionCallback()
            });
        }
        else {
            const repo = new client_1.Ui5AbapRepository({
                system,
                credentials: this.credentials,
                log,
                ignoreCertError,
                postConnectionCallback: this.postConnectionCallback()
            });
            this.connection = await repo.getConnection();
            return repo;
        }
    }
    setCredentials(credentials) {
        this.credentials = credentials;
    }
    isSameSystem(url, client) {
        var _a, _b, _c;
        return ((_b = (_a = this.url) === null || _a === void 0 ? void 0 : _a.trim()) === null || _b === void 0 ? void 0 : _b.replace(/\/$/, '')) === ((_c = url === null || url === void 0 ? void 0 : url.trim()) === null || _c === void 0 ? void 0 : _c.replace(/\/$/, '')) && this.client === client;
    }
}
exports.SapSystem = SapSystem;
function toSCPSystemName(systemName) {
    const s = systemName.trim();
    return s.match(`${ux_common_utils_1.escapeRegExp(NEW_SCP_SUFFIX)}$`) ? s : s + NEW_SCP_SUFFIX;
}
function stripOldSCPSuffix(name) {
    return name.trim().replace(/ \(SCP\)$/, '');
}
exports.stripOldSCPSuffix = stripOldSCPSuffix;
/** Return a deep clone of the object
 * The properties need to be serializable (won't work for functions, for example)
 */
function deepClone(o) {
    return JSON.parse(JSON.stringify(o));
}


/***/ }),

/***/ 17038:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sapSystem_1 = __webpack_require__(35328);
const ux_store_1 = __webpack_require__(16493);
class DefaultImplementation {
    constructor(storeService, logger) {
        this.logger = logger;
        this.storeService = storeService;
    }
    static async createInstance(logger) {
        const storeService = await ux_store_1.getService({ logger, entityName: 'system' });
        return new DefaultImplementation(storeService, logger);
    }
    async getAll() {
        const systems = (await this.storeService.getAll()) || [];
        return systems
            .map((s) => sapSystem_1.SapSystem.fromSerialized(s))
            .sort((a, b) => a
            .getDisplayName({ includeUserName: false })
            .localeCompare(b.getDisplayName({ includeUserName: false }), undefined, {
            numeric: true,
            caseFirst: 'lower'
        }))
            .reduce((result, s) => {
            result[s.name] = s;
            return result;
        }, {});
    }
    async get(url, client) {
        const serializedSystem = await this.storeService.read(new ux_store_1.BackendSystemKey({ url, client }));
        if (serializedSystem && Object.keys(serializedSystem).length > 0) {
            return sapSystem_1.SapSystem.fromSerialized(serializedSystem);
        }
        else {
            return undefined;
        }
    }
    async save(system) {
        if (typeof (system === null || system === void 0 ? void 0 : system.serialize) !== 'function') {
            //TODO: Add i18n texts to odata-client
            this.logger.warn('system does not have a serialize method, unable to save');
        }
        else {
            await this.storeService.write(system.serialize());
        }
    }
    async delete(system) {
        if (typeof (system === null || system === void 0 ? void 0 : system.serialize) !== 'function') {
            //TODO: Add i18n texts to odata-client
            this.logger.warn('system does not have a serialize method, unable to delete');
        }
        else {
            return this.storeService.delete(system.serialize());
        }
    }
    async partialUpdate({ url, client, update }) {
        await this.storeService.partialUpdate(new ux_store_1.BackendSystemKey({ url, client }), update);
    }
}
exports.getSystemStore = async (log = console) => {
    return DefaultImplementation.createInstance(log);
};


/***/ }),

/***/ 3283:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const fast_xml_parser_1 = __importDefault(__webpack_require__(6832));
const __1 = __webpack_require__(24951);
function xmlToJson(xml) {
    if (!xml || fast_xml_parser_1.default.validate(xml) !== true) {
        return;
    }
    const options = {
        attributeNamePrefix: '',
        ignoreAttributes: false,
        ignoreNameSpace: true,
        parseAttributeValue: true
    };
    const obj = fast_xml_parser_1.default.getTraversalObj(xml, options);
    return fast_xml_parser_1.default.convertToJson(obj, options);
}
exports.xmlToJson = xmlToJson;
/**
 *
 * Try to guess authentication type based on the credentials passed in
 * Optionally fall back to basic authentication as the default
 */
function guessAuthType({ credentials, fallback = false }) {
    var _a, _b;
    let authType = (credentials === null || credentials === void 0 ? void 0 : credentials.serviceKeys) || (credentials === null || credentials === void 0 ? void 0 : credentials.serviceKeysContents)
        ? __1.AuthenticationType.OAuth2RefreshToken
        : undefined;
    if (!authType && credentials && ((_b = (_a = credentials.serviceInfo) === null || _a === void 0 ? void 0 : _a.uaa) === null || _b === void 0 ? void 0 : _b.username)) {
        authType = __1.AuthenticationType.OAuth2ClientCredential;
    }
    if (!authType && fallback) {
        authType = __1.AuthenticationType.Basic;
    }
    return authType;
}
exports.guessAuthType = guessAuthType;


/***/ }),

/***/ 35024:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {promisify} = __webpack_require__(73837);
const path = __webpack_require__(71017);
const childProcess = __webpack_require__(32081);
const fs = __webpack_require__(57147);
const isWsl = __webpack_require__(39295);
const isDocker = __webpack_require__(35836);

const pAccess = promisify(fs.access);
const pExecFile = promisify(childProcess.execFile);

// Path to included `xdg-open`.
const localXdgOpenPath = path.join(__dirname, 'xdg-open');

// Convert a path from WSL format to Windows format:
// `/mnt/c/Program Files/Example/MyApp.exe`  `C:\Program Files\Example\MyApp.exe`
const wslToWindowsPath = async path => {
	const {stdout} = await pExecFile('wslpath', ['-w', path]);
	return stdout.trim();
};

module.exports = async (target, options) => {
	if (typeof target !== 'string') {
		throw new TypeError('Expected a `target`');
	}

	options = {
		wait: false,
		background: false,
		url: false,
		...options
	};

	let command;
	let appArguments = [];
	const cliArguments = [];
	const childProcessOptions = {};

	if (Array.isArray(options.app)) {
		appArguments = options.app.slice(1);
		options.app = options.app[0];
	}

	// Encodes the target as if it were an URL. Especially useful to get
	// double-quotes through the double-quotes on Windows caveat, but it
	// can be used on any platform.
	if (options.url) {
		target = encodeURI(target);

		if (isWsl) {
			target = target.replace(/&/g, '^&');
		}
	}

	if (process.platform === 'darwin') {
		command = 'open';

		if (options.wait) {
			cliArguments.push('--wait-apps');
		}

		if (options.background) {
			cliArguments.push('--background');
		}

		if (options.app) {
			cliArguments.push('-a', options.app);
		}
	} else if (process.platform === 'win32' || (isWsl && !isDocker())) {
		command = 'cmd' + (isWsl ? '.exe' : '');
		cliArguments.push('/s', '/c', 'start', '""', '/b');

		if (!isWsl) {
			// Always quoting target allows for URLs/paths to have spaces and unmarked characters, as `cmd.exe` will
			// interpret them as plain text to be forwarded as one unique argument. Enabling `windowsVerbatimArguments`
			// disables Node.js's default quotes and escapes handling (https://git.io/fjdem).
			// References:
			// - Issues #17, #44, #55, #77, #101, #115
			// - Pull requests: #74, #98
			//
			// As a result, all double-quotes are stripped from the `target` and do not get to your desired destination.
			target = `"${target}"`;
			childProcessOptions.windowsVerbatimArguments = true;

			if (options.app) {
				options.app = `"${options.app}"`;
			}
		}

		if (options.wait) {
			cliArguments.push('/wait');
		}

		if (options.app) {
			if (isWsl && options.app.startsWith('/mnt/')) {
				const windowsPath = await wslToWindowsPath(options.app);
				options.app = windowsPath;
			}

			cliArguments.push(options.app);
		}

		if (appArguments.length > 0) {
			cliArguments.push(...appArguments);
		}
	} else {
		if (options.app) {
			command = options.app;
		} else {
			// When bundled by Webpack, there's no actual package file path and no local `xdg-open`.
			const isBundled = !__dirname || __dirname === '/';

			// Check if local `xdg-open` exists and is executable.
			let exeLocalXdgOpen = false;
			try {
				await pAccess(localXdgOpenPath, fs.constants.X_OK);
				exeLocalXdgOpen = true;
			} catch (_) {}

			const useSystemXdgOpen = process.versions.electron ||
				process.platform === 'android' || isBundled || !exeLocalXdgOpen;
			command = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;
		}

		if (appArguments.length > 0) {
			cliArguments.push(...appArguments);
		}

		if (!options.wait) {
			// `xdg-open` will block the process unless stdio is ignored
			// and it's detached from the parent even if it's unref'd.
			childProcessOptions.stdio = 'ignore';
			childProcessOptions.detached = true;
		}
	}

	cliArguments.push(target);

	if (process.platform === 'darwin' && appArguments.length > 0) {
		cliArguments.push('--args', ...appArguments);
	}

	const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);

	if (options.wait) {
		return new Promise((resolve, reject) => {
			subprocess.once('error', reject);

			subprocess.once('close', exitCode => {
				if (exitCode > 0) {
					reject(new Error(`Exited with code ${exitCode}`));
					return;
				}

				resolve(subprocess);
			});
		});
	}

	subprocess.unref();

	return subprocess;
};


/***/ }),

/***/ 3164:
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),

/***/ 67750:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(13749);
var parse = __webpack_require__(81847);
var formats = __webpack_require__(3164);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ 81847:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(36283);

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset);
            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (val && options.comma && val.indexOf(',') > -1) {
            val = val.split(',');
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === 'number' ? opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),

/***/ 13749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(36283);
var formats = __webpack_require__(3164);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    formatter: formats.formatters[formats['default']],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = obj.join(',');
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        }
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ 36283:
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),

/***/ 1595:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __importStar(__webpack_require__(57147));
const path_1 = __webpack_require__(71017);
const vscode_uri_1 = __webpack_require__(57657);
const project_spec_1 = __webpack_require__(72194);
async function readFile(path) {
    return new Promise((resolve, reject) => {
        fs.readFile(path, { encoding: 'utf8' }, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
}
exports.readFile = readFile;
async function readJSON(path) {
    return JSON.parse(await readFile(path));
}
exports.readJSON = readJSON;
async function deleteFile(path) {
    return new Promise((resolve, reject) => {
        fs.unlink(path, (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
exports.deleteFile = deleteFile;
/**
 * If content === null, then the file will be deleted,
 * otherwise it will be created or updated.
 * @param path root directory for the file updates
 * @param content path+content tuples representing the files
 */
async function updateFile(path, content) {
    if (content === null || content === undefined) {
        return deleteFile(path);
    }
    else {
        return new Promise((resolve, reject) => {
            fs.writeFile(path, content, { encoding: 'utf8' }, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
}
exports.updateFile = updateFile;
async function updateJSON(path, content) {
    await updateFile(path, content ? JSON.stringify(content, null, 4) : null);
}
exports.updateJSON = updateJSON;
async function readDirectory(path) {
    return new Promise((resolve, reject) => {
        fs.readdir(path, { encoding: 'utf8' }, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
}
exports.readDirectory = readDirectory;
/**
 * Creates a directory at the given path
 * @param path path of the directory to be created
 */
async function createDirectory(path) {
    return new Promise((resolve, reject) => {
        fs.mkdir(path, (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
exports.createDirectory = createDirectory;
async function fileExists(path) {
    return new Promise((resolve) => {
        fs.exists(path, (exists) => {
            resolve(exists);
        });
    });
}
exports.fileExists = fileExists;
async function isDirectory(path) {
    return new Promise((resolve, reject) => {
        fs.stat(path, (err, stats) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(stats.isDirectory());
            }
        });
    });
}
exports.isDirectory = isDirectory;
/**
 * Recursively deletes a directory
 * @param path full path to a directory
 */
async function deleteDirectory(path) {
    if (await fileExists(path)) {
        const files = await readDirectory(path);
        for (const name of files) {
            const fullPath = path_1.join(path, name);
            if (await isDirectory(fullPath)) {
                await deleteDirectory(fullPath);
            }
            else {
                await deleteFile(fullPath);
            }
        }
        return new Promise((resolve, reject) => {
            fs.rmdir(path, (err) => {
                if (err) {
                    reject();
                }
                else {
                    resolve();
                }
            });
        });
    }
}
exports.deleteDirectory = deleteDirectory;
/**
 * Move selected file
 * @param oldPath full path to a directory
 * @param newPath full path to a directory
 */
async function moveFile(oldPath, newPath) {
    return new Promise((resolve, reject) => {
        fs.rename(oldPath, newPath, (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
exports.moveFile = moveFile;
/**
 * Convert a fs specific path into a valid Fiori tools file system path
 * @param path - file system path posix or Windows
 */
function fsPathToFtfsPath(path) {
    let posixPath = path.replace(/\\/g, '/');
    if (!path_1.posix.isAbsolute(posixPath)) {
        posixPath = `/${posixPath}`;
    }
    return vscode_uri_1.URI.parse(`${project_spec_1.SchemeName.Ftfs}:${posixPath}`).toString();
}
exports.fsPathToFtfsPath = fsPathToFtfsPath;


/***/ }),

/***/ 23794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const i18next_1 = __importDefault(__webpack_require__(20610));
const i18n_json_1 = __importDefault(__webpack_require__(13086));
exports.i18n = i18next_1.default.createInstance();
/**
 * Initialize i18next of @sap/ux-annotation-service
 */
async function initI18n() {
    await exports.i18n.init({
        resources: {
            en: {
                translation: i18n_json_1.default
            }
        },
        lng: 'en',
        fallbackLng: 'en',
        joinArrays: '\n\n'
    });
}
exports.initI18n = initI18n;


/***/ }),

/***/ 54935:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs_1 = __webpack_require__(57147);
const findit2_1 = __importDefault(__webpack_require__(69177));
const project_spec_1 = __webpack_require__(72194);
const ux_specification_1 = __webpack_require__(78998);
const find_up_1 = __importDefault(__webpack_require__(59490));
const path_1 = __webpack_require__(71017);
const i18n_1 = __webpack_require__(23794);
const file_1 = __webpack_require__(1595);
const yaml = __importStar(__webpack_require__(86916));
const os_1 = __importDefault(__webpack_require__(22037));
const ux_cds_1 = __webpack_require__(43290);
/**
 * Regex to find supported scripts in package.json
 */
exports.scriptsRegEx = /fiori run|cds watch|cds run|ui5 serve|mvn spring-boot:run/;
/**
 * Find root folder of the project containing the given file
 * @param path path of a project file
 * @param sapuxRequired if true, only find sapux projects
 */
async function findProjectRoot(path, sapuxRequired = true) {
    const pckgJson = await find_up_1.default(project_spec_1.FileName.Package, { cwd: path });
    if (!pckgJson) {
        throw new Error(`Could not find any project root. Parameter 'sapuxRequired' was ${sapuxRequired ? 'true' : 'false'}`);
    }
    let root = path_1.dirname(pckgJson);
    if (sapuxRequired) {
        const sapux = (await file_1.readJSON(pckgJson)).sapux;
        if (!sapux) {
            root = await findProjectRoot(path_1.dirname(root), sapuxRequired);
        }
    }
    return root;
}
exports.findProjectRoot = findProjectRoot;
/**
 * Find all projects in the given folder.
 * @param wsRoot root folder for the search
 * @param projects projects array to which all found projects will be added
 */
async function findProject(wsRoot, projects) {
    return findAll(wsRoot, project_spec_1.FileName.Package, projects, [
        '.git',
        'node_modules',
        'dist',
        project_spec_1.DirName.Sapux,
        project_spec_1.DirName.Webapp,
        'MDKModule' // GH #14290
    ]);
}
/**
 * Find all reuse libraries in the given folder.
 * @param wsRoot root folder for the search
 * @param libs projects array to which all found projects will be added
 */
async function findLibrary(wsRoot, libs) {
    return findAll(wsRoot, '.library', libs, ['.git', 'node_modules', 'dist']);
}
exports.findLibrary = findLibrary;
/**
 * Find function to search through folders starting from root
 * @param root - root folder to start search
 * @param filename - filename to search
 * @param results - result collector (found paths will be added here)
 * @param stopFolders - list of foldernames to exclude (search doesn't traverse into these folders)
 */
async function findAll(root, filename, results, stopFolders) {
    return new Promise((doResolve, reject) => {
        const finder = findit2_1.default(root);
        finder.on('directory', (dir, stat, stop) => {
            const base = path_1.basename(dir);
            if (stopFolders.indexOf(base) !== -1) {
                stop();
            }
        });
        finder.on('file', (file) => {
            if (file.endsWith(filename)) {
                results.push(path_1.dirname(file));
            }
        });
        finder.on('end', () => {
            doResolve();
        });
        finder.on('error', (error) => {
            reject(error);
        });
    });
}
/**
 * Find all extension files (*.fragment.xml) in the given folder.
 * @param {string} root root folder for the search
 * @param {string[]} extensionFiles projects array to which all found projects will be added
 * @param {FileName} [targetFileName=FileName.Fragment] file names as condition to search
 */
async function findExtensionFiles(root, targetFileName = project_spec_1.FileName.Fragment) {
    const extensionFiles = [];
    return new Promise((doResolve, reject) => {
        const finder = findit2_1.default(root);
        // ignore .git, node_modules, .sapux etc. folders
        finder.on('directory', (dir, stat, stop) => {
            const base = path_1.basename(dir);
            if (base === '.git' || base === 'node_modules' || base === 'dist' || base === project_spec_1.DirName.Sapux) {
                stop();
            }
        });
        finder.on('file', (file) => {
            if (file.endsWith(targetFileName)) {
                extensionFiles.push(file);
            }
        });
        finder.on('end', () => {
            doResolve(extensionFiles);
        });
        finder.on('error', (error) => {
            reject(error);
        });
    });
}
exports.findExtensionFiles = findExtensionFiles;
/**
 * WorkspaceFolder typeguard
 * @param value value to typecheck
 */
function isWorkspaceFolder(value) {
    return value && value.length > 0 && value[0].uri !== undefined;
}
/**
 * Helper to check for dependency/devDependency
 * @param packageJson - package.json to check
 * @param dependency - name of the dependency
 */
exports.hasDependency = (packageJson, dependency) => (packageJson.dependencies && packageJson.dependencies[dependency] !== undefined) ||
    (packageJson.devDependencies && packageJson.devDependencies[dependency] !== undefined);
/**
 * Helper to check if a project has a valid script.
 * @param packageJson - package.json to check
 */
const hasScript = (packageJson) => {
    if (packageJson.scripts) {
        let scriptExists = false;
        for (const script in packageJson.scripts) {
            const result = packageJson.scripts[script].match(exports.scriptsRegEx);
            if (result) {
                scriptExists = true;
                break;
            }
        }
        return scriptExists;
    }
};
/**
 * Search all manifest.json files in given workspaces. This us used as starting point to find all Fiori tools
 * supported apps.
 * @param wsFolders - workspace folders
 * @returns
 */
async function findAllManifest(wsFolders) {
    // extract root path if provided as VSCode folder
    let wsRoots;
    if (isWorkspaceFolder(wsFolders)) {
        wsRoots = [];
        wsFolders
            .filter((each) => each.uri.scheme === 'file')
            .forEach((folder) => {
            wsRoots.push(folder.uri.fsPath);
        });
    }
    else {
        wsRoots = wsFolders || [];
    }
    // find all manifest files
    const manifests = [];
    for (const root of wsRoots) {
        try {
            await findAll(root, project_spec_1.FileName.Manifest, manifests, ['.git', 'node_modules', 'dist']);
        }
        catch (error) {
            const errorMessage = i18n_1.i18n.t('ERROR_PROJECT_ROOT_WORKSPACE', {
                root,
                error: error.message
            });
            console.error(errorMessage);
        }
    }
    return manifests;
}
/**
 * Internal function to find all folders that contain a package.json in a given workspace
 * @param wsFolders - root folder paths or workspaces to start the search from
 * @param [logger] - logger to log messages (optional)
 */
async function findAllPackageJsonFolders(wsFolders, logger) {
    // extract root path if provided as VSCode folder
    let wsRoots;
    if (isWorkspaceFolder(wsFolders)) {
        wsRoots = [];
        wsFolders
            .filter((each) => each.uri.scheme === 'file')
            .forEach((folder) => {
            wsRoots.push(folder.uri.fsPath);
        });
    }
    else {
        wsRoots = wsFolders || [];
    }
    // find all folders containing a package.json
    const projects = [];
    for (const root of wsRoots) {
        try {
            await findProject(root, projects);
        }
        catch (error) {
            const errorMessage = i18n_1.i18n.t('ERROR_PROJECT_ROOT_WORKSPACE', {
                root,
                error: error.message
            });
            if (logger) {
                logger.error(errorMessage);
            }
            else {
                console.error(errorMessage);
            }
        }
    }
    return projects;
}
/**
 * Find all project root directories, either in array of directories or array of workspaces
 * @param wsFolders - root folder paths or workspaces to start the search from
 * @param sapuxRequired - if true only projects with the sapux:true or sapux: string[] setting will be returned
 * @param [logger] function to log messages (optional)
 */
async function findAllProjectRoots(wsFolders, sapuxRequired = true, logger) {
    const projects = await findAllPackageJsonFolders(wsFolders, logger);
    // if requested, only return the ones with sapux:true
    if (sapuxRequired) {
        const sapuxProjects = [];
        for (const root of projects) {
            try {
                if ((await file_1.readJSON(path_1.join(root, project_spec_1.FileName.Package))).sapux) {
                    sapuxProjects.push(root);
                }
            }
            catch (error) {
                const errorMessage = i18n_1.i18n.t('ERROR_INVALID_PACKAGE_JSON', {
                    error: error.message
                });
                if (logger) {
                    logger.error(errorMessage);
                }
                else {
                    console.error(errorMessage);
                }
            }
        }
        return sapuxProjects;
    }
    else {
        return projects;
    }
}
exports.findAllProjectRoots = findAllProjectRoots;
/**
 *
 * @param appRoot - root of the app
 * @param projectRoot - root of the project, same as app for edmx (non CAP)
 * @returns - app type like SAP Fiori elements or SAPUI5 freestyle
 */
async function getAppType(appRoot, projectRoot) {
    if (appRoot === projectRoot) {
        const appPckJson = await file_1.readJSON(path_1.join(appRoot, project_spec_1.FileName.Package));
        if (appPckJson.sapux === true) {
            return "SAP Fiori elements" /* FioriElement */;
        }
        else {
            return "SAPUI5 freestyle" /* UI5Freestyle */;
        }
    }
    try {
        const projectPckJson = await file_1.readJSON(path_1.join(projectRoot, project_spec_1.FileName.Package));
        if (!projectPckJson.sapux) {
            return "SAPUI5 freestyle" /* UI5Freestyle */;
        }
        else if (Array.isArray(projectPckJson.sapux)) {
            return projectPckJson.sapux.find((relAppPath) => path_1.join(projectRoot, ...relAppPath.split(/\\|\//)) === appRoot)
                ? "SAP Fiori elements" /* FioriElement */
                : "SAPUI5 freestyle" /* UI5Freestyle */;
        }
    }
    catch {
        // If there is no package.json at CAP root, it must be a CAP Java project with freestyle app
        return "SAPUI5 freestyle" /* UI5Freestyle */;
    }
}
exports.getAppType = getAppType;
/**
 * Get the project type from app root and project root
 * @param appRoot - root of the app
 * @param projectRoot - root of the project, same as app for edmx (non CAP)
 * @returns - project type like EDMX, CAP node.js, CAP Java. Throws error if it can't determine project type
 */
async function getDetailedProjectType(appRoot, projectRoot) {
    if (appRoot === projectRoot) {
        return "EDMX Backend" /* Edxm */;
    }
    if (await ux_cds_1.isCapJavaProject(projectRoot)) {
        return "CAP Java" /* CAPJava */;
    }
    if (await ux_cds_1.isCapNodeJsProject(projectRoot)) {
        return "CAP Node.js" /* CAPNode */;
    }
    throw new Error(i18n_1.i18n.t('ERROR_DETAIL_PROJECT_TYPE', { appRoot, projectRoot }));
}
exports.getDetailedProjectType = getDetailedProjectType;
/**
 * Find the app root and project root folder for a given path. In case of apps in non CAP projects they are the same.
 * This function also validates if an app is supported by Fiori tools considering Fiori elements apps and SAPUI5
 * freestyle apps. Only if project root and app root can be determined, they are returned, otherwise null is returned.
 * This function is used e.g. to get filter list of all manifest.json files in a workspace for SAP Fiori tools
 * supported apps and retrieve the respective root paths.
 * This function makes following assumptions:
 * - All applications have a package.json in root folder
 * - If sapux=true in package.json the app is NOT inside a CAP project
 * - Freestyle application (non CAP) has in package.json dependency to @sap/ux-ui5-tooling and <appRoot>/ui5-local.yaml
 * @param path - path to check, e.g. to the manifest.json
 * @returns - in case a supported app is found this function returns the appRoot and projcetRoot path
 */
async function findRootsForPath(path) {
    try {
        // Get the root of the app, that is where the package.json is, otherwise not supported
        const appRoot = await findProjectRoot(path, false);
        if (!appRoot) {
            return null;
        }
        const appPckJson = await file_1.readJSON(path_1.join(appRoot, project_spec_1.FileName.Package));
        // Check for most common app, Fiori elements with sapux=true in package.json
        if (appPckJson === null || appPckJson === void 0 ? void 0 : appPckJson.sapux) {
            if (typeof appPckJson.sapux === 'boolean' && appPckJson.sapux === true) {
                return {
                    appRoot,
                    projectRoot: appRoot
                };
            }
            else if (Array.isArray(appPckJson.sapux)) {
                // Backward compatibility for FE apps in CAP projects that have no app package.json,
                // but are listed in CAP root sapux array
                const relAppPaths = appPckJson.sapux.map((a) => path_1.join(...a.split(/\\|\//)));
                const relApp = relAppPaths.find((app) => path_1.join(appRoot, app, project_spec_1.DirName.Webapp) === path);
                if (relApp) {
                    return {
                        appRoot: path_1.join(appRoot, relApp),
                        projectRoot: appRoot
                    };
                }
            }
            // The first package.json we found when searching up contains sapux, but not true -> not supported
            return null;
        }
        if (await ux_cds_1.isCapProject(appRoot, appPckJson)) {
            // App is part of a CAP project, but doesn't have own package.json and is not mentioned in sapux array
            // in root -> not supported
            return null;
        }
        // Now we have the app root folder. Check for freestyle non CAP
        if (fs_1.existsSync(path_1.join(appRoot, project_spec_1.FileName.Ui5LocalYaml)) && exports.hasDependency(appPckJson, '@sap/ux-ui5-tooling')) {
            return {
                appRoot,
                projectRoot: appRoot
            };
        }
        // Project must be CAP, find project root
        try {
            const { root } = path_1.parse(appRoot);
            let projectRoot = path_1.dirname(appRoot);
            while (projectRoot !== root) {
                if (await ux_cds_1.isCapProject(projectRoot)) {
                    // We have found a CAP project as root. Check if the found app is not directly in CAP's 'app/' folder.
                    // Sometime there is a <CAP_ROOT>/app/package.json file that is used for app router (not an app)
                    if (path_1.join(projectRoot, 'app') !== appRoot) {
                        return {
                            appRoot,
                            projectRoot
                        };
                    }
                }
                projectRoot = path_1.dirname(projectRoot);
            }
        }
        catch (e) {
            // No project root can be found at parent folder.
        }
    }
    catch (error) {
        console.error(error);
    }
    return null;
}
exports.findRootsForPath = findRootsForPath;
/**
 * Find all app that are supported by Fiori tools for a given list of roots (workspace folders)
 * @param wsFolders - list of roots
 * @returns - results as path to apps plus files already parsed, e.g. manifest.json
 */
async function findAllApps(wsFolders) {
    const result = [];
    const manifestPaths = await findAllManifest(wsFolders);
    for (const manifestPath of manifestPaths) {
        try {
            // All UI5 apps have at least sap.app: { id: <ID>, type: "application" } in manifest.json
            const manifest = await file_1.readJSON(path_1.join(manifestPath, project_spec_1.FileName.Manifest));
            if (!manifest['sap.app'] || !manifest['sap.app'].id || manifest['sap.app'].type !== 'application') {
                continue;
            }
            const roots = await findRootsForPath(manifestPath);
            if (roots) {
                result.push({ appRoot: roots.appRoot, projectRoot: roots.projectRoot, manifest, manifestPath });
            }
        }
        catch (error) {
            console.info(`Couldn't check app with manifest.json located  in '${manifestPath}' for valid SAP Fiori tools project. Error was: ${error.message}`);
        }
    }
    return result;
}
exports.findAllApps = findAllApps;
/**
 * Return a list of project roots the preview command works on. These are projects that have a dependency to
 * @sap/ux-ui5-tooling or are CAP projects
 * @param workspaceRoots - array of root folders for the workspace
 */
exports.findRunnableProjects = async (workspaceRoots, logger) => {
    const result = [];
    const roots = await findAllProjectRoots(workspaceRoots, false);
    for (const root of roots) {
        try {
            const packageJson = await file_1.readJSON(path_1.join(root, project_spec_1.FileName.Package));
            if ((exports.hasDependency(packageJson, '@sap/ux-ui5-tooling') || (await ux_cds_1.isCapProject(root, packageJson))) &&
                hasScript(packageJson)) {
                result.push(root);
            }
        }
        catch (error) {
            logger === null || logger === void 0 ? void 0 : logger.info(`Invalid JSON ${path_1.join(root, project_spec_1.FileName.Package)}. Application Modeler will skip this project.`);
            continue;
        }
    }
    return result;
};
/**
 * Return true/false if project is Fiori tools.

 * @param dependency - the name of the dependency; we search in dependencies and devDependencies
 * @param sapux -
 */
async function checkPackageJson(root, dependency, sapux) {
    const packageJson = await file_1.readJSON(path_1.join(root, project_spec_1.FileName.Package));
    if ((packageJson.dependencies && packageJson.dependencies[dependency] !== undefined) ||
        (packageJson.devDependencies && packageJson.devDependencies[dependency] !== undefined)) {
        return true;
    }
    if (sapux === true && packageJson.sapux === true) {
        return true;
    }
    return false;
}
exports.checkPackageJson = checkPackageJson;
/**
 * Return true/false if project is Fiori tools.

 * @param dependency - the name of the dependency; we search in dependencies and devDependencies
 * @param sapux -
 */
async function isFioriToolsProject(root, dependency, sapux) {
    try {
        return (await checkPackageJson(root, dependency, sapux));
    }
    catch (e) {
        return false;
    }
}
exports.isFioriToolsProject = isFioriToolsProject;
/**
 * Find projects that have set a given dependency/devDependency in package.json.
 * @param wsFolders - root folder paths or workspaces to start the search from
 * @param dependency - the name of the dependency; we search in dependencies and devDependencies
 * @param [logger] - logger to log messages (optional)
 */
async function findProjectRootsByDependency(wsFolders, dependency, logger) {
    const result = [];
    const roots = await findAllPackageJsonFolders(wsFolders, logger);
    for (const root of roots) {
        try {
            if (await checkPackageJson(root, dependency, false)) {
                result.push(root);
            }
        }
        catch (error) {
            const errorMessage = i18n_1.i18n.t('ERROR_INVALIND_PACKAGE_JSON_FOR_APP', {
                root
            });
            if (logger) {
                logger.error(errorMessage);
            }
            else {
                console.error(errorMessage);
            }
        }
    }
    return result;
}
exports.findProjectRootsByDependency = findProjectRootsByDependency;
/**
 * Get the main service name from the manifest.
 * LROP: by definition the service name can be read from the UI5 model with "" as name
 * OVP: the main model needs to be read from the sap.ovp config and then the service can be derived
 * @param manifest application manifest
 */
function getMainService(manifest) {
    const model = manifest['sap.ovp'] ? manifest['sap.ovp'].globalFilterModel : '';
    return manifest['sap.ui5'] && manifest['sap.ui5'].models && manifest['sap.ui5'].models[model]
        ? manifest['sap.ui5'].models[model].dataSource
        : undefined;
}
exports.getMainService = getMainService;
/**
 * Create the structure for one application
 * @param appFolder - relative folder to app in project. '' for single app projects
 * @param manifest - manifest content for app
 * @param sync - sync enabled?
 */
function createApplicationStructureConfig(appFolder, manifest, sync) {
    return {
        manifest: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.FileName.Manifest),
        changes: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.DirName.Changes),
        app: sync ? path_1.join(appFolder, project_spec_1.DirName.Sapux, project_spec_1.FileName.App) : undefined,
        i18n: getI18nPath(path_1.join(appFolder, project_spec_1.DirName.Webapp), manifest),
        mainService: getMainService(manifest),
        services: {},
        annotations: {},
        ext: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.DirName.Ext),
        controller: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.DirName.Ext, project_spec_1.DirName.Controller),
        view: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.DirName.Ext, project_spec_1.DirName.View),
        fragment: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.DirName.Ext, project_spec_1.DirName.Fragment)
    };
}
exports.createApplicationStructureConfig = createApplicationStructureConfig;
/**
 * Add the service related information for a specific app to a project
 * @param project - The project
 * @param appFolder - the appFolder for the app, which is the project relative path to the app
 * @param manifest - manifest for the app
 */
function fillServiceSpecificationForApp(project, appFolder, manifest) {
    var _a;
    const services = manifest['sap.app'].dataSources;
    for (const name in services) {
        if (services[name].type === project_spec_1.DataSourceType.OData) {
            project.apps[appFolder].services[name] = {
                uri: services[name].uri
            };
            const appServices = project.apps[appFolder].services;
            if (services[name].settings) {
                appServices[name].local = ((_a = services[name].settings) === null || _a === void 0 ? void 0 : _a.localUri) ? path_1.join(appFolder, project_spec_1.DirName.Webapp, services[name].settings.localUri)
                    : '';
                if (services[name].settings.annotations) {
                    project.apps[appFolder].annotations[name] = project.apps[appFolder].annotations[name] || [];
                    for (const id of services[name].settings.annotations) {
                        const annotation = services[id];
                        if (annotation) {
                            // Ensure that annotation datasource exists before accessing it
                            if (!annotation.uri ||
                                (annotation.settings && annotation.uri === annotation.settings.localUri)) {
                                project.apps[appFolder].annotations[name].push(path_1.join(appFolder, project_spec_1.DirName.Webapp, annotation.settings.localUri));
                            }
                            else {
                                appServices[name].annotations = {
                                    uri: annotation.uri,
                                    local: annotation.settings && annotation.settings.localUri
                                        ? path_1.join(appFolder, project_spec_1.DirName.Webapp, annotation.settings.localUri)
                                        : undefined
                                };
                                if (appServices[name].annotations.local) {
                                    // also add service ("backend") annotation files to expose sequence wrt local annotation files
                                    project.apps[appFolder].annotations[name].push(appServices[name].annotations.local);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
exports.fillServiceSpecificationForApp = fillServiceSpecificationForApp;
function getAppConfig(project, appId) {
    let errorMessage;
    if (appId === undefined) {
        const appIds = Object.keys(project.apps);
        if (appIds.length > 1) {
            errorMessage = i18n_1.i18n.t('ERROR_REQUIRED_APP');
            throw new Error(errorMessage);
        }
        else {
            return project.apps[appIds[0]];
        }
    }
    else {
        const app = project.apps[appId];
        if (!app) {
            errorMessage = i18n_1.i18n.t('ERROR_INVALID_APP_ID');
            throw new Error(errorMessage);
        }
        return app;
    }
}
exports.getAppConfig = getAppConfig;
/**
 * Read the contents of the app.json file and add the page configs if requested.
 * @param path path to app.json file
 * @param includePageConfigs if true, also read the pages/*.json files and merge them into the object
 */
async function readAppJson(path, includePageConfigs = true) {
    const app = await file_1.readJSON(path);
    if (includePageConfigs) {
        const pagesDirectory = path.replace(project_spec_1.FileName.App, project_spec_1.DirName.Pages);
        const pageFiles = await file_1.readDirectory(pagesDirectory);
        for (const file of pageFiles) {
            const id = file.replace('.json', '');
            if (app.pages[id]) {
                app.pages[id].config = await file_1.readJSON(path_1.join(pagesDirectory, file));
            }
        }
    }
    return app;
}
exports.readAppJson = readAppJson;
/**
 * Return path to i18n.properties file from manifest.
 * @param manifestFolder - path to folder that contains manifest.json
 * @param manifest - parsed content of manifest.json
 * @returns - path to i18n.properties file
 */
function getI18nPath(manifestFolder, manifest) {
    var _a, _b, _c, _d;
    let relativePath;
    if (typeof ((_c = (_b = (_a = manifest === null || manifest === void 0 ? void 0 : manifest['sap.ui5']) === null || _a === void 0 ? void 0 : _a.models) === null || _b === void 0 ? void 0 : _b['i18n']) === null || _c === void 0 ? void 0 : _c.uri) === 'string') {
        relativePath = manifest['sap.ui5'].models['i18n'].uri;
    }
    else if (typeof ((_d = manifest === null || manifest === void 0 ? void 0 : manifest['sap.app']) === null || _d === void 0 ? void 0 : _d.i18n) === 'string') {
        relativePath = manifest['sap.app'].i18n;
    }
    return relativePath ? path_1.join(manifestFolder, relativePath) : undefined;
}
exports.getI18nPath = getI18nPath;
/**
 * Method read i18n file and traverses each line of i18n file.
 * @param {string} path I18n file path.
 * @param {I18nFileTraverseCallback} fnCallback Callback method for i18n file traverse.
 * @return {Promise<string[]>} Promise to lines array.
 */
async function traverseI18nProperties(path, fnCallback) {
    const i18nFile = await file_1.readFile(path);
    const lines = i18nFile.split(/\r\n|\n/);
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!line.startsWith('#')) {
            const [key, value] = line.includes('=') ? line.split('=') : line.split(':');
            fnCallback(line, i, key ? key.trim() : key, value ? value.trim() : value);
        }
        else {
            fnCallback(line, i);
        }
    }
    return lines;
}
/**
 * Merge i18n properties
 * @param i18n i18n object
 * @param path path to a i18n properties file
 */
async function mergeI18nProperties(i18n, path) {
    await traverseI18nProperties(path, (line, index, key, value) => {
        if (key && value) {
            i18n[key] = value;
        }
    });
    return i18n;
}
exports.mergeI18nProperties = mergeI18nProperties;
/**
 * Read the i18n properties from the given location
 * @param path path to main i18n.properties file
 * @param locale optional localization
 */
async function getI18nProperties(path, locale) {
    let i18n = {};
    i18n = await mergeI18nProperties(i18n, path);
    if (locale) {
        i18n = await mergeI18nProperties(i18n, path.replace('i18n.', `i18n_${locale}.`));
    }
    return i18n;
}
exports.getI18nProperties = getI18nProperties;
/**
 * Method to update i18n file with new i18n entry or by updating existing i18n entry.
 * @param {string} path I18n file path.
 * @param {string} key New or existing i18n entry's key.
 * @param {string} value New value for i18n entry.
 * @param {string} [comment] Comment to insert on line before new i18n entry.
 * @return {Promise<void>} Promise to void.
 */
async function updateI18nProperty(path, key, value, comment) {
    await updateI18nProperties(path, [{ key, value, comment }]);
}
exports.updateI18nProperty = updateI18nProperty;
/**
 * Method to update i18n file with new i18n entries or by updating existing i18n entries.
 * @param {string} path I18n file path.
 * @param {Array<I18nEntry>} entries New or existing i18n entries.
 */
async function updateI18nProperties(path, entries) {
    if (entries.length === 0) {
        return;
    }
    const output = [];
    const updatedEntries = {};
    // Traverse i18n file and find if key already exists in i18n file
    const lines = await traverseI18nProperties(path, (line, index, keyTemp, valueTemp) => {
        const existingIndex = valueTemp !== undefined ? entries.findIndex((entry) => entry.key === keyTemp) : -1;
        if (existingIndex !== -1) {
            const { key, value } = entries[existingIndex];
            line = `${key}=${value}`;
            updatedEntries[existingIndex] = true;
        }
        output.push(line);
    });
    // check if file does not end with new line
    if (lines.length > 0 && lines[lines.length - 1].trim() && entries.length) {
        // If there no end line - add new gap line before new content
        output.push('');
    }
    for (const index in entries) {
        if (!updatedEntries[index]) {
            const { comment, key, value } = entries[index];
            // New i18n entry - add it at the end of file
            if (comment) {
                // Add comment only for new entry
                output.push(`#${comment}`);
            }
            output.push(`${key}=${value}${os_1.default.EOL}`);
        }
    }
    await file_1.updateFile(path, output.join(os_1.default.EOL));
}
exports.updateI18nProperties = updateI18nProperties;
/**
 * Method searches for i18n property.
 * @param {string} path I18n file path.
 * @param {string} key I18N entry's key to look up.
 * @return {Promise<I18nEntry | undefined>} Returns value and line number if i18n entry matches passed key.
 */
async function findI18nProperty(path, key) {
    let i18nProperty = undefined;
    // Search property by traversing i18n file
    await traverseI18nProperties(path, (line, index, keyTemp, value) => {
        if (key && value && key === keyTemp) {
            i18nProperty = {
                key,
                value,
                lineIndex: index
            };
        }
    });
    return i18nProperty;
}
exports.findI18nProperty = findI18nProperty;
/**
 * Returns the type of project: CAP (node.js and Java) or EDMX
 * @param root - root of the project
 * @param packageJson - the parsed content of package.json
 */
async function getProjectTypeFromProjectFiles(projectRoot, packageJson) {
    return (await ux_cds_1.isCapProject(projectRoot, packageJson)) ? "Cap" /* Cap */ : "Edmx" /* Edmx */;
}
exports.getProjectTypeFromProjectFiles = getProjectTypeFromProjectFiles;
/**
 * Returns whether the project is a CAP project
 * @param root - root of the project
 */
async function getProjectType(root) {
    const packageJson = await file_1.readJSON(path_1.join(root, project_spec_1.FileName.Package));
    const projectType = await getProjectTypeFromProjectFiles(root, packageJson);
    return projectType;
}
exports.getProjectType = getProjectType;
/**
 * Returns the version of Fiori elements (v2/v4) from a given manifest
 * @param manifest - the manifest.json file
 */
function getVersionFromManifest(manifest) {
    var _a, _b, _c, _d;
    if (manifest['sap.ui.generic.app'] || manifest['sap.ovp']) {
        return ux_specification_1.FioriElementsVersion.v2;
    }
    else if ((_b = (_a = manifest['sap.ui5']) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.targets) {
        let hasV4pPages = false;
        Object.keys((_d = (_c = manifest['sap.ui5']) === null || _c === void 0 ? void 0 : _c.routing) === null || _d === void 0 ? void 0 : _d.targets).forEach((target) => {
            var _a, _b, _c;
            if ((_c = ((_b = (_a = manifest['sap.ui5']) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.targets[target]).name) === null || _c === void 0 ? void 0 : _c.startsWith('sap.fe.templates.')) {
                hasV4pPages = true;
            }
        });
        if (hasV4pPages) {
            return ux_specification_1.FioriElementsVersion.v4;
        }
        else {
            return undefined;
        }
    }
    else {
        return ux_specification_1.FioriElementsVersion.v4;
    }
}
exports.getVersionFromManifest = getVersionFromManifest;
/**
 * Returns the ui5 middleware settings of a given Fiori elements project (v2 or v4)
 * @param root: string - path to the SAP UX project (where the ui5.yaml is)
 */
async function getUi5CustomMiddleware(root) {
    const yamlContent = await file_1.readFile(path_1.join(root, project_spec_1.FileName.Ui5Yaml));
    const middlewares = yaml.parse(yamlContent).server.customMiddleware;
    return middlewares.find((element) => element.name === 'fiori-tools-proxy');
}
exports.getUi5CustomMiddleware = getUi5CustomMiddleware;
/**
 * Returns the ui5version specified in the ui5-local.yaml
 * @param root: string - path to the SAP UX project (where the package.json is)
 */
async function getLocalUI5Version(root) {
    const yamlFile = path_1.join(root, project_spec_1.FileName.Ui5LocalYaml);
    if (await file_1.fileExists(yamlFile)) {
        const yamlContent = yaml.parse(await file_1.readFile(yamlFile));
        const ui5Version = yamlContent.framework && yamlContent.framework.version;
        return ui5Version;
    }
}
exports.getLocalUI5Version = getLocalUI5Version;
/**
 * Returns the ui5version specified in the ui5.yaml
 * @param root: string - path to the SAP UX project (where the package.json is)
 */
async function getUI5Version(root) {
    let ui5Version = 'latest';
    const yamlFile = path_1.join(root, 'ui5.yaml');
    if (await file_1.fileExists(yamlFile)) {
        const middlewareProxy = await getUi5CustomMiddleware(root);
        if (middlewareProxy && middlewareProxy.configuration && middlewareProxy.configuration.ui5) {
            ui5Version = middlewareProxy.configuration.ui5.version
                ? middlewareProxy.configuration.ui5.version
                : 'latest';
        }
    }
    return ui5Version;
}
exports.getUI5Version = getUI5Version;
/**
 * Checks if the config for the serve-local middleware is correct
 *
 * @param root: string - path to the SAP UX project (where the package.json is)
 */
async function checkServeLocalConfig(root) {
    const yamlFile = path_1.join(root, project_spec_1.FileName.Ui5LocalYaml);
    if (await file_1.fileExists(yamlFile)) {
        const yamlContent = yaml.parse(await file_1.readFile(yamlFile));
        const middlewares = yamlContent.server.customMiddleware;
        const serveLocal = middlewares.find((element) => element.name === 'fiori-tools-servestatic');
        if (serveLocal) {
            if (serveLocal.mountPath &&
                serveLocal.mountPath === '/resources|/test-resources' &&
                serveLocal.configuration &&
                serveLocal.configuration.path) {
                return true;
            }
        }
        return false;
    }
    return false;
}
exports.checkServeLocalConfig = checkServeLocalConfig;
/**
 * get the appId for a file path
 *
 * @param filepath
 * @param projecRoot
 * @param appIds
 */
function getAppIdForFile(filepath, projectRoot, appIds) {
    let appId = '';
    appIds.forEach((appIdTmp) => {
        const relativeStr = path_1.relative(path_1.join(projectRoot, appIdTmp), filepath);
        // based on https://stackoverflow.com/a/45242825
        if (relativeStr && !relativeStr.startsWith('..') && !path_1.isAbsolute(relativeStr)) {
            appId = appIdTmp;
        }
    });
    // appId = os.platform() === 'win32' ? appId.replace(/\\\\/g, '\\') : appId;
    appId = os_1.default.platform() === 'win32' ? appId.replace(/\/\//g, '/') : appId;
    return appId;
}
exports.getAppIdForFile = getAppIdForFile;
/**
 * Checks if the manifest contains a `sap.ovp` property.
 * @param manifest - an application manifest
 */
function isOVPProject(manifest) {
    return !!manifest['sap.ovp'];
}
exports.isOVPProject = isOVPProject;
/**
 * Delete application from CAP project
 * @param appPath - path to the application in a CAP project
 */
async function deleteCapApp(appPath, logger) {
    var _a;
    const appName = path_1.basename(appPath);
    const projectRoot = await findProjectRoot(appPath);
    const packageJsonPath = path_1.join(projectRoot, project_spec_1.FileName.Package);
    const packageJson = await file_1.readJSON(packageJsonPath);
    const cdsFilePaths = [path_1.join(path_1.dirname(appPath), project_spec_1.FileName.ServiceCds), path_1.join(path_1.dirname(appPath), project_spec_1.FileName.IndexCds)];
    if (!Array.isArray(packageJson.sapux)) {
        logger === null || logger === void 0 ? void 0 : logger.error(i18n_1.i18n.t('ERROR_DEL_CAP_APP_SAPUX', { packageJsonPath }));
        throw Error(i18n_1.i18n.t('ERROR_DEL_CAP_APP_SAPUX', { packageJsonPath }));
    }
    logger === null || logger === void 0 ? void 0 : logger.info(i18n_1.i18n.t('INFO_DEL_CAP_APP', { appName, projectRoot }));
    const posixAppPath = appPath.replace(/\\/g, '/');
    packageJson.sapux = packageJson.sapux.filter((a) => !posixAppPath.endsWith(a));
    if (packageJson.sapux.length === 0) {
        logger === null || logger === void 0 ? void 0 : logger.info(i18n_1.i18n.t('INFO_DEL_LAST_CAP_APP', { packageJsonPath }));
        delete packageJson.sapux;
    }
    if ((_a = packageJson.scripts) === null || _a === void 0 ? void 0 : _a[`watch-${appName}`]) {
        delete packageJson.scripts[`watch-${appName}`];
    }
    await file_1.updateJSON(packageJsonPath, packageJson);
    logger === null || logger === void 0 ? void 0 : logger.info(i18n_1.i18n.t('INFO_DEL_CAP_APP_FILE_UPDATED', { packageJsonPath }));
    await file_1.deleteDirectory(appPath);
    logger === null || logger === void 0 ? void 0 : logger.info(i18n_1.i18n.t('INFO_DEL_CAP_APP_DIR_DELETED', { appPath }));
    // Check app/service.cds and app/index.cds for using statements
    const usingEntry = `using from './${appName}/annotations';`;
    for (const cdsFilePath of cdsFilePaths) {
        if (await file_1.fileExists(cdsFilePath)) {
            try {
                let cdsFile = await file_1.readFile(cdsFilePath);
                if (cdsFile.indexOf(usingEntry) !== -1) {
                    logger === null || logger === void 0 ? void 0 : logger.info(i18n_1.i18n.t('INFO_DEL_CAP_APP_DELETE_USING', { appName, cdsFilePath }));
                    cdsFile = cdsFile.replace(usingEntry, '');
                    if (cdsFile.replace(/\n/g, '').trim() === '') {
                        logger === null || logger === void 0 ? void 0 : logger.info(i18n_1.i18n.t('INFO_DEL_CAP_APP_DEL_CDS', { cdsFilePath }));
                        await file_1.deleteFile(cdsFilePath);
                    }
                    else {
                        await file_1.updateFile(cdsFilePath, cdsFile);
                    }
                }
            }
            catch (error) {
                logger === null || logger === void 0 ? void 0 : logger.error(i18n_1.i18n.t('ERROR_DEL_CAP_APP_MODIFY_CDS', { cdsFilePath }));
            }
        }
    }
    // Check if app folder is now empty
    if ((await file_1.readDirectory(path_1.dirname(appPath))).length === 0) {
        logger === null || logger === void 0 ? void 0 : logger.info(i18n_1.i18n.t('INFO_DEL_CAP_APP_FOLDER_EMPTY', { appPath: path_1.dirname(appPath) }));
        await file_1.deleteDirectory(path_1.dirname(appPath));
    }
}
exports.deleteCapApp = deleteCapApp;
/**
 * Checks existance of possible CAP project mockdata directory path, returns existing or defaulty CAP mockdata dir path
 * CAP project possible mockdata directories - db/csv, db/data, or db/src/csv.
 * see https://cap.cloud.sap/docs/guides/databases#providing-initial-data
 * @param projectRoot - path to CAP project
 * @returns CAP project mockdata directory path
 */
function getCapMockdataDirPath(projectRoot) {
    const capMockdataDirPaths = [
        path_1.join(projectRoot, project_spec_1.DirName.Db, project_spec_1.DirName.Csv),
        path_1.join(projectRoot, project_spec_1.DirName.Db, project_spec_1.DirName.Sapux, project_spec_1.DirName.Csv)
    ];
    for (const path of capMockdataDirPaths) {
        if (fs_1.existsSync(path)) {
            return path;
        }
    }
    return path_1.join(projectRoot, project_spec_1.DirName.Db, project_spec_1.DirName.Data);
}
/**
 * Returns paths to Edmx app mockdata directory.
 * If app has ui5-mock.yaml config file that re-defines mockdata dir path, re-defined path being returned instead
 * @param projectRoot - path to application root
 * @returns - edmx application mockdata directory path
 */
async function getEdmxProjectMockdataDirPath(projectRoot) {
    var _a, _b, _c, _d;
    const ui5MockCfgPath = path_1.join(projectRoot, project_spec_1.FileName.Ui5MockYaml);
    // obtaining mockdata dir path from ui5-mock.yaml config, if file exists and mockdata path's defined
    if (fs_1.existsSync(ui5MockCfgPath)) {
        const ui5MockCfgContents = await file_1.readFile(ui5MockCfgPath);
        const middlewares = (_b = (_a = yaml.parse(ui5MockCfgContents)) === null || _a === void 0 ? void 0 : _a.server) === null || _b === void 0 ? void 0 : _b.customMiddleware;
        if (middlewares && middlewares.length) {
            const mockserverMiddleware = middlewares.find((element) => element.name === 'sap-fe-mockserver');
            if (mockserverMiddleware) {
                const cfgMockdataRootPath = (_d = (_c = mockserverMiddleware === null || mockserverMiddleware === void 0 ? void 0 : mockserverMiddleware.configuration) === null || _c === void 0 ? void 0 : _c.service) === null || _d === void 0 ? void 0 : _d.mockdataRootPath;
                if (cfgMockdataRootPath) {
                    return path_1.resolve(projectRoot, cfgMockdataRootPath);
                }
            }
        }
    }
    // edmx app defaulty mockdata dir path
    return path_1.join(projectRoot, project_spec_1.DirName.Webapp, project_spec_1.DirName.LocalService, project_spec_1.DirName.Mockdata);
}
/**
 * Returns mockdata directory path for received application root.
 * @param appRoot - application root path
 * @param type - application type
 * @returns - application mockdata directory path
 */
async function getMockdataDirPath(appRoot, type) {
    if (type === "Cap" /* Cap */) {
        return getCapMockdataDirPath(appRoot);
    }
    return getEdmxProjectMockdataDirPath(appRoot);
}
exports.getMockdataDirPath = getMockdataDirPath;


/***/ }),

/***/ 57657:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "URI": () => (/* binding */ URI)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _a;
var isWindows;
if (typeof process === 'object') {
    isWindows = process.platform === 'win32';
}
else if (typeof navigator === 'object') {
    var userAgent = navigator.userAgent;
    isWindows = userAgent.indexOf('Windows') >= 0;
}
function isHighSurrogate(charCode) {
    return (0xD800 <= charCode && charCode <= 0xDBFF);
}
function isLowSurrogate(charCode) {
    return (0xDC00 <= charCode && charCode <= 0xDFFF);
}
function isLowerAsciiHex(code) {
    return code >= 97 /* a */ && code <= 102 /* f */;
}
function isLowerAsciiLetter(code) {
    return code >= 97 /* a */ && code <= 122 /* z */;
}
function isUpperAsciiLetter(code) {
    return code >= 65 /* A */ && code <= 90 /* Z */;
}
function isAsciiLetter(code) {
    return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);
}
//#endregion
var _schemePattern = /^\w[\w\d+.-]*$/;
var _singleSlashStart = /^\//;
var _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
    // scheme, must be set
    if (!ret.scheme && _strict) {
        throw new Error("[UriError]: Scheme is missing: {scheme: \"\", authority: \"" + ret.authority + "\", path: \"" + ret.path + "\", query: \"" + ret.query + "\", fragment: \"" + ret.fragment + "\"}");
    }
    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
    // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
        throw new Error('[UriError]: Scheme contains illegal characters.');
    }
    // path, http://tools.ietf.org/html/rfc3986#section-3.3
    // If a URI contains an authority component, then the path component
    // must either be empty or begin with a slash ("/") character.  If a URI
    // does not contain an authority component, then the path cannot begin
    // with two slash characters ("//").
    if (ret.path) {
        if (ret.authority) {
            if (!_singleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            }
        }
        else {
            if (_doubleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
        }
    }
}
// for a while we allowed uris *without* schemes and this is the migration
// for them, e.g. an uri without scheme and without strict-mode warns and falls
// back to the file-scheme. that should cause the least carnage and still be a
// clear warning
function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
        return 'file';
    }
    return scheme;
}
// implements a bit of https://tools.ietf.org/html/rfc3986#section-5
function _referenceResolution(scheme, path) {
    // the slash-character is our 'default base' as we don't
    // support constructing URIs relative to other URIs. This
    // also means that we alter and potentially break paths.
    // see https://tools.ietf.org/html/rfc3986#section-5.1.4
    switch (scheme) {
        case 'https':
        case 'http':
        case 'file':
            if (!path) {
                path = _slash;
            }
            else if (path[0] !== _slash) {
                path = _slash + path;
            }
            break;
    }
    return path;
}
var _empty = '';
var _slash = '/';
var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 */
var URI = /** @class */ (function () {
    /**
     * @internal
     */
    function URI(schemeOrData, authority, path, query, fragment, _strict) {
        if (_strict === void 0) { _strict = false; }
        if (typeof schemeOrData === 'object') {
            this.scheme = schemeOrData.scheme || _empty;
            this.authority = schemeOrData.authority || _empty;
            this.path = schemeOrData.path || _empty;
            this.query = schemeOrData.query || _empty;
            this.fragment = schemeOrData.fragment || _empty;
            // no validation because it's this URI
            // that creates uri components.
            // _validateUri(this);
        }
        else {
            this.scheme = _schemeFix(schemeOrData, _strict);
            this.authority = authority || _empty;
            this.path = _referenceResolution(this.scheme, path || _empty);
            this.query = query || _empty;
            this.fragment = fragment || _empty;
            _validateUri(this, _strict);
        }
    }
    URI.isUri = function (thing) {
        if (thing instanceof URI) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.authority === 'string'
            && typeof thing.fragment === 'string'
            && typeof thing.path === 'string'
            && typeof thing.query === 'string'
            && typeof thing.scheme === 'string'
            && typeof thing.fsPath === 'function'
            && typeof thing.with === 'function'
            && typeof thing.toString === 'function';
    };
    Object.defineProperty(URI.prototype, "fsPath", {
        // ---- filesystem path -----------------------
        /**
         * Returns a string representing the corresponding file system path of this URI.
         * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
         * platform specific path separator.
         *
         * * Will *not* validate the path for invalid characters and semantics.
         * * Will *not* look at the scheme of this URI.
         * * The result shall *not* be used for display purposes but for accessing a file on disk.
         *
         *
         * The *difference* to `URI#path` is the use of the platform specific separator and the handling
         * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
         *
         * ```ts
            const u = URI.parse('file://server/c$/folder/file.txt')
            u.authority === 'server'
            u.path === '/shares/c$/file.txt'
            u.fsPath === '\\server\c$\folder\file.txt'
        ```
         *
         * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
         * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
         * with URIs that represent files on disk (`file` scheme).
         */
        get: function () {
            // if (this.scheme !== 'file') {
            // 	console.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);
            // }
            return _makeFsPath(this);
        },
        enumerable: true,
        configurable: true
    });
    // ---- modify to new -------------------------
    URI.prototype.with = function (change) {
        if (!change) {
            return this;
        }
        var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;
        if (scheme === undefined) {
            scheme = this.scheme;
        }
        else if (scheme === null) {
            scheme = _empty;
        }
        if (authority === undefined) {
            authority = this.authority;
        }
        else if (authority === null) {
            authority = _empty;
        }
        if (path === undefined) {
            path = this.path;
        }
        else if (path === null) {
            path = _empty;
        }
        if (query === undefined) {
            query = this.query;
        }
        else if (query === null) {
            query = _empty;
        }
        if (fragment === undefined) {
            fragment = this.fragment;
        }
        else if (fragment === null) {
            fragment = _empty;
        }
        if (scheme === this.scheme
            && authority === this.authority
            && path === this.path
            && query === this.query
            && fragment === this.fragment) {
            return this;
        }
        return new _URI(scheme, authority, path, query, fragment);
    };
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    URI.parse = function (value, _strict) {
        if (_strict === void 0) { _strict = false; }
        var match = _regexp.exec(value);
        if (!match) {
            return new _URI(_empty, _empty, _empty, _empty, _empty);
        }
        return new _URI(match[2] || _empty, decodeURIComponent(match[4] || _empty), decodeURIComponent(match[5] || _empty), decodeURIComponent(match[7] || _empty), decodeURIComponent(match[9] || _empty), _strict);
    };
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    URI.file = function (path) {
        var authority = _empty;
        // normalize to fwd-slashes on windows,
        // on other systems bwd-slashes are valid
        // filename character, eg /f\oo/ba\r.txt
        if (isWindows) {
            path = path.replace(/\\/g, _slash);
        }
        // check for authority as used in UNC shares
        // or use the path as given
        if (path[0] === _slash && path[1] === _slash) {
            var idx = path.indexOf(_slash, 2);
            if (idx === -1) {
                authority = path.substring(2);
                path = _slash;
            }
            else {
                authority = path.substring(2, idx);
                path = path.substring(idx) || _slash;
            }
        }
        return new _URI('file', authority, path, _empty, _empty);
    };
    URI.from = function (components) {
        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
    };
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    URI.prototype.toString = function (skipEncoding) {
        if (skipEncoding === void 0) { skipEncoding = false; }
        return _asFormatted(this, skipEncoding);
    };
    URI.prototype.toJSON = function () {
        return this;
    };
    URI.revive = function (data) {
        if (!data) {
            return data;
        }
        else if (data instanceof URI) {
            return data;
        }
        else {
            var result = new _URI(data);
            result._formatted = data.external;
            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
            return result;
        }
    };
    return URI;
}());

var _pathSepMarker = isWindows ? 1 : undefined;
// tslint:disable-next-line:class-name
var _URI = /** @class */ (function (_super) {
    __extends(_URI, _super);
    function _URI() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._formatted = null;
        _this._fsPath = null;
        return _this;
    }
    Object.defineProperty(_URI.prototype, "fsPath", {
        get: function () {
            if (!this._fsPath) {
                this._fsPath = _makeFsPath(this);
            }
            return this._fsPath;
        },
        enumerable: true,
        configurable: true
    });
    _URI.prototype.toString = function (skipEncoding) {
        if (skipEncoding === void 0) { skipEncoding = false; }
        if (!skipEncoding) {
            if (!this._formatted) {
                this._formatted = _asFormatted(this, false);
            }
            return this._formatted;
        }
        else {
            // we don't cache that
            return _asFormatted(this, true);
        }
    };
    _URI.prototype.toJSON = function () {
        var res = {
            $mid: 1
        };
        // cached state
        if (this._fsPath) {
            res.fsPath = this._fsPath;
            res._sep = _pathSepMarker;
        }
        if (this._formatted) {
            res.external = this._formatted;
        }
        // uri components
        if (this.path) {
            res.path = this.path;
        }
        if (this.scheme) {
            res.scheme = this.scheme;
        }
        if (this.authority) {
            res.authority = this.authority;
        }
        if (this.query) {
            res.query = this.query;
        }
        if (this.fragment) {
            res.fragment = this.fragment;
        }
        return res;
    };
    return _URI;
}(URI));
// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2
var encodeTable = (_a = {},
    _a[58 /* Colon */] = '%3A',
    _a[47 /* Slash */] = '%2F',
    _a[63 /* QuestionMark */] = '%3F',
    _a[35 /* Hash */] = '%23',
    _a[91 /* OpenSquareBracket */] = '%5B',
    _a[93 /* CloseSquareBracket */] = '%5D',
    _a[64 /* AtSign */] = '%40',
    _a[33 /* ExclamationMark */] = '%21',
    _a[36 /* DollarSign */] = '%24',
    _a[38 /* Ampersand */] = '%26',
    _a[39 /* SingleQuote */] = '%27',
    _a[40 /* OpenParen */] = '%28',
    _a[41 /* CloseParen */] = '%29',
    _a[42 /* Asterisk */] = '%2A',
    _a[43 /* Plus */] = '%2B',
    _a[44 /* Comma */] = '%2C',
    _a[59 /* Semicolon */] = '%3B',
    _a[61 /* Equals */] = '%3D',
    _a[32 /* Space */] = '%20',
    _a);
function encodeURIComponentFast(uriComponent, allowSlash) {
    var res = undefined;
    var nativeEncodePos = -1;
    for (var pos = 0; pos < uriComponent.length; pos++) {
        var code = uriComponent.charCodeAt(pos);
        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3
        if ((code >= 97 /* a */ && code <= 122 /* z */)
            || (code >= 65 /* A */ && code <= 90 /* Z */)
            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)
            || code === 45 /* Dash */
            || code === 46 /* Period */
            || code === 95 /* Underline */
            || code === 126 /* Tilde */
            || (allowSlash && code === 47 /* Slash */)) {
            // check if we are delaying native encode
            if (nativeEncodePos !== -1) {
                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                nativeEncodePos = -1;
            }
            // check if we write into a new string (by default we try to return the param)
            if (res !== undefined) {
                res += uriComponent.charAt(pos);
            }
        }
        else {
            // encoding needed, we need to allocate a new string
            if (res === undefined) {
                res = uriComponent.substr(0, pos);
            }
            // check with default table first
            var escaped = encodeTable[code];
            if (escaped !== undefined) {
                // check if we are delaying native encode
                if (nativeEncodePos !== -1) {
                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                    nativeEncodePos = -1;
                }
                // append escaped variant to result
                res += escaped;
            }
            else if (nativeEncodePos === -1) {
                // use native encode only when needed
                nativeEncodePos = pos;
            }
        }
    }
    if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== undefined ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
    var res = undefined;
    for (var pos = 0; pos < path.length; pos++) {
        var code = path.charCodeAt(pos);
        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {
            if (res === undefined) {
                res = path.substr(0, pos);
            }
            res += encodeTable[code];
        }
        else {
            if (res !== undefined) {
                res += path[pos];
            }
        }
    }
    return res !== undefined ? res : path;
}
/**
 * Compute `fsPath` for the given uri
 */
function _makeFsPath(uri) {
    var value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
        // unc path: file://shares/c$/far/boo
        value = "//" + uri.authority + uri.path;
    }
    else if (uri.path.charCodeAt(0) === 47 /* Slash */
        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)
        && uri.path.charCodeAt(2) === 58 /* Colon */) {
        // windows drive letter: file:///c:/far/boo
        value = uri.path[1].toLowerCase() + uri.path.substr(2);
    }
    else {
        // other path
        value = uri.path;
    }
    if (isWindows) {
        value = value.replace(/\//g, '\\');
    }
    return value;
}
/**
 * Create the external version of a uri
 */
function _asFormatted(uri, skipEncoding) {
    var encoder = !skipEncoding
        ? encodeURIComponentFast
        : encodeURIComponentMinimal;
    var res = '';
    var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;
    if (scheme) {
        res += scheme;
        res += ':';
    }
    if (authority || scheme === 'file') {
        res += _slash;
        res += _slash;
    }
    if (authority) {
        var idx = authority.indexOf('@');
        if (idx !== -1) {
            // <user>@<auth>
            var userinfo = authority.substr(0, idx);
            authority = authority.substr(idx + 1);
            idx = userinfo.indexOf(':');
            if (idx === -1) {
                res += encoder(userinfo, false);
            }
            else {
                // <user>:<pass>@<auth>
                res += encoder(userinfo.substr(0, idx), false);
                res += ':';
                res += encoder(userinfo.substr(idx + 1), false);
            }
            res += '@';
        }
        authority = authority.toLowerCase();
        idx = authority.indexOf(':');
        if (idx === -1) {
            res += encoder(authority, false);
        }
        else {
            // <auth>:<port>
            res += encoder(authority.substr(0, idx), false);
            res += authority.substr(idx);
        }
    }
    if (path) {
        // lower-case windows drive letters in /C:/fff or C:/fff
        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {
            var code = path.charCodeAt(1);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = "/" + String.fromCharCode(code + 32) + ":" + path.substr(3); // "/c:".length === 3
            }
        }
        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {
            var code = path.charCodeAt(0);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = String.fromCharCode(code + 32) + ":" + path.substr(2); // "/c:".length === 3
            }
        }
        // encode the rest of the path
        res += encoder(path, true);
    }
    if (query) {
        res += '?';
        res += encoder(query, false);
    }
    if (fragment) {
        res += '#';
        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
    }
    return res;
}


/***/ }),

/***/ 4585:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var FioriElementsVersion;
(function (FioriElementsVersion) {
    FioriElementsVersion["v2"] = "v2";
    FioriElementsVersion["v4"] = "v4";
})(FioriElementsVersion = exports.FioriElementsVersion || (exports.FioriElementsVersion = {}));
var OdataVersion;
(function (OdataVersion) {
    OdataVersion["v2"] = "v2";
    OdataVersion["v4"] = "v4";
})(OdataVersion = exports.OdataVersion || (exports.OdataVersion = {}));
var PageHeaderType;
(function (PageHeaderType) {
    PageHeaderType["Dynamic"] = "Dynamic";
})(PageHeaderType = exports.PageHeaderType || (exports.PageHeaderType = {}));
var RootIntent;
(function (RootIntent) {
    RootIntent["listReportV2"] = "masterDetail-display";
    RootIntent["listReportV4"] = "fe-lrop-v4";
    RootIntent["ovp"] = "OVP-display";
})(RootIntent = exports.RootIntent || (exports.RootIntent = {}));
var AppType;
(function (AppType) {
    AppType["FioriElement"] = "SAP Fiori elements";
    AppType["UI5Freestyle"] = "SAPUI5 freestyle";
})(AppType = exports.AppType || (exports.AppType = {}));


/***/ }),

/***/ 69681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const os_1 = __webpack_require__(22037);
const path_1 = __webpack_require__(71017);
var DirName;
(function (DirName) {
    DirName["Sapux"] = "src";
    DirName["Schemas"] = ".schemas";
    DirName["Pages"] = "pages";
    DirName["Webapp"] = "webapp";
    DirName["Temp"] = ".tmp";
    DirName["Changes"] = "changes";
    DirName["LocalService"] = "localService";
    DirName["Controller"] = "controller";
    DirName["View"] = "view";
    DirName["Fragment"] = "fragment";
    DirName["Ext"] = "ext";
    DirName["VSCode"] = ".vscode";
    DirName["AppConfig"] = "appconfig";
    DirName["Db"] = "db";
    DirName["Csv"] = "csv";
    DirName["Data"] = "data";
    DirName["Mockdata"] = "mockdata";
})(DirName = exports.DirName || (exports.DirName = {}));
var FileName;
(function (FileName) {
    FileName["Manifest"] = "manifest.json";
    FileName["App"] = "app.json";
    FileName["Package"] = "package.json";
    FileName["ServiceMetadata"] = "metadata.xml";
    FileName["NeoApp"] = "neo-app.json";
    FileName["Pom"] = "pom.xml";
    FileName["Fragment"] = "fragment.xml";
    FileName["LaunchConfig"] = "launch.json";
    FileName["ServiceCds"] = "services.cds";
    FileName["IndexCds"] = "index.cds";
    FileName["Ui5Yaml"] = "ui5.yaml";
    FileName["Ui5LocalYaml"] = "ui5-local.yaml";
    FileName["Ui5MockYaml"] = "ui5-mock.yaml";
    FileName["fioriSandboxConfig"] = "fioriSandboxConfig.json";
    FileName["View"] = "view.xml";
})(FileName = exports.FileName || (exports.FileName = {}));
var FioriToolsSettings;
(function (FioriToolsSettings) {
    FioriToolsSettings["dir"] = ".fioritools";
    FioriToolsSettings["migrationSettingsFile"] = "migrationSettings.json";
})(FioriToolsSettings = exports.FioriToolsSettings || (exports.FioriToolsSettings = {}));
exports.getFioriToolsDirectory = () => {
    return path_1.join(os_1.homedir(), FioriToolsSettings.dir);
};
var SchemeName;
(function (SchemeName) {
    SchemeName["Ftfs"] = "ftfs";
})(SchemeName = exports.SchemeName || (exports.SchemeName = {}));


/***/ }),

/***/ 67080:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(29638));


/***/ }),

/***/ 29638:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var HAlign;
(function (HAlign) {
    HAlign["initial"] = "Initial";
    HAlign["left"] = "Left";
    HAlign["center"] = "Center";
    HAlign["right"] = "Right";
    HAlign["begin"] = "Begin";
    HAlign["end"] = "End";
})(HAlign = exports.HAlign || (exports.HAlign = {}));
var TableMode;
(function (TableMode) {
    TableMode["None"] = "None";
    TableMode["SingleSelect"] = "SingleSelect";
    TableMode["SingleSelectLeft"] = "SingleSelectLeft";
    TableMode["SingleSelectMaster"] = "SingleSelectMaster";
    TableMode["MultiSelect"] = "MultiSelect";
    TableMode["Delete"] = "Delete";
})(TableMode = exports.TableMode || (exports.TableMode = {}));


/***/ }),

/***/ 72194:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(4585));
__export(__webpack_require__(67080));
__export(__webpack_require__(61144));
__export(__webpack_require__(37413));
__export(__webpack_require__(69681));
__export(__webpack_require__(68858));
__export(__webpack_require__(54688));
exports.location = () => {
    // While generating schemas we use location (file path as string) to reference this lib. For Windows we need to change from single backslash to forward slash
    return __dirname.replace(/\\/g, '/');
};


/***/ }),

/***/ 68858:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var UI5FlexLayer;
(function (UI5FlexLayer) {
    UI5FlexLayer["VENDOR"] = "VENDOR";
    UI5FlexLayer["CUSTOMER_BASE"] = "CUSTOMER_BASE";
})(UI5FlexLayer = exports.UI5FlexLayer || (exports.UI5FlexLayer = {}));


/***/ }),

/***/ 61144:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(39070));


/***/ }),

/***/ 39070:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var PageType;
(function (PageType) {
    PageType["ObjectPage"] = "ObjectPage";
    PageType["ListReport"] = "ListReport";
    PageType["OverviewPage"] = "OverviewPage";
    PageType["CustomPage"] = "CustomPage";
    PageType["AnalyticalListPage"] = "AnalyticalListPage";
})(PageType = exports.PageType || (exports.PageType = {}));


/***/ }),

/***/ 54688:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ProjectType;
(function (ProjectType) {
    ProjectType["Cap"] = "Cap";
    ProjectType["Edmx"] = "Edmx";
})(ProjectType = exports.ProjectType || (exports.ProjectType = {}));
var DetailedProjectType;
(function (DetailedProjectType) {
    DetailedProjectType["Edxm"] = "EDMX Backend";
    DetailedProjectType["CAPNode"] = "CAP Node.js";
    DetailedProjectType["CAPJava"] = "CAP Java";
})(DetailedProjectType = exports.DetailedProjectType || (exports.DetailedProjectType = {}));


/***/ }),

/***/ 37413:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(33803));


/***/ }),

/***/ 33803:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(91225));
var DataSourceType;
(function (DataSourceType) {
    DataSourceType["OData"] = "OData";
    DataSourceType["ODataAnnotation"] = "ODataAnnotation";
})(DataSourceType = exports.DataSourceType || (exports.DataSourceType = {}));


/***/ }),

/***/ 91225:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FIORI_FCL_ROUTER_CLASS = 'sap.f.routing.Router';
exports.FIORI_FCL_ROOT_VIEW_NAME = 'sap.fe.templates.RootContainer.view.Fcl';
exports.FIORI_FCL_ROOT_ID = 'appRootView';
var FlexibleColumnLayoutAggregations;
(function (FlexibleColumnLayoutAggregations) {
    FlexibleColumnLayoutAggregations["BeginColumnPages"] = "beginColumnPages";
    FlexibleColumnLayoutAggregations["MidColumnPages"] = "midColumnPages";
    FlexibleColumnLayoutAggregations["EndColumnPages"] = "endColumnPages";
})(FlexibleColumnLayoutAggregations = exports.FlexibleColumnLayoutAggregations || (exports.FlexibleColumnLayoutAggregations = {}));
// Values copy/pasted from 'sap/f/library' sources
var FlexibleColumnLayoutType;
(function (FlexibleColumnLayoutType) {
    FlexibleColumnLayoutType["OneColumn"] = "OneColumn";
    FlexibleColumnLayoutType["TwoColumnsBeginExpanded"] = "TwoColumnsBeginExpanded";
    FlexibleColumnLayoutType["TwoColumnsMidExpanded"] = "TwoColumnsMidExpanded";
    FlexibleColumnLayoutType["MidColumnFullScreen"] = "MidColumnFullScreen";
    FlexibleColumnLayoutType["ThreeColumnsMidExpanded"] = "ThreeColumnsMidExpanded";
    FlexibleColumnLayoutType["ThreeColumnsEndExpanded"] = "ThreeColumnsEndExpanded";
    FlexibleColumnLayoutType["ThreeColumnsMidExpandedEndHidden"] = "ThreeColumnsMidExpandedEndHidden";
    FlexibleColumnLayoutType["ThreeColumnsBeginExpandedEndHidden"] = "ThreeColumnsBeginExpandedEndHidden";
    FlexibleColumnLayoutType["EndColumnFullScreen"] = "EndColumnFullScreen";
})(FlexibleColumnLayoutType = exports.FlexibleColumnLayoutType || (exports.FlexibleColumnLayoutType = {}));
var ViewTypes;
(function (ViewTypes) {
    ViewTypes["XML"] = "XML";
    ViewTypes["HTML"] = "HTML";
    ViewTypes["JS"] = "JS";
    ViewTypes["JSON"] = "JSON";
})(ViewTypes = exports.ViewTypes || (exports.ViewTypes = {}));


/***/ }),

/***/ 82119:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ServiceName;
(function (ServiceName) {
    ServiceName["OldSystemService"] = "fiori/system/info";
    ServiceName["OldRefreshTokenService"] = "fiori/system/refreshToken";
    ServiceName["ApiHub"] = "fiori/system/apiHub";
})(ServiceName = exports.ServiceName || (exports.ServiceName = {}));
var Entity;
(function (Entity) {
    Entity["BackendSystem"] = "system";
})(Entity = exports.Entity || (exports.Entity = {}));


/***/ }),

/***/ 41608:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const path_1 = __importStar(__webpack_require__(71017));
const fs_1 = __webpack_require__(57147);
const pluralize_1 = __webpack_require__(61053);
const ux_common_utils_1 = __webpack_require__(59859);
exports.basedir = ux_common_utils_1.getFioriToolsDirectory;
exports.FilesystemStore = class {
    constructor(logger) {
        this.logger = logger;
    }
    async read({ entityName, id }) {
        const name = toPersistenceName(entityName);
        if (!name) {
            this.logger.debug('read: Entity Type is falsy - ' + entityName);
            return Promise.resolve(undefined);
        }
        const { entities, error } = this._readAll(name);
        if (error) {
            if (error.code === 'ENOENT') {
                return Promise.resolve(undefined);
            }
            else {
                throw error;
            }
        }
        if (!entities) {
            this.logger.debug(`read: After parsing, entities is falsy. Entity: ${name}, parsed value: ${entities}`);
            return undefined;
        }
        return Promise.resolve(entities[id]);
    }
    async getAll({ entityName }) {
        const name = toPersistenceName(entityName);
        if (!name) {
            this.logger.debug('read: Entity Type is falsy - ' + entityName);
            return Promise.resolve([]);
        }
        const { entities, error } = this._readAll(name);
        if (error) {
            if (error.code === 'ENOENT') {
                return Promise.resolve([]);
            }
            else {
                throw error;
            }
        }
        if (!entities) {
            this.logger.debug(`read: After parsing, entities is falsy. Entity: ${name}, parsed value: ${entities}`);
            return Promise.resolve([]);
        }
        return Promise.resolve(Object.values(entities));
    }
    async readAll({ entityName }) {
        const name = toPersistenceName(entityName);
        if (!name) {
            this.logger.debug('read: Entity Type is falsy - ' + entityName);
            return Promise.resolve({});
        }
        const { entities, error } = this._readAll(name);
        if (error) {
            if (error.code === 'ENOENT') {
                return Promise.resolve({});
            }
            else {
                throw error;
            }
        }
        if (!entities) {
            this.logger.debug(`read: After parsing, entities is falsy. Entity: ${name}, parsed value: ${entities}`);
            return Promise.resolve({});
        }
        return Promise.resolve(entities);
    }
    async write({ entityName, id, entity }) {
        const name = toPersistenceName(entityName);
        if (!name) {
            this.logger.debug('write: Entity is falsy - ' + name);
            return Promise.resolve(undefined);
        }
        const { entities = {}, error } = this._readAll(name);
        if (error && error.code !== 'ENOENT') {
            throw error;
        }
        entities[id] = entity;
        this.writeToFile(name, entities);
        return Promise.resolve(entity);
    }
    async del({ entityName, id }) {
        const name = toPersistenceName(entityName);
        if (!name) {
            this.logger.debug('delete: Entity is falsy - ' + name);
            return Promise.resolve(false);
        }
        const { entities = {}, error } = this._readAll(name);
        if (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
        }
        const exists = !!entities[id];
        if (exists) {
            this.logger.debug(`delete: entity found  for id - ${id}. Deleting`);
            delete entities[id];
            this.writeToFile(name, entities);
            return Promise.resolve(true);
        }
        else {
            this.logger.debug('delete: entity not found');
            return Promise.resolve(false);
        }
    }
    _readAll(entityName) {
        var _a, _b;
        let rawContents;
        try {
            rawContents = (_a = fs_1.readFileSync(path_1.join(exports.basedir(), `${entityName}.json`))) === null || _a === void 0 ? void 0 : _a.toString().trim();
        }
        catch (e) {
            this.logger.debug(e.message);
            return { error: e };
        }
        if (!rawContents) {
            return { entities: undefined };
        }
        let entities = undefined;
        try {
            entities = (_b = JSON.parse(rawContents)) === null || _b === void 0 ? void 0 : _b[entityName];
        }
        catch (e) {
            return { error: e };
        }
        return { entities };
    }
    writeToFile(entityName, entities) {
        const base = exports.basedir();
        const data = JSON.stringify({ [entityName]: entities }, null, 2);
        const filename = getEntityFileName(entityName);
        try {
            fs_1.writeFileSync(path_1.default.join(base, filename), data);
        }
        catch (e) {
            if (e.code === 'ENOENT') {
                this.logger.debug(`Base directory [${base}] does not exist, trying to create it`);
                fs_1.mkdirSync(base, { recursive: true });
                fs_1.writeFileSync(path_1.default.join(base, filename), data);
            }
            else {
                throw e;
            }
        }
    }
};
/**
 * Trims, lowercases and returns plural if a non-empty string
 * @param s
 */
function toPersistenceName(s) {
    const t = s === null || s === void 0 ? void 0 : s.trim().toLowerCase();
    return t && pluralize_1.plural(t);
}
function getEntityFileName(entityName) {
    return toPersistenceName(entityName) + '.json';
}
/** Return an FSWatcher for a given entity name
 *  The client is responsible for disposing of the FSWatcher
 */
function getFilesystemWatcherFor(entityName, callback) {
    const watchPath = path_1.default.join(exports.basedir(), getEntityFileName(entityName));
    if (fs_1.existsSync(watchPath)) {
        return fs_1.watch(watchPath, undefined, () => {
            callback(entityName);
        });
    }
    else {
        // this.logger is only valid in the constructed class
        console.warn(`File Not Found: ${watchPath}`);
    }
}
exports.getFilesystemWatcherFor = getFilesystemWatcherFor;


/***/ }),

/***/ 58850:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const filesystem_1 = __webpack_require__(41608);
const utils_1 = __webpack_require__(75553);
const secure_store_1 = __webpack_require__(78238);
const decorators_1 = __webpack_require__(8114);
function getFullyQualifiedServiceName(name) {
    return 'fiori/v2/' + name;
}
/** A hybrid store
 * Stores serializable properties on the filesystem
 * The properties need to be decorated with `@serilizable` annotations
 *
 * Sensitive properties (decorated with `@sensitiveData`) will be stored
 * in the system's secure store
 */
exports.HybridStore = class {
    constructor(logger) {
        this.logger = logger;
        this.filesystem = new filesystem_1.FilesystemStore(this.logger);
        this.secureStore = secure_store_1.getSecureStore(this.logger);
    }
    async read({ entityName, id }) {
        const serialized = await this.filesystem.read({ entityName, id });
        if (!serialized) {
            this.logger.debug(`hybrid/read - id: [${id}], nothing on the filesystem`);
        }
        else {
            this.logger.debug('hybrid/read - id: [%s], filesystem: %O', id, serialized);
        }
        const sensitiveData = await this.secureStore.retrieve(getFullyQualifiedServiceName(entityName), id);
        if (!sensitiveData) {
            this.logger.debug(`hybrid/read - id: [${id}], nothing in the secure store`);
        }
        else {
            this.logger.debug(`hybrid/read - id: [${id}]. Found sensitive data in secure store`);
        }
        if (serialized || sensitiveData) {
            // Make sure sensitive props override serialized ones
            return { ...serialized, ...sensitiveData };
        }
        else {
            return undefined;
        }
    }
    async getAll({ entityName }) {
        return Object.values(await this.readAll({ entityName }));
    }
    async readAll({ entityName }) {
        const result = {};
        const entitiesFs = (await this.filesystem.readAll({ entityName })) || {};
        const entitiesInSecureStore = (await this.secureStore.getAll(getFullyQualifiedServiceName(entityName))) || {};
        for (const key of new Set([...Object.keys(entitiesFs), ...Object.keys(entitiesInSecureStore)])) {
            // Make sure sensitive props override serialized ones
            const entity = { ...entitiesFs[key], ...entitiesInSecureStore[key] };
            result[key] = entity;
        }
        return result;
    }
    async write({ entityName, id, entity }) {
        const serializableProps = decorators_1.getSerializableProperties(entity);
        const sensitiveProps = decorators_1.getSensitiveDataProperties(entity);
        if (serializableProps.length > 0 && sensitiveProps.length > 0) {
            for (let i = 0; i < serializableProps.length; i = i + 1) {
                if (sensitiveProps.indexOf(serializableProps[i]) !== -1) {
                    this.logger.debug(`hybrid/write - [${serializableProps[i]}] is also marked as sensitive. Not writing to filesystem`);
                    serializableProps.splice(i, 1);
                }
            }
        }
        const serializable = utils_1.pick(entity, ...serializableProps);
        if (serializable) {
            this.logger.debug('hybrid/write - writing serializable properties: %O', serializable);
            await this.filesystem.write({ entityName, id, entity: serializable });
        }
        else {
            this.logger.debug('hybrid/write - no serializable properties found in %O', serializable);
        }
        const sensitiveData = utils_1.pick(entity, ...sensitiveProps);
        if (sensitiveData) {
            this.logger.debug(`hybrid/write - writing sensitive properties to secure store. ID: [${id}]`);
            await this.secureStore.save(getFullyQualifiedServiceName(entityName), id, sensitiveData);
        }
        else {
            this.logger.debug('hybrid/write - no sensitive properties found in %O', entity);
        }
        return entity;
    }
    async del({ entityName, id }) {
        const deletedinFs = await this.filesystem.del({ entityName, id });
        this.logger.debug(`hybrid/del - delete result for id [${id}] on the filesystem: ${deletedinFs}`);
        const deletedInSecureStore = await this.secureStore.delete(getFullyQualifiedServiceName(entityName), id);
        this.logger.debug(`hybrid/del - delete result for id [${id}] in the secure store: ${deletedInSecureStore}`);
        return deletedinFs || deletedInSecureStore;
    }
};


/***/ }),

/***/ 99696:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var filesystem_1 = __webpack_require__(41608);
exports.getFilesystemWatcherFor = filesystem_1.getFilesystemWatcherFor;


/***/ }),

/***/ 66747:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const hybrid_1 = __webpack_require__(58850);
const backend_system_1 = __webpack_require__(87225);
const constants_1 = __webpack_require__(76229);
exports.SystemDataProvider = class {
    constructor(logger) {
        this.entityName = constants_1.Entities.BackendSystem;
        this.logger = logger;
        this.dataAccessor = new hybrid_1.HybridStore(this.logger);
    }
    async read(key) {
        return this.dataAccessor.read({ entityName: this.entityName, id: key.getId() });
    }
    async write(entity) {
        let e;
        if (!(entity instanceof backend_system_1.BackendSystem)) {
            // We need to use the correct class otherwise the annotations are not effective
            e = new backend_system_1.BackendSystem({ ...entity });
        }
        else {
            e = entity;
        }
        return this.dataAccessor.write({
            entityName: this.entityName,
            id: backend_system_1.BackendSystemKey.from(entity).getId(),
            entity: e
        });
    }
    async delete(entity) {
        return this.dataAccessor.del({
            entityName: this.entityName,
            id: backend_system_1.BackendSystemKey.from(entity).getId()
        });
    }
    async getAll() {
        var _a;
        const systems = await this.dataAccessor.readAll({ entityName: this.entityName });
        for (const id of Object.keys(systems)) {
            const system = systems[id];
            if (!((_a = system === null || system === void 0 ? void 0 : system.url) === null || _a === void 0 ? void 0 : _a.trim())) {
                this.logger.warn(`Filtering system with ID [${id}] as it seems corrupt. Run repair`);
                delete systems[id];
            }
        }
        return Object.values(systems);
    }
};


/***/ }),

/***/ 76229:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Entities;
(function (Entities) {
    Entities["BackendSystem"] = "system";
    Entities["SystemMigrationStatus"] = "systemMigrationStatus";
})(Entities = exports.Entities || (exports.Entities = {}));


/***/ }),

/***/ 48661:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const filesystem_1 = __webpack_require__(41608);
const system_migration_status_1 = __webpack_require__(80878);
const constants_1 = __webpack_require__(76229);
exports.SystemMigrationStatusDataProvider = class {
    constructor(logger) {
        this.entityName = constants_1.Entities.SystemMigrationStatus;
        this.logger = logger;
        this.dataAccessor = new filesystem_1.FilesystemStore(this.logger);
    }
    read(key) {
        return this.dataAccessor.read({ entityName: this.entityName, id: key.getId() });
    }
    write(entity) {
        return this.dataAccessor.write({
            entityName: this.entityName,
            id: new system_migration_status_1.SystemMigrationStatusKey().getId(),
            entity
        });
    }
    delete(_entity) {
        return this.dataAccessor.del({
            entityName: this.entityName,
            id: new system_migration_status_1.SystemMigrationStatusKey().getId()
        });
    }
    getAll() {
        return this.dataAccessor.getAll({ entityName: this.entityName });
    }
};


/***/ }),

/***/ 8114:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
__webpack_require__(92775);
const SERIALIZABLE = Symbol('serializable');
function serializable(target, key) {
    const serializableProperties = Reflect.getOwnMetadata(SERIALIZABLE, target.constructor) || new Set();
    Reflect.defineMetadata(SERIALIZABLE, serializableProperties.add(key), target.constructor);
}
exports.serializable = serializable;
function getSerializableProperties(target) {
    const props = Reflect.getOwnMetadata(SERIALIZABLE, target.constructor);
    return (props && Array.from(props.values())) || [];
}
exports.getSerializableProperties = getSerializableProperties;
const SENSITIVE = Symbol('sensitive');
function sensitiveData(target, key) {
    const sensitiveProperties = Reflect.getOwnMetadata(SENSITIVE, target.constructor) || new Set();
    Reflect.defineMetadata(SENSITIVE, sensitiveProperties.add(key), target.constructor);
}
exports.sensitiveData = sensitiveData;
function getSensitiveDataProperties(target) {
    const props = Reflect.getOwnMetadata(SENSITIVE, target.constructor);
    return (props && Array.from(props.values())) || [];
}
exports.getSensitiveDataProperties = getSensitiveDataProperties;


/***/ }),

/***/ 87225:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const decorators_1 = __webpack_require__(8114);
var AuthenticationType;
(function (AuthenticationType) {
    AuthenticationType["Basic"] = "basic";
    AuthenticationType["ReentranceTicket"] = "reentranceTicket";
    AuthenticationType["OAuth2RefreshToken"] = "oauth2";
    AuthenticationType["OAuth2ClientCredential"] = "oauth2ClientCredential";
})(AuthenticationType = exports.AuthenticationType || (exports.AuthenticationType = {}));
class BackendSystemKey {
    constructor({ url, client }) {
        this.url = url.trim().replace(/\/$/, '');
        this.client = client === null || client === void 0 ? void 0 : client.trim();
    }
    static from(system) {
        return new BackendSystemKey({ url: system.url, client: system.client });
    }
    getId() {
        return this.url + `${this.client ? '/' + this.client : ''}`;
    }
}
exports.BackendSystemKey = BackendSystemKey;
class BackendSystem {
    constructor({ name, url, client, serviceKeys, refreshToken, username, password, userDisplayName, authenticationType }) {
        this.name = name;
        this.url = url;
        this.client = client;
        this.serviceKeys = serviceKeys;
        this.refreshToken = refreshToken;
        this.username = username;
        this.password = password;
        this.userDisplayName = userDisplayName;
        this.authenticationType = authenticationType;
    }
}
__decorate([
    decorators_1.serializable
], BackendSystem.prototype, "name", void 0);
__decorate([
    decorators_1.serializable
], BackendSystem.prototype, "url", void 0);
__decorate([
    decorators_1.serializable
], BackendSystem.prototype, "client", void 0);
__decorate([
    decorators_1.serializable
], BackendSystem.prototype, "userDisplayName", void 0);
__decorate([
    decorators_1.sensitiveData
], BackendSystem.prototype, "serviceKeys", void 0);
__decorate([
    decorators_1.sensitiveData
], BackendSystem.prototype, "refreshToken", void 0);
__decorate([
    decorators_1.sensitiveData
], BackendSystem.prototype, "username", void 0);
__decorate([
    decorators_1.sensitiveData
], BackendSystem.prototype, "password", void 0);
__decorate([
    decorators_1.sensitiveData
], BackendSystem.prototype, "authenticationType", void 0);
exports.BackendSystem = BackendSystem;


/***/ }),

/***/ 80878:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const decorators_1 = __webpack_require__(8114);
/** This represents the migration status of the systems from pure secure store
 * the hybrid filesystem/secure store
 */
class SystemMigrationStatus {
    constructor({ authTypeMigrated, migrationDone, migrationLogs }) {
        this.migrationDone = migrationDone;
        this.authTypeMigrated = authTypeMigrated;
        this.migrationLogs = migrationLogs;
    }
}
__decorate([
    decorators_1.serializable
], SystemMigrationStatus.prototype, "migrationDone", void 0);
__decorate([
    decorators_1.serializable
], SystemMigrationStatus.prototype, "authTypeMigrated", void 0);
__decorate([
    decorators_1.serializable
], SystemMigrationStatus.prototype, "migrationLogs", void 0);
exports.SystemMigrationStatus = SystemMigrationStatus;
class SystemMigrationStatusKey {
    getId() {
        return 'systemMigration'; // A singleton
    }
}
exports.SystemMigrationStatusKey = SystemMigrationStatusKey;


/***/ }),

/***/ 64270:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const i18next_1 = __importDefault(__webpack_require__(20610));
const i18next_fs_backend_1 = __importDefault(__webpack_require__(77029));
const path_1 = __importDefault(__webpack_require__(71017));
const i18nInstance = i18next_1.default.createInstance();
async function initI18n() {
    await i18nInstance.use(i18next_fs_backend_1.default).init({
        initImmediate: false,
        fallbackLng: 'en',
        fallbackNS: 'default',
        interpolation: { escapeValue: false },
        ns: 'ux-store',
        defaultNS: 'ux-store',
        backend: {
            loadPath: path_1.default.join(__dirname, './translations/{{lng}}.{{ns}}.json')
        }
    });
}
exports.initI18n = initI18n;
function text(key, options) {
    return i18nInstance.t(key, options);
}
exports.text = text;


/***/ }),

/***/ 16493:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const contants_1 = __webpack_require__(82119);
exports.Entity = contants_1.Entity;
const i18n_1 = __webpack_require__(64270);
const backend_system_1 = __webpack_require__(37074);
const services = {
    system: backend_system_1.getInstance
};
async function getService({ logger = console, entityName }) {
    await i18n_1.initI18n();
    const factory = services[entityName];
    if (factory) {
        return factory(logger);
    }
    else {
        throw new Error(i18n_1.text('error.unsupportedEntity', { entityName }));
    }
}
exports.getService = getService;
__export(__webpack_require__(35311));
__export(__webpack_require__(78238));
__export(__webpack_require__(87225));
// Support any filesystem watchers
var data_access_1 = __webpack_require__(99696);
exports.getFilesystemWatcherFor = data_access_1.getFilesystemWatcherFor;


/***/ }),

/***/ 74469:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class DummyStore {
    constructor(log) {
        this.log = log;
    }
    async save(service, key, value) {
        this.log.warn(`Dummy store. Trying to save for service: ${service}, key: ${key}, value type: ${typeof value}`);
        return Promise.resolve(true);
    }
    async retrieve(service, key) {
        this.log.warn(`Dummy store. Trying to retrieve for service: ${service}, key: ${key}`);
        return Promise.resolve(null);
    }
    async delete(service, key) {
        this.log.warn(`Dummy store. Trying to delete for service: ${service}, key: ${key}`);
        return Promise.resolve(true);
    }
    async getAll(service) {
        this.log.warn(`Dummy store. Trying to get all values for service: [${service}]`);
        return Promise.resolve({});
    }
}
exports.DummyStore = DummyStore;


/***/ }),

/***/ 78238:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const ux_common_utils_1 = __webpack_require__(59859);
const dummy_store_1 = __webpack_require__(74469);
const keytar_store_1 = __webpack_require__(49680);
function getKeytar(log) {
    var _a, _b;
    try {
        return __webpack_require__(74602);
    }
    catch (e) {
        log.warn(e);
        log.warn(`Could not "require('keytar')". Trying VSCode's copy`);
        let vscode;
        try {
            vscode = __webpack_require__(66828);
        }
        catch (e) {
            log.warn(e);
            log.warn('Could not get hold of vscode');
            return null;
        }
        try {
            return __webpack_require__(87694)(`${(_a = vscode === null || vscode === void 0 ? void 0 : vscode.env) === null || _a === void 0 ? void 0 : _a.appRoot}/node_modules.asar/keytar`);
        }
        catch (e) {
            log.warn(e);
            log.warn('Could not get keytar from vscode node_modules.asar');
        }
        try {
            return __webpack_require__(53391)(`${(_b = vscode === null || vscode === void 0 ? void 0 : vscode.env) === null || _b === void 0 ? void 0 : _b.appRoot}/node_modules/keytar`);
        }
        catch (e) {
            log.warn(e);
            log.warn('Could not get keytar from vscode node_modules');
        }
        return null;
    }
}
/**
 * Create an instance of a store
 */
exports.getSecureStore = (log) => {
    if (ux_common_utils_1.isAppStudio() || process.env.UX_TOOLS_DISABLE_KEYSTORE) {
        return new dummy_store_1.DummyStore(log);
    }
    else {
        const keytar = getKeytar(log);
        return keytar ? new keytar_store_1.KeytarStore(log, keytar) : new dummy_store_1.DummyStore(log);
    }
};


/***/ }),

/***/ 49680:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class KeytarStore {
    constructor(log, keytar) {
        this.log = log;
        this.keytar = keytar;
    }
    async save(service, key, value) {
        try {
            const serialized = JSON.stringify(value);
            await this.keytar.setPassword(service, key, serialized);
            return true;
        }
        catch (e) {
            this.log.error(`Error saving to secure store. Service: [${service}], key: [${key}]`);
            this.log.error(e);
            return false;
        }
    }
    async retrieve(service, key) {
        try {
            const serializedValue = await this.keytar.getPassword(service, key);
            return JSON.parse(serializedValue);
        }
        catch (e) {
            this.log.error(`Error retrieving from secure store. Service: [${service}], key: [${key}]`);
            this.log.error(e);
            return null;
        }
    }
    async delete(service, key) {
        try {
            return await this.keytar.deletePassword(service, key);
        }
        catch (e) {
            this.log.error(`Error deleting from secure store. Service: [${service}], key: [${key}]`);
            this.log.error(e);
            return false;
        }
    }
    async getAll(service) {
        try {
            return (await this.keytar.findCredentials(service)).reduce((result, entry) => {
                try {
                    result[entry.account] = JSON.parse(entry.password);
                }
                catch (e) {
                    this.log.error(`Error parsing credentials for [${entry.account}]`);
                }
                return result;
            }, {});
        }
        catch (e) {
            this.log.error(`Error getting values for service: [${service}]`);
            this.log.error(e);
            return {};
        }
    }
}
exports.KeytarStore = KeytarStore;


/***/ }),

/***/ 37074:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils_1 = __webpack_require__(75553);
const backend_system_1 = __webpack_require__(66747);
const backend_system_2 = __webpack_require__(87225);
const system_migration_1 = __webpack_require__(72237);
const i18n_1 = __webpack_require__(64270);
class SystemService {
    constructor(logger) {
        this.migrationDone = false;
        this.logger = utils_1.getExtendedLogger(logger);
        this.dataProvider = new backend_system_1.SystemDataProvider(this.logger);
    }
    async partialUpdate(key, entity) {
        this.validatePartialUpdateInput(entity);
        const existingSystem = await this.readOrThrow(key);
        const updatedEntity = this.mergeProperties(entity, existingSystem);
        return this.write(updatedEntity);
    }
    mergeProperties(update, existingSystem) {
        const patch = { ...update };
        // Make sure we don't mess with key fields
        delete patch.url;
        delete patch.client;
        const updatedEntity = { ...existingSystem, ...patch };
        return new backend_system_2.BackendSystem({ ...updatedEntity });
    }
    async readOrThrow(key) {
        const existingSystem = await this.read(key);
        if (!existingSystem) {
            throw new Error(i18n_1.text('error.systemDoesNotExist', { system: key }));
        }
        return existingSystem;
    }
    validatePartialUpdateInput(entity) {
        if (!entity || !Object.keys(entity).length) {
            throw new Error(i18n_1.text('error.noPropertiesSpecified'));
        }
    }
    async ensureMigrationDone() {
        if (!this.migrationDone) {
            await system_migration_1.migrate(this.logger, this.dataProvider);
            this.migrationDone = true;
        }
    }
    async read(key) {
        await this.ensureMigrationDone();
        return this.dataProvider.read(key);
    }
    async write(entity) {
        await this.ensureMigrationDone();
        return this.dataProvider.write(entity);
    }
    async delete(entity) {
        await this.ensureMigrationDone();
        return this.dataProvider.delete(entity);
    }
    async getAll() {
        await this.ensureMigrationDone();
        return this.dataProvider.getAll();
    }
}
exports.SystemService = SystemService;
function getInstance(logger) {
    return new SystemService(logger);
}
exports.getInstance = getInstance;


/***/ }),

/***/ 35311:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var backend_system_1 = __webpack_require__(37074);
exports.SystemService = backend_system_1.SystemService;


/***/ }),

/***/ 72237:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const contants_1 = __webpack_require__(82119);
const system_migration_1 = __webpack_require__(48661);
const backend_system_1 = __webpack_require__(87225);
const system_migration_status_1 = __webpack_require__(80878);
const i18n_1 = __webpack_require__(64270);
const secure_store_1 = __webpack_require__(78238);
const utils_1 = __webpack_require__(75553);
class Migration {
    constructor({ logger, secureStore, systemMigrationStatus, systemDataProvider }) {
        this.cache = {};
        this.logger = logger;
        this.secureStore = secureStore;
        this.systemMigrationStatus = systemMigrationStatus;
        this.systemDataProvider = systemDataProvider;
    }
    async run() {
        let dirty = false;
        let migrationDone = this.systemMigrationStatus.migrationDone;
        if (!this.systemMigrationStatus.migrationDone) {
            this.logger.info(new Date(Date.now()).toString());
            await this.migrateFromPureSecureStore();
            await this.migrateRefreshTokens();
            migrationDone = dirty = true;
        }
        let authTypeMigrated = this.systemMigrationStatus.authTypeMigrated;
        if (!this.systemMigrationStatus.authTypeMigrated) {
            await this.migrateAuthType();
            authTypeMigrated = dirty = true;
        }
        return {
            migrationStatus: { ...this.systemMigrationStatus, migrationDone, authTypeMigrated },
            dirty
        };
    }
    async migrateFromPureSecureStore() {
        const systemsToMigrate = await this.secureStore.getAll(contants_1.ServiceName.OldSystemService);
        const existingSystems = await this.getExistingSystems();
        // Migrate from old store
        for (const systemId of Object.keys(systemsToMigrate)) {
            if (!existingSystems[systemId]) {
                const oldSystem = systemsToMigrate[systemId];
                this.logger.debug(`Migrating sytem ID: [${systemId}]`);
                const refreshToken = await this.getRefreshTokenFromOldStore(oldSystem);
                if (refreshToken) {
                    this.logger.info(i18n_1.text('info.foundRefreshToken', { systemId }));
                }
                await this.saveBackendSystem(new backend_system_1.BackendSystem({ ...oldSystem, refreshToken }));
                await this.secureStore.delete(contants_1.ServiceName.OldSystemService, systemId);
                if (refreshToken) {
                    await this.deleteOldRefreshToken(oldSystem, systemId);
                    this.logger.info(i18n_1.text('info.deletingRefreshTokenFromOldStore', { systemId }));
                }
            }
            else {
                this.logger.info(i18n_1.text('error.systemAlreadyExistsInHybridStore', { systemId }));
            }
        }
    }
    async migrateRefreshTokens() {
        const existingSystems = await this.getExistingSystems();
        for (const systemId of Object.keys(existingSystems)) {
            const existingSystem = existingSystems[systemId];
            const refreshToken = await this.getRefreshTokenFromOldStore(existingSystem);
            if (refreshToken) {
                this.logger.info(i18n_1.text('info.foundRefreshToken', { systemId }));
                await this.updateRefreshTokenInStoredSystem(existingSystem, refreshToken, systemId);
                await this.deleteOldRefreshToken(existingSystem, systemId);
            }
        }
    }
    async migrateAuthType() {
        const existingSystems = await this.getExistingSystems();
        for (const systemId of Object.keys(existingSystems)) {
            const existingSystem = existingSystems[systemId];
            if (!existingSystem.authenticationType) {
                this.logger.info(i18n_1.text('info.tryingToUpdateAuthType', { systemId }));
                const authenticationType = this.guessAuthType(existingSystem);
                if (authenticationType) {
                    this.logger.info(i18n_1.text('info.authTypeDetermined', { authenticationType, systemId }));
                    await this.saveBackendSystem(new backend_system_1.BackendSystem({ ...existingSystem, authenticationType }));
                }
                else {
                    this.logger.info(i18n_1.text('info.authTypeNotDetermined', { systemId }));
                }
            }
        }
    }
    guessAuthType(sys) {
        if (sys.serviceKeys) {
            return backend_system_1.AuthenticationType.OAuth2RefreshToken;
        }
        else if (sys.username) {
            return backend_system_1.AuthenticationType.Basic;
        }
        else {
            return undefined;
        }
    }
    async getRefreshTokenFromOldStore(system) {
        var _a;
        try {
            const host = (_a = new URL(system.url)) === null || _a === void 0 ? void 0 : _a.host;
            return host ? await this.secureStore.retrieve(contants_1.ServiceName.OldRefreshTokenService, host) : undefined;
        }
        catch {
            return undefined;
        }
    }
    async deleteOldRefreshToken(system, systemId) {
        var _a;
        this.logger.info(i18n_1.text('info.deletingRefreshTokenFromOldStore', { systemId }));
        try {
            const host = (_a = new URL(system.url)) === null || _a === void 0 ? void 0 : _a.host;
            await this.secureStore.delete(contants_1.ServiceName.OldRefreshTokenService, host);
        }
        catch (e) {
            this.logger.info(i18n_1.text('error.couldNotDeleteRefreshToken', { url: system.url }));
            this.logger.info(e.message);
        }
    }
    async updateRefreshTokenInStoredSystem(system, refreshToken, systemId) {
        if (system.refreshToken !== refreshToken) {
            this.logger.info(i18n_1.text('info.updatingRefreshTokenInNewStore', { systemId }));
            await this.saveBackendSystem(new backend_system_1.BackendSystem({ ...system, refreshToken }));
        }
    }
    async saveBackendSystem(backendSystem) {
        // Invalidate the cache
        this.cache.existingSystems = undefined;
        return this.systemDataProvider.write(backendSystem);
    }
    /** Warning: the first call is cached. If any writes are done, cache needs to be invalidated */
    async getExistingSystems() {
        if (!this.cache.existingSystems) {
            this.cache.existingSystems = (await this.systemDataProvider.getAll()).reduce((systems, sys) => {
                systems[new backend_system_1.BackendSystemKey(sys).getId()] = sys;
                return systems;
            }, {});
        }
        return this.cache.existingSystems;
    }
}
/** Migrate systems that were purely in the secure store
 * to the filesystem/secure hybrid store
 **/
async function migrate(logger, systemDataProvider) {
    try {
        const systemMigrationStatusDataProvider = new system_migration_1.SystemMigrationStatusDataProvider(logger);
        const systemMigrationStatus = (await systemMigrationStatusDataProvider.read(new system_migration_status_1.SystemMigrationStatusKey())) || { migrationDone: false, authTypeMigrated: false, migrationLogs: [] };
        const migrationLogger = createLogInterceptor(logger, systemMigrationStatus.migrationLogs);
        const secureStore = secure_store_1.getSecureStore(migrationLogger);
        const migration = new Migration({
            logger: migrationLogger,
            systemMigrationStatus,
            secureStore,
            systemDataProvider
        });
        const { migrationStatus: updatedStatus, dirty } = await migration.run();
        if (dirty) {
            await systemMigrationStatusDataProvider.write(new system_migration_status_1.SystemMigrationStatus({
                ...updatedStatus,
                migrationLogs: updatedStatus.migrationLogs.slice(-200) // Limit to 200 entries
            }));
        }
    }
    catch (e) {
        logger.warn(i18n_1.text('error.systemMigrationFailed'));
        logger.debug(e.message);
    }
}
exports.migrate = migrate;
function addBeforeHook(hookFn, fn) {
    return function (arg) {
        hookFn(arg);
        fn(arg);
    };
}
/** Capture all the logs to save in the migration logs */
function createLogInterceptor(logger, migrationLogs) {
    const migrationLogger = getMigrationLogger(migrationLogs);
    return {
        info: addBeforeHook(migrationLogger, logger.info),
        warn: addBeforeHook(migrationLogger, logger.warn),
        error: addBeforeHook(migrationLogger, logger.error),
        debug: migrationLogger
    };
}
function getMigrationLogger(migrationLogs) {
    const migrationLogger = utils_1.newDebugLogger(utils_1.MIGRATION_NAMESPACE);
    migrationLogger.log = (args) => {
        migrationLogs.push(args === null || args === void 0 ? void 0 : args.toString());
    };
    utils_1.enableDebugLogger(utils_1.MIGRATION_NAMESPACE);
    return migrationLogger;
}


/***/ }),

/***/ 75553:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __webpack_require__(54484);
exports.STORE_NAMESPACE = 'ft:store';
exports.MIGRATION_NAMESPACE = exports.STORE_NAMESPACE + ':migrate';
exports.newDebugLogger = (namespace = exports.STORE_NAMESPACE) => debug_1.debug(namespace);
exports.enableDebugLogger = (namespace) => debug_1.debug.enable(namespace);
/** Pick the properties listed and return a new object with a shallow-copy */
exports.pick = (target, ...props) => {
    return ((target &&
        (props === null || props === void 0 ? void 0 : props.length) > 0 &&
        props.reduce((o, k) => {
            o[k] = target[k];
            return o;
        }, {})) ||
        undefined);
};
/**
 * Extend the logger to add a debug method
 * @param l
 */
function getExtendedLogger(l) {
    return {
        ...l,
        debug: exports.newDebugLogger()
    };
}
exports.getExtendedLogger = getExtendedLogger;


/***/ }),

/***/ 41493:
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(49149)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 49149:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(571);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 54484:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(41493);
} else {
	module.exports = __webpack_require__(44433);
}


/***/ }),

/***/ 44433:
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(76224);
const util = __webpack_require__(73837);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(89531);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(49149)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 93326:
/***/ ((module) => {

"use strict";

module.exports = (flag, argv) => {
	argv = argv || process.argv;
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const pos = argv.indexOf(prefix + flag);
	const terminatorPos = argv.indexOf('--');
	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};


/***/ }),

/***/ 89531:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(22037);
const hasFlag = __webpack_require__(93326);

const env = process.env;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false')) {
	forceColor = false;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = true;
}
if ('FORCE_COLOR' in env) {
	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(stream) {
	if (forceColor === false) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (stream && !stream.isTTY && forceColor !== true) {
		return 0;
	}

	const min = forceColor ? 1 : 0;

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors. Windows 10 build 14931 is the first release
		// that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(process.versions.node.split('.')[0]) >= 8 &&
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return min;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: getSupportLevel(process.stdout),
	stderr: getSupportLevel(process.stderr)
};


/***/ }),

/***/ 33313:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const client_1 = __webpack_require__(11315);
const appInsights = __importStar(__webpack_require__(14585));
const EventHeader_1 = __webpack_require__(47421);
const SampleRate_1 = __webpack_require__(46573);
const system_1 = __webpack_require__(73883);
const telemetryClientConfig_1 = __webpack_require__(50712);
class ApplicationInsightClient extends client_1.Client {
    /**
     *
     * @param applicationKey Application key to identify the Azure Application Insight resource
     * @param extensionName Unique name of the extension in the format of {publisher}.{extension}
     * @param extensionVersion Conventional version number of the extension
     */
    constructor(applicationKey, extensionName, extensionVersion) {
        super();
        this.clients = new Map();
        super.applicationKey = applicationKey;
        this.extensionVersion = extensionVersion;
        this.extensionName = extensionName;
        const clientOnePercent = this.createTelemetryClient(SampleRate_1.SampleRate.OnePercent);
        const clientTenPercent = this.createTelemetryClient(SampleRate_1.SampleRate.TenPercent);
        const clientNoSampling = this.createTelemetryClient(SampleRate_1.SampleRate.NoSampling);
        this.clients.set(SampleRate_1.SampleRate.OnePercent, clientOnePercent);
        this.clients.set(SampleRate_1.SampleRate.TenPercent, clientTenPercent);
        this.clients.set(SampleRate_1.SampleRate.NoSampling, clientNoSampling);
        return this;
    }
    /**
     * Send a telemetry event to Azure Application Insights
     * @param eventName Categorize the type of the event within the scope of an extension.
     * @param properties A set of string properties to be reported
     * @param measurements  A set of numeric measurements to be reported
     * @param sampleRate Sampling the event to be sent
     * @param telemetryHelperProperties Properties that are passed to specific TelemetryClient for generating specific properties (E.g. ToolsSuiteTelemetryClient)
     * @param ignoreSettings Ignore telemetryEnabled settings and skip submitting telemetry data
     */
    async report(eventName, properties, measurements, sampleRate, telemetryHelperProperties, ignoreSettings) {
        if ((ignoreSettings !== undefined && !ignoreSettings) || !system_1.TelemetrySystem.telemetryEnabled) {
            return;
        }
        const processedSampleRate = sampleRate ? sampleRate : SampleRate_1.SampleRate.NoSampling;
        const client = this.clients.get(processedSampleRate);
        const eventHeader = new EventHeader_1.EventHeader(this.extensionName, eventName);
        const event = {
            name: eventHeader.toString(),
            properties: properties,
            measurements: measurements
        };
        this.trackEvent(client, event);
    }
    trackEvent(client, event) {
        if (process.env.SAP_UX_FIORI_TOOLS_DISABLE_TELEMETRY !== 'true') {
            client.trackEvent(event);
            return true;
        }
        return false;
    }
    createTelemetryClient(sampleRate) {
        let sampleRateNumer;
        switch (sampleRate) {
            case SampleRate_1.SampleRate.OnePercent:
                sampleRateNumer = 1;
                break;
            case SampleRate_1.SampleRate.TenPercent:
                sampleRateNumer = 10;
                break;
            case SampleRate_1.SampleRate.NoSampling:
            default:
                sampleRateNumer = 100;
                break;
        }
        const client = new appInsights.TelemetryClient(this.applicationKey);
        // const client: any = { config: {}, channel: { setUseDiskRetryCaching: () => {} } };
        client.config.samplingPercentage = sampleRateNumer;
        telemetryClientConfig_1.configAzureTelemetryClient(client);
        return client;
    }
}
exports.ApplicationInsightClient = ApplicationInsightClient;


/***/ }),

/***/ 11315:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Client {
    constructor() {
        this.applicationKey = '';
        this.extensionName = '';
        this.extensionVersion = '';
    }
    getApplicationKey() {
        return this.applicationKey;
    }
    getExtensionVersion() {
        return this.extensionVersion;
    }
    getExtensionName() {
        return this.extensionName;
    }
}
exports.Client = Client;


/***/ }),

/***/ 40207:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const system_1 = __webpack_require__(73883);
const telemetryPackageJSON = __importStar(__webpack_require__(18622));
const toolsSuiteTelemetry_1 = __webpack_require__(82734);
class ClientFactory {
    static getTelemetryClient() {
        return ClientFactory.getTelemetryClientByClass(toolsSuiteTelemetry_1.ToolsSuiteTelemetryClient);
    }
    static getTelemetryClientByClass(clientConstructor) {
        let client = ClientFactory.clientMap.get(clientConstructor.name);
        if (client) {
            return client;
        }
        if (system_1.TelemetrySystem.manifest) {
            client = new clientConstructor(telemetryPackageJSON.azureInstrumentationKey, system_1.TelemetrySystem.manifest.name, system_1.TelemetrySystem.manifest.version);
        }
        else {
            client = new clientConstructor(telemetryPackageJSON.azureInstrumentationKey, telemetryPackageJSON.name, telemetryPackageJSON.version);
        }
        ClientFactory.clientMap.set(clientConstructor.name, client);
        return client;
    }
}
exports.ClientFactory = ClientFactory;
ClientFactory.clientMap = new Map();


/***/ }),

/***/ 62768:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ClientType;
(function (ClientType) {
    ClientType[ClientType["AzureApplicationInsights"] = 0] = "AzureApplicationInsights";
})(ClientType = exports.ClientType || (exports.ClientType = {}));


/***/ }),

/***/ 47421:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Hierarchical event name for a telemetry event submitted to Auzre Application Insights.
 */
class EventHeader {
    constructor(extensionName, eventName) {
        this.extensionName = extensionName;
        this.eventName = eventName;
    }
    getExtensionName() {
        return this.extensionName;
    }
    getEventName() {
        return this.eventName;
    }
    toString() {
        return `${this.extensionName}/${this.eventName}`;
    }
}
exports.EventHeader = EventHeader;


/***/ }),

/***/ 70181:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var EventName;
(function (EventName) {
    EventName["Test"] = "test";
    EventName["TELEMETRY_SETTINGS_INIT_FAILED"] = "TELEMETRY_SETTINGS_INIT_FAILED";
    EventName["GUIDE_ACTION"] = "GUIDE_ACTION";
    EventName["PANEL_LOAD"] = "PANEL_LOAD";
    // Unique to Application Modeler
    EventName["PAGEMAP"] = "PAGEMAP";
    EventName["APP_ACTIONS"] = "ACTIONS";
    EventName["PAGE_EDITOR"] = "PAGE_EDITOR";
    EventName["PAGEMAP_STARTUP_TIME"] = "PAGEMAP_STARTUP_TIME";
    EventName["APPLICATION_PREVIEW"] = "APPLICATION_PREVIEW";
    EventName["APP_INFO_COMMAND_STARTED"] = "APP_INFO_COMMAND_STARTED";
    EventName["APP_INFO_LINK_CLICKED"] = "APP_INFO_LINK_CLICKED";
    EventName["APP_INFO_STARTUP_TIME"] = "APP_INFO_STARTUP_TIME";
    // Unique to Application Generator
    EventName["GENERATION_SUCCESS"] = "GENERATION_SUCCESS";
    EventName["GENERATION_INSTALL_FAIL"] = "GENERATION_INSTALL_FAIL";
    EventName["GENERATION_WRITING_FAIL"] = "GENERATION_WRITING_FAIL";
    // Unique to Service Modeler
    EventName["SRV_MODELLER_SETTINGS_CHANGED"] = "SRV_MODELER_SETTINGS_CHANGED";
    EventName["SRV_MODELER_ACTIVATED"] = "SRV_MODELER_ACTIVATED";
    EventName["SRV_MODELER_PANEL_LOAD"] = "SRV_MODELER_PANEL_LOAD";
    EventName["SRV_MODELER_BACKEND_LOAD"] = "SRV_MODELER_BACKEND_LOAD";
    EventName["SRV_MODELER_ODATA_VERSION"] = "SRV_MODELER_ODATA_VERSION";
    // Unique to Annotation File Mgr
    EventName["ANNOTATION_FILE_PANEL_LOAD"] = "ANNOTATION_FILE_PANEL_LOAD";
    EventName["ANNOTATION_FILE_BACKEND_LOAD"] = "ANNOTATION_FILE_BACKEND_LOAD";
    // Unique to Annotation Modeler
    EventName["ANNOTATION_LSP_XML_LOAD"] = "ANNOTATION_LSP_XML_LOAD";
    EventName["ANNOTATION_LSP_USAGE_TERM"] = "ANNOTATION_LSP_USAGE_TERM";
    EventName["ANNOTATION_LSP_CODE_COMPLETION_TERM"] = "ANNOTATION_LSP_CODE_COMPLETION_TERM";
    EventName["ANNOTATION_LSP_CODE_COMPLETION"] = "ANNOTATION_LSP_CODE_COMPLETION";
    // Unique to Migration
    EventName["MIGRATION_ACTIVATED"] = "MIGRATION_ACTIVATED";
    EventName["MIGRATION_BACKEND_LOAD"] = "MIGRATION_BACKEND_LOAD";
    EventName["MIGRATION_COMPLETED"] = "MIGRATION_COMPLETED";
    EventName["MIGRATION_SHOW_INFO_PAGE"] = "MIGRATION_SHOW_INFO_PAGE";
    EventName["DEPLOY_CONFIG"] = "DEPLOY_CONFIG";
    EventName["DEPLOY"] = "DEPLOY";
    EventName["DEPLOY_FAIL"] = "DEPLOY_FAIL";
    // Unique to Data Editor
    EventName["DATA_EDITOR_EVENT"] = "DATA_EDITOR_EVENT";
    // Unique to Control Property Editor
    EventName["CPE_EVENT"] = "CONTROL_PROPERTY_EDITOR_EVENT";
})(EventName = exports.EventName || (exports.EventName = {}));


/***/ }),

/***/ 46573:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var SampleRate;
(function (SampleRate) {
    SampleRate[SampleRate["OnePercent"] = 0] = "OnePercent";
    SampleRate[SampleRate["TenPercent"] = 1] = "TenPercent";
    SampleRate[SampleRate["NoSampling"] = 2] = "NoSampling";
})(SampleRate = exports.SampleRate || (exports.SampleRate = {}));


/***/ }),

/***/ 48778:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const config_1 = __webpack_require__(23538);
const decorCommon = (isAsync, target, descriptor, evtName, interceptorType, sampleRate, paramsCapturingInstructions) => {
    const originalMethod = descriptor.value;
    const interceptorTypesMap = isAsync ? config_1.asyncInterceptorTypesMapping : config_1.interceptorTypesMapping;
    const interceptor = interceptorTypesMap.get(interceptorType);
    descriptor.value = interceptor(target, originalMethod, evtName, sampleRate, paramsCapturingInstructions);
};
/**
 *
 * @param evtName - Event names to filter data on backend, use EventNames predefined in Telemetry.EventName enumeration
 * @param interceptorType - Interceptor type to apply to decorated function, use interceptorTypes predefined in Telemetry.interceptorTypes enumeration
 * @param sampleRate - Sample rate for recorded data, use predefined sample rates in Telemetry.SampleRate enumeration
 * @param paramsCapturingInstructions - Optional param, Should be passed when interceptor of type CAPTURE_PARAM being used. As single instance or array of instances (when multiple params should be captured or some additional sumbission data should be predefined). Allows predefine property name, value or specify paths to value to be captured (if it's element of array or nested in object)
 */
exports.logTelemetry = (evtName, interceptorType, sampleRate, paramsCapturingInstructions) => {
    return (target, functionName, descriptor) => {
        decorCommon(false, target, descriptor, evtName, interceptorType, sampleRate, paramsCapturingInstructions);
    };
};
/**
 *
 * @param evtName - Event names to filter data on backend, use EventNames predefined in Telemetry.EventName enumeration
 * @param interceptorType - Interceptor type to apply to decorated function, use interceptorTypes predefined in Telemetry.interceptorTypes enumeration
 * @param sampleRate - Sample rate for recorded data, use predefined sample rates in Telemetry.SampleRate enumeration
 * @param paramsCapturingInstructions - Optional param, Should be passed when interceptor of type CAPTURE_PARAM being used. As single instance or array of instances (when multiple params should be captured or some additional sumbission data should be predefined). Allows predefine property name, value or specify paths to value to be captured (if it's element of array or nested in object)
 */
exports.logTelemetryAsync = (evtName, interceptorType, sampleRate, paramsCapturingInstructions) => {
    return (target, functionName, descriptor) => {
        decorCommon(true, target, descriptor, evtName, interceptorType, sampleRate, paramsCapturingInstructions);
    };
};


/***/ }),

/***/ 65611:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Common  */
var index_1 = __webpack_require__(40207);
exports.ClientFactory = index_1.ClientFactory;
var client_1 = __webpack_require__(11315);
exports.Client = client_1.Client;
var ClientType_1 = __webpack_require__(62768);
exports.ClientType = ClientType_1.ClientType;
var appInsightClient_1 = __webpack_require__(33313);
exports.ApplicationInsightClient = appInsightClient_1.ApplicationInsightClient;
/* Low Level API */
var system_1 = __webpack_require__(73883);
exports.TelemetrySystem = system_1.TelemetrySystem;
var EventHeader_1 = __webpack_require__(47421);
exports.EventHeader = EventHeader_1.EventHeader;
var EventName_1 = __webpack_require__(70181);
exports.EventName = EventName_1.EventName;
var SampleRate_1 = __webpack_require__(46573);
exports.SampleRate = SampleRate_1.SampleRate;
var config_1 = __webpack_require__(23538);
exports.interceptorTypes = config_1.interceptorTypes;
var api_1 = __webpack_require__(1990);
exports.PerformanceMeasurementAPI = api_1.PerformanceMeasurementAPI;
var paramProcessing_1 = __webpack_require__(21677);
exports.ParamRecordConfig = paramProcessing_1.ParamRecordConfig;
exports.ParamRecordConfigField = paramProcessing_1.ParamRecordConfigField;
/* Decorator */
var decorator_1 = __webpack_require__(48778);
exports.logTelemetry = decorator_1.logTelemetry;
exports.logTelemetryAsync = decorator_1.logTelemetryAsync;
var toolsSuiteTelemetry_1 = __webpack_require__(82734);
exports.initTelemetrySettings = toolsSuiteTelemetry_1.initTelemetrySettings;
exports.ToolsSuiteTelemetryClient = toolsSuiteTelemetry_1.ToolsSuiteTelemetryClient;
exports.TelemetrySettings = {}; // mock export ot avoid CI arrs. Remove when Guided Help extension TelemetrySettings import removed.


/***/ }),

/***/ 23538:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const interceptors = __importStar(__webpack_require__(72726));
var interceptorTypes;
(function (interceptorTypes) {
    /**
     * Simple notification interceptor, reports certain event
     * occurance and requires no data to be captured or measured.
     */
    interceptorTypes["NOTIFICATION"] = "notify";
    /**
     * Duration interceptor, measures and reports runtime of decorated method.
     */
    interceptorTypes["DURATION"] = "duration";
    /**
     * Captures specified in paramCaptureConfig parameter of decorated method.
     */
    interceptorTypes["CAPTURE_PARAM"] = "captureParam";
})(interceptorTypes = exports.interceptorTypes || (exports.interceptorTypes = {}));
const interceptorTypesMapping = new Map();
exports.interceptorTypesMapping = interceptorTypesMapping;
interceptorTypesMapping.set(interceptorTypes.NOTIFICATION, interceptors.notify);
interceptorTypesMapping.set(interceptorTypes.DURATION, interceptors.duration);
interceptorTypesMapping.set(interceptorTypes.CAPTURE_PARAM, interceptors.captureParam);
const asyncInterceptorTypesMapping = new Map();
exports.asyncInterceptorTypesMapping = asyncInterceptorTypesMapping;
asyncInterceptorTypesMapping.set(interceptorTypes.NOTIFICATION, interceptors.notifyAsync);
asyncInterceptorTypesMapping.set(interceptorTypes.DURATION, interceptors.durationAsync);
asyncInterceptorTypesMapping.set(interceptorTypes.CAPTURE_PARAM, interceptors.captureParamAsync);


/***/ }),

/***/ 72726:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const client_1 = __webpack_require__(40207);
const api_1 = __webpack_require__(1990);
const paramProcessing_1 = __webpack_require__(21677);
exports.notify = (target, originalFn, evtName, sampleRate) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (...args) => {
        const result = originalFn.apply(target, args);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, {}, {}, sampleRate);
        return result;
    };
};
exports.notifyAsync = (target, originalFn, evtName, sampleRate) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return async (...args) => {
        const result = await originalFn.apply(target, args);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, {}, {}, sampleRate);
        return result;
    };
};
exports.duration = (target, originalFn, evtName, sampleRate) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (...args) => {
        const markName = api_1.PerformanceMeasurementAPI.startMark('mark');
        const result = originalFn.apply(target, args);
        api_1.PerformanceMeasurementAPI.endMark(markName);
        api_1.PerformanceMeasurementAPI.measure(markName);
        const duration = api_1.PerformanceMeasurementAPI.getMeasurementDuration(markName);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, {}, { ms: duration }, sampleRate);
        return result;
    };
};
exports.durationAsync = (target, originalFn, evtName, sampleRate) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return async (...args) => {
        const markName = api_1.PerformanceMeasurementAPI.startMark('mark');
        const result = await originalFn.apply(target, args);
        api_1.PerformanceMeasurementAPI.endMark(markName);
        api_1.PerformanceMeasurementAPI.measure(markName);
        const duration = api_1.PerformanceMeasurementAPI.getMeasurementDuration(markName);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, {}, { ms: duration }, sampleRate);
        return result;
    };
};
exports.captureParam = (target, originalFn, evtName, sampleRate, instructions) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (...args) => {
        const result = originalFn.apply(target, args);
        const [customDimensions, customMeasurements] = paramProcessing_1.getParamsData(args, instructions);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, customDimensions, customMeasurements, sampleRate);
        return result;
    };
};
exports.captureParamAsync = (target, originalFn, evtName, sampleRate, instructions) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return async (...args) => {
        const result = await originalFn.apply(target, args);
        const [customDimensions, customMeasurements] = paramProcessing_1.getParamsData(args, instructions);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, customDimensions, customMeasurements, sampleRate);
        return result;
    };
};


/***/ }),

/***/ 1990:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const entries_1 = __webpack_require__(39540);
const types_1 = __webpack_require__(68035);
const performanceNow = __webpack_require__(26899);
class PerformanceMeasurementAPI extends types_1.PerformanceMeasurement {
    // reported time is relative to the time the current Node process has started (inferred from process.uptime())
    static initialize() {
        PerformanceMeasurementAPI.initTiming = PerformanceMeasurementAPI.now();
    }
    static mark(name, type, timing) {
        const entry = new entries_1.Mark(name, type, timing);
        PerformanceMeasurementAPI.entries.push(entry);
    }
    static startMark(name) {
        const timing = PerformanceMeasurementAPI.now();
        const extendedName = name + timing;
        PerformanceMeasurementAPI.mark(extendedName, types_1.EntryType.START_MARK, timing);
        return extendedName;
    }
    static endMark(name) {
        const timing = PerformanceMeasurementAPI.now();
        PerformanceMeasurementAPI.mark(name, types_1.EntryType.END_MARK, timing);
    }
    static measure(markName) {
        const startMark = PerformanceMeasurementAPI.getEntriesByNameType(markName, types_1.EntryType.START_MARK).slice(-1)[0];
        const endMark = PerformanceMeasurementAPI.getEntriesByNameType(markName, types_1.EntryType.END_MARK).slice(-1)[0];
        if (!startMark && !endMark) {
            throw new Error(`Failed to execute 'measure': mark '${markName}' doesn't exist.`);
        }
        else if (!startMark || !endMark) {
            const errMarkType = startMark ? types_1.EntryType.END_MARK : types_1.EntryType.START_MARK;
            throw new Error(`Failed to execute 'measure': mark '${markName}'of type '${errMarkType}' doesn't exist.`);
        }
        const startTime = startMark.getStartTime();
        const endTime = endMark.getStartTime();
        const duration = endTime - startTime;
        const measurement = new entries_1.Measurement(`${markName}`, PerformanceMeasurementAPI.now(), duration);
        PerformanceMeasurementAPI.entries.push(measurement);
    }
    static getEntries() {
        return PerformanceMeasurementAPI.entries;
    }
    static getEntriesByName(name) {
        const filtered = PerformanceMeasurementAPI.entries.filter((entry) => entry.name === name);
        return filtered;
    }
    static getEntriesByNameType(name, type) {
        const filtered = PerformanceMeasurementAPI.entries.filter((entry) => entry.name === name && entry.type === type);
        return filtered;
    }
    static getEntriesByType(type) {
        const filtered = PerformanceMeasurementAPI.entries.filter((entry) => entry.type === type);
        return filtered;
    }
    static getMeasurementDuration(name) {
        const entry = PerformanceMeasurementAPI.getEntriesByNameType(name, types_1.EntryType.MEASUREMENT).slice(-1)[0];
        return entry.getDurationTime();
    }
    static clearEntries() {
        PerformanceMeasurementAPI.entries = [];
    }
}
exports.PerformanceMeasurementAPI = PerformanceMeasurementAPI;
PerformanceMeasurementAPI.now = performanceNow;
PerformanceMeasurementAPI.entries = [];
PerformanceMeasurementAPI.initialize();


/***/ }),

/***/ 39540:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const types_1 = __webpack_require__(68035);
class Mark {
    constructor(name, type, startTime) {
        this.startTime = startTime;
        this.name = name;
        this.startTime = startTime;
        this.type = type;
    }
    getStartTime() {
        return this.startTime;
    }
}
exports.Mark = Mark;
class Measurement extends Mark {
    constructor(name, startTime, duration) {
        super(name, types_1.EntryType.MEASUREMENT, startTime);
        this.startTime = startTime;
        this.duration = duration;
        this.duration = duration;
    }
    getDurationTime() {
        return this.duration;
    }
}
exports.Measurement = Measurement;


/***/ }),

/***/ 68035:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var EntryType;
(function (EntryType) {
    EntryType["START_MARK"] = "START_MARK";
    EntryType["END_MARK"] = "END_MARK";
    EntryType["MEASUREMENT"] = "MEASUREMENT";
})(EntryType || (EntryType = {}));
exports.EntryType = EntryType;
class PerformanceMeasurement {
}
exports.PerformanceMeasurement = PerformanceMeasurement;


/***/ }),

/***/ 73883:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs_1 = __importDefault(__webpack_require__(57147));
const system_1 = __webpack_require__(36891);
const cloudDebugger_1 = __webpack_require__(95974);
const ux_common_utils_1 = __webpack_require__(59859);
const errorReporting_1 = __webpack_require__(65279);
class TelemetrySystem {
    static init() {
        cloudDebugger_1.debug(`start System.init`);
        TelemetrySystem.modules = system_1.processMatchingPaths(TelemetrySystem.modules);
        let pathBase = TelemetrySystem.getMatchingModulePath(module);
        cloudDebugger_1.debug(`base path: ${pathBase}`);
        if (!pathBase) {
            TelemetrySystem.fallbackModules = system_1.processMatchingPaths(TelemetrySystem.fallbackModules);
            pathBase = TelemetrySystem.getMatchingModulePath(module, true);
        }
        const manifestPath = TelemetrySystem.getManifestPath(pathBase);
        cloudDebugger_1.debug(`package.json path: ${manifestPath}`);
        TelemetrySystem.manifest = TelemetrySystem.getManifestJSON(manifestPath);
    }
    static getManifestJSON(path) {
        try {
            return JSON.parse(fs_1.default.readFileSync(path, 'utf-8'));
        }
        catch (err) {
            console.log(`[Telemetry]: ${err.message}`);
            return null;
        }
    }
    static getManifestPath(pathBase) {
        let manifestPath = pathBase;
        // modify path for compiled extension in WING runtime
        // no need in case of app-gen core
        // To be investigated: I think extension path is no longer used in App studio.
        // e.g. ui5 tooling is no longer installed under 'extension'. May not need this any more.
        if (ux_common_utils_1.isAppStudio() &&
            manifestPath &&
            manifestPath.indexOf('generators') < 0 &&
            manifestPath.indexOf('deployment-generator') < 0 &&
            manifestPath.indexOf('/ux-ui5-tooling') < 0) {
            manifestPath = manifestPath.concat('/extension');
        }
        // edge case when telemetry ends up in Annotation modelers server flow and can't read extension manifest accordnigly.
        if (manifestPath && manifestPath.indexOf('language-server') > -1) {
            manifestPath = manifestPath.replace(/\/([^/]+)\/?$/, '/ide-extension');
        }
        // This is the case of locally built bundle, the base path
        // looks like /.../app-generator/fiori/generators/deployment-generator
        // No @sap/generator-fiori is involved in the path.
        if (manifestPath &&
            manifestPath.indexOf('generators') > -1 &&
            manifestPath.indexOf('@sap/generator-fiori') < 0) {
            if (manifestPath.indexOf('deployment-generator') > -1) {
                manifestPath = `${manifestPath}/telemetry`;
            }
            else {
                manifestPath = manifestPath.slice(0, manifestPath.lastIndexOf('/'));
            }
        }
        // E.g. path /.../node_modules/@sap/generator-fiori/generators/core
        // We should not look for package.json of wrapper generator. Instead
        // We should copy FE package.json at /.../node_modules/@sap/generator-fiori/core/telemetry.
        // Same for freestyle and deployment-generator bundled in the wrapper generator
        if (manifestPath && manifestPath.indexOf('@sap/generator-fiori') > -1) {
            manifestPath = `${manifestPath}/telemetry`;
        }
        if (manifestPath) {
            return `${manifestPath}/package.json`;
        }
        else {
            return '';
        }
    }
    /**
     *
     * @param module - module to check its filepath for match against matching
     * @param useFallbackModules - flag to use fallback modules for matching
     */
    static getMatchingModulePath(module, useFallbackModules) {
        // use files parent directory when telemetry is bundled in host
        let modulePath = module.filename || __dirname;
        if ((modulePath === null || modulePath === void 0 ? void 0 : modulePath.indexOf('\\')) > -1) {
            modulePath = modulePath.replace(/\\/g, '/');
        }
        const matchingPaths = useFallbackModules ? TelemetrySystem.fallbackModules : TelemetrySystem.modules;
        const matchingPath = TelemetrySystem.matchModule(modulePath, matchingPaths);
        if (!matchingPath && module.parent) {
            return TelemetrySystem.getMatchingModulePath(module.parent, useFallbackModules);
        }
        else {
            return matchingPath;
        }
    }
    static matchModule(modulePath, matchingPaths) {
        let path = null;
        matchingPaths.forEach((module) => {
            module.patterns.forEach((patternRegExp) => {
                const matchToken = modulePath === null || modulePath === void 0 ? void 0 : modulePath.match(patternRegExp);
                if (matchToken && matchToken.length > 0) {
                    path = matchToken[0];
                    TelemetrySystem.WORKSTREAM = module.workStream;
                }
            });
        });
        return path;
    }
}
exports.TelemetrySystem = TelemetrySystem;
TelemetrySystem.modules = [
    {
        workStream: 'extension',
        patterns: ['ide-extension', 'sap-ux-[\\w-.@]+']
    },
    {
        workStream: 'core',
        patterns: ['core']
    }
];
// fallback module to preform lookup for extension manifest
// when telemetry being invoked separate process (annotation-modeler /core; app-gen /core in yeoman-UI)
TelemetrySystem.fallbackModules = [
    {
        workStream: 'extension',
        patterns: ['language-server[\\w.-]*']
    },
    {
        workStream: 'core',
        patterns: ['generators', 'project-generator', 'deployment-generator', 'ux-ui5-tooling']
    }
];
try {
    TelemetrySystem.init();
}
catch (err) {
    errorReporting_1.reportRuntimeError(err);
}


/***/ }),

/***/ 69599:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const system_1 = __webpack_require__(73883);
/**
 * Initialize telemetry settings for the module that uses telemetry lib
 * @param {TelemetryInitSettings} options
 */
exports.initTelemetrySettings = (options) => {
    system_1.TelemetrySystem.initSettings = options;
};


/***/ }),

/***/ 34574:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const process_1 = __importDefault(__webpack_require__(77282));
const os_1 = __importDefault(__webpack_require__(22037));
const fs_1 = __importDefault(__webpack_require__(57147));
const path_1 = __importDefault(__webpack_require__(71017));
const system_1 = __webpack_require__(73883);
const cloudDebugger_1 = __webpack_require__(95974);
const ux_common_utils_1 = __webpack_require__(59859);
const definePath = (paths) => {
    const platform = process_1.default.platform;
    let settingsPath = paths[platform];
    if (ux_common_utils_1.isAppStudio()) {
        settingsPath = paths.theia;
    }
    if (!settingsPath) {
        console.error('no path for current OS is provided - ', platform);
        return null;
    }
    const homedir = os_1.default.homedir();
    return path_1.default.join(homedir, settingsPath);
};
const readSettings = (settingsPath) => {
    const content = fs_1.default.readFileSync(settingsPath, 'utf-8');
    return JSON.parse(content);
};
const GENERAL_TELEMETRY_KEY = 'telemetry.enableTelemetry';
const verifyTelemetrySettings = (settingsPath, extensionSettingKey, extensionSettingDefault) => {
    const settings = readSettings(settingsPath);
    let generalTelemetryEnabled = settings[GENERAL_TELEMETRY_KEY];
    let extensionTelemetryEnabled = settings[extensionSettingKey];
    // settings for both - general and extensions specific
    // are true by default, and if they remain unchaged or defaulty
    // they they'r not listed in settings json
    // therefore variable values for ext. specific and general telemetry
    // are set to default values
    if (generalTelemetryEnabled === undefined) {
        generalTelemetryEnabled = true;
    }
    if (extensionTelemetryEnabled === undefined) {
        extensionTelemetryEnabled = extensionSettingDefault;
    }
    cloudDebugger_1.debug(`Telemetry Setting: ${generalTelemetryEnabled}, Extension Level: ${extensionTelemetryEnabled}`);
    system_1.TelemetrySystem.telemetryEnabled = generalTelemetryEnabled && extensionTelemetryEnabled;
};
const actOnSettingsFileExistance = (settingsPath, existsCallback, missingCallback) => {
    if (fs_1.default.existsSync(settingsPath)) {
        existsCallback();
    }
    else {
        missingCallback();
    }
};
exports.extensionSettingsInit = () => {
    const manifest = system_1.TelemetrySystem.manifest;
    const extensionManifestContributes = manifest.contributes;
    // re-throw these 2 so devs could see it
    if (!extensionManifestContributes.configuration) {
        throw new Error('Missing configuration field under contributes of extension manifest');
    }
    if (!extensionManifestContributes.configuration.id) {
        throw new Error('Missing id field under contributes.configuration key of extension manifest');
    }
    const extensionSettingKey = extensionManifestContributes.configuration.id + '.enableTelemetry';
    cloudDebugger_1.debug(`Extension setting property: ${extensionSettingKey}`);
    const extensionSettingDefault = extensionManifestContributes.configuration.properties[extensionSettingKey].default;
    cloudDebugger_1.debug(`Default Telemetry setting: ${extensionSettingDefault}`);
    const paths = {
        win32: '\\AppData\\Roaming\\Code\\User',
        darwin: '/Library/Application Support/Code/User',
        linux: '/.config/Code/User',
        theia: '/.theia'
    };
    const dirPath = definePath(paths);
    cloudDebugger_1.debug(`User setting.json: ${dirPath}`);
    if (!dirPath) {
        return;
    }
    const settingsPath = path_1.default.join(dirPath, 'settings.json');
    const onSettingsExists = () => {
        verifyTelemetrySettings(settingsPath, extensionSettingKey, extensionSettingDefault);
        fs_1.default.watchFile(settingsPath, () => {
            verifyTelemetrySettings(settingsPath, extensionSettingKey, extensionSettingDefault);
        });
    };
    const onSettingsMissing = () => {
        system_1.TelemetrySystem.telemetryEnabled = extensionSettingDefault;
        if (!fs_1.default.existsSync(dirPath)) {
            return;
        }
        const dirWatcher = fs_1.default.watch(dirPath, (event, filename) => {
            if (filename !== 'settings.json') {
                return;
            }
            actOnSettingsFileExistance(settingsPath, () => {
                onSettingsExists();
                dirWatcher.close();
            }, () => {
                system_1.TelemetrySystem.telemetryEnabled = extensionSettingDefault;
            });
        });
    };
    actOnSettingsFileExistance(settingsPath, onSettingsExists, onSettingsMissing);
};


/***/ }),

/***/ 82734:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(43009));
__export(__webpack_require__(77648));
__export(__webpack_require__(25422));
__export(__webpack_require__(17878));


/***/ }),

/***/ 43009:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const appInsightClient_1 = __webpack_require__(33313);
const toolsSuiteTelemetry_1 = __webpack_require__(82734);
const date_1 = __webpack_require__(55818);
class ToolsSuiteTelemetryClient extends appInsightClient_1.ApplicationInsightClient {
    /**
     *
     * @param applicationKey Application key to identify the Azure Application Insight resource
     * @param extensionName Unique name of the extension in the format of {publisher}.{extension}
     * @param extensionVersion Conventional version number of the extension
     */
    constructor(applicationKey, extensionName, extensionVersion) {
        super(applicationKey, extensionName, extensionVersion);
    }
    /**
     * Send a telemetry event to Azure Application Insights
     * @param eventName Categorize the type of the event within the scope of an extension.
     * @param properties A set of string properties to be reported
     * @param measurements  A set of numeric measurements to be reported
     * @param sampleRate Sampling the event to be sent
     * @param telemetryHelperProperties Properties that are passed to the processCommonPropertiesHelper function to assit generate project specific telemetry data
     * @param ignoreSettings Ignore telemetryEnabled settings and skip submitting telemetry data
     */
    async report(eventName, properties, measurements, sampleRate, telemetryHelperProperties, ignoreSettings) {
        const commonProperties = await toolsSuiteTelemetry_1.processToolsSuiteTelemetry(telemetryHelperProperties);
        const finalProperties = {
            ...properties,
            ...commonProperties,
            v: this.extensionVersion,
            datetime: date_1.localDatetimeToUTC()
        };
        await super.report(eventName, finalProperties, measurements, sampleRate, telemetryHelperProperties, ignoreSettings);
    }
}
exports.ToolsSuiteTelemetryClient = ToolsSuiteTelemetryClient;


/***/ }),

/***/ 77648:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * A callback function to be called by generic telemetry API. It takes the init settings options
 * passed to initTelemetrySettings API call, as well as properties and measurements passed to
 * ClientFactory.getTelemetryClient().report() as input. The output is specific properties and
 * measurements that are common th the tools suite telemetry events. These common
 * properties and measurements are then attached to every telemetry event.
 * @returns
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ux_common_utils_1 = __webpack_require__(59859);
const axios_1 = __importDefault(__webpack_require__(61674));
const fs_1 = __importDefault(__webpack_require__(57147));
const path_1 = __importDefault(__webpack_require__(71017));
const yaml_1 = __importDefault(__webpack_require__(87985));
const utils_1 = __webpack_require__(54935);
const capProject_1 = __webpack_require__(62112);
const types_1 = __webpack_require__(17878);
const ux_feature_toggle_1 = __webpack_require__(69513);
/**
 * @param initSettings Pass to initTelemetrySettings() api
 *  - internalFeaturesEnabled
 * @param telemetryHelperProperties Pass to report ApplicationInsightClient.report()
 *  - appPath
 * @returns
 */
async function processToolsSuiteTelemetry(telemetryHelperProperties) {
    const commonProperties = {};
    commonProperties[types_1.CommonProperties.DevSpace] = await getSbasDevspace();
    commonProperties[types_1.CommonProperties.AppStudio] = `${ux_common_utils_1.isAppStudio()}`;
    commonProperties[types_1.CommonProperties.AppStudioBackwardCompatible] = commonProperties[types_1.CommonProperties.AppStudio];
    commonProperties[types_1.CommonProperties.InternlVsExternal] = getInternalVsExternal();
    commonProperties[types_1.CommonProperties.InternlVsExternalBackwardCompatible] =
        commonProperties[types_1.CommonProperties.InternlVsExternal];
    let appProperties = {};
    if (telemetryHelperProperties) {
        appProperties = await getAppProperties(telemetryHelperProperties['appPath']);
    }
    const finalProperties = { ...commonProperties, ...appProperties };
    return finalProperties;
}
exports.processToolsSuiteTelemetry = processToolsSuiteTelemetry;
/**
 * Obtain dev space type from SBAS rest api.
 * @returns SBAS Dev Space Name. Empty string is returned if unable to fetch workspace type or the environment is not SBAS
 */
async function getSbasDevspace() {
    var _a, _b;
    if (ux_common_utils_1.isAppStudio()) {
        const h20Url = process.env.H2O_URL;
        const workspaceId = process.env.WORKSPACE_ID.replace('workspaces-', '');
        const url = `${h20Url}/destinations/ws-manager/api/v1/workspace/${workspaceId}`;
        try {
            const response = await axios_1.default.get(url);
            if (response.data) {
                const workspaceConfig = response.data;
                const devspace = (_b = (_a = workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.config) === null || _a === void 0 ? void 0 : _a.annotations) === null || _b === void 0 ? void 0 : _b.pack;
                return devspace ? devspace : '';
            }
        }
        catch (error) {
            // handling error
        }
    }
    return '';
}
/**
 * Feature to be implemented in next US #16043
 * @param appPath
 * @returns Properties to be append to properties in telemetry event
 */
async function getAppProperties(appPath) {
    if (!appPath) {
        return {};
    }
    const templateType = await getTemplateType(appPath);
    const deployTarget = await getDeployTarget(appPath);
    const odataSource = await getODataSource(appPath);
    const output = {};
    output[types_1.CommonProperties.TemplateType] = templateType;
    output[types_1.CommonProperties.DeployTargetType] = deployTarget;
    output[types_1.CommonProperties.ODataSourceType] = odataSource;
    return output;
}
/**
 * Read template type from README.md of an Fiori app. This will be improved once we have the floor
 * plan information added to e.g. manifest.json of generated app.
 * @param appPath Root folder path of Fiori app
 * @returns Template type used in the Fiori app
 */
async function getTemplateType(appPath) {
    const readmeFilePath = path_1.default.join(appPath, 'README.md');
    if (fs_1.default.existsSync(readmeFilePath)) {
        const readmeContent = await fs_1.default.promises.readFile(readmeFilePath, 'utf-8');
        if (readmeContent) {
            let templateType = '';
            const lines = readmeContent.split(/\r?\n/);
            for (const line of lines) {
                // Check if the line matches the pattern |**Floorplan Used**<br>{{TemplateType}}|
                const match = line.match(/\|\*\*Floorplan Used\*\*<br>.*\|/g);
                if (match && match.length > 0) {
                    // Extract {{TemplateType}} from the matching pattern
                    // templateType = line.match(/[^|**Floorplan Used**<br>].*[^|]/g)[0];
                    templateType = line
                        .replace('|**Floorplan Used**<br>', '')
                        .replace('|', '')
                        .trim();
                    break;
                }
            }
            return templateType;
        }
    }
    return '';
}
/**
 * Find OData Source type of a given app folder path.
 * @param appPath Root folder path of Fiori app
 * @returns Project Type ABAP | CAPJava | CAPNode | UNKNOWN
 */
async function getODataSource(appPath) {
    try {
        // First attempt: Loop up a folder that contain a pacakge.json that has sapux property as project root
        // If appPath has package.json that contains sapux, it is EDMX project type and we derive odata source
        // is ABAP.
        let projectRoot;
        try {
            projectRoot = await utils_1.findProjectRoot(appPath);
        }
        catch {
            // No project root can be found
        }
        // Second attempt: For FF app, package.json does not have sapux property. Try to find the
        // first parent folder that contain pacakge.json as CAP root. If no such folder exists,
        // use appPath as project root.
        if (!projectRoot) {
            try {
                const appParentFolder = path_1.default.dirname(appPath);
                projectRoot = await utils_1.findProjectRoot(appParentFolder, false);
            }
            catch (e) {
                // No project root can be found at parent folder.
            }
        }
        // Third attempt: CAPJava that doesn't have package.json at project root. We assume
        // the project has default structure <projectRoot>/app/<appPath>, and use parent folder
        // path two levels above appPath as projectRoot. This should cover most cases until we have
        // a better solution
        let isCapJavaWithoutPackageJson = false;
        if (!projectRoot) {
            const directParentFolder = path_1.default.dirname(appPath);
            const twoLevelUpParentFolder = path_1.default.dirname(directParentFolder);
            isCapJavaWithoutPackageJson = await capProject_1.isCapJavaProject(twoLevelUpParentFolder);
            projectRoot = isCapJavaWithoutPackageJson ? twoLevelUpParentFolder : appPath;
        }
        if (isCapJavaWithoutPackageJson) {
            return types_1.ODataSource.CAPJava;
        }
        const projectType = await utils_1.getProjectType(projectRoot);
        if (projectType === "Cap" /* Cap */) {
            if (await capProject_1.isCapJavaProject(projectRoot)) {
                return types_1.ODataSource.CAPJava;
            }
            else if (await capProject_1.isCapNodeJsProject(projectRoot)) {
                return types_1.ODataSource.CAPNode;
            }
        }
        else if (projectType === "Edmx" /* Edmx */) {
            return types_1.ODataSource.ABAP;
        }
    }
    catch (e) {
        return types_1.ODataSource.UNKNOWN;
    }
}
/**
 * Read ui5-deploy.yaml to decide if it is CF or ABAP deploy target
 * @param appPath  appPath Root folder path of Fiori app
 * @returns CF | ABAP | NO_DEPLOY_CONFIG | UNKNOWN_DEPLOY_CONFIG
 */
async function getDeployTarget(appPath) {
    var _a;
    const deployConfigPath = path_1.default.join(appPath, 'ui5-deploy.yaml');
    if (fs_1.default.existsSync(deployConfigPath)) {
        const deployConfigContent = await fs_1.default.promises.readFile(deployConfigPath, 'utf-8');
        const deployConfig = yaml_1.default.parse(deployConfigContent);
        const customTasks = (_a = deployConfig === null || deployConfig === void 0 ? void 0 : deployConfig.builder) === null || _a === void 0 ? void 0 : _a.customTasks;
        let isAbapReployTarget = false;
        if (customTasks) {
            for (const customTask of customTasks) {
                if (customTask.name === 'deploy-to-abap') {
                    isAbapReployTarget = true;
                    break;
                }
            }
            return isAbapReployTarget ? types_1.DeployTarget.ABAP : types_1.DeployTarget.CF;
        }
        else {
            return types_1.DeployTarget.UNKNOWN_DEPLOY_CONFIG;
        }
    }
    return types_1.DeployTarget.NO_DEPLOY_CONFIG;
}
/**
 * Convert init setting property internalFeaturesEnabled to string value.
 * @returns String value 'internal' | 'external' to be backward compatible with existing telemetry data format.
 */
function getInternalVsExternal() {
    return ux_feature_toggle_1.isInternalFeaturesSettingEnabled() ? 'internal' : 'external';
}


/***/ }),

/***/ 25422:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const telemetrySettings_1 = __webpack_require__(69599);
const errorReporting_1 = __webpack_require__(65279);
const extensionInit_1 = __webpack_require__(34574);
const cloudDebugger_1 = __webpack_require__(95974);
const system_1 = __webpack_require__(73883);
const isExtensionModule = (packageJson) => {
    return (packageJson['contributes'] || packageJson['activationEvents'] || packageJson.name.match(/sap-ux-.*-extension/g));
};
const validateDisableTelemetrySetting = (disableTelemetry) => {
    if (disableTelemetry === undefined) {
        throw new Error('Telemetry enablement flag is missing');
    }
    system_1.TelemetrySystem.telemetryEnabled = !disableTelemetry;
};
const initToolsSuiteTelemetrySettings = (options) => {
    cloudDebugger_1.debug('start initTelemetrySettings');
    if (!system_1.TelemetrySystem.WORKSTREAM) {
        throw new Error('Workstream is undefined');
    }
    cloudDebugger_1.debug(`workstream: ${system_1.TelemetrySystem.WORKSTREAM}`);
    switch (system_1.TelemetrySystem.WORKSTREAM) {
        case 'extension': {
            extensionInit_1.extensionSettingsInit();
            break;
        }
        case 'core':
        default: {
            validateDisableTelemetrySetting(options.disableTelemetry);
            break;
        }
    }
};
const initWithInputManifest = (options) => {
    system_1.TelemetrySystem.WORKSTREAM = isExtensionModule(options.modulePackageJson) ? 'extension' : 'core';
    system_1.TelemetrySystem.manifest = options.modulePackageJson;
    initToolsSuiteTelemetrySettings(options);
};
/**
 * Telemetry API function to init settings.
 * @param options
 */
exports.initTelemetrySettings = (options) => {
    telemetrySettings_1.initTelemetrySettings(options);
    try {
        if (options.modulePackageJson) {
            initWithInputManifest(options);
        }
        else {
            initToolsSuiteTelemetrySettings(options);
        }
    }
    catch (err) {
        errorReporting_1.reportRuntimeError(err);
    }
};


/***/ }),

/***/ 17878:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ODataSource;
(function (ODataSource) {
    ODataSource["CAPJava"] = "CAPJava";
    ODataSource["CAPNode"] = "CAPNode";
    ODataSource["ABAP"] = "ABAP";
    ODataSource["UNKNOWN"] = "UNKNOWN";
})(ODataSource = exports.ODataSource || (exports.ODataSource = {}));
var DeployTarget;
(function (DeployTarget) {
    DeployTarget["CF"] = "CF";
    DeployTarget["ABAP"] = "ABAP";
    DeployTarget["UNKNOWN_DEPLOY_CONFIG"] = "UNKNOWN_DEPLOY_CONFIG";
    DeployTarget["NO_DEPLOY_CONFIG"] = "NO_DEPLOY_CONFIG";
})(DeployTarget = exports.DeployTarget || (exports.DeployTarget = {}));
var CommonProperties;
(function (CommonProperties) {
    CommonProperties["DevSpace"] = "cmn.devspace";
    CommonProperties["AppStudio"] = "cmn.appstudio";
    CommonProperties["AppStudioBackwardCompatible"] = "appstudio";
    CommonProperties["InternlVsExternal"] = "cmn.internalFeatures";
    CommonProperties["InternlVsExternalBackwardCompatible"] = "internalVsExternal";
    CommonProperties["TemplateType"] = "cmn.template";
    CommonProperties["DeployTargetType"] = "cmn.deployTarget";
    CommonProperties["ODataSourceType"] = "cmn.odataSource";
})(CommonProperties = exports.CommonProperties || (exports.CommonProperties = {}));


/***/ }),

/***/ 95974:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs_1 = __importDefault(__webpack_require__(57147));
const os_1 = __importDefault(__webpack_require__(22037));
const path_1 = __importDefault(__webpack_require__(71017));
const homedir = os_1.default.homedir();
const debugFilePath = path_1.default.join(homedir, 'theiadebug.txt');
exports.debug = (message, active = false) => {
    if (active) {
        fs_1.default.appendFileSync(debugFilePath, `${message}\n`, 'utf8');
    }
};


/***/ }),

/***/ 55818:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.localDatetimeToUTC = () => {
    const timeInMs = new Date().getTime();
    return new Date(timeInMs).toISOString();
};


/***/ }),

/***/ 65279:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const EventName_1 = __webpack_require__(70181);
const appInsights = __importStar(__webpack_require__(14585));
const telemetryPackageJSON = __importStar(__webpack_require__(18622));
const telemetryClientConfig_1 = __webpack_require__(50712);
const parseErrorStack = (errorStack) => {
    const regexps = [/sap-ux.+/gi, /[a-zA-Z-]+\/ide-extension\/.+/gi, /(\/telemetry\/.+)/gi];
    const parsedStack = [];
    const filtered = errorStack.split('\n').filter((line) => !!line.match(/^\s*at .*(\S+:\d+|\(native\))/m));
    if (!filtered.length) {
        return parsedStack;
    }
    filtered.forEach((line) => {
        let sanitizedLine = line.replace(/^\s+/, '');
        const location = line.match(/ (\((.+):(\d+):(\d+)\)$)/);
        if (!location) {
            return;
        }
        let filepath = null;
        const normalizedFilepath = location[2].replace(/\\/g, '/');
        for (const regexp of regexps) {
            const match = normalizedFilepath.match(regexp);
            if (match) {
                filepath = match[0];
                break;
            }
        }
        if (!filepath) {
            return;
        }
        sanitizedLine = sanitizedLine.replace(location[0], '');
        const functionName = sanitizedLine
            .split(/\s+/)
            .slice(1)
            .join('');
        const lineNumber = location[3];
        const columnNumber = location[4];
        const parsedStackLine = `${functionName} at (${filepath}:${lineNumber}:${columnNumber});`;
        parsedStack.push(parsedStackLine);
    });
    return parsedStack;
};
const errorReportingTelemetryClient = new appInsights.TelemetryClient(telemetryPackageJSON.azureInstrumentationKey);
telemetryClientConfig_1.configAzureTelemetryClient(errorReportingTelemetryClient);
exports.reportRuntimeError = (error) => {
    const properties = { message: error.message };
    if (error.stack) {
        const parsedStack = parseErrorStack(error.stack);
        if (parsedStack.length) {
            properties.stack = parsedStack.join(' \n');
        }
    }
    const telemetryEvent = {
        name: EventName_1.EventName.TELEMETRY_SETTINGS_INIT_FAILED,
        properties,
        measurements: {}
    };
    errorReportingTelemetryClient.trackEvent(telemetryEvent);
};


/***/ }),

/***/ 21677:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class ParamRecordConfigField {
    constructor(path) {
        this.path = path;
    }
}
exports.ParamRecordConfigField = ParamRecordConfigField;
class ParamRecordConfig {
    /**
     *
     * @param key - string or undefined;
     * When string set as key of new field;
     * When undefined key of new field set to - 'data';
     *
     * @param value - instance of ParamReParamRecordConfigFieldcordConfig, string or undefined;
     * When instance of ParamRecordConfigField data gets extracted from specified path of parameter under index specified in @param paramIndex;
     * When string set as value of new field;
     * When undefined - new fields value being set as parameter under index of @param paramIndex;
     *
     * @param paramIndex - optional, number or undefined;
     * When number - speicifes index of parameter to capture or extract data from;
     * Set to undefined when want to use strin passed as @param value as new fields value;
     */
    constructor(key = undefined, value = undefined, paramIndex = undefined) {
        this.key = key;
        this.value = value;
        this.paramIndex = paramIndex;
    }
}
exports.ParamRecordConfig = ParamRecordConfig;
exports.wrongPathErr = (field, index) => new Error(`Wrong path for '${field}' field is specified in instructions with index - ${index}`);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.getValue = (obj, path, field, paramIndex) => {
    const pathArr = path.split('/');
    let node = obj, i = 0;
    while (i < pathArr.length) {
        node = node[pathArr[i]];
        if (node === undefined) {
            throw exports.wrongPathErr(field, paramIndex);
        }
        i++;
    }
    return node;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.paramsProcessing = (params, instructions) => {
    const processedDimensions = {};
    const processedMeasurements = {};
    let param = null; // eslint-disable-line @typescript-eslint/no-explicit-any
    if (instructions.paramIndex !== undefined) {
        param = params[instructions.paramIndex];
    }
    const key = instructions.key ? instructions.key : 'data';
    let val = '';
    if (typeof instructions.value === 'string') {
        val = instructions.value;
    }
    else if (instructions.value !== undefined && instructions.paramIndex !== undefined) {
        val = exports.getValue(param, instructions.value.path, 'val', instructions.paramIndex);
    }
    else {
        val = param;
    }
    if (!isNaN(val)) {
        processedMeasurements[key] = val;
    }
    else {
        processedDimensions[key] = val;
    }
    return [processedDimensions, processedMeasurements];
};
exports.getParamsData = (params, // eslint-disable-line @typescript-eslint/no-explicit-any
instructions) => {
    let processedDimensions, processedMeasurements;
    let customDimensions = {};
    let customMeasurements = {};
    if (Array.isArray(instructions)) {
        for (const instruction of instructions) {
            [processedDimensions, processedMeasurements] = exports.paramsProcessing(params, instruction);
            customDimensions = {
                ...customDimensions,
                ...processedDimensions
            };
            customMeasurements = {
                ...customMeasurements,
                ...processedMeasurements
            };
        }
    }
    else {
        [customDimensions, customMeasurements] = exports.paramsProcessing(params, instructions);
    }
    return [customDimensions, customMeasurements];
};


/***/ }),

/***/ 36891:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processMatchingPaths = (matchingPaths) => {
    const matchPaths = matchingPaths;
    matchPaths.forEach((matchingPath) => {
        matchingPath.patterns = matchingPath.patterns.map((pattern) => new RegExp(`[\\w\\s-./:@!]+${pattern}`, 'gi'));
    });
    return matchPaths;
};


/***/ }),

/***/ 50712:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function configAzureTelemetryClient(client) {
    client.channel.setUseDiskRetryCaching(true);
    // disabling GDPR sensitive data collection.
    client.addTelemetryProcessor((envelope) => {
        envelope.tags['ai.location.ip'] = '0.0.0.0';
        envelope.tags['ai.cloud.roleInstance'] = 'masked';
        envelope.tags['ai.cloud.role'] = 'masked';
        envelope.tags['ai.device.type'] = 'masked';
        return true;
    });
}
exports.configAzureTelemetryClient = configAzureTelemetryClient;


/***/ }),

/***/ 42745:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path_1 = __webpack_require__(71017);
const fs_1 = __webpack_require__(57147);
const ux_i18n_properties_1 = __webpack_require__(55203);
const resolve_1 = __webpack_require__(96749);
const utils_1 = __webpack_require__(8655);
const json_1 = __webpack_require__(34692);
const csv_1 = __webpack_require__(98944);
/**
 * Adds new i18n entries to an existing file or in a new file if one does not exist
 * @param env CDS environment configuration
 * @param root project root, where i18n folder should reside if no i18n file exists
 * @param path path to cds file for which translation should be maintained
 * @param newI18nEntries new i18n entries that will be maintained
 */
async function addI18nEntriesForCdsFile(env, root, path, newI18nEntries) {
    const { folders, baseFileName } = utils_1.getI18nConfiguration(env);
    let i18nFolderPath = resolve_1.resolveI18nFolderForFile(env, path_1.join(root, path));
    if (!i18nFolderPath) {
        const folder = folders[0];
        i18nFolderPath = path_1.join(root, folder);
        await fs_1.promises.mkdir(i18nFolderPath);
    }
    const updaters = [tryAddJsonTexts, tryAddPropertiesTexts, tryAddCsvTexts];
    const filePath = path_1.join(i18nFolderPath, baseFileName);
    for (const update of updaters) {
        const completed = await update(env, filePath, newI18nEntries);
        if (completed) {
            break;
        }
    }
}
exports.addI18nEntriesForCdsFile = addI18nEntriesForCdsFile;
async function tryAddJsonTexts(env, path, newI18nEntries) {
    const { fallbackLanguage } = utils_1.getI18nConfiguration(env);
    try {
        const i18nFilePath = utils_1.jsonPathFormatter(path);
        const content = await fs_1.promises.readFile(i18nFilePath, { encoding: 'utf8' });
        const newContent = json_1.addJsonTexts(content, fallbackLanguage, newI18nEntries);
        await fs_1.promises.writeFile(i18nFilePath, newContent, { encoding: 'utf8' });
    }
    catch (error) {
        if ((error === null || error === void 0 ? void 0 : error.code) === 'ENOENT') {
            return false;
        }
        else {
            throw error;
        }
    }
    return true;
}
async function tryAddPropertiesTexts(env, path, newI18nEntries) {
    const i18nFilePath = utils_1.propertiesPathFormatter(path, env);
    let newContent = newI18nEntries
        .map((entry) => ux_i18n_properties_1.printPropertiesFileI18nEntry(entry.key, entry.value, entry.annotation))
        //No need join with new line, because it is already added in 'printPropertiesFileI18nEntry'
        .join('');
    try {
        const content = await fs_1.promises.readFile(i18nFilePath, { encoding: 'utf8' });
        const lines = content.split(/\r\n|\n/);
        // check if file does not end with new line
        if (lines.length > 0 && lines[lines.length - 1].trim()) {
            // If there no end line - add new gap line before new content
            newContent = `\n${newContent}`;
        }
        await fs_1.promises.writeFile(i18nFilePath, content.concat(newContent), { encoding: 'utf8' });
    }
    catch (error) {
        if ((error === null || error === void 0 ? void 0 : error.code) === 'ENOENT') {
            const completed = await tryAddCsvTexts(env, path, newI18nEntries);
            if (!completed) {
                await fs_1.promises.writeFile(i18nFilePath, newContent, { encoding: 'utf8' });
                return true;
            }
            return true;
        }
        else {
            throw error;
        }
    }
    return true;
}
async function tryAddCsvTexts(env, path, newI18nEntries) {
    const { defaultLanguage } = utils_1.getI18nConfiguration(env);
    try {
        const i18nFilePath = utils_1.csvPathFormatter(path);
        const content = await fs_1.promises.readFile(i18nFilePath, { encoding: 'utf8' });
        const newContent = csv_1.addCsvTexts(content, defaultLanguage, newI18nEntries);
        await fs_1.promises.writeFile(i18nFilePath, newContent, { encoding: 'utf8' });
    }
    catch (error) {
        if ((error === null || error === void 0 ? void 0 : error.code) === 'ENOENT') {
            return false;
        }
        else {
            throw error;
        }
    }
    return true;
}


/***/ }),

/***/ 98944:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_languageserver_textdocument_1 = __webpack_require__(61096);
const ux_i18n_properties_1 = __webpack_require__(55203);
const csvParser_1 = __webpack_require__(34521);
const utils_1 = __webpack_require__(8655);
function loadCsvTexts(text, filePath = '') {
    const bundle = {};
    const document = csvParser_1.parseCsv(text);
    for (let columnIndex = 1; columnIndex < document.header.fields.length; columnIndex++) {
        const locale = document.header.fields[columnIndex];
        const entries = [];
        bundle[locale.value] = entries;
        for (let i = 0; i < document.rows.length; i++) {
            const row = document.rows[i];
            if (row) {
                const key = toTextNode(row.fields[0]);
                const value = toTextNode(row.fields[columnIndex]);
                if (key && value) {
                    entries.push({
                        filePath,
                        key,
                        value
                    });
                }
            }
        }
    }
    return bundle;
}
exports.loadCsvTexts = loadCsvTexts;
function addCsvTexts(text, fallbackLocale, newEntries) {
    const csvDocument = csvParser_1.parseCsv(text);
    const eol = utils_1.discoverLineEnding(text);
    const headerFields = csvDocument.header.fields;
    const fallbackFieldIndex = headerFields.findIndex((field) => field.value === fallbackLocale);
    if (fallbackFieldIndex !== -1) {
        let newText = '';
        for (const entry of newEntries) {
            newText += `${entry.key};`;
            for (let column = 1; column < headerFields.length; column++) {
                const columnHeader = headerFields[column];
                if (columnHeader.value === fallbackLocale) {
                    newText += `${entry.value}`;
                }
                if (column + 1 !== headerFields.length) {
                    newText += ';';
                }
            }
            newText += eol;
        }
        if (text.endsWith(eol)) {
            return text + newText;
        }
        else {
            return text + eol + newText;
        }
    }
    else if (headerFields.length === 0) {
        let newText = `key;${fallbackLocale}${eol}`;
        for (const entry of newEntries) {
            newText += `${entry.key};${entry.value}${eol}`;
        }
        return text + newText;
    }
    else {
        const document = vscode_languageserver_textdocument_1.TextDocument.create('', '', 0, text);
        const edits = [];
        edits.push({
            newText: `;${fallbackLocale}`,
            range: ux_i18n_properties_1.Range.create(0, csvDocument.header.range.end.character, 0, csvDocument.header.range.end.character)
        });
        for (const row of csvDocument.rows) {
            edits.push({
                newText: `;`,
                range: ux_i18n_properties_1.Range.create(row.range.end, row.range.end)
            });
        }
        let newText = `${eol}`;
        for (const entry of newEntries) {
            newText += `${entry.key};`;
            for (let column = 1; column < headerFields.length; column++) {
                newText += ';';
            }
            newText += `${entry.value}${eol}`;
        }
        const lastRow = csvDocument.rows.slice(-1)[0];
        const position = lastRow ? lastRow.range.end : ux_i18n_properties_1.Position.create(1, 0);
        edits.push({
            newText,
            range: ux_i18n_properties_1.Range.create(position, position)
        });
        return vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, edits);
    }
}
exports.addCsvTexts = addCsvTexts;
function toTextNode(field) {
    if (field) {
        return {
            value: field.value,
            range: field.range
        };
    }
}
function createTextNode(value, range) {
    return {
        value,
        range
    };
}
exports.createTextNode = createTextNode;


/***/ }),

/***/ 34521:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const ux_i18n_properties_1 = __webpack_require__(55203);
const SEPARATOR = /[,;\t]/;
function parseCsv(text) {
    const tokens = tokenize(text);
    const lineOffsets = ux_i18n_properties_1.getLineOffsets(text);
    const contentLength = text.length;
    let i = 0;
    const peek = (count) => (count ? tokens[i + count] : tokens[i]);
    const consume = () => tokens[i++];
    const eof = () => i >= tokens.length;
    function parseField() {
        const token = consume();
        return {
            quoted: token.type === 'escaped-text' ? true : false,
            value: token.value,
            range: ux_i18n_properties_1.Range.create(ux_i18n_properties_1.positionAt(lineOffsets, token.start, contentLength), ux_i18n_properties_1.positionAt(lineOffsets, token.end, contentLength))
        };
    }
    function parseRow() {
        var _a;
        const row = {
            fields: [],
            range: ux_i18n_properties_1.Range.create(0, 0, 0, 0)
        };
        while (!eof() && ((_a = peek()) === null || _a === void 0 ? void 0 : _a.type) !== 'eol') {
            if (peek().type === 'escaped-text' || peek().type === 'text') {
                row.fields.push(parseField());
            }
            const next = peek();
            if (next && next.type !== 'eol') {
                if (next.type === 'separator' && peek(1) === undefined) {
                    // trailing separator at the end of file
                    row.fields.push({
                        quoted: false,
                        value: '',
                        range: ux_i18n_properties_1.Range.create(ux_i18n_properties_1.positionAt(lineOffsets, next.end, contentLength), ux_i18n_properties_1.positionAt(lineOffsets, next.end, contentLength))
                    });
                }
                consume();
            }
        }
        if (row.fields.length) {
            const start = row.fields[0].range.start;
            const end = row.fields[row.fields.length - 1].range.end;
            row.range = ux_i18n_properties_1.Range.create(start.line, start.character, end.line, end.character);
        }
        return row;
    }
    function parseDocument() {
        var _a, _b;
        const document = {
            header: parseRow(),
            rows: []
        };
        while (!eof()) {
            if (((_a = peek()) === null || _a === void 0 ? void 0 : _a.type) === 'escaped-text' || ((_b = peek()) === null || _b === void 0 ? void 0 : _b.type) === 'text') {
                document.rows.push(parseRow());
            }
            consume();
        }
        return document;
    }
    return parseDocument();
}
exports.parseCsv = parseCsv;
function tokenize(text) {
    const tokens = [];
    let i = 0;
    let value = '';
    let mode = 'default';
    let start = 0;
    let lastTextTokenType = 'text';
    while (i < text.length) {
        const character = text[i];
        if (mode === 'default') {
            if (SEPARATOR.test(character) || character === '\n') {
                tokens.push({
                    type: lastTextTokenType,
                    value,
                    start,
                    end: i
                });
                if (character === '\n') {
                    tokens.push({
                        type: 'eol',
                        value: '\n',
                        start: i,
                        end: i + 1
                    });
                }
                else if (SEPARATOR.test(character)) {
                    tokens.push({
                        type: 'separator',
                        value: character,
                        start: i,
                        end: i + 1
                    });
                }
                value = '';
                start = i + 1;
                lastTextTokenType = 'text';
            }
            else if (character === '"') {
                mode = 'quoted';
            }
            else {
                value += character;
            }
        }
        else if (mode === 'quoted') {
            if (character === '"') {
                // we need to check if it is escaping next double quote
                if (i + 1 < text.length && text[i + 1] === '"') {
                    value += '"';
                    i++;
                }
                else {
                    lastTextTokenType = 'escaped-text';
                    mode = 'default';
                }
            }
            else {
                value += character;
            }
        }
        i++;
    }
    if (value) {
        tokens.push({
            type: 'text',
            value,
            start,
            end: i
        });
    }
    return tokens;
}
exports.tokenize = tokenize;


/***/ }),

/***/ 98702:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var csv_1 = __webpack_require__(98944);
exports.addCsvTexts = csv_1.addCsvTexts;
exports.loadCsvTexts = csv_1.loadCsvTexts;
var json_1 = __webpack_require__(34692);
exports.addJsonTexts = json_1.addJsonTexts;
exports.loadJsonTexts = json_1.loadJsonTexts;
var resolve_1 = __webpack_require__(96749);
exports.getI18nFolderNames = resolve_1.getI18nFolderNames;
exports.getCapI18nBundle = resolve_1.getCapI18nBundle;
var add_1 = __webpack_require__(42745);
exports.addI18nEntriesForCdsFile = add_1.addI18nEntriesForCdsFile;


/***/ }),

/***/ 34692:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const jsonc_parser_1 = __webpack_require__(48617);
const vscode_languageserver_textdocument_1 = __webpack_require__(61096);
const ux_i18n_properties_1 = __webpack_require__(55203);
const utils_1 = __webpack_require__(8655);
function loadJsonTexts(text, filePath = '') {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const bundle = {};
    const rootNode = jsonc_parser_1.parseTree(text);
    const lineOffsets = ux_i18n_properties_1.getLineOffsets(text);
    const contentLength = text.length;
    if ((rootNode === null || rootNode === void 0 ? void 0 : rootNode.type) === 'object') {
        const localeNodes = (_a = rootNode.children) !== null && _a !== void 0 ? _a : [];
        for (const localeNode of localeNodes) {
            if (localeNode.type === 'property') {
                const entries = [];
                const locale = (_d = (_c = ((_b = localeNode.children) !== null && _b !== void 0 ? _b : [])[0]) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : '';
                bundle[locale] = entries;
                const textNodes = (_g = (_f = ((_e = localeNode.children) !== null && _e !== void 0 ? _e : [])[1]) === null || _f === void 0 ? void 0 : _f.children) !== null && _g !== void 0 ? _g : [];
                for (const textNode of textNodes) {
                    if (textNode.type === 'property') {
                        const key = toTextNode(((_h = textNode.children) !== null && _h !== void 0 ? _h : [])[0], lineOffsets, contentLength);
                        const value = toTextNode(((_j = textNode.children) !== null && _j !== void 0 ? _j : [])[1], lineOffsets, contentLength);
                        entries.push({
                            filePath,
                            key,
                            value
                        });
                    }
                }
            }
        }
    }
    return bundle;
}
exports.loadJsonTexts = loadJsonTexts;
function createFullBundle(fallbackLocale, newEntries) {
    const fallbackBundle = newEntries.reduce((acc, entry) => {
        acc[entry.key] = entry.value;
        return acc;
    }, {});
    const bundle = {
        [fallbackLocale]: fallbackBundle
    };
    return bundle;
}
function addJsonTexts(text, fallbackLocale, newEntries) {
    var _a, _b, _c;
    if (text === '') {
        const bundle = createFullBundle(fallbackLocale, newEntries);
        return JSON.stringify(bundle, undefined, 4);
    }
    const rootNode = jsonc_parser_1.parseTree(text);
    if ((rootNode === null || rootNode === void 0 ? void 0 : rootNode.type) === 'object') {
        const localeNodes = (_a = rootNode.children) !== null && _a !== void 0 ? _a : [];
        const eol = utils_1.discoverLineEnding(text);
        const indent = utils_1.discoverIndent(text);
        const fallbackLocaleNode = localeNodes.find((node) => { var _a, _b; return ((_b = ((_a = node.children) !== null && _a !== void 0 ? _a : [])[0]) === null || _b === void 0 ? void 0 : _b.value) === fallbackLocale; });
        if (fallbackLocaleNode) {
            const bundleNode = ((_b = fallbackLocaleNode.children) !== null && _b !== void 0 ? _b : [])[1];
            const textNodes = (_c = bundleNode === null || bundleNode === void 0 ? void 0 : bundleNode.children) !== null && _c !== void 0 ? _c : [];
            if (textNodes.length) {
                const document = vscode_languageserver_textdocument_1.TextDocument.create('', '', 0, text);
                const position = document.positionAt(textNodes[0].offset);
                let newText = '';
                for (let i = 0; i < newEntries.length; i++) {
                    const entry = newEntries[i];
                    newText += `${indent + indent}"${entry.key}": "${entry.value}",${eol}`;
                }
                const edit = {
                    newText: newText,
                    range: ux_i18n_properties_1.Range.create(position.line, 0, position.line, 0)
                };
                return vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, [edit]);
            }
            else if (bundleNode === null || bundleNode === void 0 ? void 0 : bundleNode.offset) {
                const document = vscode_languageserver_textdocument_1.TextDocument.create('', '', 0, text);
                const start = document.positionAt(bundleNode.offset);
                const end = document.positionAt(bundleNode.offset + bundleNode.length);
                const bundle = createFullBundle(fallbackLocale, newEntries);
                const newText = JSON.stringify(bundle[fallbackLocale], undefined, indent);
                const indented = utils_1.applyIndent(`${newText}`, indent, eol, false);
                const edit = {
                    newText: indented,
                    range: ux_i18n_properties_1.Range.create(start, end)
                };
                return vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, [edit]);
            }
        }
        else if (localeNodes.length === 0) {
            const bundle = createFullBundle(fallbackLocale, newEntries);
            return JSON.stringify(bundle, undefined, 4);
        }
        else {
            const document = vscode_languageserver_textdocument_1.TextDocument.create('', '', 0, text);
            const [last] = localeNodes.slice(-1);
            const position = document.positionAt(last.offset);
            const bundle = createFullBundle(fallbackLocale, newEntries);
            const newText = JSON.stringify(bundle[fallbackLocale], undefined, indent);
            const indented = utils_1.applyIndent(`"${fallbackLocale}": ${newText},`, indent, eol);
            const edit = {
                newText: indented + eol,
                range: ux_i18n_properties_1.Range.create(position.line, 0, position.line, 0)
            };
            return vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, [edit]);
        }
    }
    return text;
}
exports.addJsonTexts = addJsonTexts;
function createTextNode(value, range) {
    return {
        value,
        range
    };
}
exports.createTextNode = createTextNode;
function toTextNode(node, lineOffsets, contentLength) {
    if (node) {
        switch (typeof node.value) {
            case 'string': {
                // for string literals node offset starts with '"' character, but we don't include it in the text node range
                const start = ux_i18n_properties_1.positionAt(lineOffsets, node.offset + 1, contentLength);
                const { value } = node;
                return createTextNode(value, ux_i18n_properties_1.Range.create(start, ux_i18n_properties_1.Position.create(start.line, start.character + value.length)));
            }
            case 'number': {
                const start = ux_i18n_properties_1.positionAt(lineOffsets, node.offset, contentLength);
                const value = node.value.toString();
                return createTextNode(value, ux_i18n_properties_1.Range.create(start, ux_i18n_properties_1.Position.create(start.line, start.character + value.length)));
            }
            case 'boolean': {
                const start = ux_i18n_properties_1.positionAt(lineOffsets, node.offset, contentLength);
                // CDS currently uses the boolean value if its true, otherwise falls back to using the key
                const value = node.value ? 'true' : '';
                return createTextNode(value, ux_i18n_properties_1.Range.create(start, ux_i18n_properties_1.Position.create(start.line, start.character + value.length)));
            }
            default: {
                const start = ux_i18n_properties_1.positionAt(lineOffsets, node.offset, contentLength);
                return createTextNode('', ux_i18n_properties_1.Range.create(start, start));
            }
        }
    }
}


/***/ }),

/***/ 96749:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path_1 = __webpack_require__(71017);
const fs_1 = __webpack_require__(57147);
const ux_i18n_properties_1 = __webpack_require__(55203);
const csv_1 = __webpack_require__(98944);
const json_1 = __webpack_require__(34692);
const utils_1 = __webpack_require__(8655);
/**
 * Returns a list of allowed i18n folder names, where translation files can be found.
 */
function getI18nFolderNames(env) {
    const { folders } = utils_1.getI18nConfiguration(env);
    return folders;
}
exports.getI18nFolderNames = getI18nFolderNames;
/**
 * Returns the location of an existing _i18n folder next to or in the
 * folder hierarchy above the given path, if any.
 * @param env CDS environment configuration
 * @param filePath CDS source file path
 * @param cache If translation file mapping should be cached
 */
function resolveI18nFolderForFile(env, filePath) {
    const { folders } = utils_1.getI18nConfiguration(env);
    function resolve(path) {
        // check whether a <path>/_i18n exists
        for (const folderName of folders) {
            const folderPath = path_1.join(path, folderName);
            if (fs_1.existsSync(folderPath)) {
                return folderPath;
            }
        }
        //> no --> search up the folder hierarchy
        const next = path_1.dirname(path);
        return next === path ? undefined : resolve(next);
    }
    return resolve(filePath);
}
exports.resolveI18nFolderForFile = resolveI18nFolderForFile;
/**
 * Merges i18n files in to a single bundle for CDS source files
 * @param env CDS environment configuration
 * @param filePaths CDS file path
 * @param logger Fiori tools logger
 */
async function getCapI18nBundle(env, filePaths, logger) {
    var _a;
    const { defaultLanguage, fallbackLanguage, baseFileName } = utils_1.getI18nConfiguration(env);
    const bundle = {};
    const i18nFiles = filePaths.reduce((acc, filePath) => {
        const i18nFolder = resolveI18nFolderForFile(env, filePath);
        if (i18nFolder) {
            const file = path_1.join(i18nFolder, baseFileName);
            if (acc.indexOf(file) === -1) {
                acc.push(file);
            }
        }
        return acc;
    }, []);
    const loaders = [
        { loader: json_1.loadJsonTexts, filePathFormatter: utils_1.jsonPathFormatter },
        {
            loader: (content, path) => ({
                [fallbackLanguage]: ux_i18n_properties_1.loadPropertiesTexts(content, path)
            }),
            filePathFormatter: utils_1.propertiesPathFormatter
        },
        { loader: csv_1.loadCsvTexts, filePathFormatter: utils_1.csvPathFormatter }
    ];
    for (const path of i18nFiles) {
        let loaded = false;
        let hasError = false;
        for (const { loader, filePathFormatter } of loaders) {
            const i18nFilePath = filePathFormatter(path, env);
            try {
                const entries = await tryLoadTexts(i18nFilePath, loader);
                if (entries) {
                    const currentBundle = (_a = entries[fallbackLanguage]) !== null && _a !== void 0 ? _a : entries[defaultLanguage];
                    for (const entry of currentBundle) {
                        if (bundle[entry.key.value]) {
                            bundle[entry.key.value].push(entry);
                        }
                        else {
                            bundle[entry.key.value] = [entry];
                        }
                    }
                    logger.info(`Loaded i18n texts from ${i18nFilePath}`);
                    loaded = true;
                    break;
                }
            }
            catch (error) {
                hasError = true;
                logger.error(`Failed to load ${i18nFilePath}. ${error === null || error === void 0 ? void 0 : error.message}`);
                break;
            }
        }
        if (!loaded && !hasError) {
            logger.error(`No translation file found in ${path_1.dirname(path)}`);
        }
    }
    return bundle;
}
exports.getCapI18nBundle = getCapI18nBundle;
async function tryLoadTexts(path, loader) {
    try {
        const content = await fs_1.promises.readFile(path, { encoding: 'utf8' });
        return loader(content, path);
    }
    catch (error) {
        if ((error === null || error === void 0 ? void 0 : error.code) === 'ENOENT') {
            return;
        }
        else {
            throw error;
        }
    }
}


/***/ }),

/***/ 8655:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const LINE_ENDING_PATTERN = /\r|\n|\r?\n/;
const INDENT_PATTERN = /(?:\r|\n|\r?\n)([\t|\s]+)/;
function discoverLineEnding(text) {
    for (let i = 0; i < text.length; i++) {
        const character = text[i];
        if (character === '\r') {
            if (i + 1 < text.length && text[i + 1] === '\n') {
                return '\r\n';
            }
            return '\r';
        }
        else if (character === '\n') {
            return '\n';
        }
    }
    return '\n';
}
exports.discoverLineEnding = discoverLineEnding;
function discoverIndent(text) {
    const match = INDENT_PATTERN.exec(text);
    if (match) {
        return match[1];
    }
    return '    ';
}
exports.discoverIndent = discoverIndent;
function applyIndent(text, indent, eol, indentFirstLine = true) {
    const lines = text.split(LINE_ENDING_PATTERN);
    let out = '';
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!indentFirstLine && i === 0) {
            out += line;
        }
        else {
            out += indent + line;
        }
        if (i + 1 !== lines.length) {
            out += eol;
        }
    }
    return out;
}
exports.applyIndent = applyIndent;
function getI18nConfiguration(env) {
    // eslint-disable-next-line @typescript-eslint/camelcase
    const { default_language, fallback_bundle, file, folders } = (env && env.i18n) || {};
    return {
        // eslint-disable-next-line @typescript-eslint/camelcase
        defaultLanguage: default_language !== null && default_language !== void 0 ? default_language : 'en',
        // eslint-disable-next-line @typescript-eslint/camelcase
        fallbackLanguage: fallback_bundle !== null && fallback_bundle !== void 0 ? fallback_bundle : '',
        baseFileName: file !== null && file !== void 0 ? file : 'i18n',
        folders: folders !== null && folders !== void 0 ? folders : ['_i18n', 'i18n']
    };
}
exports.getI18nConfiguration = getI18nConfiguration;
function jsonPathFormatter(path) {
    return `${path}.json`;
}
exports.jsonPathFormatter = jsonPathFormatter;
function propertiesPathFormatter(path, env) {
    const { fallbackLanguage } = getI18nConfiguration(env);
    return `${path}${fallbackLanguage === '' ? '' : `_${fallbackLanguage}`}.properties`;
}
exports.propertiesPathFormatter = propertiesPathFormatter;
function csvPathFormatter(path) {
    return `${path}.csv`;
}
exports.csvPathFormatter = csvPathFormatter;


/***/ }),

/***/ 43290:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(9929));
__export(__webpack_require__(98702));


/***/ }),

/***/ 62112:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path_1 = __webpack_require__(71017);
const fs_1 = __webpack_require__(57147);
const file_1 = __webpack_require__(13681);
exports.CAP_SERVICES_FOLDER = 'srv';
exports.CAP_APPS_FOLDER = 'app';
exports.CAP_DB_FOLDER = 'db';
const packageJsonFileName = 'package.json';
/**
 * Parses the package.json file at the root of a project.
 *
 * @param {string} projectRoot - the root path of the project
 * @return {Promise<CapNpmPackage>} the parsed JSON object
 */
async function parsePackageJson(projectRoot) {
    let packageJson;
    const packageJsonPath = path_1.join(projectRoot, packageJsonFileName);
    if (await file_1.fileExists(packageJsonPath)) {
        try {
            packageJson = JSON.parse(await file_1.readFile(packageJsonPath));
        }
        catch (error) {
            // Ignore errors while reading the package.json file
        }
    }
    return packageJson;
}
/**
 * Returns true if the project is either a CAP Node.js or a CAP Java project.
 *
 * @export
 * @param {string} projectRoot - the root path of the project
 * @param {*} [packageJson] - the parsed package.json object
 * @return {Promise<boolean>} - true if the project is a CAP project
 */
async function isCapProject(projectRoot, packageJson) {
    return (await isCapNodeJsProject(projectRoot, packageJson)) || (await isCapJavaProject(projectRoot));
}
exports.isCapProject = isCapProject;
/**
 * Returns true if the project is a CAP Node.js project.
 *
 * @export
 * @param {string} projectRoot - the root path of the project
 * @param {*} [packageJson] - the parsed package.json object
 * @return {Promise<boolean>} - true if the project is a CAP Node.js project
 */
async function isCapNodeJsProject(projectRoot, packageJson) {
    var _a;
    // Parse package.json file if not provided
    if (!packageJson) {
        packageJson = await parsePackageJson(projectRoot);
    }
    return !!((packageJson === null || packageJson === void 0 ? void 0 : packageJson.cds) || ((_a = packageJson === null || packageJson === void 0 ? void 0 : packageJson.dependencies) === null || _a === void 0 ? void 0 : _a['@sap/cds']));
}
exports.isCapNodeJsProject = isCapNodeJsProject;
/**
 * Returns true if the project is a CAP Java project.
 *
 * @export
 * @param {string} projectRoot - the root path of the project
 * @return {Promise<boolean>} - true if the project is a CAP project
 */
async function isCapJavaProject(projectRoot) {
    const hasApplicationYaml = await file_1.fileExists(path_1.join(projectRoot, exports.CAP_SERVICES_FOLDER, 'src', 'main', 'resources', 'application.yaml'));
    return hasApplicationYaml;
}
exports.isCapJavaProject = isCapJavaProject;
/**
 * Get CAP CDS project custom paths for project root
 * @params {capProjectPath}
 * @returns {CapCustomPaths} Cap Custom Paths
 */
exports.getCapCustomPaths = function (capProjectPath) {
    var _a;
    const result = {};
    const packagePath = path_1.join(capProjectPath, 'package.json');
    try {
        const packageJson = JSON.parse(fs_1.readFileSync(packagePath, 'utf8'));
        if ((_a = packageJson === null || packageJson === void 0 ? void 0 : packageJson.cds) === null || _a === void 0 ? void 0 : _a.folders) {
            result.app = packageJson.cds.folders.app;
            result.db = packageJson.cds.folders.db;
            result.srv = packageJson.cds.folders.srv;
        }
    }
    catch (e) {
        // Ignore errors as may have no custom paths or invalid package.json
    }
    return result;
};
exports.toAbsoluteUri = (project, relativeUri) => path_1.join(project.root, relativeUri);
exports.toReferenceUri = async (project, relativeUriFrom, relativeUriTo) => {
    let relativeUri = '';
    const indexNodeModules = relativeUriTo.lastIndexOf('node_modules');
    if (indexNodeModules >= 0) {
        // extract module name from fileUri - e.g. '@sap/cds/common' from '../../node_modules/@sap/cds/common.cds'
        const indexLastDot = relativeUriTo.lastIndexOf('.');
        if (indexLastDot > indexNodeModules + 13) {
            relativeUri = relativeUriTo.slice(indexNodeModules + 13, indexLastDot);
        }
        else {
            relativeUri = relativeUriTo.slice(indexNodeModules + 13);
        }
    }
    else if (relativeUriTo.startsWith('../') || relativeUriTo.startsWith('..\\')) {
        // file outside current project (e.g. mono repo)
        const result = await getPackageNameInFolder(project.root, relativeUriTo);
        if (result.packageName) {
            relativeUri = result.packageName + relativeUriTo.slice(result.packageFolder.length);
        }
    }
    if (!relativeUri) {
        // build relative path
        const fromDir = path_1.dirname(exports.toAbsoluteUri(project, relativeUriFrom));
        relativeUri = path_1.relative(fromDir, exports.toAbsoluteUri(project, relativeUriTo));
        if (!relativeUri.startsWith('.')) {
            relativeUri = './' + relativeUri;
        }
    }
    // remove file extension
    const fileExtension = relativeUri.lastIndexOf('.') > 0 ? relativeUri.slice(relativeUri.lastIndexOf('.') + 1) : '';
    if (['CDS', 'JSON'].includes(fileExtension.toUpperCase())) {
        relativeUri = relativeUri.slice(0, relativeUri.length - fileExtension.length - 1);
    }
    // always use '/' instead of platform specific separator
    return relativeUri.split(path_1.sep).join('/');
};
async function getPackageNameInFolder(baseUri, relativeUri) {
    const refUriParts = relativeUri.split(path_1.sep);
    const result = { packageName: '', packageFolder: relativeUri };
    for (let i = refUriParts.length - 1; i >= 0 && !result.packageName; i--) {
        const currentFolder = refUriParts.slice(0, i).join(path_1.sep);
        result.packageName = await readPackageNameForFolder(baseUri, currentFolder);
        if (result.packageName) {
            result.packageFolder = currentFolder;
        }
    }
    return result;
}
async function readPackageNameForFolder(baseUri, relativeUri) {
    let packageName = '';
    try {
        const path = path_1.normalize(baseUri + '/' + relativeUri + '/' + 'package.json');
        const content = await file_1.readFile(path);
        if (content) {
            const parsed = JSON.parse(content);
            packageName = parsed.name;
        }
    }
    catch (e) {
        packageName = '';
    }
    return packageName;
}


/***/ }),

/***/ 13681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs_1 = __webpack_require__(57147);
async function readFile(path) {
    const data = await fs_1.promises.readFile(path);
    return Buffer.from(data).toString('utf8');
}
exports.readFile = readFile;
/**
 * Checks if the provided file exists in the file system.
 *
 * @param {string} path - the file path
 * @return {Promise<boolean>} - true if the file exists; false otherwise.
 */
async function fileExists(path) {
    try {
        await fs_1.promises.access(path);
        return true;
    }
    catch {
        return false;
    }
}
exports.fileExists = fileExists;


/***/ }),

/***/ 9929:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(62112));


/***/ }),

/***/ 48368:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const path_1 = __webpack_require__(71017);
const fs_1 = __webpack_require__(57147);
const child_process_1 = __webpack_require__(32081);
const ux_telemetry_1 = __webpack_require__(65611);
const ux_odata_client_1 = __webpack_require__(24951);
const logger_1 = __webpack_require__(25791);
const i18next_1 = __importDefault(__webpack_require__(20610));
const yaml_1 = __importDefault(__webpack_require__(75992));
const log = logger_1.getLogger('cf spaces');
async function _spawnAsync(cmd, args, options) {
    return new Promise((resolve, reject) => {
        const process = child_process_1.spawn(cmd, args, options);
        process.on('exit', (exitCode) => {
            var _a;
            if (exitCode === 0) {
                resolve(exitCode);
            }
            else {
                if ((_a = process === null || process === void 0 ? void 0 : process.stderr) === null || _a === void 0 ? void 0 : _a.on) {
                    process.stderr.on('data', (data) => {
                        const errorMsg = data && data.toString
                            ? data.toString('utf8').trim()
                            : `Error when run cf spaces. Exit code ${exitCode}`;
                        log.info(errorMsg);
                    });
                }
                reject(exitCode);
            }
        });
    });
}
async function _reportDeployTelemetry(exitCode, markName) {
    ux_telemetry_1.PerformanceMeasurementAPI.endMark(markName);
    ux_telemetry_1.PerformanceMeasurementAPI.measure(markName);
    const executionTime = ux_telemetry_1.PerformanceMeasurementAPI.getMeasurementDuration(markName);
    let scp, authType;
    try {
        if (fs_1.existsSync('xs-app.json')) {
            let destination;
            const xsAppConfig = JSON.parse(fs_1.readFileSync('xs-app.json', 'utf-8'));
            const xsAppRoutes = xsAppConfig['routes'].filter((route) => route.destination && route.destination !== 'ui5');
            if (xsAppRoutes.length === 1) {
                destination = xsAppRoutes[0].destination;
            }
            if (destination) {
                const sapSystems = await ux_odata_client_1.listSAPSystems();
                const targetSystems = Object.values(sapSystems).filter((sapSystem) => sapSystem.name === destination);
                if (targetSystems && targetSystems.length === 1) {
                    scp = targetSystems[0].isScp() ? 'true' : 'false';
                    authType = targetSystems[0].config.destinationAuthType;
                }
            }
        }
    }
    catch (error) {
        // Hide the telemetry error from end user
        // Backend would report telemetry value undefined.
    }
    const eventName = exitCode === 0 ? ux_telemetry_1.EventName.DEPLOY : ux_telemetry_1.EventName.DEPLOY_FAIL;
    ux_telemetry_1.ClientFactory.getTelemetryClient().report(eventName, {
        target: 'cf',
        exitCode: `${exitCode}`,
        scp,
        authType
    }, { DeployTime: executionTime }, ux_telemetry_1.SampleRate.NoSampling);
    return;
}
async function _getMtaAppName() {
    let mtaId;
    try {
        const mtaYamlPath = path_1.join(process.cwd(), 'mta.yaml');
        if (fs_1.existsSync(mtaYamlPath)) {
            const mtaYaml = yaml_1.default.parseDocument(await fs_1.promises.readFile(mtaYamlPath, { encoding: 'utf8' })).toJSON();
            if (mtaYaml) {
                mtaId = mtaYaml === null || mtaYaml === void 0 ? void 0 : mtaYaml.ID;
            }
        }
    }
    catch (err) {
        // Hide the error from the end user
    }
    return mtaId;
}
async function _showHelpGuide() {
    try {
        const mtaId = await _getMtaAppName();
        // Display CF command only for managed approuter
        if (mtaId && fs_1.existsSync('xs-app.json')) {
            log.info(i18next_1.default.t('DEPLOYMENT_MSG'));
            log.info(`\t${i18next_1.default.t('DEPLOYMENT_MANAGED_CF_URL', { mtaId })}`);
        }
        else {
            // Assume standalone
            log.info(i18next_1.default.t('DEPLOYMENT_STANDALONE_CF_URL'));
        }
    }
    catch (err) {
        // Hide the error from the end user
    }
    log.info(`${i18next_1.default.t('DEPLOYMENT_HELP')}`);
    return;
}
module.exports = async function task() {
    ux_telemetry_1.initTelemetrySettings({
        disableTelemetry: false,
        internalFeaturesEnabled: false
    });
    const markName = ux_telemetry_1.PerformanceMeasurementAPI.startMark('LOADING_TIME');
    let cfAuthenticated = true;
    try {
        await _spawnAsync('cf', ['spaces']);
    }
    catch (error) {
        cfAuthenticated = false;
    }
    if (cfAuthenticated) {
        // Note spawn is not a promise function to avoid breaking deployment process.
        // This call will be executed asynchronously.
        // Logic after deploy should be executed in the on exit callback.
        const defaultMtaDir = 'mta_archives';
        let archiveName = 'archive.mtar';
        try {
            // There should only ever be one mta archive present when the build:mta is used
            const mtaArchives = fs_1.readdirSync(defaultMtaDir);
            if (mtaArchives.length === 1 && mtaArchives[0].includes('.mtar')) {
                archiveName = mtaArchives[0];
            }
        }
        catch (err) {
            // Not much we can do, default back to archive.mtar and give the user the error
        }
        let exitCode;
        let error;
        // Need to handle the exception so that we can trigger the telemetry
        try {
            exitCode = await _spawnAsync('cf', ['deploy', `${defaultMtaDir}/${archiveName}`], { stdio: 'inherit' });
        }
        catch (err) {
            // Let the spawn handle the error
            error = err;
            exitCode = 1;
        }
        // Only show help guide if everything was successful
        if (exitCode === 0) {
            await _showHelpGuide();
        }
        // Trigger the telemetry
        try {
            await _reportDeployTelemetry(exitCode, markName);
        }
        catch (err) {
            // Nothing we can do BUT dont stop the flow
        }
        // If a genuine error was found i.e. mta folder does not exist, show the user the exact cf error
        if (error) {
            throw error;
        }
    }
    return;
};


/***/ }),

/***/ 87694:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 87694;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 53391:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 53391;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 54529:
/***/ ((module) => {

"use strict";
module.exports = require("@opentelemetry/tracing");

/***/ }),

/***/ 32220:
/***/ ((module) => {

"use strict";
module.exports = require("applicationinsights-native-metrics");

/***/ }),

/***/ 10146:
/***/ ((module) => {

"use strict";
module.exports = require("express");

/***/ }),

/***/ 74602:
/***/ ((module) => {

"use strict";
module.exports = require("keytar");

/***/ }),

/***/ 66828:
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ 39491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 50852:
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");

/***/ }),

/***/ 14300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 32081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 96206:
/***/ ((module) => {

"use strict";
module.exports = require("console");

/***/ }),

/***/ 22057:
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 9523:
/***/ ((module) => {

"use strict";
module.exports = require("dns");

/***/ }),

/***/ 82361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 57147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 13685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 95687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 98188:
/***/ ((module) => {

"use strict";
module.exports = require("module");

/***/ }),

/***/ 41808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 22037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 71017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 77282:
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ 12781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 71576:
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ 39512:
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ 26821:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 76224:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 57310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 73837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 59796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 85072:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _default = function _default(filename) {
  if (filename.indexOf('.') < 0) return undefined;
  return ".".concat(filename.split('.').pop());
};

exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 78729:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
var unicode = {
  Space_Separator: Space_Separator,
  ID_Start: ID_Start,
  ID_Continue: ID_Continue
};
var util = {
  isSpaceSeparator: function isSpaceSeparator(c) {
    return typeof c === 'string' && unicode.Space_Separator.test(c);
  },
  isIdStartChar: function isIdStartChar(c) {
    return typeof c === 'string' && (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c === '$' || c === '_' || unicode.ID_Start.test(c));
  },
  isIdContinueChar: function isIdContinueChar(c) {
    return typeof c === 'string' && (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c === '$' || c === '_' || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c));
  },
  isDigit: function isDigit(c) {
    return typeof c === 'string' && /[0-9]/.test(c);
  },
  isHexDigit: function isHexDigit(c) {
    return typeof c === 'string' && /[0-9A-Fa-f]/.test(c);
  }
};
var source;
var parseState;
var stack;
var pos;
var line;
var column;
var token;
var key;
var root;

var parse = function parse(text, reviver) {
  source = String(text);
  parseState = 'start';
  stack = [];
  pos = 0;
  line = 1;
  column = 0;
  token = undefined;
  key = undefined;
  root = undefined;

  do {
    token = lex();
    parseStates[parseState]();
  } while (token.type !== 'eof');

  if (typeof reviver === 'function') {
    return internalize({
      '': root
    }, '', reviver);
  }

  return root;
};

function internalize(holder, name, reviver) {
  var value = holder[name];

  if (value != null && _typeof(value) === 'object') {
    for (var _key in value) {
      var replacement = internalize(value, _key, reviver);

      if (replacement === undefined) {
        delete value[_key];
      } else {
        value[_key] = replacement;
      }
    }
  }

  return reviver.call(holder, name, value);
}

var lexState;
var buffer;
var doubleQuote;

var _sign;

var c;

function lex() {
  lexState = 'default';
  buffer = '';
  doubleQuote = false;
  _sign = 1;

  for (;;) {
    c = peek();

    var _token = lexStates[lexState]();

    if (_token) {
      return _token;
    }
  }
}

function peek() {
  if (source[pos]) {
    return String.fromCodePoint(source.codePointAt(pos));
  }
}

function read() {
  var c = peek();

  if (c === '\n') {
    line++;
    column = 0;
  } else if (c) {
    column += c.length;
  } else {
    column++;
  }

  if (c) {
    pos += c.length;
  }

  return c;
}

var lexStates = {
  default: function _default() {
    switch (c) {
      case '\t':
      case '\v':
      case '\f':
      case ' ':
      case "\xA0":
      case "\uFEFF":
      case '\n':
      case '\r':
      case "\u2028":
      case "\u2029":
        read();
        return;

      case '/':
        read();
        lexState = 'comment';
        return;

      case undefined:
        read();
        return newToken('eof');
    }

    if (util.isSpaceSeparator(c)) {
      read();
      return;
    }

    return lexStates[parseState]();
  },
  comment: function comment() {
    switch (c) {
      case '*':
        read();
        lexState = 'multiLineComment';
        return;

      case '/':
        read();
        lexState = 'singleLineComment';
        return;
    }

    throw invalidChar(read());
  },
  multiLineComment: function multiLineComment() {
    switch (c) {
      case '*':
        read();
        lexState = 'multiLineCommentAsterisk';
        return;

      case undefined:
        throw invalidChar(read());
    }

    read();
  },
  multiLineCommentAsterisk: function multiLineCommentAsterisk() {
    switch (c) {
      case '*':
        read();
        return;

      case '/':
        read();
        lexState = 'default';
        return;

      case undefined:
        throw invalidChar(read());
    }

    read();
    lexState = 'multiLineComment';
  },
  singleLineComment: function singleLineComment() {
    switch (c) {
      case '\n':
      case '\r':
      case "\u2028":
      case "\u2029":
        read();
        lexState = 'default';
        return;

      case undefined:
        read();
        return newToken('eof');
    }

    read();
  },
  value: function value() {
    switch (c) {
      case '{':
      case '[':
        return newToken('punctuator', read());

      case 'n':
        read();
        literal('ull');
        return newToken('null', null);

      case 't':
        read();
        literal('rue');
        return newToken('boolean', true);

      case 'f':
        read();
        literal('alse');
        return newToken('boolean', false);

      case '-':
      case '+':
        if (read() === '-') {
          _sign = -1;
        }

        lexState = 'sign';
        return;

      case '.':
        buffer = read();
        lexState = 'decimalPointLeading';
        return;

      case '0':
        buffer = read();
        lexState = 'zero';
        return;

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        buffer = read();
        lexState = 'decimalInteger';
        return;

      case 'I':
        read();
        literal('nfinity');
        return newToken('numeric', Infinity);

      case 'N':
        read();
        literal('aN');
        return newToken('numeric', NaN);

      case '"':
      case "'":
        doubleQuote = read() === '"';
        buffer = '';
        lexState = 'string';
        return;
    }

    throw invalidChar(read());
  },
  identifierNameStartEscape: function identifierNameStartEscape() {
    if (c !== 'u') {
      throw invalidChar(read());
    }

    read();
    var u = unicodeEscape();

    switch (u) {
      case '$':
      case '_':
        break;

      default:
        if (!util.isIdStartChar(u)) {
          throw invalidIdentifier();
        }

        break;
    }

    buffer += u;
    lexState = 'identifierName';
  },
  identifierName: function identifierName() {
    switch (c) {
      case '$':
      case '_':
      case "\u200C":
      case "\u200D":
        buffer += read();
        return;

      case '\\':
        read();
        lexState = 'identifierNameEscape';
        return;
    }

    if (util.isIdContinueChar(c)) {
      buffer += read();
      return;
    }

    return newToken('identifier', buffer);
  },
  identifierNameEscape: function identifierNameEscape() {
    if (c !== 'u') {
      throw invalidChar(read());
    }

    read();
    var u = unicodeEscape();

    switch (u) {
      case '$':
      case '_':
      case "\u200C":
      case "\u200D":
        break;

      default:
        if (!util.isIdContinueChar(u)) {
          throw invalidIdentifier();
        }

        break;
    }

    buffer += u;
    lexState = 'identifierName';
  },
  sign: function sign() {
    switch (c) {
      case '.':
        buffer = read();
        lexState = 'decimalPointLeading';
        return;

      case '0':
        buffer = read();
        lexState = 'zero';
        return;

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        buffer = read();
        lexState = 'decimalInteger';
        return;

      case 'I':
        read();
        literal('nfinity');
        return newToken('numeric', _sign * Infinity);

      case 'N':
        read();
        literal('aN');
        return newToken('numeric', NaN);
    }

    throw invalidChar(read());
  },
  zero: function zero() {
    switch (c) {
      case '.':
        buffer += read();
        lexState = 'decimalPoint';
        return;

      case 'e':
      case 'E':
        buffer += read();
        lexState = 'decimalExponent';
        return;

      case 'x':
      case 'X':
        buffer += read();
        lexState = 'hexadecimal';
        return;
    }

    return newToken('numeric', _sign * 0);
  },
  decimalInteger: function decimalInteger() {
    switch (c) {
      case '.':
        buffer += read();
        lexState = 'decimalPoint';
        return;

      case 'e':
      case 'E':
        buffer += read();
        lexState = 'decimalExponent';
        return;
    }

    if (util.isDigit(c)) {
      buffer += read();
      return;
    }

    return newToken('numeric', _sign * Number(buffer));
  },
  decimalPointLeading: function decimalPointLeading() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = 'decimalFraction';
      return;
    }

    throw invalidChar(read());
  },
  decimalPoint: function decimalPoint() {
    switch (c) {
      case 'e':
      case 'E':
        buffer += read();
        lexState = 'decimalExponent';
        return;
    }

    if (util.isDigit(c)) {
      buffer += read();
      lexState = 'decimalFraction';
      return;
    }

    return newToken('numeric', _sign * Number(buffer));
  },
  decimalFraction: function decimalFraction() {
    switch (c) {
      case 'e':
      case 'E':
        buffer += read();
        lexState = 'decimalExponent';
        return;
    }

    if (util.isDigit(c)) {
      buffer += read();
      return;
    }

    return newToken('numeric', _sign * Number(buffer));
  },
  decimalExponent: function decimalExponent() {
    switch (c) {
      case '+':
      case '-':
        buffer += read();
        lexState = 'decimalExponentSign';
        return;
    }

    if (util.isDigit(c)) {
      buffer += read();
      lexState = 'decimalExponentInteger';
      return;
    }

    throw invalidChar(read());
  },
  decimalExponentSign: function decimalExponentSign() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = 'decimalExponentInteger';
      return;
    }

    throw invalidChar(read());
  },
  decimalExponentInteger: function decimalExponentInteger() {
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }

    return newToken('numeric', _sign * Number(buffer));
  },
  hexadecimal: function hexadecimal() {
    if (util.isHexDigit(c)) {
      buffer += read();
      lexState = 'hexadecimalInteger';
      return;
    }

    throw invalidChar(read());
  },
  hexadecimalInteger: function hexadecimalInteger() {
    if (util.isHexDigit(c)) {
      buffer += read();
      return;
    }

    return newToken('numeric', _sign * Number(buffer));
  },
  string: function string() {
    switch (c) {
      case '\\':
        read();
        buffer += escape();
        return;

      case '"':
        if (doubleQuote) {
          read();
          return newToken('string', buffer);
        }

        buffer += read();
        return;

      case "'":
        if (!doubleQuote) {
          read();
          return newToken('string', buffer);
        }

        buffer += read();
        return;

      case '\n':
      case '\r':
        throw invalidChar(read());

      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;

      case undefined:
        throw invalidChar(read());
    }

    buffer += read();
  },
  start: function start() {
    switch (c) {
      case '{':
      case '[':
        return newToken('punctuator', read());
    }

    lexState = 'value';
  },
  beforePropertyName: function beforePropertyName() {
    switch (c) {
      case '$':
      case '_':
        buffer = read();
        lexState = 'identifierName';
        return;

      case '\\':
        read();
        lexState = 'identifierNameStartEscape';
        return;

      case '}':
        return newToken('punctuator', read());

      case '"':
      case "'":
        doubleQuote = read() === '"';
        lexState = 'string';
        return;
    }

    if (util.isIdStartChar(c)) {
      buffer += read();
      lexState = 'identifierName';
      return;
    }

    throw invalidChar(read());
  },
  afterPropertyName: function afterPropertyName() {
    if (c === ':') {
      return newToken('punctuator', read());
    }

    throw invalidChar(read());
  },
  beforePropertyValue: function beforePropertyValue() {
    lexState = 'value';
  },
  afterPropertyValue: function afterPropertyValue() {
    switch (c) {
      case ',':
      case '}':
        return newToken('punctuator', read());
    }

    throw invalidChar(read());
  },
  beforeArrayValue: function beforeArrayValue() {
    if (c === ']') {
      return newToken('punctuator', read());
    }

    lexState = 'value';
  },
  afterArrayValue: function afterArrayValue() {
    switch (c) {
      case ',':
      case ']':
        return newToken('punctuator', read());
    }

    throw invalidChar(read());
  },
  end: function end() {
    throw invalidChar(read());
  }
};

function newToken(type, value) {
  return {
    type: type,
    value: value,
    line: line,
    column: column
  };
}

function literal(s) {
  var _iterator = _createForOfIteratorHelper(s),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _c = _step.value;
      var p = peek();

      if (p !== _c) {
        throw invalidChar(read());
      }

      read();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function escape() {
  var c = peek();

  switch (c) {
    case 'b':
      read();
      return '\b';

    case 'f':
      read();
      return '\f';

    case 'n':
      read();
      return '\n';

    case 'r':
      read();
      return '\r';

    case 't':
      read();
      return '\t';

    case 'v':
      read();
      return '\v';

    case '0':
      read();

      if (util.isDigit(peek())) {
        throw invalidChar(read());
      }

      return '\0';

    case 'x':
      read();
      return hexEscape();

    case 'u':
      read();
      return unicodeEscape();

    case '\n':
    case "\u2028":
    case "\u2029":
      read();
      return '';

    case '\r':
      read();

      if (peek() === '\n') {
        read();
      }

      return '';

    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      throw invalidChar(read());

    case undefined:
      throw invalidChar(read());
  }

  return read();
}

function hexEscape() {
  var buffer = '';
  var c = peek();

  if (!util.isHexDigit(c)) {
    throw invalidChar(read());
  }

  buffer += read();
  c = peek();

  if (!util.isHexDigit(c)) {
    throw invalidChar(read());
  }

  buffer += read();
  return String.fromCodePoint(parseInt(buffer, 16));
}

function unicodeEscape() {
  var buffer = '';
  var count = 4;

  while (count-- > 0) {
    var _c2 = peek();

    if (!util.isHexDigit(_c2)) {
      throw invalidChar(read());
    }

    buffer += read();
  }

  return String.fromCodePoint(parseInt(buffer, 16));
}

var parseStates = {
  start: function start() {
    if (token.type === 'eof') {
      throw invalidEOF();
    }

    push();
  },
  beforePropertyName: function beforePropertyName() {
    switch (token.type) {
      case 'identifier':
      case 'string':
        key = token.value;
        parseState = 'afterPropertyName';
        return;

      case 'punctuator':
        pop();
        return;

      case 'eof':
        throw invalidEOF();
    }
  },
  afterPropertyName: function afterPropertyName() {
    if (token.type === 'eof') {
      throw invalidEOF();
    }

    parseState = 'beforePropertyValue';
  },
  beforePropertyValue: function beforePropertyValue() {
    if (token.type === 'eof') {
      throw invalidEOF();
    }

    push();
  },
  beforeArrayValue: function beforeArrayValue() {
    if (token.type === 'eof') {
      throw invalidEOF();
    }

    if (token.type === 'punctuator' && token.value === ']') {
      pop();
      return;
    }

    push();
  },
  afterPropertyValue: function afterPropertyValue() {
    if (token.type === 'eof') {
      throw invalidEOF();
    }

    switch (token.value) {
      case ',':
        parseState = 'beforePropertyName';
        return;

      case '}':
        pop();
    }
  },
  afterArrayValue: function afterArrayValue() {
    if (token.type === 'eof') {
      throw invalidEOF();
    }

    switch (token.value) {
      case ',':
        parseState = 'beforeArrayValue';
        return;

      case ']':
        pop();
    }
  },
  end: function end() {}
};

function push() {
  var value;

  switch (token.type) {
    case 'punctuator':
      switch (token.value) {
        case '{':
          value = {};
          break;

        case '[':
          value = [];
          break;
      }

      break;

    case 'null':
    case 'boolean':
    case 'numeric':
    case 'string':
      value = token.value;
      break;
  }

  if (root === undefined) {
    root = value;
  } else {
    var parent = stack[stack.length - 1];

    if (Array.isArray(parent)) {
      parent.push(value);
    } else {
      parent[key] = value;
    }
  }

  if (value !== null && _typeof(value) === 'object') {
    stack.push(value);

    if (Array.isArray(value)) {
      parseState = 'beforeArrayValue';
    } else {
      parseState = 'beforePropertyName';
    }
  } else {
    var current = stack[stack.length - 1];

    if (current == null) {
      parseState = 'end';
    } else if (Array.isArray(current)) {
      parseState = 'afterArrayValue';
    } else {
      parseState = 'afterPropertyValue';
    }
  }
}

function pop() {
  stack.pop();
  var current = stack[stack.length - 1];

  if (current == null) {
    parseState = 'end';
  } else if (Array.isArray(current)) {
    parseState = 'afterArrayValue';
  } else {
    parseState = 'afterPropertyValue';
  }
}

function invalidChar(c) {
  if (c === undefined) {
    return syntaxError("JSON5: invalid end of input at ".concat(line, ":").concat(column));
  }

  return syntaxError("JSON5: invalid character '".concat(formatChar(c), "' at ").concat(line, ":").concat(column));
}

function invalidEOF() {
  return syntaxError("JSON5: invalid end of input at ".concat(line, ":").concat(column));
}

function invalidIdentifier() {
  column -= 5;
  return syntaxError("JSON5: invalid identifier character at ".concat(line, ":").concat(column));
}

function separatorChar(c) {
  console.warn("JSON5: '".concat(formatChar(c), "' in strings is not valid ECMAScript; consider escaping"));
}

function formatChar(c) {
  var replacements = {
    "'": "\\'",
    '"': '\\"',
    '\\': '\\\\',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t',
    '\v': '\\v',
    '\0': '\\0',
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };

  if (replacements[c]) {
    return replacements[c];
  }

  if (c < ' ') {
    var hexString = c.charCodeAt(0).toString(16);
    return '\\x' + ('00' + hexString).substring(hexString.length);
  }

  return c;
}

function syntaxError(message) {
  var err = new SyntaxError(message);
  err.lineNumber = line;
  err.columnNumber = column;
  return err;
}

var stringify = function stringify(value, replacer, space) {
  var stack = [];
  var indent = '';
  var propertyList;
  var replacerFunc;
  var gap = '';
  var quote;

  if (replacer != null && _typeof(replacer) === 'object' && !Array.isArray(replacer)) {
    space = replacer.space;
    quote = replacer.quote;
    replacer = replacer.replacer;
  }

  if (typeof replacer === 'function') {
    replacerFunc = replacer;
  } else if (Array.isArray(replacer)) {
    propertyList = [];

    var _iterator2 = _createForOfIteratorHelper(replacer),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var v = _step2.value;
        var item = void 0;

        if (typeof v === 'string') {
          item = v;
        } else if (typeof v === 'number' || v instanceof String || v instanceof Number) {
          item = String(v);
        }

        if (item !== undefined && propertyList.indexOf(item) < 0) {
          propertyList.push(item);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  if (space instanceof Number) {
    space = Number(space);
  } else if (space instanceof String) {
    space = String(space);
  }

  if (typeof space === 'number') {
    if (space > 0) {
      space = Math.min(10, Math.floor(space));
      gap = '          '.substr(0, space);
    }
  } else if (typeof space === 'string') {
    gap = space.substr(0, 10);
  }

  return serializeProperty('', {
    '': value
  });

  function serializeProperty(key, holder) {
    var value = holder[key];

    if (value != null) {
      if (typeof value.toJSON5 === 'function') {
        value = value.toJSON5(key);
      } else if (typeof value.toJSON === 'function') {
        value = value.toJSON(key);
      }
    }

    if (replacerFunc) {
      value = replacerFunc.call(holder, key, value);
    }

    if (value instanceof Number) {
      value = Number(value);
    } else if (value instanceof String) {
      value = String(value);
    } else if (value instanceof Boolean) {
      value = value.valueOf();
    }

    switch (value) {
      case null:
        return 'null';

      case true:
        return 'true';

      case false:
        return 'false';
    }

    if (typeof value === 'string') {
      return quoteString(value, false);
    }

    if (typeof value === 'number') {
      return String(value);
    }

    if (_typeof(value) === 'object') {
      return Array.isArray(value) ? serializeArray(value) : serializeObject(value);
    }

    return undefined;
  }

  function quoteString(value) {
    var quotes = {
      "'": 0.1,
      '"': 0.2
    };
    var replacements = {
      "'": "\\'",
      '"': '\\"',
      '\\': '\\\\',
      '\b': '\\b',
      '\f': '\\f',
      '\n': '\\n',
      '\r': '\\r',
      '\t': '\\t',
      '\v': '\\v',
      '\0': '\\0',
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    var product = '';

    for (var i = 0; i < value.length; i++) {
      var _c3 = value[i];

      switch (_c3) {
        case "'":
        case '"':
          quotes[_c3]++;
          product += _c3;
          continue;

        case '\0':
          if (util.isDigit(value[i + 1])) {
            product += '\\x00';
            continue;
          }

      }

      if (replacements[_c3]) {
        product += replacements[_c3];
        continue;
      }

      if (_c3 < ' ') {
        var hexString = _c3.charCodeAt(0).toString(16);

        product += '\\x' + ('00' + hexString).substring(hexString.length);
        continue;
      }

      product += _c3;
    }

    var quoteChar = quote || Object.keys(quotes).reduce(function (a, b) {
      return quotes[a] < quotes[b] ? a : b;
    });
    product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);
    return quoteChar + product + quoteChar;
  }

  function serializeObject(value) {
    if (stack.indexOf(value) >= 0) {
      throw TypeError('Converting circular structure to JSON5');
    }

    stack.push(value);
    var stepback = indent;
    indent = indent + gap;
    var keys = propertyList || Object.keys(value);
    var partial = [];

    var _iterator3 = _createForOfIteratorHelper(keys),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _key2 = _step3.value;
        var propertyString = serializeProperty(_key2, value);

        if (propertyString !== undefined) {
          var member = serializeKey(_key2) + ':';

          if (gap !== '') {
            member += ' ';
          }

          member += propertyString;
          partial.push(member);
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    var final;

    if (partial.length === 0) {
      final = '{}';
    } else {
      var properties;

      if (gap === '') {
        properties = partial.join(',');
        final = '{' + properties + '}';
      } else {
        var separator = ',\n' + indent;
        properties = partial.join(separator);
        final = '{\n' + indent + properties + ',\n' + stepback + '}';
      }
    }

    stack.pop();
    indent = stepback;
    return final;
  }

  function serializeKey(key) {
    if (key.length === 0) {
      return quoteString(key, true);
    }

    var firstChar = String.fromCodePoint(key.codePointAt(0));

    if (!util.isIdStartChar(firstChar)) {
      return quoteString(key, true);
    }

    for (var i = firstChar.length; i < key.length; i++) {
      if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
        return quoteString(key, true);
      }
    }

    return key;
  }

  function serializeArray(value) {
    if (stack.indexOf(value) >= 0) {
      throw TypeError('Converting circular structure to JSON5');
    }

    stack.push(value);
    var stepback = indent;
    indent = indent + gap;
    var partial = [];

    for (var i = 0; i < value.length; i++) {
      var propertyString = serializeProperty(String(i), value);
      partial.push(propertyString !== undefined ? propertyString : 'null');
    }

    var final;

    if (partial.length === 0) {
      final = '[]';
    } else {
      if (gap === '') {
        var properties = partial.join(',');
        final = '[' + properties + ']';
      } else {
        var separator = ',\n' + indent;

        var _properties = partial.join(separator);

        final = '[\n' + indent + _properties + ',\n' + stepback + ']';
      }
    }

    stack.pop();
    indent = stepback;
    return final;
  }
};

var JSON5 = {
  parse: parse,
  stringify: stringify
};
var lib = JSON5;
var _default2 = lib;
exports["default"] = _default2;
module.exports = exports.default;

/***/ }),

/***/ 56090:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.safeLoadAll = exports.safeLoad = exports.safeDump = exports.loadAll = exports.load = exports.dump = exports.YAMLException = exports.Type = exports.Schema = exports.JSON_SCHEMA = exports.FAILSAFE_SCHEMA = exports.DEFAULT_SCHEMA = exports.CORE_SCHEMA = exports["default"] = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! js-yaml 4.0.0 https://github.com/nodeca/js-yaml @license MIT */
function isNothing(subject) {
  return typeof subject === 'undefined' || subject === null;
}

function isObject(subject) {
  return _typeof(subject) === 'object' && subject !== null;
}

function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];
  return [sequence];
}

function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}

function repeat(string, count) {
  var result = '',
      cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}

function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}

var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};

function formatError(exception, compact) {
  var where = '',
      message = exception.reason || '(unknown reason)';
  if (!exception.mark) return message;

  if (exception.mark.name) {
    where += 'in "' + exception.mark.name + '" ';
  }

  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

  if (!compact && exception.mark.snippet) {
    where += '\n\n' + exception.mark.snippet;
  }

  return message + ' ' + where;
}

function YAMLException(reason, mark) {
  Error.call(this);
  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || '';
  }
}

YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;

YAMLException.prototype.toString = function toString(compact) {
  return this.name + ': ' + formatError(this, compact);
};

var exception = YAMLException;

function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = '';
  var tail = '';
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

  if (position - lineStart > maxHalfLength) {
    head = ' ... ';
    lineStart = position - maxHalfLength + head.length;
  }

  if (lineEnd - position > maxHalfLength) {
    tail = ' ...';
    lineEnd = position + maxHalfLength - tail.length;
  }

  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, '') + tail,
    pos: position - lineStart + head.length
  };
}

function padStart(string, max) {
  return common.repeat(' ', max - string.length) + string;
}

function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== 'number') options.indent = 1;
  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
  if (typeof options.linesAfter !== 'number') options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;

  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);

    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }

  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = '',
      i,
      line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + ' | ' + line.str + '\n' + result;
  }

  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + ' | ' + line.str + '\n';
  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + ' | ' + line.str + '\n';
  }

  return result.replace(/\n$/, '');
}

var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'multi', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'representName', 'defaultStyle', 'styleAliases'];
var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.tag = tag;
  this.kind = options['kind'] || null;

  this.resolve = options['resolve'] || function () {
    return true;
  };

  this.construct = options['construct'] || function (data) {
    return data;
  };

  this.instanceOf = options['instanceOf'] || null;
  this.predicate = options['predicate'] || null;
  this.represent = options['represent'] || null;
  this.representName = options['representName'] || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.multi = options['multi'] || false;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

var type = Type;

function compileList(schema, name, result) {
  var exclude = [];
  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        exclude.push(previousIndex);
      }
    });
    result.push(currentType);
  });
  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}

function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  },
      index,
      length;

  function collectType(type) {
    if (type.multi) {
      result.multi[type.kind].push(type);
      result.multi['fallback'].push(type);
    } else {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}

function Schema(definition) {
  return this.extend(definition);
}

Schema.prototype.extend = function extend(definition) {
  var implicit = [];
  var explicit = [];

  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception('Schema.extend argument should be a Type, [ Type ], ' + 'or a schema definition ({ implicit: [...], explicit: [...] })');
  }

  implicit.forEach(function (type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    if (type$1.loadKind && type$1.loadKind !== 'scalar') {
      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }

    if (type$1.multi) {
      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
    }
  });
  explicit.forEach(function (type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }
  });
  var result = Object.create(Schema.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, 'implicit', []);
  result.compiledExplicit = compileList(result, 'explicit', []);
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};

var schema = Schema;
var str = new type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function construct(data) {
    return data !== null ? data : '';
  }
});
var seq = new type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function construct(data) {
    return data !== null ? data : [];
  }
});
var map = new type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function construct(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [str, seq, map]
});

function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

var _null = new type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function canonical() {
      return '~';
    },
    lowercase: function lowercase() {
      return 'null';
    },
    uppercase: function uppercase() {
      return 'NULL';
    },
    camelcase: function camelcase() {
      return 'Null';
    },
    empty: function empty() {
      return '';
    }
  },
  defaultStyle: 'lowercase'
});

function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
}

function constructYamlBoolean(data) {
  return data === 'true' || data === 'True' || data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

var bool = new type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function lowercase(object) {
      return object ? 'true' : 'false';
    },
    uppercase: function uppercase(object) {
      return object ? 'TRUE' : 'FALSE';
    },
    camelcase: function camelcase(object) {
      return object ? 'True' : 'False';
    }
  },
  defaultStyle: 'lowercase'
});

function isHexCode(c) {
  return 0x30 <= c && c <= 0x39 || 0x41 <= c && c <= 0x46 || 0x61 <= c && c <= 0x66;
}

function isOctCode(c) {
  return 0x30 <= c && c <= 0x37;
}

function isDecCode(c) {
  return 0x30 <= c && c <= 0x39;
}

function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;
  if (!max) return false;
  ch = data[index];

  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    if (index + 1 === max) return true;
    ch = data[++index];

    if (ch === 'b') {
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }

      return hasDigits && ch !== '_';
    }

    if (ch === 'x') {
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }

      return hasDigits && ch !== '_';
    }

    if (ch === 'o') {
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }

      return hasDigits && ch !== '_';
    }
  }

  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;

    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }

    hasDigits = true;
  }

  if (!hasDigits || ch === '_') return false;
  return true;
}

function constructYamlInteger(data) {
  var value = data,
      sign = 1,
      ch;

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);
}

var int = new type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function binary(obj) {
      return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
    },
    octal: function octal(obj) {
      return obj >= 0 ? '0o' + obj.toString(8) : '-0o' + obj.toString(8).slice(1);
    },
    decimal: function decimal(obj) {
      return obj.toString(10);
    },
    hexadecimal: function hexadecimal(obj) {
      return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary: [2, 'bin'],
    octal: [8, 'oct'],
    decimal: [10, 'dec'],
    hexadecimal: [16, 'hex']
  }
});
var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + '|[-+]?\\.(?:inf|Inf|INF)' + '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, '').toLowerCase();
  sign = value[0] === '-' ? -1 : 1;

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === '.nan') {
    return NaN;
  }

  return sign * parseFloat(value, 10);
}

var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase':
        return '.nan';

      case 'uppercase':
        return '.NAN';

      case 'camelcase':
        return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '.inf';

      case 'uppercase':
        return '.INF';

      case 'camelcase':
        return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '-.inf';

      case 'uppercase':
        return '-.INF';

      case 'camelcase':
        return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
}

var float = new type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});
var json = failsafe.extend({
  implicit: [_null, bool, int, float]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + '-([0-9][0-9])' + '-([0-9][0-9])$');
var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + '-([0-9][0-9]?)' + '-([0-9][0-9]?)' + '(?:[Tt]|[ \\t]+)' + '([0-9][0-9]?)' + ':([0-9][0-9])' + ':([0-9][0-9])' + '(?:\\.([0-9]*))?' + '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + '(?::([0-9][0-9]))?))?$');

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match,
      year,
      month,
      day,
      hour,
      minute,
      second,
      fraction = 0,
      delta = null,
      tz_hour,
      tz_minute,
      date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error('Date resolve error');
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];

  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }

  hour = +match[4];
  minute = +match[5];
  second = +match[6];

  if (match[7]) {
    fraction = match[7].slice(0, 3);

    while (fraction.length < 3) {
      fraction += '0';
    }

    fraction = +fraction;
  }

  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000;
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}

function representYamlTimestamp(object) {
  return object.toISOString();
}

var timestamp = new type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

var merge = new type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';

function resolveYamlBinary(data) {
  if (data === null) return false;
  var code,
      idx,
      bitlen = 0,
      max = data.length,
      map = BASE64_MAP;

  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }

  return bitlen % 8 === 0;
}

function constructYamlBinary(data) {
  var idx,
      tailbits,
      input = data.replace(/[\r\n=]/g, ''),
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 0xFF);
      result.push(bits >> 8 & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = bits << 6 | map.indexOf(input.charAt(idx));
  }

  tailbits = max % 4 * 6;

  if (tailbits === 0) {
    result.push(bits >> 16 & 0xFF);
    result.push(bits >> 8 & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 0xFF);
    result.push(bits >> 2 & 0xFF);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 0xFF);
  }

  return new Uint8Array(result);
}

function representYamlBinary(object) {
  var result = '',
      bits = 0,
      idx,
      tail,
      max = object.length,
      map = BASE64_MAP;

  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map[bits >> 18 & 0x3F];
      result += map[bits >> 12 & 0x3F];
      result += map[bits >> 6 & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  tail = max % 3;

  if (tail === 0) {
    result += map[bits >> 18 & 0x3F];
    result += map[bits >> 12 & 0x3F];
    result += map[bits >> 6 & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[bits >> 10 & 0x3F];
    result += map[bits >> 4 & 0x3F];
    result += map[bits << 2 & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[bits >> 2 & 0x3F];
    result += map[bits << 4 & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(obj) {
  return Object.prototype.toString.call(obj) === '[object Uint8Array]';
}

var binary = new type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [],
      index,
      length,
      pair,
      pairKey,
      pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;else return false;
      }
    }

    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

var omap = new type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;
  var index,
      length,
      pair,
      keys,
      result,
      object = data;
  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== '[object Object]') return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];
  var index,
      length,
      pair,
      keys,
      result,
      object = data;
  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }

  return result;
}

var pairs = new type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;
  var key,
      object = data;

  for (key in object) {
    if (_hasOwnProperty$1.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

var set = new type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

var _default = core.extend({
  implicit: [timestamp, merge],
  explicit: [binary, omap, pairs, set]
});

var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function is_EOL(c) {
  return c === 0x0A || c === 0x0D;
}

function is_WHITE_SPACE(c) {
  return c === 0x09 || c === 0x20;
}

function is_WS_OR_EOL(c) {
  return c === 0x09 || c === 0x20 || c === 0x0A || c === 0x0D;
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C || c === 0x5B || c === 0x5D || c === 0x7B || c === 0x7D;
}

function fromHexCode(c) {
  var lc;

  if (0x30 <= c && c <= 0x39) {
    return c - 0x30;
  }

  lc = c | 0x20;

  if (0x61 <= lc && lc <= 0x66) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78) {
      return 2;
    }

  if (c === 0x75) {
      return 4;
    }

  if (c === 0x55) {
      return 8;
    }

  return 0;
}

function fromDecimalCode(c) {
  if (0x30 <= c && c <= 0x39) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  return c === 0x30 ? '\x00' : c === 0x61 ? '\x07' : c === 0x62 ? '\x08' : c === 0x74 ? '\x09' : c === 0x09 ? '\x09' : c === 0x6E ? '\x0A' : c === 0x76 ? '\x0B' : c === 0x66 ? '\x0C' : c === 0x72 ? '\x0D' : c === 0x65 ? '\x1B' : c === 0x20 ? ' ' : c === 0x22 ? '\x22' : c === 0x2F ? '/' : c === 0x5C ? '\x5C' : c === 0x4E ? '\x85' : c === 0x5F ? '\xA0' : c === 0x4C ? "\u2028" : c === 0x50 ? "\u2029" : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }

  return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}

var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);

for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}

function State(input, options) {
  this.input = input;
  this.filename = options['filename'] || null;
  this.schema = options['schema'] || _default;
  this.onWarning = options['onWarning'] || null;
  this.legacy = options['legacy'] || false;
  this.json = options['json'] || false;
  this.listener = options['listener'] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}

function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}

var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = minor < 2;

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty$2.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, 'tag prefix is malformed: ' + prefix);
    }

    state.tagMap[handle] = prefix;
  }
};

function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);

        if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty$2.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;

  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (_typeof(keyNode) === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  if (_typeof(keyNode) === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$2.call(overridableKeys, keyNode) && _hasOwnProperty$2.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }

    if (keyNode === '__proto__') {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }

    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A) {
      state.position++;
    } else if (ch === 0x0D) {
      state.position++;

      if (state.input.charCodeAt(state.position) === 0x0A) {
          state.position++;
        }
    } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 0x09 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }

      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A && ch !== 0x0D && ch !== 0);
      }

    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;
  ch = state.input.charCodeAt(_position);

  if ((ch === 0x2D || ch === 0x2E) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}

function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 || ch === 0x26 || ch === 0x2A || ch === 0x21 || ch === 0x7C || ch === 0x3E || ch === 0x27 || ch === 0x22 || ch === 0x25 || ch === 0x40 || ch === 0x60) {
      return false;
    }

  if (ch === 0x3F || ch === 0x2D) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 0x23) {
        preceding = state.input.charCodeAt(state.position - 1);

        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27) {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
          return true;
        }
      } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22) {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 0x5C) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, 'expected hexadecimal character');
            }
          }

          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, 'unknown escape sequence');
        }

        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _lineStart,
      _pos,
      _tag = state.tag,
      _result,
      _anchor = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = Object.create(null),
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B) {
      terminator = 0x5D;
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B) {
      terminator = 0x7D;
      isMapping = true;
      _result = {};
    } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    } else if (ch === 0x2C) {
        throwError(state, "expected the node content, but found ','");
      }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }

    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent = nodeIndent,
      emptyLines = 0,
      atMoreIndented = false,
      tmp,
      ch;
  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C) {
      folding = false;
    } else if (ch === 0x3E) {
      folding = true;
    } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B || ch === 0x2D) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 0x2B ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, 'repeat of a chomping mode identifier');
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }
    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));

    if (ch === 0x23) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += '\n';
        }
      }

      break;
    }

    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += ' ';
        }
      } else {
        state.result += common.repeat('\n', emptyLines);
      }
    } else {
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = [],
      following,
      detected = false,
      ch;

  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    if (ch !== 0x2D) {
        break;
      }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);

        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);

    _result.push(state.result);

    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }

  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _keyLine,
      _keyLineStart,
      _keyPos,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = {},
      overridableKeys = Object.create(null),
      keyTag = null,
      keyNode = null,
      valueNode = null,
      atExplicitKey = false,
      detected = false,
      ch;

  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;

    if ((ch === 0x3F || ch === 0x3A) && is_WS_OR_EOL(following)) {
      if (ch === 0x3F) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;

      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A) {
            ch = state.input.charCodeAt(++state.position);

            if (!is_WS_OR_EOL(ch)) {
              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }

    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }

      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x21) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21) {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);
    } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 0x3E);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 0x21) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, 'named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, 'tag name is malformed: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$2.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;
  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position, ch;

  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x26) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias, ch;

  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x2A) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty$2.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1,
      atNewLine = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      typeList,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === '?') {
    if (state.result !== null && state.kind !== 'scalar') {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }

    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type = state.implicitTypes[typeIndex];

      if (type.resolve(state.result)) {
        state.result = type.construct(state.result);
        state.tag = type.tag;

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }

        break;
      }
    }
  } else if (state.tag !== '!') {
    if (_hasOwnProperty$2.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];
    } else {
      type = null;
      typeList = state.typeMap.multi[state.kind || 'fallback'];

      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type = typeList[typeIndex];
          break;
        }
      }
    }

    if (!type) {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }

    if (state.result !== null && type.kind !== state.kind) {
      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
    }

    if (!type.resolve(state.result, state.tag)) {
      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
    } else {
      state.result = type.construct(state.result, state.tag);

      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }

  return state.tag !== null || state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25) {
        break;
      }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));

          break;
        }

      if (is_EOL(ch)) break;
      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty$2.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D && state.input.charCodeAt(state.position + 1) === 0x2D && state.input.charCodeAt(state.position + 2) === 0x2D) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 0x2E) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }

    return;
  }

  if (state.position < state.length - 1) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}

function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 0x0A && input.charCodeAt(input.length - 1) !== 0x0D) {
        input += '\n';
      }

    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);
  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < state.length - 1) {
    readDocument(state);
  }

  return state.documents;
}

function loadAll(input, iterator, options) {
  if (iterator !== null && _typeof(iterator) === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}

function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }

  throw new exception('expected a single document in the stream, but found more');
}

var loadAll_1 = loadAll;
var load_1 = load;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString$2 = Object.prototype.toString;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var CHAR_BOM = 0xFEFF;
var CHAR_TAB = 0x09;
var CHAR_LINE_FEED = 0x0A;
var CHAR_CARRIAGE_RETURN = 0x0D;
var CHAR_SPACE = 0x20;
var CHAR_EXCLAMATION = 0x21;
var CHAR_DOUBLE_QUOTE = 0x22;
var CHAR_SHARP = 0x23;
var CHAR_PERCENT = 0x25;
var CHAR_AMPERSAND = 0x26;
var CHAR_SINGLE_QUOTE = 0x27;
var CHAR_ASTERISK = 0x2A;
var CHAR_COMMA = 0x2C;
var CHAR_MINUS = 0x2D;
var CHAR_COLON = 0x3A;
var CHAR_EQUALS = 0x3D;
var CHAR_GREATER_THAN = 0x3E;
var CHAR_QUESTION = 0x3F;
var CHAR_COMMERCIAL_AT = 0x40;
var CHAR_LEFT_SQUARE_BRACKET = 0x5B;
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;
var CHAR_GRAVE_ACCENT = 0x60;
var CHAR_LEFT_CURLY_BRACKET = 0x7B;
var CHAR_VERTICAL_LINE = 0x7C;
var CHAR_RIGHT_CURLY_BRACKET = 0x7D;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0x00] = '\\0';
ESCAPE_SEQUENCES[0x07] = '\\a';
ESCAPE_SEQUENCES[0x08] = '\\b';
ESCAPE_SEQUENCES[0x09] = '\\t';
ESCAPE_SEQUENCES[0x0A] = '\\n';
ESCAPE_SEQUENCES[0x0B] = '\\v';
ESCAPE_SEQUENCES[0x0C] = '\\f';
ESCAPE_SEQUENCES[0x0D] = '\\r';
ESCAPE_SEQUENCES[0x1B] = '\\e';
ESCAPE_SEQUENCES[0x22] = '\\"';
ESCAPE_SEQUENCES[0x5C] = '\\\\';
ESCAPE_SEQUENCES[0x85] = '\\N';
ESCAPE_SEQUENCES[0xA0] = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';
var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;
  if (map === null) return {};
  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty$3.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

var QUOTING_TYPE_SINGLE = 1,
    QUOTING_TYPE_DOUBLE = 2;

function State$1(options) {
  this.schema = options['schema'] || _default;
  this.indent = Math.max(1, options['indent'] || 2);
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys = options['sortKeys'] || false;
  this.lineWidth = options['lineWidth'] || 80;
  this.noRefs = options['noRefs'] || false;
  this.noCompatMode = options['noCompatMode'] || false;
  this.condenseFlow = options['condenseFlow'] || false;
  this.quotingType = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options['forceQuotes'] || false;
  this.replacer = typeof options['replacer'] === 'function' ? options['replacer'] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = '';
  this.duplicates = [];
  this.usedDuplicates = null;
}

function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);

    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;
    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

function isPrintable(c) {
  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== CHAR_BOM || 0x10000 <= c && c <= 0x10FFFF;
}

function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}

function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
}

function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}

function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}

function codePointAt(string, pos) {
  var first = string.charCodeAt(pos),
      second;

  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);

    if (second >= 0xDC00 && second <= 0xDFFF) {
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }

  return first;
}

function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN = 1,
    STYLE_SINGLE = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED = 4,
    STYLE_DOUBLE = 5;

function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));

  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);

      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }

      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);

      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;

        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }

      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }

    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
  }

  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }

    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }

  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }

  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }

  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}

function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function () {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }

    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }

    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;

    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
      case STYLE_PLAIN:
        return string;

      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";

      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));

      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));

      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';

      default:
        throw new exception('impossible error: invalid scalar style');
    }
  }();
}

function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';
  var clip = string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : clip ? '' : '-';
  return indentIndicator + chomp + '\n';
}

function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;

  var result = function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();

  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;
  var match;

  while (match = lineRe.exec(string)) {
    var prefix = match[1],
        line = match[2];
    moreIndented = line[0] === ' ';
    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0,
      end,
      curr = 0,
      next = 0;
  var result = '';

  while (match = breakRe.exec(line)) {
    next = match.index;

    if (next - start > width) {
      end = curr > start ? curr : next;
      result += '\n' + line.slice(start, end);
      start = end + 1;
    }

    curr = next;
  }

  result += '\n';

  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1);
}

function escapeString(string) {
  var result = '';
  var char = 0;
  var escapeSeq;

  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];

    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 0x10000) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    if (writeNode(state, level, value, false, false) || typeof value === 'undefined' && writeNode(state, level, null, false, false)) {
      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === 'undefined' && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== '') {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]';
}

function writeFlowMapping(state, level, object) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';
    if (_result !== '') pairBuffer += ', ';
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';
    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }

    pairBuffer += state.dump;
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || _result !== '') {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }

    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}';
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf || type.predicate) && (!type.instanceOf || _typeof(object) === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
      if (explicit) {
        if (type.multi && type.representName) {
          state.tag = type.representName(object);
        } else {
          state.tag = type.tag;
        }
      } else {
        state.tag = '?';
      }

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString$2.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty$3.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString$2.call(state.dump);

  var inblock = block;
  var tagStr;

  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }

    if (type === '[object Object]') {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type === '[object Undefined]') {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      tagStr = encodeURI(state.tag[0] === '!' ? state.tag.slice(1) : state.tag).replace(/!/g, '%21');

      if (state.tag[0] === '!') {
        tagStr = '!' + tagStr;
      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
        tagStr = '!!' + tagStr.slice(18);
      } else {
        tagStr = '!<' + tagStr + '>';
      }

      state.dump = tagStr + ' ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;
  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }

  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;

  if (object !== null && _typeof(object) === 'object') {
    index = objects.indexOf(object);

    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};
  var state = new State$1(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;

  if (state.replacer) {
    value = state.replacer.call({
      '': value
    }, '', value);
  }

  if (writeNode(state, 0, value, true, true)) return state.dump + '\n';
  return '';
}

var dump_1 = dump;
var dumper = {
  dump: dump_1
};

function renamed(from, to) {
  return function () {
    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' + 'Use yaml.' + to + ' instead, which is now safe by default.');
  };
}

var Type$1 = type;
exports.Type = Type$1;
var Schema$1 = schema;
exports.Schema = Schema$1;
var FAILSAFE_SCHEMA = failsafe;
exports.FAILSAFE_SCHEMA = FAILSAFE_SCHEMA;
var JSON_SCHEMA = json;
exports.JSON_SCHEMA = JSON_SCHEMA;
var CORE_SCHEMA = core;
exports.CORE_SCHEMA = CORE_SCHEMA;
var DEFAULT_SCHEMA = _default;
exports.DEFAULT_SCHEMA = DEFAULT_SCHEMA;
var load$1 = loader.load;
exports.load = load$1;
var loadAll$1 = loader.loadAll;
exports.loadAll = loadAll$1;
var dump$1 = dumper.dump;
exports.dump = dump$1;
var YAMLException$1 = exception;
exports.YAMLException = YAMLException$1;
var safeLoad = renamed('safeLoad', 'load');
exports.safeLoad = safeLoad;
var safeLoadAll = renamed('safeLoadAll', 'loadAll');
exports.safeLoadAll = safeLoadAll;
var safeDump = renamed('safeDump', 'dump');
exports.safeDump = safeDump;
var jsYaml = {
  Type: Type$1,
  Schema: Schema$1,
  FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
  JSON_SCHEMA: JSON_SCHEMA,
  CORE_SCHEMA: CORE_SCHEMA,
  DEFAULT_SCHEMA: DEFAULT_SCHEMA,
  load: load$1,
  loadAll: loadAll$1,
  dump: dump$1,
  YAMLException: YAMLException$1,
  safeLoad: safeLoad,
  safeLoadAll: safeLoadAll,
  safeDump: safeDump
};
var _default2 = jsYaml;
exports["default"] = _default2;

/***/ }),

/***/ 92092:
/***/ ((module, exports, __webpack_require__) => {

if (true) {
  var f = __webpack_require__(57147)
  if (f.default) f = f.default
  exports["default"] = f
  module.exports = exports.default
}


/***/ }),

/***/ 77029:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(19699);

var _readFile = __webpack_require__(26450);

var _writeFile2 = __webpack_require__(31107);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var getDefaults = function getDefaults() {
  return {
    loadPath: '/locales/{{lng}}/{{ns}}.json',
    addPath: '/locales/{{lng}}/{{ns}}.missing.json',
    ident: 2,
    parse: JSON.parse,
    stringify: JSON.stringify
  };
};

var Backend = function () {
  function Backend(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var allOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Backend);

    this.services = services;
    this.options = options;
    this.allOptions = allOptions;
    this.type = 'backend';
    this.init(services, options, allOptions);
  }

  _createClass(Backend, [{
    key: "init",
    value: function init(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var allOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.services = services;
      this.options = (0, _utils.defaults)(options, this.options || {}, getDefaults());
      this.allOptions = allOptions;
      this.queuedWrites = {};
      this.debouncedWrite = (0, _utils.debounce)(this.write, 250);
    }
  }, {
    key: "read",
    value: function read(language, namespace, callback) {
      var _this = this;

      var loadPath = this.options.loadPath;

      if (typeof this.options.loadPath === 'function') {
        loadPath = this.options.loadPath(language, namespace);
      }

      var filename = this.services.interpolator.interpolate(loadPath, {
        lng: language,
        ns: namespace
      });

      if (this.allOptions.initImmediate === false) {
        try {
          var _readFileSync = (0, _readFile.readFileSync)(filename, this.options),
              data = _readFileSync.data,
              stat = _readFileSync.stat;

          if (this.options.expirationTime && stat && stat.mtime && stat.mtime.getTime() + this.options.expirationTime < Date.now()) {
            this.removeFile(language, namespace);
            return callback(new Error('File expired!'), false);
          }

          callback(null, data);
        } catch (err) {
          callback(err, false);
        }

        return;
      }

      (0, _readFile.readFile)(filename, this.options).then(function (_ref) {
        var data = _ref.data,
            stat = _ref.stat;

        if (_this.options.expirationTime && stat && stat.mtime && stat.mtime.getTime() + _this.options.expirationTime < Date.now()) {
          _this.removeFile(language, namespace);

          return callback(new Error('File expired!'), false);
        }

        callback(null, data);
      }).catch(function (err) {
        return callback(err, false);
      });
    }
  }, {
    key: "create",
    value: function create(languages, namespace, key, fallbackValue, callback) {
      var _this2 = this;

      if (!callback) callback = function callback() {};
      if (typeof languages === 'string') languages = [languages];
      var todo = languages.length;

      var done = function done() {
        if (! --todo) callback();
      };

      languages.forEach(function (lng) {
        _this2.queue.call(_this2, lng, namespace, key, fallbackValue, done);
      });
    }
  }, {
    key: "save",
    value: function save(language, namespace, data, callback) {
      var _this3 = this;

      if (!callback) callback = function callback() {};
      var keys = Object.keys(data);
      var todo = keys.length;

      var done = function done() {
        if (! --todo) callback();
      };

      keys.forEach(function (key) {
        _this3.queue.call(_this3, language, namespace, key, data[key], done);
      });
    }
  }, {
    key: "removeFile",
    value: function removeFile(language, namespace) {
      var addPath = this.options.addPath;

      if (typeof this.options.addPath === 'function') {
        addPath = this.options.addPath(language, namespace);
      }

      var filename = this.services.interpolator.interpolate(addPath, {
        lng: language,
        ns: namespace
      });
      (0, _writeFile2.removeFile)(filename, this.options).then(function () {}).catch(function () {});
    }
  }, {
    key: "write",
    value: function write() {
      for (var lng in this.queuedWrites) {
        var namespaces = this.queuedWrites[lng];

        if (lng !== 'locks') {
          for (var ns in namespaces) {
            this.writeFile(lng, ns);
          }
        }
      }
    }
  }, {
    key: "writeFile",
    value: function writeFile(lng, namespace) {
      var _this4 = this;

      var lock = (0, _utils.getPath)(this.queuedWrites, ['locks', lng, namespace]);
      if (lock) return;
      var addPath = this.options.addPath;

      if (typeof this.options.addPath === 'function') {
        addPath = this.options.addPath(lng, namespace);
      }

      var filename = this.services.interpolator.interpolate(addPath, {
        lng: lng,
        ns: namespace
      });
      var missings = (0, _utils.getPath)(this.queuedWrites, [lng, namespace]);
      (0, _utils.setPath)(this.queuedWrites, [lng, namespace], []);

      if (missings.length) {
        (0, _utils.setPath)(this.queuedWrites, ['locks', lng, namespace], true);

        var proceed = function proceed(_ref2) {
          var data = _ref2.data;
          missings.forEach(function (missing) {
            var path = _this4.allOptions.keySeparator === false ? [missing.key] : missing.key.split(_this4.allOptions.keySeparator || '.');
            (0, _utils.setPath)(data, path, missing.fallbackValue);
          });

          var proceedWrite = function proceedWrite() {
            (0, _utils.setPath)(_this4.queuedWrites, ['locks', lng, namespace], false);
            missings.forEach(function (missing) {
              if (missing.callback) missing.callback();
            });

            _this4.debouncedWrite();
          };

          (0, _writeFile2.writeFile)(filename, data, _this4.options).then(proceedWrite).catch(proceedWrite);
        };

        (0, _readFile.readFile)(filename, this.options).then(proceed).catch(function () {
          return proceed({
            data: {}
          });
        });
      }
    }
  }, {
    key: "queue",
    value: function queue(lng, namespace, key, fallbackValue, callback) {
      (0, _utils.pushPath)(this.queuedWrites, [lng, namespace], {
        key: key,
        fallbackValue: fallbackValue || '',
        callback: callback
      });
      this.debouncedWrite();
    }
  }]);

  return Backend;
}();

Backend.type = 'backend';
var _default = Backend;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 26450:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.readFileSync = readFileSync;
exports.readFile = readFile;

var _json = _interopRequireDefault(__webpack_require__(78729));

var _yaml = _interopRequireDefault(__webpack_require__(56090));

var fsMod = _interopRequireWildcard(__webpack_require__(92092));

var _extname = _interopRequireDefault(__webpack_require__(85072));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isDeno = typeof Deno !== 'undefined';
var YAML = typeof _yaml.default !== 'undefined' && _yaml.default.load ? _yaml.default : undefined;
var fs = fsMod ? fsMod.default || fsMod : undefined;

var readFileInNodeSync = function readFileInNodeSync(filename) {
  var data = fs.readFileSync(filename, 'utf8');
  var stat;

  try {
    stat = fs.statSync(filename);
  } catch (e) {}

  return {
    data: data,
    stat: stat
  };
};

var readFileInNode = function readFileInNode(filename) {
  return new Promise(function (resolve, reject) {
    fs.readFile(filename, 'utf8', function (err, data) {
      if (err) return reject(err);
      fs.stat(filename, function (err, stat) {
        if (err) return resolve({
          data: data
        });
        return resolve({
          data: data,
          stat: stat
        });
      });
    });
  });
};

var readFileInDenoSync = function readFileInDenoSync(filename) {
  var decoder = new TextDecoder('utf-8');
  var d = Deno.readFileSync(filename);
  var data = decoder.decode(d);
  var stat;

  try {
    stat = Deno.statSync(filename);
  } catch (e) {}

  return {
    data: data,
    stat: stat
  };
};

var readFileInDeno = function readFileInDeno(filename) {
  return new Promise(function (resolve, reject) {
    var decoder = new TextDecoder('utf-8');
    Deno.readFile(filename).then(function (d) {
      var data = decoder.decode(d);
      Deno.stat(filename).then(function (stat) {
        return resolve({
          data: data,
          stat: stat
        });
      }).catch(function () {
        return resolve({
          data: data
        });
      });
    }).catch(reject);
  });
};

var parseData = function parseData(extension, data, options) {
  data = data.replace(/^\uFEFF/, '');
  var result = {};

  switch (extension) {
    case '.js':
    case '.ts':
      if (false) {}

      result = eval(data);
      break;

    case '.json5':
      result = _json.default.parse(data);
      break;

    case '.yml':
    case '.yaml':
      result = YAML.load(data);
      break;

    default:
      result = options.parse(data);
  }

  return result;
};

function readFileSync(filename, options) {
  var ext = (0, _extname.default)(filename);

  if (['.js', '.ts'].indexOf(ext) > -1 && "function" !== 'undefined') {
    return __webpack_require__(14929)(!filename.startsWith('/') && typeof process !== 'undefined' && process.cwd ? "".concat(process.cwd(), "/").concat(filename) : filename);
  }

  var data, stat;

  if (isDeno) {
    var ret = readFileInDenoSync(filename);
    data = ret.data;
    stat = ret.stat;
  } else {
    var _ret = readFileInNodeSync(filename);

    data = _ret.data;
    stat = _ret.stat;
  }

  return {
    data: parseData(ext, data, options),
    stat: stat
  };
}

function readFile(filename) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    parse: JSON.parse
  };
  var ext = (0, _extname.default)(filename);

  if (['.js', '.ts'].indexOf(ext) > -1 && "function" !== 'undefined') {
    return new Promise(function (resolve, reject) {
      try {
        resolve({
          data: __webpack_require__(14929)(!filename.startsWith('/') && typeof process !== 'undefined' && process.cwd ? "".concat(process.cwd(), "/").concat(filename) : filename)
        });
      } catch (err) {
        reject(err);
      }
    });
  }

  var fn = isDeno ? readFileInDeno : readFileInNode;
  return new Promise(function (resolve, reject) {
    fn(filename).then(function (_ref) {
      var data = _ref.data,
          stat = _ref.stat;

      try {
        var ret = parseData(ext, data, options);
        resolve({
          data: ret,
          stat: stat
        });
      } catch (err) {
        err.message = 'error parsing ' + filename + ': ' + err.message;
        reject(err);
      }
    }).catch(reject);
  });
}

/***/ }),

/***/ 19699:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.defaults = defaults;
exports.debounce = debounce;
exports.setPath = setPath;
exports.pushPath = pushPath;
exports.getPath = getPath;
var arr = [];
var each = arr.forEach;
var slice = arr.slice;

function defaults(obj) {
  each.call(slice.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this;
    var args = arguments;

    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
  }

  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

  while (stack.length > 1) {
    if (!object) return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty) object[key] = new Empty();
    object = object[key];
  }

  if (!object) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}

function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  obj[k] = newValue;
}

function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object),
      obj = _getLastOfPath2.obj,
      k = _getLastOfPath2.k;

  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}

function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}

/***/ }),

/***/ 31107:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.writeFileSync = writeFileSync;
exports.writeFile = writeFile;
exports.removeFileSync = removeFileSync;
exports.removeFile = removeFile;

var _json = _interopRequireDefault(__webpack_require__(78729));

var _yaml = _interopRequireDefault(__webpack_require__(56090));

var fsMod = _interopRequireWildcard(__webpack_require__(92092));

var _extname = _interopRequireDefault(__webpack_require__(85072));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isDeno = typeof Deno !== 'undefined';
var YAML = typeof _yaml.default !== 'undefined' && _yaml.default.load ? _yaml.default : undefined;
var fs = fsMod ? fsMod.default || fsMod : undefined;

function dirname(path) {
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47;
  var end = -1;
  var matchedSlash = true;

  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);

    if (code === 47) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) return '//';
  return path.slice(0, end);
}

var writeFileInNodeSync = function writeFileInNodeSync(filename, payload) {
  try {
    fs.mkdirSync(dirname(filename), {
      recursive: true
    });
  } catch (err) {}

  return fs.writeFileSync(filename, payload, 'utf8');
};

var writeFileInNode = function writeFileInNode(filename, payload) {
  return new Promise(function (resolve, reject) {
    fs.mkdir(dirname(filename), {
      recursive: true
    }, function () {
      fs.writeFile(filename, payload, 'utf8', function (err, data) {
        return err ? reject(err) : resolve(data);
      });
    });
  });
};

var removeFileInNodeSync = function removeFileInNodeSync(filename) {
  return fs.unlinkSync(filename);
};

var removeFileInNode = function removeFileInNode(filename) {
  return new Promise(function (resolve, reject) {
    return fs.unlink(filename, function (err) {
      return err ? reject(err) : resolve();
    });
  });
};

var writeFileInDenoSync = function writeFileInDenoSync(filename, payload) {
  var encoder = new TextEncoder();
  var data = encoder.encode(payload);

  try {
    Deno.mkdirSync(dirname(filename), {
      recursive: true
    });
  } catch (err) {}

  Deno.writeFileSync(filename, data);
};

var writeFileInDeno = function writeFileInDeno(filename, payload) {
  var encoder = new TextEncoder();
  var data = encoder.encode(payload);
  return new Promise(function (resolve, reject) {
    Deno.mkdir(dirname(filename), {
      recursive: true
    }).then(function () {
      Deno.writeFile(filename, data).then(resolve, reject);
    }).catch(function () {
      Deno.writeFile(filename, data).then(resolve, reject);
    });
  });
};

var removeFileInDenoSync = function removeFileInDenoSync(filename) {
  Deno.removeSync(filename);
};

var removeFileInDeno = function removeFileInDeno(filename) {
  return Deno.remove(filename);
};

var stringifyData = function stringifyData(extension, data, options) {
  var result = '';

  switch (extension) {
    case '.js':
    case '.ts':
      if (false) {} else {
        result = "module.exports = ".concat(options.stringify(data, null, options.ident));
      }

      break;

    case '.json5':
      result = _json.default.stringify(data, null, options.ident);
      break;

    case '.yml':
    case '.yaml':
      result = YAML.dump(data, {
        ident: options.indent
      });
      break;

    default:
      result = options.stringify(data, null, options.ident);
  }

  return result;
};

function writeFileSync(filename, payload, options) {
  var ext = (0, _extname.default)(filename);
  var data;

  try {
    data = stringifyData(ext, payload, options);
  } catch (err) {
    err.message = 'error stringifying ' + filename + ': ' + err.message;
    throw err;
  }

  if (isDeno) {
    return writeFileInDenoSync(filename, data);
  } else {
    return writeFileInNodeSync(filename, data);
  }
}

function writeFile(filename, payload) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    stringify: JSON.stringify,
    ident: 2
  };
  var ext = (0, _extname.default)(filename);
  var data;

  try {
    data = stringifyData(ext, payload, options);
  } catch (err) {
    err.message = 'error stringifying ' + filename + ': ' + err.message;
    throw err;
  }

  var fn = isDeno ? writeFileInDeno : writeFileInNode;
  return fn(filename, data);
}

function removeFileSync(filename) {
  if (isDeno) {
    return removeFileInDenoSync(filename);
  } else {
    return removeFileInNodeSync(filename);
  }
}

function removeFile(filename) {
  var fn = isDeno ? removeFileInDeno : removeFileInNode;
  return fn(filename);
}

/***/ }),

/***/ 99512:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var PlainValue = __webpack_require__(75551);
var resolveSeq = __webpack_require__(28393);
var Schema = __webpack_require__(51430);

const defaultOptions = {
  anchorPrefix: 'a',
  customTags: null,
  indent: 2,
  indentSeq: true,
  keepCstNodes: false,
  keepNodeTypes: true,
  keepBlobsInJSON: true,
  mapAsMap: false,
  maxAliasCount: 100,
  prettyErrors: false,
  // TODO Set true in v2
  simpleKeys: false,
  version: '1.2'
};
const scalarOptions = {
  get binary() {
    return resolveSeq.binaryOptions;
  },

  set binary(opt) {
    Object.assign(resolveSeq.binaryOptions, opt);
  },

  get bool() {
    return resolveSeq.boolOptions;
  },

  set bool(opt) {
    Object.assign(resolveSeq.boolOptions, opt);
  },

  get int() {
    return resolveSeq.intOptions;
  },

  set int(opt) {
    Object.assign(resolveSeq.intOptions, opt);
  },

  get null() {
    return resolveSeq.nullOptions;
  },

  set null(opt) {
    Object.assign(resolveSeq.nullOptions, opt);
  },

  get str() {
    return resolveSeq.strOptions;
  },

  set str(opt) {
    Object.assign(resolveSeq.strOptions, opt);
  }

};
const documentOptions = {
  '1.0': {
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [{
      handle: '!',
      prefix: PlainValue.defaultTagPrefix
    }, {
      handle: '!!',
      prefix: 'tag:private.yaml.org,2002:'
    }]
  },
  1.1: {
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [{
      handle: '!',
      prefix: '!'
    }, {
      handle: '!!',
      prefix: PlainValue.defaultTagPrefix
    }]
  },
  1.2: {
    schema: 'core',
    merge: false,
    tagPrefixes: [{
      handle: '!',
      prefix: '!'
    }, {
      handle: '!!',
      prefix: PlainValue.defaultTagPrefix
    }]
  }
};

function stringifyTag(doc, tag) {
  if ((doc.version || doc.options.version) === '1.0') {
    const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
    if (priv) return '!' + priv[1];
    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;
  }

  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);

  if (!p) {
    const dtp = doc.getDefaults().tagPrefixes;
    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);
  }

  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;
  const suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, ch => ({
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
  })[ch]);
  return p.handle + suffix;
}

function getTagObject(tags, item) {
  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;

  if (item.tag) {
    const match = tags.filter(t => t.tag === item.tag);
    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];
  }

  let tagObj, obj;

  if (item instanceof resolveSeq.Scalar) {
    obj = item.value; // TODO: deprecate/remove class check

    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);
  } else {
    obj = item;
    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
  }

  if (!tagObj) {
    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }

  return tagObj;
} // needs to be called before value stringifier to allow for circular anchor refs


function stringifyProps(node, tagObj, {
  anchors,
  doc
}) {
  const props = [];
  const anchor = doc.anchors.getName(node);

  if (anchor) {
    anchors[anchor] = node;
    props.push(`&${anchor}`);
  }

  if (node.tag) {
    props.push(stringifyTag(doc, node.tag));
  } else if (!tagObj.default) {
    props.push(stringifyTag(doc, tagObj.tag));
  }

  return props.join(' ');
}

function stringify(item, ctx, onComment, onChompKeep) {
  const {
    anchors,
    schema
  } = ctx.doc;
  let tagObj;

  if (!(item instanceof resolveSeq.Node)) {
    const createCtx = {
      aliasNodes: [],
      onTagObj: o => tagObj = o,
      prevObjects: new Map()
    };
    item = schema.createNode(item, true, null, createCtx);

    for (const alias of createCtx.aliasNodes) {
      alias.source = alias.source.node;
      let name = anchors.getName(alias.source);

      if (!name) {
        name = anchors.newName();
        anchors.map[name] = alias.source;
      }
    }
  }

  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);
  if (!tagObj) tagObj = getTagObject(schema.tags, item);
  const props = stringifyProps(item, tagObj, ctx);
  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
  if (!props) return str;
  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
}

class Anchors {
  static validAnchorNode(node) {
    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;
  }

  constructor(prefix) {
    PlainValue._defineProperty(this, "map", Object.create(null));

    this.prefix = prefix;
  }

  createAlias(node, name) {
    this.setAnchor(node, name);
    return new resolveSeq.Alias(node);
  }

  createMergePair(...sources) {
    const merge = new resolveSeq.Merge();
    merge.value.items = sources.map(s => {
      if (s instanceof resolveSeq.Alias) {
        if (s.source instanceof resolveSeq.YAMLMap) return s;
      } else if (s instanceof resolveSeq.YAMLMap) {
        return this.createAlias(s);
      }

      throw new Error('Merge sources must be Map nodes or their Aliases');
    });
    return merge;
  }

  getName(node) {
    const {
      map
    } = this;
    return Object.keys(map).find(a => map[a] === node);
  }

  getNames() {
    return Object.keys(this.map);
  }

  getNode(name) {
    return this.map[name];
  }

  newName(prefix) {
    if (!prefix) prefix = this.prefix;
    const names = Object.keys(this.map);

    for (let i = 1; true; ++i) {
      const name = `${prefix}${i}`;
      if (!names.includes(name)) return name;
    }
  } // During parsing, map & aliases contain CST nodes


  resolveNodes() {
    const {
      map,
      _cstAliases
    } = this;
    Object.keys(map).forEach(a => {
      map[a] = map[a].resolved;
    });

    _cstAliases.forEach(a => {
      a.source = a.source.resolved;
    });

    delete this._cstAliases;
  }

  setAnchor(node, name) {
    if (node != null && !Anchors.validAnchorNode(node)) {
      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');
    }

    if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
      throw new Error('Anchor names must not contain whitespace or control characters');
    }

    const {
      map
    } = this;
    const prev = node && Object.keys(map).find(a => map[a] === node);

    if (prev) {
      if (!name) {
        return prev;
      } else if (prev !== name) {
        delete map[prev];
        map[name] = node;
      }
    } else {
      if (!name) {
        if (!node) return null;
        name = this.newName();
      }

      map[name] = node;
    }

    return name;
  }

}

const visit = (node, tags) => {
  if (node && typeof node === 'object') {
    const {
      tag
    } = node;

    if (node instanceof resolveSeq.Collection) {
      if (tag) tags[tag] = true;
      node.items.forEach(n => visit(n, tags));
    } else if (node instanceof resolveSeq.Pair) {
      visit(node.key, tags);
      visit(node.value, tags);
    } else if (node instanceof resolveSeq.Scalar) {
      if (tag) tags[tag] = true;
    }
  }

  return tags;
};

const listTagNames = node => Object.keys(visit(node, {}));

function parseContents(doc, contents) {
  const comments = {
    before: [],
    after: []
  };
  let body = undefined;
  let spaceBefore = false;

  for (const node of contents) {
    if (node.valueRange) {
      if (body !== undefined) {
        const msg = 'Document contains trailing content not separated by a ... or --- line';
        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));
        break;
      }

      const res = resolveSeq.resolveNode(doc, node);

      if (spaceBefore) {
        res.spaceBefore = true;
        spaceBefore = false;
      }

      body = res;
    } else if (node.comment !== null) {
      const cc = body === undefined ? comments.before : comments.after;
      cc.push(node.comment);
    } else if (node.type === PlainValue.Type.BLANK_LINE) {
      spaceBefore = true;

      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {
        // space-separated comments at start are parsed as document comments
        doc.commentBefore = comments.before.join('\n');
        comments.before = [];
      }
    }
  }

  doc.contents = body || null;

  if (!body) {
    doc.comment = comments.before.concat(comments.after).join('\n') || null;
  } else {
    const cb = comments.before.join('\n');

    if (cb) {
      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;
      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\n${cbNode.commentBefore}` : cb;
    }

    doc.comment = comments.after.join('\n') || null;
  }
}

function resolveTagDirective({
  tagPrefixes
}, directive) {
  const [handle, prefix] = directive.parameters;

  if (!handle || !prefix) {
    const msg = 'Insufficient parameters given for %TAG directive';
    throw new PlainValue.YAMLSemanticError(directive, msg);
  }

  if (tagPrefixes.some(p => p.handle === handle)) {
    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';
    throw new PlainValue.YAMLSemanticError(directive, msg);
  }

  return {
    handle,
    prefix
  };
}

function resolveYamlDirective(doc, directive) {
  let [version] = directive.parameters;
  if (directive.name === 'YAML:1.0') version = '1.0';

  if (!version) {
    const msg = 'Insufficient parameters given for %YAML directive';
    throw new PlainValue.YAMLSemanticError(directive, msg);
  }

  if (!documentOptions[version]) {
    const v0 = doc.version || doc.options.version;
    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;
    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
  }

  return version;
}

function parseDirectives(doc, directives, prevDoc) {
  const directiveComments = [];
  let hasDirectives = false;

  for (const directive of directives) {
    const {
      comment,
      name
    } = directive;

    switch (name) {
      case 'TAG':
        try {
          doc.tagPrefixes.push(resolveTagDirective(doc, directive));
        } catch (error) {
          doc.errors.push(error);
        }

        hasDirectives = true;
        break;

      case 'YAML':
      case 'YAML:1.0':
        if (doc.version) {
          const msg = 'The %YAML directive must only be given at most once per document.';
          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));
        }

        try {
          doc.version = resolveYamlDirective(doc, directive);
        } catch (error) {
          doc.errors.push(error);
        }

        hasDirectives = true;
        break;

      default:
        if (name) {
          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;
          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
        }

    }

    if (comment) directiveComments.push(comment);
  }

  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {
    const copyTagPrefix = ({
      handle,
      prefix
    }) => ({
      handle,
      prefix
    });

    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
    doc.version = prevDoc.version;
  }

  doc.commentBefore = directiveComments.join('\n') || null;
}

function assertCollection(contents) {
  if (contents instanceof resolveSeq.Collection) return true;
  throw new Error('Expected a YAML collection as document contents');
}

class Document {
  constructor(options) {
    this.anchors = new Anchors(options.anchorPrefix);
    this.commentBefore = null;
    this.comment = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.errors = [];
    this.options = options;
    this.schema = null;
    this.tagPrefixes = [];
    this.version = null;
    this.warnings = [];
  }

  add(value) {
    assertCollection(this.contents);
    return this.contents.add(value);
  }

  addIn(path, value) {
    assertCollection(this.contents);
    this.contents.addIn(path, value);
  }

  delete(key) {
    assertCollection(this.contents);
    return this.contents.delete(key);
  }

  deleteIn(path) {
    if (resolveSeq.isEmptyPath(path)) {
      if (this.contents == null) return false;
      this.contents = null;
      return true;
    }

    assertCollection(this.contents);
    return this.contents.deleteIn(path);
  }

  getDefaults() {
    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};
  }

  get(key, keepScalar) {
    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;
  }

  getIn(path, keepScalar) {
    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;
    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;
  }

  has(key) {
    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;
  }

  hasIn(path) {
    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;
    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;
  }

  set(key, value) {
    assertCollection(this.contents);
    this.contents.set(key, value);
  }

  setIn(path, value) {
    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {
      assertCollection(this.contents);
      this.contents.setIn(path, value);
    }
  }

  setSchema(id, customTags) {
    if (!id && !customTags && this.schema) return;
    if (typeof id === 'number') id = id.toFixed(1);

    if (id === '1.0' || id === '1.1' || id === '1.2') {
      if (this.version) this.version = id;else this.options.version = id;
      delete this.options.schema;
    } else if (id && typeof id === 'string') {
      this.options.schema = id;
    }

    if (Array.isArray(customTags)) this.options.customTags = customTags;
    const opt = Object.assign({}, this.getDefaults(), this.options);
    this.schema = new Schema.Schema(opt);
  }

  parse(node, prevDoc) {
    if (this.options.keepCstNodes) this.cstNode = node;
    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';
    const {
      directives = [],
      contents = [],
      directivesEndMarker,
      error,
      valueRange
    } = node;

    if (error) {
      if (!error.source) error.source = this;
      this.errors.push(error);
    }

    parseDirectives(this, directives, prevDoc);
    if (directivesEndMarker) this.directivesEndMarker = true;
    this.range = valueRange ? [valueRange.start, valueRange.end] : null;
    this.setSchema();
    this.anchors._cstAliases = [];
    parseContents(this, contents);
    this.anchors.resolveNodes();

    if (this.options.prettyErrors) {
      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();

      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();
    }

    return this;
  }

  listNonDefaultTags() {
    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);
  }

  setTagPrefix(handle, prefix) {
    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');

    if (prefix) {
      const prev = this.tagPrefixes.find(p => p.handle === handle);
      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({
        handle,
        prefix
      });
    } else {
      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);
    }
  }

  toJSON(arg, onAnchor) {
    const {
      keepBlobsInJSON,
      mapAsMap,
      maxAliasCount
    } = this.options;
    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));
    const ctx = {
      doc: this,
      indentStep: '  ',
      keep,
      mapAsMap: keep && !!mapAsMap,
      maxAliasCount,
      stringify // Requiring directly in Pair would create circular dependencies

    };
    const anchorNames = Object.keys(this.anchors.map);
    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {
      alias: [],
      aliasCount: 0,
      count: 1
    }]));
    const res = resolveSeq.toJSON(this.contents, arg, ctx);
    if (typeof onAnchor === 'function' && ctx.anchors) for (const {
      count,
      res
    } of ctx.anchors.values()) onAnchor(res, count);
    return res;
  }

  toString() {
    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
    const indentSize = this.options.indent;

    if (!Number.isInteger(indentSize) || indentSize <= 0) {
      const s = JSON.stringify(indentSize);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }

    this.setSchema();
    const lines = [];
    let hasDirectives = false;

    if (this.version) {
      let vd = '%YAML 1.2';

      if (this.schema.name === 'yaml-1.1') {
        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';
      }

      lines.push(vd);
      hasDirectives = true;
    }

    const tagNames = this.listNonDefaultTags();
    this.tagPrefixes.forEach(({
      handle,
      prefix
    }) => {
      if (tagNames.some(t => t.indexOf(prefix) === 0)) {
        lines.push(`%TAG ${handle} ${prefix}`);
        hasDirectives = true;
      }
    });
    if (hasDirectives || this.directivesEndMarker) lines.push('---');

    if (this.commentBefore) {
      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');
      lines.unshift(this.commentBefore.replace(/^/gm, '#'));
    }

    const ctx = {
      anchors: Object.create(null),
      doc: this,
      indent: '',
      indentStep: ' '.repeat(indentSize),
      stringify // Requiring directly in nodes would create circular dependencies

    };
    let chompKeep = false;
    let contentComment = null;

    if (this.contents) {
      if (this.contents instanceof resolveSeq.Node) {
        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');
        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment

        ctx.forceBlockIndent = !!this.comment;
        contentComment = this.contents.comment;
      }

      const onChompKeep = contentComment ? null : () => chompKeep = true;
      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);
      lines.push(resolveSeq.addComment(body, '', contentComment));
    } else if (this.contents !== undefined) {
      lines.push(stringify(this.contents, ctx));
    }

    if (this.comment) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
      lines.push(this.comment.replace(/^/gm, '#'));
    }

    return lines.join('\n') + '\n';
  }

}

PlainValue._defineProperty(Document, "defaults", documentOptions);

exports.Document = Document;
exports.defaultOptions = defaultOptions;
exports.scalarOptions = scalarOptions;


/***/ }),

/***/ 75551:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const Char = {
  ANCHOR: '&',
  COMMENT: '#',
  TAG: '!',
  DIRECTIVES_END: '-',
  DOCUMENT_END: '.'
};
const Type = {
  ALIAS: 'ALIAS',
  BLANK_LINE: 'BLANK_LINE',
  BLOCK_FOLDED: 'BLOCK_FOLDED',
  BLOCK_LITERAL: 'BLOCK_LITERAL',
  COMMENT: 'COMMENT',
  DIRECTIVE: 'DIRECTIVE',
  DOCUMENT: 'DOCUMENT',
  FLOW_MAP: 'FLOW_MAP',
  FLOW_SEQ: 'FLOW_SEQ',
  MAP: 'MAP',
  MAP_KEY: 'MAP_KEY',
  MAP_VALUE: 'MAP_VALUE',
  PLAIN: 'PLAIN',
  QUOTE_DOUBLE: 'QUOTE_DOUBLE',
  QUOTE_SINGLE: 'QUOTE_SINGLE',
  SEQ: 'SEQ',
  SEQ_ITEM: 'SEQ_ITEM'
};
const defaultTagPrefix = 'tag:yaml.org,2002:';
const defaultTags = {
  MAP: 'tag:yaml.org,2002:map',
  SEQ: 'tag:yaml.org,2002:seq',
  STR: 'tag:yaml.org,2002:str'
};

function findLineStarts(src) {
  const ls = [0];
  let offset = src.indexOf('\n');

  while (offset !== -1) {
    offset += 1;
    ls.push(offset);
    offset = src.indexOf('\n', offset);
  }

  return ls;
}

function getSrcInfo(cst) {
  let lineStarts, src;

  if (typeof cst === 'string') {
    lineStarts = findLineStarts(cst);
    src = cst;
  } else {
    if (Array.isArray(cst)) cst = cst[0];

    if (cst && cst.context) {
      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
      lineStarts = cst.lineStarts;
      src = cst.context.src;
    }
  }

  return {
    lineStarts,
    src
  };
}
/**
 * @typedef {Object} LinePos - One-indexed position in the source
 * @property {number} line
 * @property {number} col
 */

/**
 * Determine the line/col position matching a character offset.
 *
 * Accepts a source string or a CST document as the second parameter. With
 * the latter, starting indices for lines are cached in the document as
 * `lineStarts: number[]`.
 *
 * Returns a one-indexed `{ line, col }` location if found, or
 * `undefined` otherwise.
 *
 * @param {number} offset
 * @param {string|Document|Document[]} cst
 * @returns {?LinePos}
 */


function getLinePos(offset, cst) {
  if (typeof offset !== 'number' || offset < 0) return null;
  const {
    lineStarts,
    src
  } = getSrcInfo(cst);
  if (!lineStarts || !src || offset > src.length) return null;

  for (let i = 0; i < lineStarts.length; ++i) {
    const start = lineStarts[i];

    if (offset < start) {
      return {
        line: i,
        col: offset - lineStarts[i - 1] + 1
      };
    }

    if (offset === start) return {
      line: i + 1,
      col: 1
    };
  }

  const line = lineStarts.length;
  return {
    line,
    col: offset - lineStarts[line - 1] + 1
  };
}
/**
 * Get a specified line from the source.
 *
 * Accepts a source string or a CST document as the second parameter. With
 * the latter, starting indices for lines are cached in the document as
 * `lineStarts: number[]`.
 *
 * Returns the line as a string if found, or `null` otherwise.
 *
 * @param {number} line One-indexed line number
 * @param {string|Document|Document[]} cst
 * @returns {?string}
 */

function getLine(line, cst) {
  const {
    lineStarts,
    src
  } = getSrcInfo(cst);
  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
  const start = lineStarts[line - 1];
  let end = lineStarts[line]; // undefined for last line; that's ok for slice()

  while (end && end > start && src[end - 1] === '\n') --end;

  return src.slice(start, end);
}
/**
 * Pretty-print the starting line from the source indicated by the range `pos`
 *
 * Trims output to `maxWidth` chars while keeping the starting column visible,
 * using `` at either end to indicate dropped characters.
 *
 * Returns a two-line string (or `null`) with `\n` as separator; the second line
 * will hold appropriately indented `^` marks indicating the column range.
 *
 * @param {Object} pos
 * @param {LinePos} pos.start
 * @param {LinePos} [pos.end]
 * @param {string|Document|Document[]*} cst
 * @param {number} [maxWidth=80]
 * @returns {?string}
 */

function getPrettyContext({
  start,
  end
}, cst, maxWidth = 80) {
  let src = getLine(start.line, cst);
  if (!src) return null;
  let {
    col
  } = start;

  if (src.length > maxWidth) {
    if (col <= maxWidth - 10) {
      src = src.substr(0, maxWidth - 1) + '';
    } else {
      const halfWidth = Math.round(maxWidth / 2);
      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '';
      col -= src.length - maxWidth;
      src = '' + src.substr(1 - maxWidth);
    }
  }

  let errLen = 1;
  let errEnd = '';

  if (end) {
    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
      errLen = end.col - start.col;
    } else {
      errLen = Math.min(src.length + 1, maxWidth) - col;
      errEnd = '';
    }
  }

  const offset = col > 1 ? ' '.repeat(col - 1) : '';
  const err = '^'.repeat(errLen);
  return `${src}\n${offset}${err}${errEnd}`;
}

class Range {
  static copy(orig) {
    return new Range(orig.start, orig.end);
  }

  constructor(start, end) {
    this.start = start;
    this.end = end || start;
  }

  isEmpty() {
    return typeof this.start !== 'number' || !this.end || this.end <= this.start;
  }
  /**
   * Set `origStart` and `origEnd` to point to the original source range for
   * this node, which may differ due to dropped CR characters.
   *
   * @param {number[]} cr - Positions of dropped CR characters
   * @param {number} offset - Starting index of `cr` from the last call
   * @returns {number} - The next offset, matching the one found for `origStart`
   */


  setOrigRange(cr, offset) {
    const {
      start,
      end
    } = this;

    if (cr.length === 0 || end <= cr[0]) {
      this.origStart = start;
      this.origEnd = end;
      return offset;
    }

    let i = offset;

    while (i < cr.length) {
      if (cr[i] > start) break;else ++i;
    }

    this.origStart = start + i;
    const nextOffset = i;

    while (i < cr.length) {
      // if end was at \n, it should now be at \r
      if (cr[i] >= end) break;else ++i;
    }

    this.origEnd = end + i;
    return nextOffset;
  }

}

/** Root class of all nodes */

class Node {
  static addStringTerminator(src, offset, str) {
    if (str[str.length - 1] === '\n') return str;
    const next = Node.endOfWhiteSpace(src, offset);
    return next >= src.length || src[next] === '\n' ? str + '\n' : str;
  } // ^(---|...)


  static atDocumentBoundary(src, offset, sep) {
    const ch0 = src[offset];
    if (!ch0) return true;
    const prev = src[offset - 1];
    if (prev && prev !== '\n') return false;

    if (sep) {
      if (ch0 !== sep) return false;
    } else {
      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;
    }

    const ch1 = src[offset + 1];
    const ch2 = src[offset + 2];
    if (ch1 !== ch0 || ch2 !== ch0) return false;
    const ch3 = src[offset + 3];
    return !ch3 || ch3 === '\n' || ch3 === '\t' || ch3 === ' ';
  }

  static endOfIdentifier(src, offset) {
    let ch = src[offset];
    const isVerbatim = ch === '<';
    const notOk = isVerbatim ? ['\n', '\t', ' ', '>'] : ['\n', '\t', ' ', '[', ']', '{', '}', ','];

    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];

    if (isVerbatim && ch === '>') offset += 1;
    return offset;
  }

  static endOfIndent(src, offset) {
    let ch = src[offset];

    while (ch === ' ') ch = src[offset += 1];

    return offset;
  }

  static endOfLine(src, offset) {
    let ch = src[offset];

    while (ch && ch !== '\n') ch = src[offset += 1];

    return offset;
  }

  static endOfWhiteSpace(src, offset) {
    let ch = src[offset];

    while (ch === '\t' || ch === ' ') ch = src[offset += 1];

    return offset;
  }

  static startOfLine(src, offset) {
    let ch = src[offset - 1];
    if (ch === '\n') return offset;

    while (ch && ch !== '\n') ch = src[offset -= 1];

    return offset + 1;
  }
  /**
   * End of indentation, or null if the line's indent level is not more
   * than `indent`
   *
   * @param {string} src
   * @param {number} indent
   * @param {number} lineStart
   * @returns {?number}
   */


  static endOfBlockIndent(src, indent, lineStart) {
    const inEnd = Node.endOfIndent(src, lineStart);

    if (inEnd > lineStart + indent) {
      return inEnd;
    } else {
      const wsEnd = Node.endOfWhiteSpace(src, inEnd);
      const ch = src[wsEnd];
      if (!ch || ch === '\n') return wsEnd;
    }

    return null;
  }

  static atBlank(src, offset, endAsBlank) {
    const ch = src[offset];
    return ch === '\n' || ch === '\t' || ch === ' ' || endAsBlank && !ch;
  }

  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
    if (!ch || indentDiff < 0) return false;
    if (indentDiff > 0) return true;
    return indicatorAsIndent && ch === '-';
  } // should be at line or string end, or at next non-whitespace char


  static normalizeOffset(src, offset) {
    const ch = src[offset];
    return !ch ? offset : ch !== '\n' && src[offset - 1] === '\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);
  } // fold single newline into space, multiple newlines to N - 1 newlines
  // presumes src[offset] === '\n'


  static foldNewline(src, offset, indent) {
    let inCount = 0;
    let error = false;
    let fold = '';
    let ch = src[offset + 1];

    while (ch === ' ' || ch === '\t' || ch === '\n') {
      switch (ch) {
        case '\n':
          inCount = 0;
          offset += 1;
          fold += '\n';
          break;

        case '\t':
          if (inCount <= indent) error = true;
          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;
          break;

        case ' ':
          inCount += 1;
          offset += 1;
          break;
      }

      ch = src[offset + 1];
    }

    if (!fold) fold = ' ';
    if (ch && inCount <= indent) error = true;
    return {
      fold,
      offset,
      error
    };
  }

  constructor(type, props, context) {
    Object.defineProperty(this, 'context', {
      value: context || null,
      writable: true
    });
    this.error = null;
    this.range = null;
    this.valueRange = null;
    this.props = props || [];
    this.type = type;
    this.value = null;
  }

  getPropValue(idx, key, skipKey) {
    if (!this.context) return null;
    const {
      src
    } = this.context;
    const prop = this.props[idx];
    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
  }

  get anchor() {
    for (let i = 0; i < this.props.length; ++i) {
      const anchor = this.getPropValue(i, Char.ANCHOR, true);
      if (anchor != null) return anchor;
    }

    return null;
  }

  get comment() {
    const comments = [];

    for (let i = 0; i < this.props.length; ++i) {
      const comment = this.getPropValue(i, Char.COMMENT, true);
      if (comment != null) comments.push(comment);
    }

    return comments.length > 0 ? comments.join('\n') : null;
  }

  commentHasRequiredWhitespace(start) {
    const {
      src
    } = this.context;
    if (this.header && start === this.header.end) return false;
    if (!this.valueRange) return false;
    const {
      end
    } = this.valueRange;
    return start !== end || Node.atBlank(src, end - 1);
  }

  get hasComment() {
    if (this.context) {
      const {
        src
      } = this.context;

      for (let i = 0; i < this.props.length; ++i) {
        if (src[this.props[i].start] === Char.COMMENT) return true;
      }
    }

    return false;
  }

  get hasProps() {
    if (this.context) {
      const {
        src
      } = this.context;

      for (let i = 0; i < this.props.length; ++i) {
        if (src[this.props[i].start] !== Char.COMMENT) return true;
      }
    }

    return false;
  }

  get includesTrailingLines() {
    return false;
  }

  get jsonLike() {
    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
    return jsonLikeTypes.indexOf(this.type) !== -1;
  }

  get rangeAsLinePos() {
    if (!this.range || !this.context) return undefined;
    const start = getLinePos(this.range.start, this.context.root);
    if (!start) return undefined;
    const end = getLinePos(this.range.end, this.context.root);
    return {
      start,
      end
    };
  }

  get rawValue() {
    if (!this.valueRange || !this.context) return null;
    const {
      start,
      end
    } = this.valueRange;
    return this.context.src.slice(start, end);
  }

  get tag() {
    for (let i = 0; i < this.props.length; ++i) {
      const tag = this.getPropValue(i, Char.TAG, false);

      if (tag != null) {
        if (tag[1] === '<') {
          return {
            verbatim: tag.slice(2, -1)
          };
        } else {
          // eslint-disable-next-line no-unused-vars
          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
          return {
            handle,
            suffix
          };
        }
      }
    }

    return null;
  }

  get valueRangeContainsNewline() {
    if (!this.valueRange || !this.context) return false;
    const {
      start,
      end
    } = this.valueRange;
    const {
      src
    } = this.context;

    for (let i = start; i < end; ++i) {
      if (src[i] === '\n') return true;
    }

    return false;
  }

  parseComment(start) {
    const {
      src
    } = this.context;

    if (src[start] === Char.COMMENT) {
      const end = Node.endOfLine(src, start + 1);
      const commentRange = new Range(start, end);
      this.props.push(commentRange);
      return end;
    }

    return start;
  }
  /**
   * Populates the `origStart` and `origEnd` values of all ranges for this
   * node. Extended by child classes to handle descendant nodes.
   *
   * @param {number[]} cr - Positions of dropped CR characters
   * @param {number} offset - Starting index of `cr` from the last call
   * @returns {number} - The next offset, matching the one found for `origStart`
   */


  setOrigRanges(cr, offset) {
    if (this.range) offset = this.range.setOrigRange(cr, offset);
    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
    this.props.forEach(prop => prop.setOrigRange(cr, offset));
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      range,
      value
    } = this;
    if (value != null) return value;
    const str = src.slice(range.start, range.end);
    return Node.addStringTerminator(src, range.end, str);
  }

}

class YAMLError extends Error {
  constructor(name, source, message) {
    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);
    super();
    this.name = name;
    this.message = message;
    this.source = source;
  }

  makePretty() {
    if (!this.source) return;
    this.nodeType = this.source.type;
    const cst = this.source.context && this.source.context.root;

    if (typeof this.offset === 'number') {
      this.range = new Range(this.offset, this.offset + 1);
      const start = cst && getLinePos(this.offset, cst);

      if (start) {
        const end = {
          line: start.line,
          col: start.col + 1
        };
        this.linePos = {
          start,
          end
        };
      }

      delete this.offset;
    } else {
      this.range = this.source.range;
      this.linePos = this.source.rangeAsLinePos;
    }

    if (this.linePos) {
      const {
        line,
        col
      } = this.linePos.start;
      this.message += ` at line ${line}, column ${col}`;
      const ctx = cst && getPrettyContext(this.linePos, cst);
      if (ctx) this.message += `:\n\n${ctx}\n`;
    }

    delete this.source;
  }

}
class YAMLReferenceError extends YAMLError {
  constructor(source, message) {
    super('YAMLReferenceError', source, message);
  }

}
class YAMLSemanticError extends YAMLError {
  constructor(source, message) {
    super('YAMLSemanticError', source, message);
  }

}
class YAMLSyntaxError extends YAMLError {
  constructor(source, message) {
    super('YAMLSyntaxError', source, message);
  }

}
class YAMLWarning extends YAMLError {
  constructor(source, message) {
    super('YAMLWarning', source, message);
  }

}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class PlainValue extends Node {
  static endOfLine(src, start, inFlow) {
    let ch = src[start];
    let offset = start;

    while (ch && ch !== '\n') {
      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;
      const next = src[offset + 1];
      if (ch === ':' && (!next || next === '\n' || next === '\t' || next === ' ' || inFlow && next === ',')) break;
      if ((ch === ' ' || ch === '\t') && next === '#') break;
      offset += 1;
      ch = next;
    }

    return offset;
  }

  get strValue() {
    if (!this.valueRange || !this.context) return null;
    let {
      start,
      end
    } = this.valueRange;
    const {
      src
    } = this.context;
    let ch = src[end - 1];

    while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) ch = src[--end - 1];

    let str = '';

    for (let i = start; i < end; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        const {
          fold,
          offset
        } = Node.foldNewline(src, i, -1);
        str += fold;
        i = offset;
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (i < end && (next === ' ' || next === '\t')) {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    const ch0 = src[start];

    switch (ch0) {
      case '\t':
        {
          const msg = 'Plain value cannot start with a tab character';
          const errors = [new YAMLSemanticError(this, msg)];
          return {
            errors,
            str
          };
        }

      case '@':
      case '`':
        {
          const msg = `Plain value cannot start with reserved character ${ch0}`;
          const errors = [new YAMLSemanticError(this, msg)];
          return {
            errors,
            str
          };
        }

      default:
        return str;
    }
  }

  parseBlockValue(start) {
    const {
      indent,
      inFlow,
      src
    } = this.context;
    let offset = start;
    let valueEnd = start;

    for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
      if (Node.atDocumentBoundary(src, offset + 1)) break;
      const end = Node.endOfBlockIndent(src, indent, offset + 1);
      if (end === null || src[end] === '#') break;

      if (src[end] === '\n') {
        offset = end;
      } else {
        valueEnd = PlainValue.endOfLine(src, end, inFlow);
        offset = valueEnd;
      }
    }

    if (this.valueRange.isEmpty()) this.valueRange.start = start;
    this.valueRange.end = valueEnd;
    return valueEnd;
  }
  /**
   * Parses a plain value from the source
   *
   * Accepted forms are:
   * ```
   * #comment
   *
   * first line
   *
   * first line #comment
   *
   * first line
   * block
   * lines
   *
   * #comment
   * block
   * lines
   * ```
   * where block lines are empty or have an indent level greater than `indent`.
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar, may be `\n`
   */


  parse(context, start) {
    this.context = context;
    const {
      inFlow,
      src
    } = context;
    let offset = start;
    const ch = src[offset];

    if (ch && ch !== '#' && ch !== '\n') {
      offset = PlainValue.endOfLine(src, start, inFlow);
    }

    this.valueRange = new Range(start, offset);
    offset = Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);

    if (!this.hasComment || this.valueRange.isEmpty()) {
      offset = this.parseBlockValue(offset);
    }

    return offset;
  }

}

exports.Char = Char;
exports.Node = Node;
exports.PlainValue = PlainValue;
exports.Range = Range;
exports.Type = Type;
exports.YAMLError = YAMLError;
exports.YAMLReferenceError = YAMLReferenceError;
exports.YAMLSemanticError = YAMLSemanticError;
exports.YAMLSyntaxError = YAMLSyntaxError;
exports.YAMLWarning = YAMLWarning;
exports._defineProperty = _defineProperty;
exports.defaultTagPrefix = defaultTagPrefix;
exports.defaultTags = defaultTags;


/***/ }),

/***/ 51430:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var PlainValue = __webpack_require__(75551);
var resolveSeq = __webpack_require__(28393);
var warnings = __webpack_require__(19114);

function createMap(schema, obj, ctx) {
  const map = new resolveSeq.YAMLMap(schema);

  if (obj instanceof Map) {
    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));
  } else if (obj && typeof obj === 'object') {
    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));
  }

  if (typeof schema.sortMapEntries === 'function') {
    map.items.sort(schema.sortMapEntries);
  }

  return map;
}

const map = {
  createNode: createMap,
  default: true,
  nodeClass: resolveSeq.YAMLMap,
  tag: 'tag:yaml.org,2002:map',
  resolve: resolveSeq.resolveMap
};

function createSeq(schema, obj, ctx) {
  const seq = new resolveSeq.YAMLSeq(schema);

  if (obj && obj[Symbol.iterator]) {
    for (const it of obj) {
      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);
      seq.items.push(v);
    }
  }

  return seq;
}

const seq = {
  createNode: createSeq,
  default: true,
  nodeClass: resolveSeq.YAMLSeq,
  tag: 'tag:yaml.org,2002:seq',
  resolve: resolveSeq.resolveSeq
};

const string = {
  identify: value => typeof value === 'string',
  default: true,
  tag: 'tag:yaml.org,2002:str',
  resolve: resolveSeq.resolveString,

  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({
      actualString: true
    }, ctx);
    return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);
  },

  options: resolveSeq.strOptions
};

const failsafe = [map, seq, string];

/* global BigInt */

const intIdentify$2 = value => typeof value === 'bigint' || Number.isInteger(value);

const intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);

function intStringify$1(node, radix, prefix) {
  const {
    value
  } = node;
  if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);
  return resolveSeq.stringifyNumber(node);
}

const nullObj = {
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => null,
  options: resolveSeq.nullOptions,
  stringify: () => resolveSeq.nullOptions.nullStr
};
const boolObj = {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: str => str[0] === 't' || str[0] === 'T',
  options: resolveSeq.boolOptions,
  stringify: ({
    value
  }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr
};
const octObj = {
  identify: value => intIdentify$2(value) && value >= 0,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'OCT',
  test: /^0o([0-7]+)$/,
  resolve: (str, oct) => intResolve$1(str, oct, 8),
  options: resolveSeq.intOptions,
  stringify: node => intStringify$1(node, 8, '0o')
};
const intObj = {
  identify: intIdentify$2,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^[-+]?[0-9]+$/,
  resolve: str => intResolve$1(str, str, 10),
  options: resolveSeq.intOptions,
  stringify: resolveSeq.stringifyNumber
};
const hexObj = {
  identify: value => intIdentify$2(value) && value >= 0,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'HEX',
  test: /^0x([0-9a-fA-F]+)$/,
  resolve: (str, hex) => intResolve$1(str, hex, 16),
  options: resolveSeq.intOptions,
  stringify: node => intStringify$1(node, 16, '0x')
};
const nanObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: resolveSeq.stringifyNumber
};
const expObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'EXP',
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: str => parseFloat(str),
  stringify: ({
    value
  }) => Number(value).toExponential()
};
const floatObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,

  resolve(str, frac1, frac2) {
    const frac = frac1 || frac2;
    const node = new resolveSeq.Scalar(parseFloat(str));
    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;
    return node;
  },

  stringify: resolveSeq.stringifyNumber
};
const core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);

/* global BigInt */

const intIdentify$1 = value => typeof value === 'bigint' || Number.isInteger(value);

const stringifyJSON = ({
  value
}) => JSON.stringify(value);

const json = [map, seq, {
  identify: value => typeof value === 'string',
  default: true,
  tag: 'tag:yaml.org,2002:str',
  resolve: resolveSeq.resolveString,
  stringify: stringifyJSON
}, {
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^null$/,
  resolve: () => null,
  stringify: stringifyJSON
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^true|false$/,
  resolve: str => str === 'true',
  stringify: stringifyJSON
}, {
  identify: intIdentify$1,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^-?(?:0|[1-9][0-9]*)$/,
  resolve: str => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),
  stringify: ({
    value
  }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
  resolve: str => parseFloat(str),
  stringify: stringifyJSON
}];

json.scalarFallback = str => {
  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);
};

/* global BigInt */

const boolStringify = ({
  value
}) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;

const intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);

function intResolve(sign, src, radix) {
  let str = src.replace(/_/g, '');

  if (resolveSeq.intOptions.asBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;

      case 8:
        str = `0o${str}`;
        break;

      case 16:
        str = `0x${str}`;
        break;
    }

    const n = BigInt(str);
    return sign === '-' ? BigInt(-1) * n : n;
  }

  const n = parseInt(str, radix);
  return sign === '-' ? -1 * n : n;
}

function intStringify(node, radix, prefix) {
  const {
    value
  } = node;

  if (intIdentify(value)) {
    const str = value.toString(radix);
    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
  }

  return resolveSeq.stringifyNumber(node);
}

const yaml11 = failsafe.concat([{
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => null,
  options: resolveSeq.nullOptions,
  stringify: () => resolveSeq.nullOptions.nullStr
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => true,
  options: resolveSeq.boolOptions,
  stringify: boolStringify
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => false,
  options: resolveSeq.boolOptions,
  stringify: boolStringify
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'BIN',
  test: /^([-+]?)0b([0-1_]+)$/,
  resolve: (str, sign, bin) => intResolve(sign, bin, 2),
  stringify: node => intStringify(node, 2, '0b')
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'OCT',
  test: /^([-+]?)0([0-7_]+)$/,
  resolve: (str, sign, oct) => intResolve(sign, oct, 8),
  stringify: node => intStringify(node, 8, '0')
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^([-+]?)([0-9][0-9_]*)$/,
  resolve: (str, sign, abs) => intResolve(sign, abs, 10),
  stringify: resolveSeq.stringifyNumber
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'HEX',
  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
  resolve: (str, sign, hex) => intResolve(sign, hex, 16),
  stringify: node => intStringify(node, 16, '0x')
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: resolveSeq.stringifyNumber
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'EXP',
  test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: str => parseFloat(str.replace(/_/g, '')),
  stringify: ({
    value
  }) => Number(value).toExponential()
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,

  resolve(str, frac) {
    const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, '')));

    if (frac) {
      const f = frac.replace(/_/g, '');
      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;
    }

    return node;
  },

  stringify: resolveSeq.stringifyNumber
}], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);

const schemas = {
  core,
  failsafe,
  json,
  yaml11
};
const tags = {
  binary: warnings.binary,
  bool: boolObj,
  float: floatObj,
  floatExp: expObj,
  floatNaN: nanObj,
  floatTime: warnings.floatTime,
  int: intObj,
  intHex: hexObj,
  intOct: octObj,
  intTime: warnings.intTime,
  map,
  null: nullObj,
  omap: warnings.omap,
  pairs: warnings.pairs,
  seq,
  set: warnings.set,
  timestamp: warnings.timestamp
};

function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter(t => t.tag === tagName);
    const tagObj = match.find(t => !t.format) || match[0];
    if (!tagObj) throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  } // TODO: deprecate/remove class check


  return tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
}

function createNode(value, tagName, ctx) {
  if (value instanceof resolveSeq.Node) return value;
  const {
    defaultPrefix,
    onTagObj,
    prevObjects,
    schema,
    wrapScalars
  } = ctx;
  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema.tags);

  if (!tagObj) {
    if (typeof value.toJSON === 'function') value = value.toJSON();
    if (!value || typeof value !== 'object') return wrapScalars ? new resolveSeq.Scalar(value) : value;
    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
  }

  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  } // Detect duplicate references to the same object & use Alias nodes for all
  // after first. The `obj` wrapper allows for circular references to resolve.


  const obj = {
    value: undefined,
    node: undefined
  };

  if (value && typeof value === 'object' && prevObjects) {
    const prev = prevObjects.get(value);

    if (prev) {
      const alias = new resolveSeq.Alias(prev); // leaves source dirty; must be cleaned by caller

      ctx.aliasNodes.push(alias); // defined along with prevObjects

      return alias;
    }

    obj.value = value;
    prevObjects.set(value, obj);
  }

  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;
  if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;
  return obj.node;
}

function getSchemaTags(schemas, knownTags, customTags, schemaId) {
  let tags = schemas[schemaId.replace(/\W/g, '')]; // 'yaml-1.1' -> 'yaml11'

  if (!tags) {
    const keys = Object.keys(schemas).map(key => JSON.stringify(key)).join(', ');
    throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
  }

  if (Array.isArray(customTags)) {
    for (const tag of customTags) tags = tags.concat(tag);
  } else if (typeof customTags === 'function') {
    tags = customTags(tags.slice());
  }

  for (let i = 0; i < tags.length; ++i) {
    const tag = tags[i];

    if (typeof tag === 'string') {
      const tagObj = knownTags[tag];

      if (!tagObj) {
        const keys = Object.keys(knownTags).map(key => JSON.stringify(key)).join(', ');
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
      }

      tags[i] = tagObj;
    }
  }

  return tags;
}

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

class Schema {
  // TODO: remove in v2
  // TODO: remove in v2
  constructor({
    customTags,
    merge,
    schema,
    sortMapEntries,
    tags: deprecatedCustomTags
  }) {
    this.merge = !!merge;
    this.name = schema;
    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
    if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation('tags', 'customTags');
    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
  }

  createNode(value, wrapScalars, tagName, ctx) {
    const baseCtx = {
      defaultPrefix: Schema.defaultPrefix,
      schema: this,
      wrapScalars
    };
    const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
    return createNode(value, tagName, createCtx);
  }

  createPair(key, value, ctx) {
    if (!ctx) ctx = {
      wrapScalars: true
    };
    const k = this.createNode(key, ctx.wrapScalars, null, ctx);
    const v = this.createNode(value, ctx.wrapScalars, null, ctx);
    return new resolveSeq.Pair(k, v);
  }

}

PlainValue._defineProperty(Schema, "defaultPrefix", PlainValue.defaultTagPrefix);

PlainValue._defineProperty(Schema, "defaultTags", PlainValue.defaultTags);

exports.Schema = Schema;


/***/ }),

/***/ 36537:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var parseCst = __webpack_require__(82246);
var Document$1 = __webpack_require__(99512);
var Schema = __webpack_require__(51430);
var PlainValue = __webpack_require__(75551);
var warnings = __webpack_require__(19114);
__webpack_require__(28393);

function createNode(value, wrapScalars = true, tag) {
  if (tag === undefined && typeof wrapScalars === 'string') {
    tag = wrapScalars;
    wrapScalars = true;
  }

  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);
  const schema = new Schema.Schema(options);
  return schema.createNode(value, wrapScalars, tag);
}

class Document extends Document$1.Document {
  constructor(options) {
    super(Object.assign({}, Document$1.defaultOptions, options));
  }

}

function parseAllDocuments(src, options) {
  const stream = [];
  let prev;

  for (const cstDoc of parseCst.parse(src)) {
    const doc = new Document(options);
    doc.parse(cstDoc, prev);
    stream.push(doc);
    prev = doc;
  }

  return stream;
}

function parseDocument(src, options) {
  const cst = parseCst.parse(src);
  const doc = new Document(options).parse(cst[0]);

  if (cst.length > 1) {
    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';
    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));
  }

  return doc;
}

function parse(src, options) {
  const doc = parseDocument(src, options);
  doc.warnings.forEach(warning => warnings.warn(warning));
  if (doc.errors.length > 0) throw doc.errors[0];
  return doc.toJSON();
}

function stringify(value, options) {
  const doc = new Document(options);
  doc.contents = value;
  return String(doc);
}

const YAML = {
  createNode,
  defaultOptions: Document$1.defaultOptions,
  Document,
  parse,
  parseAllDocuments,
  parseCST: parseCst.parse,
  parseDocument,
  scalarOptions: Document$1.scalarOptions,
  stringify
};

exports.YAML = YAML;


/***/ }),

/***/ 82246:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var PlainValue = __webpack_require__(75551);

class BlankLine extends PlainValue.Node {
  constructor() {
    super(PlainValue.Type.BLANK_LINE);
  }
  /* istanbul ignore next */


  get includesTrailingLines() {
    // This is never called from anywhere, but if it were,
    // this is the value it should return.
    return true;
  }
  /**
   * Parses a blank line from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first \n character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    this.range = new PlainValue.Range(start, start + 1);
    return start + 1;
  }

}

class CollectionItem extends PlainValue.Node {
  constructor(type, props) {
    super(type, props);
    this.node = null;
  }

  get includesTrailingLines() {
    return !!this.node && this.node.includesTrailingLines;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context;
    let {
      atLineStart,
      lineStart
    } = context;
    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
    const indent = atLineStart ? start - lineStart : context.indent;
    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
    let ch = src[offset];
    const inlineComment = ch === '#';
    const comments = [];
    let blankLine = null;

    while (ch === '\n' || ch === '#') {
      if (ch === '#') {
        const end = PlainValue.Node.endOfLine(src, offset + 1);
        comments.push(new PlainValue.Range(offset, end));
        offset = end;
      } else {
        atLineStart = true;
        lineStart = offset + 1;
        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);

        if (src[wsEnd] === '\n' && comments.length === 0) {
          blankLine = new BlankLine();
          lineStart = blankLine.parse({
            src
          }, lineStart);
        }

        offset = PlainValue.Node.endOfIndent(src, lineStart);
      }

      ch = src[offset];
    }

    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {
      this.node = parseNode({
        atLineStart,
        inCollection: false,
        indent,
        lineStart,
        parent: this
      }, offset);
    } else if (ch && lineStart > start + 1) {
      offset = lineStart - 1;
    }

    if (this.node) {
      if (blankLine) {
        // Only blank lines preceding non-empty nodes are captured. Note that
        // this means that collection item range start indices do not always
        // increase monotonically. -- eemeli/yaml#126
        const items = context.parent.items || context.parent.contents;
        if (items) items.push(blankLine);
      }

      if (comments.length) Array.prototype.push.apply(this.props, comments);
      offset = this.node.range.end;
    } else {
      if (inlineComment) {
        const c = comments[0];
        this.props.push(c);
        offset = c.end;
      } else {
        offset = PlainValue.Node.endOfLine(src, start + 1);
      }
    }

    const end = this.node ? this.node.valueRange.end : offset;
    this.valueRange = new PlainValue.Range(start, end);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    return this.node ? this.node.setOrigRanges(cr, offset) : offset;
  }

  toString() {
    const {
      context: {
        src
      },
      node,
      range,
      value
    } = this;
    if (value != null) return value;
    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
    return PlainValue.Node.addStringTerminator(src, range.end, str);
  }

}

class Comment extends PlainValue.Node {
  constructor() {
    super(PlainValue.Type.COMMENT);
  }
  /**
   * Parses a comment line from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const offset = this.parseComment(start);
    this.range = new PlainValue.Range(start, offset);
    return offset;
  }

}

function grabCollectionEndComments(node) {
  let cnode = node;

  while (cnode instanceof CollectionItem) cnode = cnode.node;

  if (!(cnode instanceof Collection)) return null;
  const len = cnode.items.length;
  let ci = -1;

  for (let i = len - 1; i >= 0; --i) {
    const n = cnode.items[i];

    if (n.type === PlainValue.Type.COMMENT) {
      // Keep sufficiently indented comments with preceding node
      const {
        indent,
        lineStart
      } = n.context;
      if (indent > 0 && n.range.start >= lineStart + indent) break;
      ci = i;
    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;
  }

  if (ci === -1) return null;
  const ca = cnode.items.splice(ci, len - ci);
  const prevEnd = ca[0].range.start;

  while (true) {
    cnode.range.end = prevEnd;
    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
    if (cnode === node) break;
    cnode = cnode.context.parent;
  }

  return ca;
}
class Collection extends PlainValue.Node {
  static nextContentHasIndent(src, offset, indent) {
    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;
    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);
    const ch = src[offset];
    if (!ch) return false;
    if (offset >= lineStart + indent) return true;
    if (ch !== '#' && ch !== '\n') return false;
    return Collection.nextContentHasIndent(src, offset, indent);
  }

  constructor(firstItem) {
    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);

    for (let i = firstItem.props.length - 1; i >= 0; --i) {
      if (firstItem.props[i].start < firstItem.context.lineStart) {
        // props on previous line are assumed by the collection
        this.props = firstItem.props.slice(0, i + 1);
        firstItem.props = firstItem.props.slice(i + 1);
        const itemRange = firstItem.props[0] || firstItem.valueRange;
        firstItem.range.start = itemRange.start;
        break;
      }
    }

    this.items = [firstItem];
    const ec = grabCollectionEndComments(firstItem);
    if (ec) Array.prototype.push.apply(this.items, ec);
  }

  get includesTrailingLines() {
    return this.items.length > 0;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context; // It's easier to recalculate lineStart here rather than tracking down the
    // last context from which to read it -- eemeli/yaml#2

    let lineStart = PlainValue.Node.startOfLine(src, start);
    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling
    // -- eemeli/yaml#17

    firstItem.context.parent = this;
    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);
    const indent = firstItem.range.start - firstItem.context.lineStart;
    let offset = start;
    offset = PlainValue.Node.normalizeOffset(src, offset);
    let ch = src[offset];
    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;
    let prevIncludesTrailingLines = false;

    while (ch) {
      while (ch === '\n' || ch === '#') {
        if (atLineStart && ch === '\n' && !prevIncludesTrailingLines) {
          const blankLine = new BlankLine();
          offset = blankLine.parse({
            src
          }, offset);
          this.valueRange.end = offset;

          if (offset >= src.length) {
            ch = null;
            break;
          }

          this.items.push(blankLine);
          offset -= 1; // blankLine.parse() consumes terminal newline
        } else if (ch === '#') {
          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {
            return offset;
          }

          const comment = new Comment();
          offset = comment.parse({
            indent,
            lineStart,
            src
          }, offset);
          this.items.push(comment);
          this.valueRange.end = offset;

          if (offset >= src.length) {
            ch = null;
            break;
          }
        }

        lineStart = offset + 1;
        offset = PlainValue.Node.endOfIndent(src, lineStart);

        if (PlainValue.Node.atBlank(src, offset)) {
          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);
          const next = src[wsEnd];

          if (!next || next === '\n' || next === '#') {
            offset = wsEnd;
          }
        }

        ch = src[offset];
        atLineStart = true;
      }

      if (!ch) {
        break;
      }

      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {
        if (offset < lineStart + indent) {
          if (lineStart > start) offset = lineStart;
          break;
        } else if (!this.error) {
          const msg = 'All collection items must start at the same column';
          this.error = new PlainValue.YAMLSyntaxError(this, msg);
        }
      }

      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {
        if (ch !== '-') {
          if (lineStart > start) offset = lineStart;
          break;
        }
      } else if (ch === '-' && !this.error) {
        // map key may start with -, as long as it's followed by a non-whitespace char
        const next = src[offset + 1];

        if (!next || next === '\n' || next === '\t' || next === ' ') {
          const msg = 'A collection cannot be both a mapping and a sequence';
          this.error = new PlainValue.YAMLSyntaxError(this, msg);
        }
      }

      const node = parseNode({
        atLineStart,
        inCollection: true,
        indent,
        lineStart,
        parent: this
      }, offset);
      if (!node) return offset; // at next document start

      this.items.push(node);
      this.valueRange.end = node.valueRange.end;
      offset = PlainValue.Node.normalizeOffset(src, node.range.end);
      ch = src[offset];
      atLineStart = false;
      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range
      // has advanced to check the current line's indentation level
      // -- eemeli/yaml#10 & eemeli/yaml#38

      if (ch) {
        let ls = offset - 1;
        let prev = src[ls];

        while (prev === ' ' || prev === '\t') prev = src[--ls];

        if (prev === '\n') {
          lineStart = ls + 1;
          atLineStart = true;
        }
      }

      const ec = grabCollectionEndComments(node);
      if (ec) Array.prototype.push.apply(this.items, ec);
    }

    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.items.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      items,
      range,
      value
    } = this;
    if (value != null) return value;
    let str = src.slice(range.start, items[0].range.start) + String(items[0]);

    for (let i = 1; i < items.length; ++i) {
      const item = items[i];
      const {
        atLineStart,
        indent
      } = item.context;
      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';
      str += String(item);
    }

    return PlainValue.Node.addStringTerminator(src, range.end, str);
  }

}

class Directive extends PlainValue.Node {
  constructor() {
    super(PlainValue.Type.DIRECTIVE);
    this.name = null;
  }

  get parameters() {
    const raw = this.rawValue;
    return raw ? raw.trim().split(/[ \t]+/) : [];
  }

  parseName(start) {
    const {
      src
    } = this.context;
    let offset = start;
    let ch = src[offset];

    while (ch && ch !== '\n' && ch !== '\t' && ch !== ' ') ch = src[offset += 1];

    this.name = src.slice(start, offset);
    return offset;
  }

  parseParameters(start) {
    const {
      src
    } = this.context;
    let offset = start;
    let ch = src[offset];

    while (ch && ch !== '\n' && ch !== '#') ch = src[offset += 1];

    this.valueRange = new PlainValue.Range(start, offset);
    return offset;
  }

  parse(context, start) {
    this.context = context;
    let offset = this.parseName(start + 1);
    offset = this.parseParameters(offset);
    offset = this.parseComment(offset);
    this.range = new PlainValue.Range(start, offset);
    return offset;
  }

}

class Document extends PlainValue.Node {
  static startCommentOrEndBlankLine(src, start) {
    const offset = PlainValue.Node.endOfWhiteSpace(src, start);
    const ch = src[offset];
    return ch === '#' || ch === '\n' ? offset : start;
  }

  constructor() {
    super(PlainValue.Type.DOCUMENT);
    this.directives = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.documentEndMarker = null;
  }

  parseDirectives(start) {
    const {
      src
    } = this.context;
    this.directives = [];
    let atLineStart = true;
    let hasDirectives = false;
    let offset = start;

    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {
      offset = Document.startCommentOrEndBlankLine(src, offset);

      switch (src[offset]) {
        case '\n':
          if (atLineStart) {
            const blankLine = new BlankLine();
            offset = blankLine.parse({
              src
            }, offset);

            if (offset < src.length) {
              this.directives.push(blankLine);
            }
          } else {
            offset += 1;
            atLineStart = true;
          }

          break;

        case '#':
          {
            const comment = new Comment();
            offset = comment.parse({
              src
            }, offset);
            this.directives.push(comment);
            atLineStart = false;
          }
          break;

        case '%':
          {
            const directive = new Directive();
            offset = directive.parse({
              parent: this,
              src
            }, offset);
            this.directives.push(directive);
            hasDirectives = true;
            atLineStart = false;
          }
          break;

        default:
          if (hasDirectives) {
            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');
          } else if (this.directives.length > 0) {
            this.contents = this.directives;
            this.directives = [];
          }

          return offset;
      }
    }

    if (src[offset]) {
      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);
      return offset + 3;
    }

    if (hasDirectives) {
      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');
    } else if (this.directives.length > 0) {
      this.contents = this.directives;
      this.directives = [];
    }

    return offset;
  }

  parseContents(start) {
    const {
      parseNode,
      src
    } = this.context;
    if (!this.contents) this.contents = [];
    let lineStart = start;

    while (src[lineStart - 1] === '-') lineStart -= 1;

    let offset = PlainValue.Node.endOfWhiteSpace(src, start);
    let atLineStart = lineStart === start;
    this.valueRange = new PlainValue.Range(offset);

    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {
      switch (src[offset]) {
        case '\n':
          if (atLineStart) {
            const blankLine = new BlankLine();
            offset = blankLine.parse({
              src
            }, offset);

            if (offset < src.length) {
              this.contents.push(blankLine);
            }
          } else {
            offset += 1;
            atLineStart = true;
          }

          lineStart = offset;
          break;

        case '#':
          {
            const comment = new Comment();
            offset = comment.parse({
              src
            }, offset);
            this.contents.push(comment);
            atLineStart = false;
          }
          break;

        default:
          {
            const iEnd = PlainValue.Node.endOfIndent(src, offset);
            const context = {
              atLineStart,
              indent: -1,
              inFlow: false,
              inCollection: false,
              lineStart,
              parent: this
            };
            const node = parseNode(context, iEnd);
            if (!node) return this.valueRange.end = iEnd; // at next document start

            this.contents.push(node);
            offset = node.range.end;
            atLineStart = false;
            const ec = grabCollectionEndComments(node);
            if (ec) Array.prototype.push.apply(this.contents, ec);
          }
      }

      offset = Document.startCommentOrEndBlankLine(src, offset);
    }

    this.valueRange.end = offset;

    if (src[offset]) {
      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);
      offset += 3;

      if (src[offset]) {
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);

        if (src[offset] === '#') {
          const comment = new Comment();
          offset = comment.parse({
            src
          }, offset);
          this.contents.push(comment);
        }

        switch (src[offset]) {
          case '\n':
            offset += 1;
            break;

          case undefined:
            break;

          default:
            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');
        }
      }
    }

    return offset;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    context.root = this;
    this.context = context;
    const {
      src
    } = context;
    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM

    offset = this.parseDirectives(offset);
    offset = this.parseContents(offset);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.directives.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
    this.contents.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
    return offset;
  }

  toString() {
    const {
      contents,
      directives,
      value
    } = this;
    if (value != null) return value;
    let str = directives.join('');

    if (contents.length > 0) {
      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\n';
      str += contents.join('');
    }

    if (str[str.length - 1] !== '\n') str += '\n';
    return str;
  }

}

class Alias extends PlainValue.Node {
  /**
   * Parses an *alias from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */
  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);
    this.valueRange = new PlainValue.Range(start + 1, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

const Chomp = {
  CLIP: 'CLIP',
  KEEP: 'KEEP',
  STRIP: 'STRIP'
};
class BlockValue extends PlainValue.Node {
  constructor(type, props) {
    super(type, props);
    this.blockIndent = null;
    this.chomping = Chomp.CLIP;
    this.header = null;
  }

  get includesTrailingLines() {
    return this.chomping === Chomp.KEEP;
  }

  get strValue() {
    if (!this.valueRange || !this.context) return null;
    let {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (this.valueRange.isEmpty()) return '';
    let lastNewLine = null;
    let ch = src[end - 1];

    while (ch === '\n' || ch === '\t' || ch === ' ') {
      end -= 1;

      if (end <= start) {
        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens
      }

      if (ch === '\n') lastNewLine = end;
      ch = src[end - 1];
    }

    let keepStart = end + 1;

    if (lastNewLine) {
      if (this.chomping === Chomp.KEEP) {
        keepStart = lastNewLine;
        end = this.valueRange.end;
      } else {
        end = lastNewLine;
      }
    }

    const bi = indent + this.blockIndent;
    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;
    let atStart = true;
    let str = '';
    let sep = '';
    let prevMoreIndented = false;

    for (let i = start; i < end; ++i) {
      for (let j = 0; j < bi; ++j) {
        if (src[i] !== ' ') break;
        i += 1;
      }

      const ch = src[i];

      if (ch === '\n') {
        if (sep === '\n') str += '\n';else sep = '\n';
      } else {
        const lineEnd = PlainValue.Node.endOfLine(src, i);
        const line = src.slice(i, lineEnd);
        i = lineEnd;

        if (folded && (ch === ' ' || ch === '\t') && i < keepStart) {
          if (sep === ' ') sep = '\n';else if (!prevMoreIndented && !atStart && sep === '\n') sep = '\n\n';
          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')

          sep = lineEnd < end && src[lineEnd] || '';
          prevMoreIndented = true;
        } else {
          str += sep + line;
          sep = folded && i < keepStart ? ' ' : '\n';
          prevMoreIndented = false;
        }

        if (atStart && line !== '') atStart = false;
      }
    }

    return this.chomping === Chomp.STRIP ? str : str + '\n';
  }

  parseBlockHeader(start) {
    const {
      src
    } = this.context;
    let offset = start + 1;
    let bi = '';

    while (true) {
      const ch = src[offset];

      switch (ch) {
        case '-':
          this.chomping = Chomp.STRIP;
          break;

        case '+':
          this.chomping = Chomp.KEEP;
          break;

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          bi += ch;
          break;

        default:
          this.blockIndent = Number(bi) || null;
          this.header = new PlainValue.Range(start, offset);
          return offset;
      }

      offset += 1;
    }
  }

  parseBlockValue(start) {
    const {
      indent,
      src
    } = this.context;
    const explicit = !!this.blockIndent;
    let offset = start;
    let valueEnd = start;
    let minBlockIndent = 1;

    for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
      offset += 1;
      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;
      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?

      if (end === null) break;
      const ch = src[end];
      const lineIndent = end - (offset + indent);

      if (!this.blockIndent) {
        // no explicit block indent, none yet detected
        if (src[end] !== '\n') {
          // first line with non-whitespace content
          if (lineIndent < minBlockIndent) {
            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
            this.error = new PlainValue.YAMLSemanticError(this, msg);
          }

          this.blockIndent = lineIndent;
        } else if (lineIndent > minBlockIndent) {
          // empty line with more whitespace
          minBlockIndent = lineIndent;
        }
      } else if (ch && ch !== '\n' && lineIndent < this.blockIndent) {
        if (src[end] === '#') break;

        if (!this.error) {
          const src = explicit ? 'explicit indentation indicator' : 'first line';
          const msg = `Block scalars must not be less indented than their ${src}`;
          this.error = new PlainValue.YAMLSemanticError(this, msg);
        }
      }

      if (src[end] === '\n') {
        offset = end;
      } else {
        offset = valueEnd = PlainValue.Node.endOfLine(src, end);
      }
    }

    if (this.chomping !== Chomp.KEEP) {
      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
    }

    this.valueRange = new PlainValue.Range(start + 1, offset);
    return offset;
  }
  /**
   * Parses a block value from the source
   *
   * Accepted forms are:
   * ```
   * BS
   * block
   * lines
   *
   * BS #comment
   * block
   * lines
   * ```
   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
   * are empty or have an indent level greater than `indent`.
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this block
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = this.parseBlockHeader(start);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    offset = this.parseBlockValue(offset);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    return this.header ? this.header.setOrigRange(cr, offset) : offset;
  }

}

class FlowCollection extends PlainValue.Node {
  constructor(type, props) {
    super(type, props);
    this.items = null;
  }

  prevNodeIsJsonLike(idx = this.items.length) {
    const node = this.items[idx - 1];
    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context;
    let {
      indent,
      lineStart
    } = context;
    let char = src[start]; // { or [

    this.items = [{
      char,
      offset: start
    }];
    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
    char = src[offset];

    while (char && char !== ']' && char !== '}') {
      switch (char) {
        case '\n':
          {
            lineStart = offset + 1;
            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);

            if (src[wsEnd] === '\n') {
              const blankLine = new BlankLine();
              lineStart = blankLine.parse({
                src
              }, lineStart);
              this.items.push(blankLine);
            }

            offset = PlainValue.Node.endOfIndent(src, lineStart);

            if (offset <= lineStart + indent) {
              char = src[offset];

              if (offset < lineStart + indent || char !== ']' && char !== '}') {
                const msg = 'Insufficient indentation in flow collection';
                this.error = new PlainValue.YAMLSemanticError(this, msg);
              }
            }
          }
          break;

        case ',':
          {
            this.items.push({
              char,
              offset
            });
            offset += 1;
          }
          break;

        case '#':
          {
            const comment = new Comment();
            offset = comment.parse({
              src
            }, offset);
            this.items.push(comment);
          }
          break;

        case '?':
        case ':':
          {
            const next = src[offset + 1];

            if (next === '\n' || next === '\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace
            char === ':' && this.prevNodeIsJsonLike()) {
              this.items.push({
                char,
                offset
              });
              offset += 1;
              break;
            }
          }
        // fallthrough

        default:
          {
            const node = parseNode({
              atLineStart: false,
              inCollection: false,
              inFlow: true,
              indent: -1,
              lineStart,
              parent: this
            }, offset);

            if (!node) {
              // at next document start
              this.valueRange = new PlainValue.Range(start, offset);
              return offset;
            }

            this.items.push(node);
            offset = PlainValue.Node.normalizeOffset(src, node.range.end);
          }
      }

      offset = PlainValue.Node.endOfWhiteSpace(src, offset);
      char = src[offset];
    }

    this.valueRange = new PlainValue.Range(start, offset + 1);

    if (char) {
      this.items.push({
        char,
        offset
      });
      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);
      offset = this.parseComment(offset);
    }

    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.items.forEach(node => {
      if (node instanceof PlainValue.Node) {
        offset = node.setOrigRanges(cr, offset);
      } else if (cr.length === 0) {
        node.origOffset = node.offset;
      } else {
        let i = offset;

        while (i < cr.length) {
          if (cr[i] > node.offset) break;else ++i;
        }

        node.origOffset = node.offset + i;
        offset = i;
      }
    });
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      items,
      range,
      value
    } = this;
    if (value != null) return value;
    const nodes = items.filter(item => item instanceof PlainValue.Node);
    let str = '';
    let prevEnd = range.start;
    nodes.forEach(node => {
      const prefix = src.slice(prevEnd, node.range.start);
      prevEnd = node.range.end;
      str += prefix + String(node);

      if (str[str.length - 1] === '\n' && src[prevEnd - 1] !== '\n' && src[prevEnd] === '\n') {
        // Comment range does not include the terminal newline, but its
        // stringified value does. Without this fix, newlines at comment ends
        // get duplicated.
        prevEnd += 1;
      }
    });
    str += src.slice(prevEnd, range.end);
    return PlainValue.Node.addStringTerminator(src, range.end, str);
  }

}

class QuoteDouble extends PlainValue.Node {
  static endOfQuote(src, offset) {
    let ch = src[offset];

    while (ch && ch !== '"') {
      offset += ch === '\\' ? 2 : 1;
      ch = src[offset];
    }

    return offset + 1;
  }
  /**
   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
   */


  get strValue() {
    if (!this.valueRange || !this.context) return null;
    const errors = [];
    const {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (src[end - 1] !== '"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing "quote')); // Using String#replace is too painful with escaped newlines preceded by
    // escaped backslashes; also, this should be faster.

    let str = '';

    for (let i = start + 1; i < end - 1; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
        const {
          fold,
          offset,
          error
        } = PlainValue.Node.foldNewline(src, i, indent);
        str += fold;
        i = offset;
        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));
      } else if (ch === '\\') {
        i += 1;

        switch (src[i]) {
          case '0':
            str += '\0';
            break;
          // null character

          case 'a':
            str += '\x07';
            break;
          // bell character

          case 'b':
            str += '\b';
            break;
          // backspace

          case 'e':
            str += '\x1b';
            break;
          // escape character

          case 'f':
            str += '\f';
            break;
          // form feed

          case 'n':
            str += '\n';
            break;
          // line feed

          case 'r':
            str += '\r';
            break;
          // carriage return

          case 't':
            str += '\t';
            break;
          // horizontal tab

          case 'v':
            str += '\v';
            break;
          // vertical tab

          case 'N':
            str += '\u0085';
            break;
          // Unicode next line

          case '_':
            str += '\u00a0';
            break;
          // Unicode non-breaking space

          case 'L':
            str += '\u2028';
            break;
          // Unicode line separator

          case 'P':
            str += '\u2029';
            break;
          // Unicode paragraph separator

          case ' ':
            str += ' ';
            break;

          case '"':
            str += '"';
            break;

          case '/':
            str += '/';
            break;

          case '\\':
            str += '\\';
            break;

          case '\t':
            str += '\t';
            break;

          case 'x':
            str += this.parseCharCode(i + 1, 2, errors);
            i += 2;
            break;

          case 'u':
            str += this.parseCharCode(i + 1, 4, errors);
            i += 4;
            break;

          case 'U':
            str += this.parseCharCode(i + 1, 8, errors);
            i += 8;
            break;

          case '\n':
            // skip escaped newlines, but still trim the following line
            while (src[i + 1] === ' ' || src[i + 1] === '\t') i += 1;

            break;

          default:
            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));
            str += '\\' + src[i];
        }
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (next === ' ' || next === '\t') {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    return errors.length > 0 ? {
      errors,
      str
    } : str;
  }

  parseCharCode(offset, length, errors) {
    const {
      src
    } = this.context;
    const cc = src.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;

    if (isNaN(code)) {
      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));
      return src.substr(offset - 2, length + 2);
    }

    return String.fromCodePoint(code);
  }
  /**
   * Parses a "double quoted" value from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = QuoteDouble.endOfQuote(src, start + 1);
    this.valueRange = new PlainValue.Range(start, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

class QuoteSingle extends PlainValue.Node {
  static endOfQuote(src, offset) {
    let ch = src[offset];

    while (ch) {
      if (ch === "'") {
        if (src[offset + 1] !== "'") break;
        ch = src[offset += 2];
      } else {
        ch = src[offset += 1];
      }
    }

    return offset + 1;
  }
  /**
   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
   */


  get strValue() {
    if (!this.valueRange || !this.context) return null;
    const errors = [];
    const {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (src[end - 1] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, "Missing closing 'quote"));
    let str = '';

    for (let i = start + 1; i < end - 1; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
        const {
          fold,
          offset,
          error
        } = PlainValue.Node.foldNewline(src, i, indent);
        str += fold;
        i = offset;
        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));
      } else if (ch === "'") {
        str += ch;
        i += 1;
        if (src[i] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (next === ' ' || next === '\t') {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    return errors.length > 0 ? {
      errors,
      str
    } : str;
  }
  /**
   * Parses a 'single quoted' value from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = QuoteSingle.endOfQuote(src, start + 1);
    this.valueRange = new PlainValue.Range(start, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

function createNewNode(type, props) {
  switch (type) {
    case PlainValue.Type.ALIAS:
      return new Alias(type, props);

    case PlainValue.Type.BLOCK_FOLDED:
    case PlainValue.Type.BLOCK_LITERAL:
      return new BlockValue(type, props);

    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.FLOW_SEQ:
      return new FlowCollection(type, props);

    case PlainValue.Type.MAP_KEY:
    case PlainValue.Type.MAP_VALUE:
    case PlainValue.Type.SEQ_ITEM:
      return new CollectionItem(type, props);

    case PlainValue.Type.COMMENT:
    case PlainValue.Type.PLAIN:
      return new PlainValue.PlainValue(type, props);

    case PlainValue.Type.QUOTE_DOUBLE:
      return new QuoteDouble(type, props);

    case PlainValue.Type.QUOTE_SINGLE:
      return new QuoteSingle(type, props);

    /* istanbul ignore next */

    default:
      return null;
    // should never happen
  }
}
/**
 * @param {boolean} atLineStart - Node starts at beginning of line
 * @param {boolean} inFlow - true if currently in a flow context
 * @param {boolean} inCollection - true if currently in a collection context
 * @param {number} indent - Current level of indentation
 * @param {number} lineStart - Start of the current line
 * @param {Node} parent - The parent of the node
 * @param {string} src - Source of the YAML document
 */


class ParseContext {
  static parseType(src, offset, inFlow) {
    switch (src[offset]) {
      case '*':
        return PlainValue.Type.ALIAS;

      case '>':
        return PlainValue.Type.BLOCK_FOLDED;

      case '|':
        return PlainValue.Type.BLOCK_LITERAL;

      case '{':
        return PlainValue.Type.FLOW_MAP;

      case '[':
        return PlainValue.Type.FLOW_SEQ;

      case '?':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;

      case ':':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;

      case '-':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;

      case '"':
        return PlainValue.Type.QUOTE_DOUBLE;

      case "'":
        return PlainValue.Type.QUOTE_SINGLE;

      default:
        return PlainValue.Type.PLAIN;
    }
  }

  constructor(orig = {}, {
    atLineStart,
    inCollection,
    inFlow,
    indent,
    lineStart,
    parent
  } = {}) {
    PlainValue._defineProperty(this, "parseNode", (overlay, start) => {
      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;
      const context = new ParseContext(this, overlay);
      const {
        props,
        type,
        valueStart
      } = context.parseProps(start);
      const node = createNewNode(type, props);
      let offset = node.parse(context, valueStart);
      node.range = new PlainValue.Range(start, offset);
      /* istanbul ignore if */

      if (offset <= start) {
        // This should never happen, but if it does, let's make sure to at least
        // step one character forward to avoid a busy loop.
        node.error = new Error(`Node#parse consumed no characters`);
        node.error.parseEnd = offset;
        node.error.source = node;
        node.range.end = start + 1;
      }

      if (context.nodeStartsCollection(node)) {
        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {
          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');
        }

        const collection = new Collection(node);
        offset = collection.parse(new ParseContext(context), offset);
        collection.range = new PlainValue.Range(start, offset);
        return collection;
      }

      return node;
    });

    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
    this.indent = indent != null ? indent : orig.indent;
    this.lineStart = lineStart != null ? lineStart : orig.lineStart;
    this.parent = parent != null ? parent : orig.parent || {};
    this.root = orig.root;
    this.src = orig.src;
  }

  nodeStartsCollection(node) {
    const {
      inCollection,
      inFlow,
      src
    } = this;
    if (inCollection || inFlow) return false;
    if (node instanceof CollectionItem) return true; // check for implicit key

    let offset = node.range.end;
    if (src[offset] === '\n' || src[offset - 1] === '\n') return false;
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    return src[offset] === ':';
  } // Anchor and tag are before type, which determines the node implementation
  // class; hence this intermediate step.


  parseProps(offset) {
    const {
      inFlow,
      parent,
      src
    } = this;
    const props = [];
    let lineHasProps = false;
    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);
    let ch = src[offset];

    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\n') {
      if (ch === '\n') {
        let inEnd = offset;
        let lineStart;

        do {
          lineStart = inEnd + 1;
          inEnd = PlainValue.Node.endOfIndent(src, lineStart);
        } while (src[inEnd] === '\n');

        const indentDiff = inEnd - (lineStart + this.indent);
        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;
        if (src[inEnd] !== '#' && !PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
        this.atLineStart = true;
        this.lineStart = lineStart;
        lineHasProps = false;
        offset = inEnd;
      } else if (ch === PlainValue.Char.COMMENT) {
        const end = PlainValue.Node.endOfLine(src, offset + 1);
        props.push(new PlainValue.Range(offset, end));
        offset = end;
      } else {
        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);

        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, end + 13))) {
          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather
          // than an empty but 'foo.bar' private-tagged node in a flow collection
          // followed without whitespace by a plain string starting with a year
          // or date divided by something.
          end = PlainValue.Node.endOfIdentifier(src, end + 5);
        }

        props.push(new PlainValue.Range(offset, end));
        lineHasProps = true;
        offset = PlainValue.Node.endOfWhiteSpace(src, end);
      }

      ch = src[offset];
    } // '- &a : b' has an anchor on an empty node


    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;
    const type = ParseContext.parseType(src, offset, inFlow);
    return {
      props,
      type,
      valueStart: offset
    };
  }
  /**
   * Parses a node from the source
   * @param {ParseContext} overlay
   * @param {number} start - Index of first non-whitespace character for the node
   * @returns {?Node} - null if at a document boundary
   */


}

// Published as 'yaml/parse-cst'
function parse(src) {
  const cr = [];

  if (src.indexOf('\r') !== -1) {
    src = src.replace(/\r\n?/g, (match, offset) => {
      if (match.length > 1) cr.push(offset);
      return '\n';
    });
  }

  const documents = [];
  let offset = 0;

  do {
    const doc = new Document();
    const context = new ParseContext({
      src
    });
    offset = doc.parse(context, offset);
    documents.push(doc);
  } while (offset < src.length);

  documents.setOrigRanges = () => {
    if (cr.length === 0) return false;

    for (let i = 1; i < cr.length; ++i) cr[i] -= i;

    let crOffset = 0;

    for (let i = 0; i < documents.length; ++i) {
      crOffset = documents[i].setOrigRanges(cr, crOffset);
    }

    cr.splice(0, cr.length);
    return true;
  };

  documents.toString = () => documents.join('...\n');

  return documents;
}

exports.parse = parse;


/***/ }),

/***/ 28393:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var PlainValue = __webpack_require__(75551);

function addCommentBefore(str, indent, comment) {
  if (!comment) return str;
  const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
  return `#${cc}\n${indent}${str}`;
}
function addComment(str, indent, comment) {
  return !comment ? str : comment.indexOf('\n') === -1 ? `${str} #${comment}` : `${str}\n` + comment.replace(/^/gm, `${indent || ''}#`);
}

class Node {}

function toJSON(value, arg, ctx) {
  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));

  if (value && typeof value.toJSON === 'function') {
    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
    if (anchor) ctx.onCreate = res => {
      anchor.res = res;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (anchor && ctx.onCreate) ctx.onCreate(res);
    return res;
  }

  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);
  return value;
}

class Scalar extends Node {
  constructor(value) {
    super();
    this.value = value;
  }

  toJSON(arg, ctx) {
    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
  }

  toString() {
    return String(this.value);
  }

}

function collectionFromPath(schema, path, value) {
  let v = value;

  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];

    if (Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      const o = {};
      Object.defineProperty(o, k, {
        value: v,
        writable: true,
        enumerable: true,
        configurable: true
      });
      v = o;
    }
  }

  return schema.createNode(v, false);
} // null, undefined, or an empty non-string iterable (e.g. [])


const isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;
class Collection extends Node {
  constructor(schema) {
    super();

    PlainValue._defineProperty(this, "items", []);

    this.schema = schema;
  }

  addIn(path, value) {
    if (isEmptyPath(path)) this.add(value);else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }

  deleteIn([key, ...rest]) {
    if (rest.length === 0) return this.delete(key);
    const node = this.get(key, true);
    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }

  getIn([key, ...rest], keepScalar) {
    const node = this.get(key, true);
    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;
  }

  hasAllNullValues() {
    return this.items.every(node => {
      if (!node || node.type !== 'PAIR') return false;
      const n = node.value;
      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }

  hasIn([key, ...rest]) {
    if (rest.length === 0) return this.has(key);
    const node = this.get(key, true);
    return node instanceof Collection ? node.hasIn(rest) : false;
  }

  setIn([key, ...rest], value) {
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  } // overridden in implementations

  /* istanbul ignore next */


  toJSON() {
    return null;
  }

  toString(ctx, {
    blockItem,
    flowChars,
    isMap,
    itemIndent
  }, onComment, onChompKeep) {
    const {
      indent,
      indentStep,
      stringify
    } = ctx;
    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
    if (inFlow) itemIndent += indentStep;
    const allNullValues = isMap && this.hasAllNullValues();
    ctx = Object.assign({}, ctx, {
      allNullValues,
      indent: itemIndent,
      inFlow,
      type: null
    });
    let chompKeep = false;
    let hasItemWithNewLine = false;
    const nodes = this.items.reduce((nodes, item, i) => {
      let comment;

      if (item) {
        if (!chompKeep && item.spaceBefore) nodes.push({
          type: 'comment',
          str: ''
        });
        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {
          nodes.push({
            type: 'comment',
            str: `#${line}`
          });
        });
        if (item.comment) comment = item.comment;
        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
      }

      chompKeep = false;
      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);
      if (inFlow && !hasItemWithNewLine && str.includes('\n')) hasItemWithNewLine = true;
      if (inFlow && i < this.items.length - 1) str += ',';
      str = addComment(str, itemIndent, comment);
      if (chompKeep && (comment || inFlow)) chompKeep = false;
      nodes.push({
        type: 'item',
        str
      });
      return nodes;
    }, []);
    let str;

    if (nodes.length === 0) {
      str = flowChars.start + flowChars.end;
    } else if (inFlow) {
      const {
        start,
        end
      } = flowChars;
      const strings = nodes.map(n => n.str);

      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {
        str = start;

        for (const s of strings) {
          str += s ? `\n${indentStep}${indent}${s}` : '\n';
        }

        str += `\n${indent}${end}`;
      } else {
        str = `${start} ${strings.join(' ')} ${end}`;
      }
    } else {
      const strings = nodes.map(blockItem);
      str = strings.shift();

      for (const s of strings) str += s ? `\n${indent}${s}` : '\n';
    }

    if (this.comment) {
      str += '\n' + this.comment.replace(/^/gm, `${indent}#`);
      if (onComment) onComment();
    } else if (chompKeep && onChompKeep) onChompKeep();

    return str;
  }

}

PlainValue._defineProperty(Collection, "maxFlowStringSingleLineLength", 60);

function asItemIndex(key) {
  let idx = key instanceof Scalar ? key.value : key;
  if (idx && typeof idx === 'string') idx = Number(idx);
  return Number.isInteger(idx) && idx >= 0 ? idx : null;
}

class YAMLSeq extends Collection {
  add(value) {
    this.items.push(value);
  }

  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }

  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return undefined;
    const it = this.items[idx];
    return !keepScalar && it instanceof Scalar ? it.value : it;
  }

  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === 'number' && idx < this.items.length;
  }

  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);
    this.items[idx] = value;
  }

  toJSON(_, ctx) {
    const seq = [];
    if (ctx && ctx.onCreate) ctx.onCreate(seq);
    let i = 0;

    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));

    return seq;
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);
    return super.toString(ctx, {
      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,
      flowChars: {
        start: '[',
        end: ']'
      },
      isMap: false,
      itemIndent: (ctx.indent || '') + '  '
    }, onComment, onChompKeep);
  }

}

const stringifyKey = (key, jsKey, ctx) => {
  if (jsKey === null) return '';
  if (typeof jsKey !== 'object') return String(jsKey);
  if (key instanceof Node && ctx && ctx.doc) return key.toString({
    anchors: Object.create(null),
    doc: ctx.doc,
    indent: '',
    indentStep: ctx.indentStep,
    inFlow: true,
    inStringifyKey: true,
    stringify: ctx.stringify
  });
  return JSON.stringify(jsKey);
};

class Pair extends Node {
  constructor(key, value = null) {
    super();
    this.key = key;
    this.value = value;
    this.type = Pair.Type.PAIR;
  }

  get commentBefore() {
    return this.key instanceof Node ? this.key.commentBefore : undefined;
  }

  set commentBefore(cb) {
    if (this.key == null) this.key = new Scalar(null);
    if (this.key instanceof Node) this.key.commentBefore = cb;else {
      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';
      throw new Error(msg);
    }
  }

  addToJSMap(ctx, map) {
    const key = toJSON(this.key, '', ctx);

    if (map instanceof Map) {
      const value = toJSON(this.value, key, ctx);
      map.set(key, value);
    } else if (map instanceof Set) {
      map.add(key);
    } else {
      const stringKey = stringifyKey(this.key, key, ctx);
      const value = toJSON(this.value, stringKey, ctx);
      if (stringKey in map) Object.defineProperty(map, stringKey, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });else map[stringKey] = value;
    }

    return map;
  }

  toJSON(_, ctx) {
    const pair = ctx && ctx.mapAsMap ? new Map() : {};
    return this.addToJSMap(ctx, pair);
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx || !ctx.doc) return JSON.stringify(this);
    const {
      indent: indentSize,
      indentSeq,
      simpleKeys
    } = ctx.doc.options;
    let {
      key,
      value
    } = this;
    let keyComment = key instanceof Node && key.comment;

    if (simpleKeys) {
      if (keyComment) {
        throw new Error('With simple keys, key nodes cannot have comments');
      }

      if (key instanceof Collection) {
        const msg = 'With simple keys, collection cannot be used as a key value';
        throw new Error(msg);
      }
    }

    let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === 'object'));
    const {
      doc,
      indent,
      indentStep,
      stringify
    } = ctx;
    ctx = Object.assign({}, ctx, {
      implicitKey: !explicitKey,
      indent: indent + indentStep
    });
    let chompKeep = false;
    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);
    str = addComment(str, ctx.indent, keyComment);

    if (!explicitKey && str.length > 1024) {
      if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
      explicitKey = true;
    }

    if (ctx.allNullValues && !simpleKeys) {
      if (this.comment) {
        str = addComment(str, ctx.indent, this.comment);
        if (onComment) onComment();
      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();

      return ctx.inFlow && !explicitKey ? str : `? ${str}`;
    }

    str = explicitKey ? `? ${str}\n${indent}:` : `${str}:`;

    if (this.comment) {
      // expected (but not strictly required) to be a single-line comment
      str = addComment(str, ctx.indent, this.comment);
      if (onComment) onComment();
    }

    let vcb = '';
    let valueComment = null;

    if (value instanceof Node) {
      if (value.spaceBefore) vcb = '\n';

      if (value.commentBefore) {
        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
        vcb += `\n${cs}`;
      }

      valueComment = value.comment;
    } else if (value && typeof value === 'object') {
      value = doc.schema.createNode(value, true);
    }

    ctx.implicitKey = false;
    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;
    chompKeep = false;

    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
      // If indentSeq === false, consider '- ' as part of indentation where possible
      ctx.indent = ctx.indent.substr(2);
    }

    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);
    let ws = ' ';

    if (vcb || this.comment) {
      ws = `${vcb}\n${ctx.indent}`;
    } else if (!explicitKey && value instanceof Collection) {
      const flow = valueStr[0] === '[' || valueStr[0] === '{';
      if (!flow || valueStr.includes('\n')) ws = `\n${ctx.indent}`;
    } else if (valueStr[0] === '\n') ws = '';

    if (chompKeep && !valueComment && onChompKeep) onChompKeep();
    return addComment(str + ws + valueStr, ctx.indent, valueComment);
  }

}

PlainValue._defineProperty(Pair, "Type", {
  PAIR: 'PAIR',
  MERGE_PAIR: 'MERGE_PAIR'
});

const getAliasCount = (node, anchors) => {
  if (node instanceof Alias) {
    const anchor = anchors.get(node.source);
    return anchor.count * anchor.aliasCount;
  } else if (node instanceof Collection) {
    let count = 0;

    for (const item of node.items) {
      const c = getAliasCount(item, anchors);
      if (c > count) count = c;
    }

    return count;
  } else if (node instanceof Pair) {
    const kc = getAliasCount(node.key, anchors);
    const vc = getAliasCount(node.value, anchors);
    return Math.max(kc, vc);
  }

  return 1;
};

class Alias extends Node {
  static stringify({
    range,
    source
  }, {
    anchors,
    doc,
    implicitKey,
    inStringifyKey
  }) {
    let anchor = Object.keys(anchors).find(a => anchors[a] === source);
    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;
    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';
    throw new Error(`${msg} [${range}]`);
  }

  constructor(source) {
    super();
    this.source = source;
    this.type = PlainValue.Type.ALIAS;
  }

  set tag(t) {
    throw new Error('Alias nodes cannot have tags');
  }

  toJSON(arg, ctx) {
    if (!ctx) return toJSON(this.source, arg, ctx);
    const {
      anchors,
      maxAliasCount
    } = ctx;
    const anchor = anchors.get(this.source);
    /* istanbul ignore if */

    if (!anchor || anchor.res === undefined) {
      const msg = 'This should not happen: Alias anchor was not resolved?';
      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
    }

    if (maxAliasCount >= 0) {
      anchor.count += 1;
      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);

      if (anchor.count * anchor.aliasCount > maxAliasCount) {
        const msg = 'Excessive alias count indicates a resource exhaustion attack';
        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
      }
    }

    return anchor.res;
  } // Only called when stringifying an alias mapping key while constructing
  // Object output.


  toString(ctx) {
    return Alias.stringify(this, ctx);
  }

}

PlainValue._defineProperty(Alias, "default", true);

function findPair(items, key) {
  const k = key instanceof Scalar ? key.value : key;

  for (const it of items) {
    if (it instanceof Pair) {
      if (it.key === key || it.key === k) return it;
      if (it.key && it.key.value === k) return it;
    }
  }

  return undefined;
}
class YAMLMap extends Collection {
  add(pair, overwrite) {
    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);
    const prev = findPair(this.items, pair.key);
    const sortEntries = this.schema && this.schema.sortMapEntries;

    if (prev) {
      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);
    } else if (sortEntries) {
      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);
      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);
    } else {
      this.items.push(pair);
    }
  }

  delete(key) {
    const it = findPair(this.items, key);
    if (!it) return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }

  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it && it.value;
    return !keepScalar && node instanceof Scalar ? node.value : node;
  }

  has(key) {
    return !!findPair(this.items, key);
  }

  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param {*} arg ignored
   * @param {*} ctx Conversion context, originally set in Document#toJSON()
   * @param {Class} Type If set, forces the returned collection type
   * @returns {*} Instance of Type, Map, or Object
   */


  toJSON(_, ctx, Type) {
    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
    if (ctx && ctx.onCreate) ctx.onCreate(map);

    for (const item of this.items) item.addToJSMap(ctx, map);

    return map;
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);

    for (const item of this.items) {
      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }

    return super.toString(ctx, {
      blockItem: n => n.str,
      flowChars: {
        start: '{',
        end: '}'
      },
      isMap: true,
      itemIndent: ctx.indent || ''
    }, onComment, onChompKeep);
  }

}

const MERGE_KEY = '<<';
class Merge extends Pair {
  constructor(pair) {
    if (pair instanceof Pair) {
      let seq = pair.value;

      if (!(seq instanceof YAMLSeq)) {
        seq = new YAMLSeq();
        seq.items.push(pair.value);
        seq.range = pair.value.range;
      }

      super(pair.key, seq);
      this.range = pair.range;
    } else {
      super(new Scalar(MERGE_KEY), new YAMLSeq());
    }

    this.type = Pair.Type.MERGE_PAIR;
  } // If the value associated with a merge key is a single mapping node, each of
  // its key/value pairs is inserted into the current mapping, unless the key
  // already exists in it. If the value associated with the merge key is a
  // sequence, then this sequence is expected to contain mapping nodes and each
  // of these nodes is merged in turn according to its order in the sequence.
  // Keys in mapping nodes earlier in the sequence override keys specified in
  // later mapping nodes. -- http://yaml.org/type/merge.html


  addToJSMap(ctx, map) {
    for (const {
      source
    } of this.value.items) {
      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');
      const srcMap = source.toJSON(null, ctx, Map);

      for (const [key, value] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key)) map.set(key, value);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    }

    return map;
  }

  toString(ctx, onComment) {
    const seq = this.value;
    if (seq.items.length > 1) return super.toString(ctx, onComment);
    this.value = seq.items[0];
    const str = super.toString(ctx, onComment);
    this.value = seq;
    return str;
  }

}

const binaryOptions = {
  defaultType: PlainValue.Type.BLOCK_LITERAL,
  lineWidth: 76
};
const boolOptions = {
  trueStr: 'true',
  falseStr: 'false'
};
const intOptions = {
  asBigInt: false
};
const nullOptions = {
  nullStr: 'null'
};
const strOptions = {
  defaultType: PlainValue.Type.PLAIN,
  doubleQuoted: {
    jsonEncoding: false,
    minMultiLineLength: 40
  },
  fold: {
    lineWidth: 80,
    minContentWidth: 20
  }
};

function resolveScalar(str, tags, scalarFallback) {
  for (const {
    format,
    test,
    resolve
  } of tags) {
    if (test) {
      const match = str.match(test);

      if (match) {
        let res = resolve.apply(null, match);
        if (!(res instanceof Scalar)) res = new Scalar(res);
        if (format) res.format = format;
        return res;
      }
    }
  }

  if (scalarFallback) str = scalarFallback(str);
  return new Scalar(str);
}

const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line
// returns index of last newline in more-indented block

const consumeMoreIndentedLines = (text, i) => {
  let ch = text[i + 1];

  while (ch === ' ' || ch === '\t') {
    do {
      ch = text[i += 1];
    } while (ch && ch !== '\n');

    ch = text[i + 1];
  }

  return i;
};
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 *
 * @param {string} text
 * @param {string} indent
 * @param {string} [mode='flow'] `'block'` prevents more-indented lines
 *   from being folded; `'quoted'` allows for `\` escapes, including escaped
 *   newlines
 * @param {Object} options
 * @param {number} [options.indentAtStart] Accounts for leading contents on
 *   the first line, defaulting to `indent.length`
 * @param {number} [options.lineWidth=80]
 * @param {number} [options.minContentWidth=20] Allow highly indented lines to
 *   stretch the line width or indent content from the start
 * @param {function} options.onFold Called once if the text is folded
 * @param {function} options.onFold Called once if any line of text exceeds
 *   lineWidth characters
 */


function foldFlowLines(text, indent, mode, {
  indentAtStart,
  lineWidth = 80,
  minContentWidth = 20,
  onFold,
  onOverflow
}) {
  if (!lineWidth || lineWidth < 0) return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep) return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;

  if (typeof indentAtStart === 'number') {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;
  }

  let split = undefined;
  let prev = undefined;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;

  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1) end = i + endStep;
  }

  for (let ch; ch = text[i += 1];) {
    if (mode === FOLD_QUOTED && ch === '\\') {
      escStart = i;

      switch (text[i + 1]) {
        case 'x':
          i += 3;
          break;

        case 'u':
          i += 5;
          break;

        case 'U':
          i += 9;
          break;

        default:
          i += 1;
      }

      escEnd = i;
    }

    if (ch === '\n') {
      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = undefined;
    } else {
      if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') {
        // space surrounded by non-space can be replaced with newline + indent
        const next = text[i + 1];
        if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i;
      }

      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = undefined;
        } else if (mode === FOLD_QUOTED) {
          // white-space collected at end may stretch past lineWidth
          while (prev === ' ' || prev === '\t') {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          } // Account for newline escape, but don't break preceding escape


          const j = i > escEnd + 1 ? i - 2 : escStart - 1; // Bail out if lineWidth & minContentWidth are shorter than an escape string

          if (escapedFolds[j]) return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = undefined;
        } else {
          overflow = true;
        }
      }
    }

    prev = ch;
  }

  if (overflow && onOverflow) onOverflow();
  if (folds.length === 0) return text;
  if (onFold) onFold();
  let res = text.slice(0, folds[0]);

  for (let i = 0; i < folds.length; ++i) {
    const fold = folds[i];
    const end = folds[i + 1] || text.length;
    if (fold === 0) res = `\n${indent}${text.slice(0, end)}`;else {
      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
      res += `\n${indent}${text.slice(fold + 1, end)}`;
    }
  }

  return res;
}

const getFoldOptions = ({
  indentAtStart
}) => indentAtStart ? Object.assign({
  indentAtStart
}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.


const containsDocumentMarker = str => /^(%|---|\.\.\.)/m.test(str);

function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0) return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit) return false;

  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === '\n') {
      if (i - start > limit) return true;
      start = i + 1;
      if (strLen - start <= limit) return false;
    }
  }

  return true;
}

function doubleQuotedString(value, ctx) {
  const {
    implicitKey
  } = ctx;
  const {
    jsonEncoding,
    minMultiLineLength
  } = strOptions.doubleQuoted;
  const json = JSON.stringify(value);
  if (jsonEncoding) return json;
  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  let str = '';
  let start = 0;

  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
      // space before newline needs to be escaped to not be folded
      str += json.slice(start, i) + '\\ ';
      i += 1;
      start = i;
      ch = '\\';
    }

    if (ch === '\\') switch (json[i + 1]) {
      case 'u':
        {
          str += json.slice(start, i);
          const code = json.substr(i + 2, 4);

          switch (code) {
            case '0000':
              str += '\\0';
              break;

            case '0007':
              str += '\\a';
              break;

            case '000b':
              str += '\\v';
              break;

            case '001b':
              str += '\\e';
              break;

            case '0085':
              str += '\\N';
              break;

            case '00a0':
              str += '\\_';
              break;

            case '2028':
              str += '\\L';
              break;

            case '2029':
              str += '\\P';
              break;

            default:
              if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);else str += json.substr(i, 6);
          }

          i += 5;
          start = i + 1;
        }
        break;

      case 'n':
        if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
          i += 1;
        } else {
          // folding will eat first newline
          str += json.slice(start, i) + '\n\n';

          while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
            str += '\n';
            i += 2;
          }

          str += indent; // space after newline needs to be escaped to not be folded

          if (json[i + 2] === ' ') str += '\\';
          i += 1;
          start = i + 1;
        }

        break;

      default:
        i += 1;
    }
  }

  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}

function singleQuotedString(value, ctx) {
  if (ctx.implicitKey) {
    if (/\n/.test(value)) return doubleQuotedString(value, ctx);
  } else {
    // single quoted string can't have leading or trailing whitespace around newline
    if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
  }

  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}

function blockString({
  comment,
  type,
  value
}, ctx, onComment, onChompKeep) {
  // 1. Block can't end in whitespace unless the last line is non-empty.
  // 2. Strings consisting of only whitespace are best rendered explicitly.
  if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return doubleQuotedString(value, ctx);
  }

  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
  const indentSize = indent ? '2' : '1'; // root is at -1

  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
  let header = literal ? '|' : '>';
  if (!value) return header + '\n';
  let wsStart = '';
  let wsEnd = '';
  value = value.replace(/[\n\t ]*$/, ws => {
    const n = ws.indexOf('\n');

    if (n === -1) {
      header += '-'; // strip
    } else if (value === ws || n !== ws.length - 1) {
      header += '+'; // keep

      if (onChompKeep) onChompKeep();
    }

    wsEnd = ws.replace(/\n$/, '');
    return '';
  }).replace(/^[\n ]*/, ws => {
    if (ws.indexOf(' ') !== -1) header += indentSize;
    const m = ws.match(/ +$/);

    if (m) {
      wsStart = ws.slice(0, -m[0].length);
      return m[0];
    } else {
      wsStart = ws;
      return '';
    }
  });
  if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  if (wsStart) wsStart = wsStart.replace(/\n+/g, `$&${indent}`);

  if (comment) {
    header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
    if (onComment) onComment();
  }

  if (!value) return `${header}${indentSize}\n${indent}${wsEnd}`;

  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}\n${indent}${wsStart}${value}${wsEnd}`;
  }

  value = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent
  .replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);
  return `${header}\n${indent}${body}`;
}

function plainString(item, ctx, onComment, onChompKeep) {
  const {
    comment,
    type,
    value
  } = item;
  const {
    actualString,
    implicitKey,
    indent,
    inFlow
  } = ctx;

  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return doubleQuotedString(value, ctx);
  }

  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    // not allowed:
    // - empty string, '-' or '?'
    // - start with an indicator character (except [?:-]) or /[?-] /
    // - '\n ', ': ' or ' \n' anywhere
    // - '#' not preceded by a non-space char
    // - end with ' ' or ':'
    return implicitKey || inFlow || value.indexOf('\n') === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }

  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\n') !== -1) {
    // Where allowed & type not set explicitly, prefer block style for multiline strings
    return blockString(item, ctx, onComment, onChompKeep);
  }

  if (indent === '' && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }

  const str = value.replace(/\n+/g, `$&\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and
  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
  // and others in v1.1.

  if (actualString) {
    const {
      tags
    } = ctx.doc.schema;
    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;
    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);
  }

  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));

  if (comment && !inFlow && (body.indexOf('\n') !== -1 || comment.indexOf('\n') !== -1)) {
    if (onComment) onComment();
    return addCommentBefore(body, indent, comment);
  }

  return body;
}

function stringifyString(item, ctx, onComment, onChompKeep) {
  const {
    defaultType
  } = strOptions;
  const {
    implicitKey,
    inFlow
  } = ctx;
  let {
    type,
    value
  } = item;

  if (typeof value !== 'string') {
    value = String(value);
    item = Object.assign({}, item, {
      value
    });
  }

  const _stringify = _type => {
    switch (_type) {
      case PlainValue.Type.BLOCK_FOLDED:
      case PlainValue.Type.BLOCK_LITERAL:
        return blockString(item, ctx, onComment, onChompKeep);

      case PlainValue.Type.QUOTE_DOUBLE:
        return doubleQuotedString(value, ctx);

      case PlainValue.Type.QUOTE_SINGLE:
        return singleQuotedString(value, ctx);

      case PlainValue.Type.PLAIN:
        return plainString(item, ctx, onComment, onChompKeep);

      default:
        return null;
    }
  };

  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
    // force double quotes on control characters
    type = PlainValue.Type.QUOTE_DOUBLE;
  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {
    // should not happen; blocks are not valid inside flow containers
    type = PlainValue.Type.QUOTE_DOUBLE;
  }

  let res = _stringify(type);

  if (res === null) {
    res = _stringify(defaultType);
    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);
  }

  return res;
}

function stringifyNumber({
  format,
  minFractionDigits,
  tag,
  value
}) {
  if (typeof value === 'bigint') return String(value);
  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';
  let n = JSON.stringify(value);

  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
    let i = n.indexOf('.');

    if (i < 0) {
      i = n.length;
      n += '.';
    }

    let d = minFractionDigits - (n.length - i - 1);

    while (d-- > 0) n += '0';
  }

  return n;
}

function checkFlowCollectionEnd(errors, cst) {
  let char, name;

  switch (cst.type) {
    case PlainValue.Type.FLOW_MAP:
      char = '}';
      name = 'flow map';
      break;

    case PlainValue.Type.FLOW_SEQ:
      char = ']';
      name = 'flow sequence';
      break;

    default:
      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));
      return;
  }

  let lastItem;

  for (let i = cst.items.length - 1; i >= 0; --i) {
    const item = cst.items[i];

    if (!item || item.type !== PlainValue.Type.COMMENT) {
      lastItem = item;
      break;
    }
  }

  if (lastItem && lastItem.char !== char) {
    const msg = `Expected ${name} to end with ${char}`;
    let err;

    if (typeof lastItem.offset === 'number') {
      err = new PlainValue.YAMLSemanticError(cst, msg);
      err.offset = lastItem.offset + 1;
    } else {
      err = new PlainValue.YAMLSemanticError(lastItem, msg);
      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
    }

    errors.push(err);
  }
}
function checkFlowCommentSpace(errors, comment) {
  const prev = comment.context.src[comment.range.start - 1];

  if (prev !== '\n' && prev !== '\t' && prev !== ' ') {
    const msg = 'Comments must be separated from other tokens by white space characters';
    errors.push(new PlainValue.YAMLSemanticError(comment, msg));
  }
}
function getLongKeyError(source, key) {
  const sk = String(key);
  const k = sk.substr(0, 8) + '...' + sk.substr(-8);
  return new PlainValue.YAMLSemanticError(source, `The "${k}" key is too long`);
}
function resolveComments(collection, comments) {
  for (const {
    afterKey,
    before,
    comment
  } of comments) {
    let item = collection.items[before];

    if (!item) {
      if (comment !== undefined) {
        if (collection.comment) collection.comment += '\n' + comment;else collection.comment = comment;
      }
    } else {
      if (afterKey && item.value) item = item.value;

      if (comment === undefined) {
        if (afterKey || !item.commentBefore) item.spaceBefore = true;
      } else {
        if (item.commentBefore) item.commentBefore += '\n' + comment;else item.commentBefore = comment;
      }
    }
  }
}

// on error, will return { str: string, errors: Error[] }
function resolveString(doc, node) {
  const res = node.strValue;
  if (!res) return '';
  if (typeof res === 'string') return res;
  res.errors.forEach(error => {
    if (!error.source) error.source = node;
    doc.errors.push(error);
  });
  return res.str;
}

function resolveTagHandle(doc, node) {
  const {
    handle,
    suffix
  } = node.tag;
  let prefix = doc.tagPrefixes.find(p => p.handle === handle);

  if (!prefix) {
    const dtp = doc.getDefaults().tagPrefixes;
    if (dtp) prefix = dtp.find(p => p.handle === handle);
    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);
  }

  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);

  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {
    if (suffix[0] === '^') {
      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));
      return suffix;
    }

    if (/[:/]/.test(suffix)) {
      // word/foo -> tag:word.yaml.org,2002:foo
      const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
    }
  }

  return prefix.prefix + decodeURIComponent(suffix);
}

function resolveTagName(doc, node) {
  const {
    tag,
    type
  } = node;
  let nonSpecific = false;

  if (tag) {
    const {
      handle,
      suffix,
      verbatim
    } = tag;

    if (verbatim) {
      if (verbatim !== '!' && verbatim !== '!!') return verbatim;
      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
    } else if (handle === '!' && !suffix) {
      nonSpecific = true;
    } else {
      try {
        return resolveTagHandle(doc, node);
      } catch (error) {
        doc.errors.push(error);
      }
    }
  }

  switch (type) {
    case PlainValue.Type.BLOCK_FOLDED:
    case PlainValue.Type.BLOCK_LITERAL:
    case PlainValue.Type.QUOTE_DOUBLE:
    case PlainValue.Type.QUOTE_SINGLE:
      return PlainValue.defaultTags.STR;

    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.MAP:
      return PlainValue.defaultTags.MAP;

    case PlainValue.Type.FLOW_SEQ:
    case PlainValue.Type.SEQ:
      return PlainValue.defaultTags.SEQ;

    case PlainValue.Type.PLAIN:
      return nonSpecific ? PlainValue.defaultTags.STR : null;

    default:
      return null;
  }
}

function resolveByTagName(doc, node, tagName) {
  const {
    tags
  } = doc.schema;
  const matchWithTest = [];

  for (const tag of tags) {
    if (tag.tag === tagName) {
      if (tag.test) matchWithTest.push(tag);else {
        const res = tag.resolve(doc, node);
        return res instanceof Collection ? res : new Scalar(res);
      }
    }
  }

  const str = resolveString(doc, node);
  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);
  return null;
}

function getFallbackTagName({
  type
}) {
  switch (type) {
    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.MAP:
      return PlainValue.defaultTags.MAP;

    case PlainValue.Type.FLOW_SEQ:
    case PlainValue.Type.SEQ:
      return PlainValue.defaultTags.SEQ;

    default:
      return PlainValue.defaultTags.STR;
  }
}

function resolveTag(doc, node, tagName) {
  try {
    const res = resolveByTagName(doc, node, tagName);

    if (res) {
      if (tagName && node.tag) res.tag = tagName;
      return res;
    }
  } catch (error) {
    /* istanbul ignore if */
    if (!error.source) error.source = node;
    doc.errors.push(error);
    return null;
  }

  try {
    const fallback = getFallbackTagName(node);
    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);
    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));
    const res = resolveByTagName(doc, node, fallback);
    res.tag = tagName;
    return res;
  } catch (error) {
    const refError = new PlainValue.YAMLReferenceError(node, error.message);
    refError.stack = error.stack;
    doc.errors.push(refError);
    return null;
  }
}

const isCollectionItem = node => {
  if (!node) return false;
  const {
    type
  } = node;
  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;
};

function resolveNodeProps(errors, node) {
  const comments = {
    before: [],
    after: []
  };
  let hasAnchor = false;
  let hasTag = false;
  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;

  for (const {
    start,
    end
  } of props) {
    switch (node.context.src[start]) {
      case PlainValue.Char.COMMENT:
        {
          if (!node.commentHasRequiredWhitespace(start)) {
            const msg = 'Comments must be separated from other tokens by white space characters';
            errors.push(new PlainValue.YAMLSemanticError(node, msg));
          }

          const {
            header,
            valueRange
          } = node;
          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
          cc.push(node.context.src.slice(start + 1, end));
          break;
        }
      // Actual anchor & tag resolution is handled by schema, here we just complain

      case PlainValue.Char.ANCHOR:
        if (hasAnchor) {
          const msg = 'A node can have at most one anchor';
          errors.push(new PlainValue.YAMLSemanticError(node, msg));
        }

        hasAnchor = true;
        break;

      case PlainValue.Char.TAG:
        if (hasTag) {
          const msg = 'A node can have at most one tag';
          errors.push(new PlainValue.YAMLSemanticError(node, msg));
        }

        hasTag = true;
        break;
    }
  }

  return {
    comments,
    hasAnchor,
    hasTag
  };
}

function resolveNodeValue(doc, node) {
  const {
    anchors,
    errors,
    schema
  } = doc;

  if (node.type === PlainValue.Type.ALIAS) {
    const name = node.rawValue;
    const src = anchors.getNode(name);

    if (!src) {
      const msg = `Aliased anchor not found: ${name}`;
      errors.push(new PlainValue.YAMLReferenceError(node, msg));
      return null;
    } // Lazy resolution for circular references


    const res = new Alias(src);

    anchors._cstAliases.push(res);

    return res;
  }

  const tagName = resolveTagName(doc, node);
  if (tagName) return resolveTag(doc, node, tagName);

  if (node.type !== PlainValue.Type.PLAIN) {
    const msg = `Failed to resolve ${node.type} node here`;
    errors.push(new PlainValue.YAMLSyntaxError(node, msg));
    return null;
  }

  try {
    const str = resolveString(doc, node);
    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
  } catch (error) {
    if (!error.source) error.source = node;
    errors.push(error);
    return null;
  }
} // sets node.resolved on success


function resolveNode(doc, node) {
  if (!node) return null;
  if (node.error) doc.errors.push(node.error);
  const {
    comments,
    hasAnchor,
    hasTag
  } = resolveNodeProps(doc.errors, node);

  if (hasAnchor) {
    const {
      anchors
    } = doc;
    const name = node.anchor;
    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor
    // name have already been resolved, so it may safely be renamed.

    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as
    // anchors need to be available during resolution to allow for
    // circular references.

    anchors.map[name] = node;
  }

  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {
    const msg = 'An alias node must not specify any properties';
    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
  }

  const res = resolveNodeValue(doc, node);

  if (res) {
    res.range = [node.range.start, node.range.end];
    if (doc.options.keepCstNodes) res.cstNode = node;
    if (doc.options.keepNodeTypes) res.type = node.type;
    const cb = comments.before.join('\n');

    if (cb) {
      res.commentBefore = res.commentBefore ? `${res.commentBefore}\n${cb}` : cb;
    }

    const ca = comments.after.join('\n');
    if (ca) res.comment = res.comment ? `${res.comment}\n${ca}` : ca;
  }

  return node.resolved = res;
}

function resolveMap(doc, cst) {
  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {
    const msg = `A ${cst.type} node cannot be resolved as a mapping`;
    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
    return null;
  }

  const {
    comments,
    items
  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
  const map = new YAMLMap();
  map.items = items;
  resolveComments(map, comments);
  let hasCollectionKey = false;

  for (let i = 0; i < items.length; ++i) {
    const {
      key: iKey
    } = items[i];
    if (iKey instanceof Collection) hasCollectionKey = true;

    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
      items[i] = new Merge(items[i]);
      const sources = items[i].value.items;
      let error = null;
      sources.some(node => {
        if (node instanceof Alias) {
          // During parsing, alias sources are CST nodes; to account for
          // circular references their resolved values can't be used here.
          const {
            type
          } = node.source;
          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;
          return error = 'Merge nodes aliases can only point to maps';
        }

        return error = 'Merge nodes can only have Alias nodes as values';
      });
      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));
    } else {
      for (let j = i + 1; j < items.length; ++j) {
        const {
          key: jKey
        } = items[j];

        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {
          const msg = `Map keys must be unique; "${iKey}" is repeated`;
          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
          break;
        }
      }
    }
  }

  if (hasCollectionKey && !doc.options.mapAsMap) {
    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
  }

  cst.resolved = map;
  return map;
}

const valueHasPairComment = ({
  context: {
    lineStart,
    node,
    src
  },
  props
}) => {
  if (props.length === 0) return false;
  const {
    start
  } = props[0];
  if (node && start > node.valueRange.start) return false;
  if (src[start] !== PlainValue.Char.COMMENT) return false;

  for (let i = lineStart; i < start; ++i) if (src[i] === '\n') return false;

  return true;
};

function resolvePairComment(item, pair) {
  if (!valueHasPairComment(item)) return;
  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);
  let found = false;
  const cb = pair.value.commentBefore;

  if (cb && cb.startsWith(comment)) {
    pair.value.commentBefore = cb.substr(comment.length + 1);
    found = true;
  } else {
    const cc = pair.value.comment;

    if (!item.node && cc && cc.startsWith(comment)) {
      pair.value.comment = cc.substr(comment.length + 1);
      found = true;
    }
  }

  if (found) pair.comment = comment;
}

function resolveBlockMapItems(doc, cst) {
  const comments = [];
  const items = [];
  let key = undefined;
  let keyStart = null;

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    switch (item.type) {
      case PlainValue.Type.BLANK_LINE:
        comments.push({
          afterKey: !!key,
          before: items.length
        });
        break;

      case PlainValue.Type.COMMENT:
        comments.push({
          afterKey: !!key,
          before: items.length,
          comment: item.comment
        });
        break;

      case PlainValue.Type.MAP_KEY:
        if (key !== undefined) items.push(new Pair(key));
        if (item.error) doc.errors.push(item.error);
        key = resolveNode(doc, item.node);
        keyStart = null;
        break;

      case PlainValue.Type.MAP_VALUE:
        {
          if (key === undefined) key = null;
          if (item.error) doc.errors.push(item.error);

          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {
            const msg = 'Nested mappings are not allowed in compact mappings';
            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
          }

          let valueNode = item.node;

          if (!valueNode && item.props.length > 0) {
            // Comments on an empty mapping value need to be preserved, so we
            // need to construct a minimal empty node here to use instead of the
            // missing `item.node`. -- eemeli/yaml#19
            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
            valueNode.context = {
              parent: item,
              src: item.context.src
            };
            const pos = item.range.start + 1;
            valueNode.range = {
              start: pos,
              end: pos
            };
            valueNode.valueRange = {
              start: pos,
              end: pos
            };

            if (typeof item.range.origStart === 'number') {
              const origPos = item.range.origStart + 1;
              valueNode.range.origStart = valueNode.range.origEnd = origPos;
              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
            }
          }

          const pair = new Pair(key, resolveNode(doc, valueNode));
          resolvePairComment(item, pair);
          items.push(pair);

          if (key && typeof keyStart === 'number') {
            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
          }

          key = undefined;
          keyStart = null;
        }
        break;

      default:
        if (key !== undefined) items.push(new Pair(key));
        key = resolveNode(doc, item);
        keyStart = item.range.start;
        if (item.error) doc.errors.push(item.error);

        next: for (let j = i + 1;; ++j) {
          const nextItem = cst.items[j];

          switch (nextItem && nextItem.type) {
            case PlainValue.Type.BLANK_LINE:
            case PlainValue.Type.COMMENT:
              continue next;

            case PlainValue.Type.MAP_VALUE:
              break next;

            default:
              {
                const msg = 'Implicit map keys need to be followed by map values';
                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                break next;
              }
          }
        }

        if (item.valueRangeContainsNewline) {
          const msg = 'Implicit map keys need to be on a single line';
          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
        }

    }
  }

  if (key !== undefined) items.push(new Pair(key));
  return {
    comments,
    items
  };
}

function resolveFlowMapItems(doc, cst) {
  const comments = [];
  const items = [];
  let key = undefined;
  let explicitKey = false;
  let next = '{';

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    if (typeof item.char === 'string') {
      const {
        char,
        offset
      } = item;

      if (char === '?' && key === undefined && !explicitKey) {
        explicitKey = true;
        next = ':';
        continue;
      }

      if (char === ':') {
        if (key === undefined) key = null;

        if (next === ':') {
          next = ',';
          continue;
        }
      } else {
        if (explicitKey) {
          if (key === undefined && char !== ',') key = null;
          explicitKey = false;
        }

        if (key !== undefined) {
          items.push(new Pair(key));
          key = undefined;

          if (char === ',') {
            next = ':';
            continue;
          }
        }
      }

      if (char === '}') {
        if (i === cst.items.length - 1) continue;
      } else if (char === next) {
        next = ':';
        continue;
      }

      const msg = `Flow map contains an unexpected ${char}`;
      const err = new PlainValue.YAMLSyntaxError(cst, msg);
      err.offset = offset;
      doc.errors.push(err);
    } else if (item.type === PlainValue.Type.BLANK_LINE) {
      comments.push({
        afterKey: !!key,
        before: items.length
      });
    } else if (item.type === PlainValue.Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        afterKey: !!key,
        before: items.length,
        comment: item.comment
      });
    } else if (key === undefined) {
      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));
      key = resolveNode(doc, item);
    } else {
      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));
      items.push(new Pair(key, resolveNode(doc, item)));
      key = undefined;
      explicitKey = false;
    }
  }

  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== undefined) items.push(new Pair(key));
  return {
    comments,
    items
  };
}

function resolveSeq(doc, cst) {
  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {
    const msg = `A ${cst.type} node cannot be resolved as a sequence`;
    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
    return null;
  }

  const {
    comments,
    items
  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
  const seq = new YAMLSeq();
  seq.items = items;
  resolveComments(seq, comments);

  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {
    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
  }

  cst.resolved = seq;
  return seq;
}

function resolveBlockSeqItems(doc, cst) {
  const comments = [];
  const items = [];

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    switch (item.type) {
      case PlainValue.Type.BLANK_LINE:
        comments.push({
          before: items.length
        });
        break;

      case PlainValue.Type.COMMENT:
        comments.push({
          comment: item.comment,
          before: items.length
        });
        break;

      case PlainValue.Type.SEQ_ITEM:
        if (item.error) doc.errors.push(item.error);
        items.push(resolveNode(doc, item.node));

        if (item.hasProps) {
          const msg = 'Sequence items cannot have tags or anchors before the - indicator';
          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
        }

        break;

      default:
        if (item.error) doc.errors.push(item.error);
        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
    }
  }

  return {
    comments,
    items
  };
}

function resolveFlowSeqItems(doc, cst) {
  const comments = [];
  const items = [];
  let explicitKey = false;
  let key = undefined;
  let keyStart = null;
  let next = '[';
  let prevItem = null;

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    if (typeof item.char === 'string') {
      const {
        char,
        offset
      } = item;

      if (char !== ':' && (explicitKey || key !== undefined)) {
        if (explicitKey && key === undefined) key = next ? items.pop() : null;
        items.push(new Pair(key));
        explicitKey = false;
        key = undefined;
        keyStart = null;
      }

      if (char === next) {
        next = null;
      } else if (!next && char === '?') {
        explicitKey = true;
      } else if (next !== '[' && char === ':' && key === undefined) {
        if (next === ',') {
          key = items.pop();

          if (key instanceof Pair) {
            const msg = 'Chaining flow sequence pairs is invalid';
            const err = new PlainValue.YAMLSemanticError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }

          if (!explicitKey && typeof keyStart === 'number') {
            const keyEnd = item.range ? item.range.start : item.offset;
            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
            const {
              src
            } = prevItem.context;

            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\n') {
              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';
              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
              break;
            }
          }
        } else {
          key = null;
        }

        keyStart = null;
        explicitKey = false;
        next = null;
      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {
        const msg = `Flow sequence contains an unexpected ${char}`;
        const err = new PlainValue.YAMLSyntaxError(cst, msg);
        err.offset = offset;
        doc.errors.push(err);
      }
    } else if (item.type === PlainValue.Type.BLANK_LINE) {
      comments.push({
        before: items.length
      });
    } else if (item.type === PlainValue.Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        comment: item.comment,
        before: items.length
      });
    } else {
      if (next) {
        const msg = `Expected a ${next} in flow sequence`;
        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
      }

      const value = resolveNode(doc, item);

      if (key === undefined) {
        items.push(value);
        prevItem = item;
      } else {
        items.push(new Pair(key, value));
        key = undefined;
      }

      keyStart = item.range.start;
      next = ',';
    }
  }

  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== undefined) items.push(new Pair(key));
  return {
    comments,
    items
  };
}

exports.Alias = Alias;
exports.Collection = Collection;
exports.Merge = Merge;
exports.Node = Node;
exports.Pair = Pair;
exports.Scalar = Scalar;
exports.YAMLMap = YAMLMap;
exports.YAMLSeq = YAMLSeq;
exports.addComment = addComment;
exports.binaryOptions = binaryOptions;
exports.boolOptions = boolOptions;
exports.findPair = findPair;
exports.intOptions = intOptions;
exports.isEmptyPath = isEmptyPath;
exports.nullOptions = nullOptions;
exports.resolveMap = resolveMap;
exports.resolveNode = resolveNode;
exports.resolveSeq = resolveSeq;
exports.resolveString = resolveString;
exports.strOptions = strOptions;
exports.stringifyNumber = stringifyNumber;
exports.stringifyString = stringifyString;
exports.toJSON = toJSON;


/***/ }),

/***/ 19114:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var PlainValue = __webpack_require__(75551);
var resolveSeq = __webpack_require__(28393);

/* global atob, btoa, Buffer */
const binary = {
  identify: value => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: 'tag:yaml.org,2002:binary',

  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve: (doc, node) => {
    const src = resolveSeq.resolveString(doc, node);

    if (typeof Buffer === 'function') {
      return Buffer.from(src, 'base64');
    } else if (typeof atob === 'function') {
      // On IE 11, atob() can't handle newlines
      const str = atob(src.replace(/[\n\r]/g, ''));
      const buffer = new Uint8Array(str.length);

      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);

      return buffer;
    } else {
      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';
      doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));
      return null;
    }
  },
  options: resolveSeq.binaryOptions,
  stringify: ({
    comment,
    type,
    value
  }, ctx, onComment, onChompKeep) => {
    let src;

    if (typeof Buffer === 'function') {
      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');
    } else if (typeof btoa === 'function') {
      let s = '';

      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);

      src = btoa(s);
    } else {
      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
    }

    if (!type) type = resolveSeq.binaryOptions.defaultType;

    if (type === PlainValue.Type.QUOTE_DOUBLE) {
      value = src;
    } else {
      const {
        lineWidth
      } = resolveSeq.binaryOptions;
      const n = Math.ceil(src.length / lineWidth);
      const lines = new Array(n);

      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = src.substr(o, lineWidth);
      }

      value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? '\n' : ' ');
    }

    return resolveSeq.stringifyString({
      comment,
      type,
      value
    }, ctx, onComment, onChompKeep);
  }
};

function parsePairs(doc, cst) {
  const seq = resolveSeq.resolveSeq(doc, cst);

  for (let i = 0; i < seq.items.length; ++i) {
    let item = seq.items[i];
    if (item instanceof resolveSeq.Pair) continue;else if (item instanceof resolveSeq.YAMLMap) {
      if (item.items.length > 1) {
        const msg = 'Each pair must have its own sequence indicator';
        throw new PlainValue.YAMLSemanticError(cst, msg);
      }

      const pair = item.items[0] || new resolveSeq.Pair();
      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\n${pair.commentBefore}` : item.commentBefore;
      if (item.comment) pair.comment = pair.comment ? `${item.comment}\n${pair.comment}` : item.comment;
      item = pair;
    }
    seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);
  }

  return seq;
}
function createPairs(schema, iterable, ctx) {
  const pairs = new resolveSeq.YAMLSeq(schema);
  pairs.tag = 'tag:yaml.org,2002:pairs';

  for (const it of iterable) {
    let key, value;

    if (Array.isArray(it)) {
      if (it.length === 2) {
        key = it[0];
        value = it[1];
      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
    } else if (it && it instanceof Object) {
      const keys = Object.keys(it);

      if (keys.length === 1) {
        key = keys[0];
        value = it[key];
      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);
    } else {
      key = it;
    }

    const pair = schema.createPair(key, value, ctx);
    pairs.items.push(pair);
  }

  return pairs;
}
const pairs = {
  default: false,
  tag: 'tag:yaml.org,2002:pairs',
  resolve: parsePairs,
  createNode: createPairs
};

class YAMLOMap extends resolveSeq.YAMLSeq {
  constructor() {
    super();

    PlainValue._defineProperty(this, "add", resolveSeq.YAMLMap.prototype.add.bind(this));

    PlainValue._defineProperty(this, "delete", resolveSeq.YAMLMap.prototype.delete.bind(this));

    PlainValue._defineProperty(this, "get", resolveSeq.YAMLMap.prototype.get.bind(this));

    PlainValue._defineProperty(this, "has", resolveSeq.YAMLMap.prototype.has.bind(this));

    PlainValue._defineProperty(this, "set", resolveSeq.YAMLMap.prototype.set.bind(this));

    this.tag = YAMLOMap.tag;
  }

  toJSON(_, ctx) {
    const map = new Map();
    if (ctx && ctx.onCreate) ctx.onCreate(map);

    for (const pair of this.items) {
      let key, value;

      if (pair instanceof resolveSeq.Pair) {
        key = resolveSeq.toJSON(pair.key, '', ctx);
        value = resolveSeq.toJSON(pair.value, key, ctx);
      } else {
        key = resolveSeq.toJSON(pair, '', ctx);
      }

      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
      map.set(key, value);
    }

    return map;
  }

}

PlainValue._defineProperty(YAMLOMap, "tag", 'tag:yaml.org,2002:omap');

function parseOMap(doc, cst) {
  const pairs = parsePairs(doc, cst);
  const seenKeys = [];

  for (const {
    key
  } of pairs.items) {
    if (key instanceof resolveSeq.Scalar) {
      if (seenKeys.includes(key.value)) {
        const msg = 'Ordered maps must not include duplicate keys';
        throw new PlainValue.YAMLSemanticError(cst, msg);
      } else {
        seenKeys.push(key.value);
      }
    }
  }

  return Object.assign(new YAMLOMap(), pairs);
}

function createOMap(schema, iterable, ctx) {
  const pairs = createPairs(schema, iterable, ctx);
  const omap = new YAMLOMap();
  omap.items = pairs.items;
  return omap;
}

const omap = {
  identify: value => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: 'tag:yaml.org,2002:omap',
  resolve: parseOMap,
  createNode: createOMap
};

class YAMLSet extends resolveSeq.YAMLMap {
  constructor() {
    super();
    this.tag = YAMLSet.tag;
  }

  add(key) {
    const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);
    const prev = resolveSeq.findPair(this.items, pair.key);
    if (!prev) this.items.push(pair);
  }

  get(key, keepPair) {
    const pair = resolveSeq.findPair(this.items, key);
    return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;
  }

  set(key, value) {
    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = resolveSeq.findPair(this.items, key);

    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new resolveSeq.Pair(key));
    }
  }

  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);
    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');
  }

}

PlainValue._defineProperty(YAMLSet, "tag", 'tag:yaml.org,2002:set');

function parseSet(doc, cst) {
  const map = resolveSeq.resolveMap(doc, cst);
  if (!map.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, 'Set items must all have null values');
  return Object.assign(new YAMLSet(), map);
}

function createSet(schema, iterable, ctx) {
  const set = new YAMLSet();

  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));

  return set;
}

const set = {
  identify: value => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: 'tag:yaml.org,2002:set',
  resolve: parseSet,
  createNode: createSet
};

const parseSexagesimal = (sign, parts) => {
  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);
  return sign === '-' ? -n : n;
}; // hhhh:mm:ss.sss


const stringifySexagesimal = ({
  value
}) => {
  if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);
  let sign = '';

  if (value < 0) {
    sign = '-';
    value = Math.abs(value);
  }

  const parts = [value % 60]; // seconds, including ms

  if (value < 60) {
    parts.unshift(0); // at least one : is required
  } else {
    value = Math.round((value - parts[0]) / 60);
    parts.unshift(value % 60); // minutes

    if (value >= 60) {
      value = Math.round((value - parts[0]) / 60);
      parts.unshift(value); // hours
    }
  }

  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
  ;
};

const intTime = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'TIME',
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
  stringify: stringifySexagesimal
};
const floatTime = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'TIME',
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
  stringify: stringifySexagesimal
};
const timestamp = {
  identify: value => value instanceof Date,
  default: true,
  tag: 'tag:yaml.org,2002:timestamp',
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
  '(?:(?:t|T|[ \\t]+)' + // t | T | whitespace
  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
  '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
  ')?' + ')$'),
  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
    if (millisec) millisec = (millisec + '00').substr(1, 3);
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);

    if (tz && tz !== 'Z') {
      let d = parseSexagesimal(tz[0], tz.slice(1));
      if (Math.abs(d) < 30) d *= 60;
      date -= 60000 * d;
    }

    return new Date(date);
  },
  stringify: ({
    value
  }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};

/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */
function shouldWarn(deprecation) {
  const env = typeof process !== 'undefined' && process.env || {};

  if (deprecation) {
    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;
    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
  }

  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;
  return !env.YAML_SILENCE_WARNINGS;
}

function warn(warning, type) {
  if (shouldWarn(false)) {
    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to
    // https://github.com/facebook/jest/issues/2549

    if (emit) emit(warning, type);else {
      // eslint-disable-next-line no-console
      console.warn(type ? `${type}: ${warning}` : warning);
    }
  }
}
function warnFileDeprecation(filename) {
  if (shouldWarn(true)) {
    const path = filename.replace(/.*yaml[/\\]/i, '').replace(/\.js$/, '').replace(/\\/g, '/');
    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');
  }
}
const warned = {};
function warnOptionDeprecation(name, alternative) {
  if (!warned[name] && shouldWarn(true)) {
    warned[name] = true;
    let msg = `The option '${name}' will be removed in a future release`;
    msg += alternative ? `, use '${alternative}' instead.` : '.';
    warn(msg, 'DeprecationWarning');
  }
}

exports.binary = binary;
exports.floatTime = floatTime;
exports.intTime = intTime;
exports.omap = omap;
exports.pairs = pairs;
exports.set = set;
exports.timestamp = timestamp;
exports.warn = warn;
exports.warnFileDeprecation = warnFileDeprecation;
exports.warnOptionDeprecation = warnOptionDeprecation;


/***/ }),

/***/ 87985:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(36537).YAML


/***/ }),

/***/ 75206:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Anchors = void 0;

var _Alias = __webpack_require__(44058);

var _Map = __webpack_require__(80022);

var _Merge = __webpack_require__(69375);

var _Scalar = __webpack_require__(55858);

var _Seq = __webpack_require__(74151);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Anchors {
  static validAnchorNode(node) {
    return node instanceof _Scalar.Scalar || node instanceof _Seq.YAMLSeq || node instanceof _Map.YAMLMap;
  }

  constructor(prefix) {
    _defineProperty(this, "map", {});

    this.prefix = prefix;
  }

  createAlias(node, name) {
    this.setAnchor(node, name);
    return new _Alias.Alias(node);
  }

  createMergePair(...sources) {
    const merge = new _Merge.Merge();
    merge.value.items = sources.map(s => {
      if (s instanceof _Alias.Alias) {
        if (s.source instanceof _Map.YAMLMap) return s;
      } else if (s instanceof _Map.YAMLMap) {
        return this.createAlias(s);
      }

      throw new Error('Merge sources must be Map nodes or their Aliases');
    });
    return merge;
  }

  getName(node) {
    const {
      map
    } = this;
    return Object.keys(map).find(a => map[a] === node);
  }

  getNode(name) {
    return this.map[name];
  }

  newName(prefix) {
    if (!prefix) prefix = this.prefix;
    const names = Object.keys(this.map);

    for (let i = 1; true; ++i) {
      const name = `${prefix}${i}`;
      if (!names.includes(name)) return name;
    }
  } // During parsing, map & aliases contain CST nodes


  resolveNodes() {
    const {
      map,
      _cstAliases
    } = this;
    Object.keys(map).forEach(a => {
      map[a] = map[a].resolved;
    });

    _cstAliases.forEach(a => {
      a.source = a.source.resolved;
    });

    delete this._cstAliases;
  }

  setAnchor(node, name) {
    if (node != null && !Anchors.validAnchorNode(node)) {
      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');
    }

    if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
      throw new Error('Anchor names must not contain whitespace or control characters');
    }

    const {
      map
    } = this;
    const prev = node && Object.keys(map).find(a => map[a] === node);

    if (prev) {
      if (!name) {
        return prev;
      } else if (prev !== name) {
        delete map[prev];
        map[name] = node;
      }
    } else {
      if (!name) {
        if (!node) return null;
        name = this.newName();
      }

      map[name] = node;
    }

    return name;
  }

}

exports.Anchors = Anchors;

/***/ }),

/***/ 24404:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Document = void 0;

var _addComment = __webpack_require__(5350);

var _Anchors = __webpack_require__(75206);

var _constants = __webpack_require__(87270);

var _errors = __webpack_require__(61298);

var _listTagNames = __webpack_require__(89153);

var _schema = __webpack_require__(2383);

var _Alias = __webpack_require__(44058);

var _Collection = __webpack_require__(67404);

var _Node = __webpack_require__(70800);

var _Scalar = __webpack_require__(55858);

var _toJSON = __webpack_require__(35613);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const isCollectionItem = node => node && [_constants.Type.MAP_KEY, _constants.Type.MAP_VALUE, _constants.Type.SEQ_ITEM].includes(node.type);

class Document {
  constructor(options) {
    this.anchors = new _Anchors.Anchors(options.anchorPrefix);
    this.commentBefore = null;
    this.comment = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.errors = [];
    this.options = options;
    this.schema = null;
    this.tagPrefixes = [];
    this.version = null;
    this.warnings = [];
  }

  assertCollectionContents() {
    if (this.contents instanceof _Collection.Collection) return true;
    throw new Error('Expected a YAML collection as document contents');
  }

  add(value) {
    this.assertCollectionContents();
    return this.contents.add(value);
  }

  addIn(path, value) {
    this.assertCollectionContents();
    this.contents.addIn(path, value);
  }

  delete(key) {
    this.assertCollectionContents();
    return this.contents.delete(key);
  }

  deleteIn(path) {
    if ((0, _Collection.isEmptyPath)(path)) {
      if (this.contents == null) return false;
      this.contents = null;
      return true;
    }

    this.assertCollectionContents();
    return this.contents.deleteIn(path);
  }

  getDefaults() {
    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};
  }

  get(key, keepScalar) {
    return this.contents instanceof _Collection.Collection ? this.contents.get(key, keepScalar) : undefined;
  }

  getIn(path, keepScalar) {
    if ((0, _Collection.isEmptyPath)(path)) return !keepScalar && this.contents instanceof _Scalar.Scalar ? this.contents.value : this.contents;
    return this.contents instanceof _Collection.Collection ? this.contents.getIn(path, keepScalar) : undefined;
  }

  has(key) {
    return this.contents instanceof _Collection.Collection ? this.contents.has(key) : false;
  }

  hasIn(path) {
    if ((0, _Collection.isEmptyPath)(path)) return this.contents !== undefined;
    return this.contents instanceof _Collection.Collection ? this.contents.hasIn(path) : false;
  }

  set(key, value) {
    this.assertCollectionContents();
    this.contents.set(key, value);
  }

  setIn(path, value) {
    if ((0, _Collection.isEmptyPath)(path)) this.contents = value;else {
      this.assertCollectionContents();
      this.contents.setIn(path, value);
    }
  }

  setSchema(id, customTags) {
    if (!id && !customTags && this.schema) return;
    if (typeof id === 'number') id = id.toFixed(1);

    if (id === '1.0' || id === '1.1' || id === '1.2') {
      if (this.version) this.version = id;else this.options.version = id;
      delete this.options.schema;
    } else if (id && typeof id === 'string') {
      this.options.schema = id;
    }

    if (Array.isArray(customTags)) this.options.customTags = customTags;
    const opt = Object.assign({}, this.getDefaults(), this.options);
    this.schema = new _schema.Schema(opt);
  }

  parse(node, prevDoc) {
    if (this.options.keepCstNodes) this.cstNode = node;
    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';
    const {
      directives = [],
      contents = [],
      directivesEndMarker,
      error,
      valueRange
    } = node;

    if (error) {
      if (!error.source) error.source = this;
      this.errors.push(error);
    }

    this.parseDirectives(directives, prevDoc);
    if (directivesEndMarker) this.directivesEndMarker = true;
    this.range = valueRange ? [valueRange.start, valueRange.end] : null;
    this.setSchema();
    this.anchors._cstAliases = [];
    this.parseContents(contents);
    this.anchors.resolveNodes();

    if (this.options.prettyErrors) {
      for (const error of this.errors) if (error instanceof _errors.YAMLError) error.makePretty();

      for (const warn of this.warnings) if (warn instanceof _errors.YAMLError) warn.makePretty();
    }

    return this;
  }

  parseDirectives(directives, prevDoc) {
    const directiveComments = [];
    let hasDirectives = false;
    directives.forEach(directive => {
      const {
        comment,
        name
      } = directive;

      switch (name) {
        case 'TAG':
          this.resolveTagDirective(directive);
          hasDirectives = true;
          break;

        case 'YAML':
        case 'YAML:1.0':
          this.resolveYamlDirective(directive);
          hasDirectives = true;
          break;

        default:
          if (name) {
            const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;
            this.warnings.push(new _errors.YAMLWarning(directive, msg));
          }

      }

      if (comment) directiveComments.push(comment);
    });

    if (prevDoc && !hasDirectives && '1.1' === (this.version || prevDoc.version || this.options.version)) {
      const copyTagPrefix = ({
        handle,
        prefix
      }) => ({
        handle,
        prefix
      });

      this.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
      this.version = prevDoc.version;
    }

    this.commentBefore = directiveComments.join('\n') || null;
  }

  parseContents(contents) {
    const comments = {
      before: [],
      after: []
    };
    const contentNodes = [];
    let spaceBefore = false;
    contents.forEach(node => {
      if (node.valueRange) {
        if (contentNodes.length === 1) {
          const msg = 'Document is not valid YAML (bad indentation?)';
          this.errors.push(new _errors.YAMLSyntaxError(node, msg));
        }

        const res = this.resolveNode(node);

        if (spaceBefore) {
          res.spaceBefore = true;
          spaceBefore = false;
        }

        contentNodes.push(res);
      } else if (node.comment !== null) {
        const cc = contentNodes.length === 0 ? comments.before : comments.after;
        cc.push(node.comment);
      } else if (node.type === _constants.Type.BLANK_LINE) {
        spaceBefore = true;

        if (contentNodes.length === 0 && comments.before.length > 0 && !this.commentBefore) {
          // space-separated comments at start are parsed as document comments
          this.commentBefore = comments.before.join('\n');
          comments.before = [];
        }
      }
    });

    switch (contentNodes.length) {
      case 0:
        this.contents = null;
        comments.after = comments.before;
        break;

      case 1:
        this.contents = contentNodes[0];

        if (this.contents) {
          const cb = comments.before.join('\n') || null;

          if (cb) {
            const cbNode = this.contents instanceof _Collection.Collection && this.contents.items[0] ? this.contents.items[0] : this.contents;
            cbNode.commentBefore = cbNode.commentBefore ? `${cb}\n${cbNode.commentBefore}` : cb;
          }
        } else {
          comments.after = comments.before.concat(comments.after);
        }

        break;

      default:
        this.contents = contentNodes;

        if (this.contents[0]) {
          this.contents[0].commentBefore = comments.before.join('\n') || null;
        } else {
          comments.after = comments.before.concat(comments.after);
        }

    }

    this.comment = comments.after.join('\n') || null;
  }

  resolveTagDirective(directive) {
    const [handle, prefix] = directive.parameters;

    if (handle && prefix) {
      if (this.tagPrefixes.every(p => p.handle !== handle)) {
        this.tagPrefixes.push({
          handle,
          prefix
        });
      } else {
        const msg = 'The %TAG directive must only be given at most once per handle in the same document.';
        this.errors.push(new _errors.YAMLSemanticError(directive, msg));
      }
    } else {
      const msg = 'Insufficient parameters given for %TAG directive';
      this.errors.push(new _errors.YAMLSemanticError(directive, msg));
    }
  }

  resolveYamlDirective(directive) {
    let [version] = directive.parameters;
    if (directive.name === 'YAML:1.0') version = '1.0';

    if (this.version) {
      const msg = 'The %YAML directive must only be given at most once per document.';
      this.errors.push(new _errors.YAMLSemanticError(directive, msg));
    }

    if (!version) {
      const msg = 'Insufficient parameters given for %YAML directive';
      this.errors.push(new _errors.YAMLSemanticError(directive, msg));
    } else {
      if (!Document.defaults[version]) {
        const v0 = this.version || this.options.version;
        const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;
        this.warnings.push(new _errors.YAMLWarning(directive, msg));
      }

      this.version = version;
    }
  }

  resolveTagName(node) {
    const {
      tag,
      type
    } = node;
    let nonSpecific = false;

    if (tag) {
      const {
        handle,
        suffix,
        verbatim
      } = tag;

      if (verbatim) {
        if (verbatim !== '!' && verbatim !== '!!') return verbatim;
        const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
        this.errors.push(new _errors.YAMLSemanticError(node, msg));
      } else if (handle === '!' && !suffix) {
        nonSpecific = true;
      } else {
        let prefix = this.tagPrefixes.find(p => p.handle === handle);

        if (!prefix) {
          const dtp = this.getDefaults().tagPrefixes;
          if (dtp) prefix = dtp.find(p => p.handle === handle);
        }

        if (prefix) {
          if (suffix) {
            if (handle === '!' && (this.version || this.options.version) === '1.0') {
              if (suffix[0] === '^') return suffix;

              if (/[:/]/.test(suffix)) {
                // word/foo -> tag:word.yaml.org,2002:foo
                const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
                return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
              }
            }

            return prefix.prefix + decodeURIComponent(suffix);
          }

          this.errors.push(new _errors.YAMLSemanticError(node, `The ${handle} tag has no suffix.`));
        } else {
          const msg = `The ${handle} tag handle is non-default and was not declared.`;
          this.errors.push(new _errors.YAMLSemanticError(node, msg));
        }
      }
    }

    switch (type) {
      case _constants.Type.BLOCK_FOLDED:
      case _constants.Type.BLOCK_LITERAL:
      case _constants.Type.QUOTE_DOUBLE:
      case _constants.Type.QUOTE_SINGLE:
        return _schema.Schema.defaultTags.STR;

      case _constants.Type.FLOW_MAP:
      case _constants.Type.MAP:
        return _schema.Schema.defaultTags.MAP;

      case _constants.Type.FLOW_SEQ:
      case _constants.Type.SEQ:
        return _schema.Schema.defaultTags.SEQ;

      case _constants.Type.PLAIN:
        return nonSpecific ? _schema.Schema.defaultTags.STR : null;

      default:
        return null;
    }
  }

  resolveNode(node) {
    if (!node) return null;
    const {
      anchors,
      errors,
      schema
    } = this;
    let hasAnchor = false;
    let hasTag = false;
    const comments = {
      before: [],
      after: []
    };
    const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;

    for (const {
      start,
      end
    } of props) {
      switch (node.context.src[start]) {
        case _constants.Char.COMMENT:
          {
            if (!node.commentHasRequiredWhitespace(start)) {
              const msg = 'Comments must be separated from other tokens by white space characters';
              errors.push(new _errors.YAMLSemanticError(node, msg));
            }

            const c = node.context.src.slice(start + 1, end);
            const {
              header,
              valueRange
            } = node;

            if (valueRange && (start > valueRange.start || header && start > header.start)) {
              comments.after.push(c);
            } else {
              comments.before.push(c);
            }
          }
          break;

        case _constants.Char.ANCHOR:
          if (hasAnchor) {
            const msg = 'A node can have at most one anchor';
            errors.push(new _errors.YAMLSemanticError(node, msg));
          }

          hasAnchor = true;
          break;

        case _constants.Char.TAG:
          if (hasTag) {
            const msg = 'A node can have at most one tag';
            errors.push(new _errors.YAMLSemanticError(node, msg));
          }

          hasTag = true;
          break;
      }
    }

    if (hasAnchor) {
      const name = node.anchor;
      const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor
      // name have already been resolved, so it may safely be renamed.

      if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as
      // anchors need to be available during resolution to allow for
      // circular references.

      anchors.map[name] = node;
    }

    let res;

    if (node.type === _constants.Type.ALIAS) {
      if (hasAnchor || hasTag) {
        const msg = 'An alias node must not specify any properties';
        errors.push(new _errors.YAMLSemanticError(node, msg));
      }

      const name = node.rawValue;
      const src = anchors.getNode(name);

      if (!src) {
        const msg = `Aliased anchor not found: ${name}`;
        errors.push(new _errors.YAMLReferenceError(node, msg));
        return null;
      } // Lazy resolution for circular references


      res = new _Alias.Alias(src);

      anchors._cstAliases.push(res);
    } else {
      const tagName = this.resolveTagName(node);

      if (tagName) {
        res = schema.resolveNodeWithFallback(this, node, tagName);
      } else {
        if (node.type !== _constants.Type.PLAIN) {
          const msg = `Failed to resolve ${node.type} node here`;
          errors.push(new _errors.YAMLSyntaxError(node, msg));
          return null;
        }

        try {
          res = schema.resolveScalar(node.strValue || '');
        } catch (error) {
          if (!error.source) error.source = node;
          errors.push(error);
          return null;
        }
      }
    }

    if (res) {
      res.range = [node.range.start, node.range.end];
      if (this.options.keepCstNodes) res.cstNode = node;
      if (this.options.keepNodeTypes) res.type = node.type;
      const cb = comments.before.join('\n');

      if (cb) {
        res.commentBefore = res.commentBefore ? `${res.commentBefore}\n${cb}` : cb;
      }

      const ca = comments.after.join('\n');
      if (ca) res.comment = res.comment ? `${res.comment}\n${ca}` : ca;
    }

    return node.resolved = res;
  }

  listNonDefaultTags() {
    return (0, _listTagNames.listTagNames)(this.contents).filter(t => t.indexOf(_schema.Schema.defaultPrefix) !== 0);
  }

  setTagPrefix(handle, prefix) {
    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');

    if (prefix) {
      const prev = this.tagPrefixes.find(p => p.handle === handle);
      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({
        handle,
        prefix
      });
    } else {
      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);
    }
  }

  stringifyTag(tag) {
    if ((this.version || this.options.version) === '1.0') {
      const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
      if (priv) return '!' + priv[1];
      const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
      return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;
    } else {
      let p = this.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);

      if (!p) {
        const dtp = this.getDefaults().tagPrefixes;
        p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);
      }

      if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;
      const suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, ch => ({
        '!': '%21',
        ',': '%2C',
        '[': '%5B',
        ']': '%5D',
        '{': '%7B',
        '}': '%7D'
      })[ch]);
      return p.handle + suffix;
    }
  }

  toJSON(arg, onAnchor) {
    const {
      keepBlobsInJSON,
      mapAsMap,
      maxAliasCount
    } = this.options;
    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof _Scalar.Scalar));
    const ctx = {
      doc: this,
      indentStep: '  ',
      keep,
      mapAsMap: keep && !!mapAsMap,
      maxAliasCount
    };
    const anchorNames = Object.keys(this.anchors.map);
    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {
      alias: [],
      aliasCount: 0,
      count: 1
    }]));
    const res = (0, _toJSON.toJSON)(this.contents, arg, ctx);
    if (typeof onAnchor === 'function' && ctx.anchors) for (const {
      count,
      res
    } of ctx.anchors.values()) onAnchor(res, count);
    return res;
  }

  toString() {
    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
    const indentSize = this.options.indent;

    if (!Number.isInteger(indentSize) || indentSize <= 0) {
      const s = JSON.stringify(indentSize);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }

    this.setSchema();
    const lines = [];
    let hasDirectives = false;

    if (this.version) {
      let vd = '%YAML 1.2';

      if (this.schema.name === 'yaml-1.1') {
        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';
      }

      lines.push(vd);
      hasDirectives = true;
    }

    const tagNames = this.listNonDefaultTags();
    this.tagPrefixes.forEach(({
      handle,
      prefix
    }) => {
      if (tagNames.some(t => t.indexOf(prefix) === 0)) {
        lines.push(`%TAG ${handle} ${prefix}`);
        hasDirectives = true;
      }
    });
    if (hasDirectives || this.directivesEndMarker) lines.push('---');

    if (this.commentBefore) {
      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');
      lines.unshift(this.commentBefore.replace(/^/gm, '#'));
    }

    const ctx = {
      anchors: {},
      doc: this,
      indent: '',
      indentStep: ' '.repeat(indentSize)
    };
    let chompKeep = false;
    let contentComment = null;

    if (this.contents) {
      if (this.contents instanceof _Node.Node) {
        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');
        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment

        ctx.forceBlockIndent = !!this.comment;
        contentComment = this.contents.comment;
      }

      const onChompKeep = contentComment ? null : () => chompKeep = true;
      const body = this.schema.stringify(this.contents, ctx, () => contentComment = null, onChompKeep);
      lines.push((0, _addComment.addComment)(body, '', contentComment));
    } else if (this.contents !== undefined) {
      lines.push(this.schema.stringify(this.contents, ctx));
    }

    if (this.comment) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
      lines.push(this.comment.replace(/^/gm, '#'));
    }

    return lines.join('\n') + '\n';
  }

}

exports.Document = Document;

_defineProperty(Document, "defaults", {
  '1.0': {
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [{
      handle: '!',
      prefix: _schema.Schema.defaultPrefix
    }, {
      handle: '!!',
      prefix: 'tag:private.yaml.org,2002:'
    }]
  },
  '1.1': {
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [{
      handle: '!',
      prefix: '!'
    }, {
      handle: '!!',
      prefix: _schema.Schema.defaultPrefix
    }]
  },
  '1.2': {
    schema: 'core',
    merge: false,
    tagPrefixes: [{
      handle: '!',
      prefix: '!'
    }, {
      handle: '!!',
      prefix: _schema.Schema.defaultPrefix
    }]
  }
});

/***/ }),

/***/ 5350:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.addCommentBefore = addCommentBefore;
exports.addComment = addComment;

function addCommentBefore(str, indent, comment) {
  if (!comment) return str;
  const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
  return `#${cc}\n${indent}${str}`;
}

function addComment(str, indent, comment) {
  return !comment ? str : comment.indexOf('\n') === -1 ? `${str} #${comment}` : `${str}\n` + comment.replace(/^/gm, `${indent || ''}#`);
}

/***/ }),

/***/ 87270:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.Type = exports.Char = void 0;
const Char = {
  ANCHOR: '&',
  COMMENT: '#',
  TAG: '!',
  DIRECTIVES_END: '-',
  DOCUMENT_END: '.'
};
exports.Char = Char;
const Type = {
  ALIAS: 'ALIAS',
  BLANK_LINE: 'BLANK_LINE',
  BLOCK_FOLDED: 'BLOCK_FOLDED',
  BLOCK_LITERAL: 'BLOCK_LITERAL',
  COMMENT: 'COMMENT',
  DIRECTIVE: 'DIRECTIVE',
  DOCUMENT: 'DOCUMENT',
  FLOW_MAP: 'FLOW_MAP',
  FLOW_SEQ: 'FLOW_SEQ',
  MAP: 'MAP',
  MAP_KEY: 'MAP_KEY',
  MAP_VALUE: 'MAP_VALUE',
  PLAIN: 'PLAIN',
  QUOTE_DOUBLE: 'QUOTE_DOUBLE',
  QUOTE_SINGLE: 'QUOTE_SINGLE',
  SEQ: 'SEQ',
  SEQ_ITEM: 'SEQ_ITEM'
};
exports.Type = Type;

/***/ }),

/***/ 19550:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Alias = void 0;

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

class Alias extends _Node.Node {
  /**
   * Parses an *alias from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */
  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;

    let offset = _Node.Node.endOfIdentifier(src, start + 1);

    this.valueRange = new _Range.Range(start + 1, offset);
    offset = _Node.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

exports.Alias = Alias;

/***/ }),

/***/ 68633:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.BlankLine = void 0;

var _constants = __webpack_require__(87270);

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

class BlankLine extends _Node.Node {
  constructor() {
    super(_constants.Type.BLANK_LINE);
  }
  /* istanbul ignore next */


  get includesTrailingLines() {
    // This is never called from anywhere, but if it were,
    // this is the value it should return.
    return true;
  }
  /**
   * Parses a blank line from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first \n character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    this.range = new _Range.Range(start, start + 1);
    return start + 1;
  }

}

exports.BlankLine = BlankLine;

/***/ }),

/***/ 31181:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.BlockValue = exports.Chomp = void 0;

var _constants = __webpack_require__(87270);

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

const Chomp = {
  CLIP: 'CLIP',
  KEEP: 'KEEP',
  STRIP: 'STRIP'
};
exports.Chomp = Chomp;

class BlockValue extends _Node.Node {
  constructor(type, props) {
    super(type, props);
    this.blockIndent = null;
    this.chomping = Chomp.CLIP;
    this.header = null;
  }

  get includesTrailingLines() {
    return this.chomping === Chomp.KEEP;
  }

  get strValue() {
    if (!this.valueRange || !this.context) return null;
    let {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (this.valueRange.isEmpty()) return '';
    let lastNewLine = null;
    let ch = src[end - 1];

    while (ch === '\n' || ch === '\t' || ch === ' ') {
      end -= 1;

      if (end <= start) {
        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens
      }

      if (ch === '\n') lastNewLine = end;
      ch = src[end - 1];
    }

    let keepStart = end + 1;

    if (lastNewLine) {
      if (this.chomping === Chomp.KEEP) {
        keepStart = lastNewLine;
        end = this.valueRange.end;
      } else {
        end = lastNewLine;
      }
    }

    const bi = indent + this.blockIndent;
    const folded = this.type === _constants.Type.BLOCK_FOLDED;
    let atStart = true;
    let str = '';
    let sep = '';
    let prevMoreIndented = false;

    for (let i = start; i < end; ++i) {
      for (let j = 0; j < bi; ++j) {
        if (src[i] !== ' ') break;
        i += 1;
      }

      const ch = src[i];

      if (ch === '\n') {
        if (sep === '\n') str += '\n';else sep = '\n';
      } else {
        const lineEnd = _Node.Node.endOfLine(src, i);

        const line = src.slice(i, lineEnd);
        i = lineEnd;

        if (folded && (ch === ' ' || ch === '\t') && i < keepStart) {
          if (sep === ' ') sep = '\n';else if (!prevMoreIndented && !atStart && sep === '\n') sep = '\n\n';
          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')

          sep = lineEnd < end && src[lineEnd] || '';
          prevMoreIndented = true;
        } else {
          str += sep + line;
          sep = folded && i < keepStart ? ' ' : '\n';
          prevMoreIndented = false;
        }

        if (atStart && line !== '') atStart = false;
      }
    }

    return this.chomping === Chomp.STRIP ? str : str + '\n';
  }

  parseBlockHeader(start) {
    const {
      src
    } = this.context;
    let offset = start + 1;
    let bi = '';

    while (true) {
      const ch = src[offset];

      switch (ch) {
        case '-':
          this.chomping = Chomp.STRIP;
          break;

        case '+':
          this.chomping = Chomp.KEEP;
          break;

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          bi += ch;
          break;

        default:
          this.blockIndent = Number(bi) || null;
          this.header = new _Range.Range(start, offset);
          return offset;
      }

      offset += 1;
    }
  }

  parseBlockValue(start) {
    const {
      indent,
      src
    } = this.context;
    let offset = start;
    let valueEnd = start;
    let bi = this.blockIndent ? indent + this.blockIndent - 1 : indent;
    let minBlockIndent = 1;

    for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
      offset += 1;
      if (_Node.Node.atDocumentBoundary(src, offset)) break;

      const end = _Node.Node.endOfBlockIndent(src, bi, offset); // should not include tab?


      if (end === null) break;

      if (!this.blockIndent) {
        // no explicit block indent, none yet detected
        const lineIndent = end - (offset + indent);

        if (src[end] !== '\n') {
          // first line with non-whitespace content
          if (lineIndent < minBlockIndent) {
            offset -= 1;
            break;
          }

          this.blockIndent = lineIndent;
          bi = indent + this.blockIndent - 1;
        } else if (lineIndent > minBlockIndent) {
          // empty line with more whitespace
          minBlockIndent = lineIndent;
        }
      }

      if (src[end] === '\n') {
        offset = end;
      } else {
        offset = valueEnd = _Node.Node.endOfLine(src, end);
      }
    }

    if (this.chomping !== Chomp.KEEP) {
      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
    }

    this.valueRange = new _Range.Range(start + 1, offset);
    return offset;
  }
  /**
   * Parses a block value from the source
   *
   * Accepted forms are:
   * ```
   * BS
   * block
   * lines
   *
   * BS #comment
   * block
   * lines
   * ```
   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
   * are empty or have an indent level greater than `indent`.
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this block
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = this.parseBlockHeader(start);
    offset = _Node.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    offset = this.parseBlockValue(offset);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    return this.header ? this.header.setOrigRange(cr, offset) : offset;
  }

}

exports.BlockValue = BlockValue;

/***/ }),

/***/ 42399:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.grabCollectionEndComments = grabCollectionEndComments;
exports.Collection = void 0;

var _constants = __webpack_require__(87270);

var _BlankLine = __webpack_require__(68633);

var _CollectionItem = __webpack_require__(80768);

var _Comment = __webpack_require__(34272);

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

function grabCollectionEndComments(node) {
  let cnode = node;

  while (cnode instanceof _CollectionItem.CollectionItem) cnode = cnode.node;

  if (!(cnode instanceof Collection)) return null;
  const len = cnode.items.length;
  let ci = -1;

  for (let i = len - 1; i >= 0; --i) {
    const n = cnode.items[i];

    if (n.type === _constants.Type.COMMENT) {
      // Keep sufficiently indented comments with preceding node
      const {
        indent,
        lineStart
      } = n.context;
      if (indent > 0 && n.range.start >= lineStart + indent) break;
      ci = i;
    } else if (n.type === _constants.Type.BLANK_LINE) ci = i;else break;
  }

  if (ci === -1) return null;
  const ca = cnode.items.splice(ci, len - ci);
  const prevEnd = ca[0].range.start;

  while (true) {
    cnode.range.end = prevEnd;
    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
    if (cnode === node) break;
    cnode = cnode.context.parent;
  }

  return ca;
}

class Collection extends _Node.Node {
  static nextContentHasIndent(src, offset, indent) {
    const lineStart = _Node.Node.endOfLine(src, offset) + 1;
    offset = _Node.Node.endOfWhiteSpace(src, lineStart);
    const ch = src[offset];
    if (!ch) return false;
    if (offset >= lineStart + indent) return true;
    if (ch !== '#' && ch !== '\n') return false;
    return Collection.nextContentHasIndent(src, offset, indent);
  }

  constructor(firstItem) {
    super(firstItem.type === _constants.Type.SEQ_ITEM ? _constants.Type.SEQ : _constants.Type.MAP);

    for (let i = firstItem.props.length - 1; i >= 0; --i) {
      if (firstItem.props[i].start < firstItem.context.lineStart) {
        // props on previous line are assumed by the collection
        this.props = firstItem.props.slice(0, i + 1);
        firstItem.props = firstItem.props.slice(i + 1);
        const itemRange = firstItem.props[0] || firstItem.valueRange;
        firstItem.range.start = itemRange.start;
        break;
      }
    }

    this.items = [firstItem];
    const ec = grabCollectionEndComments(firstItem);
    if (ec) Array.prototype.push.apply(this.items, ec);
  }

  get includesTrailingLines() {
    return this.items.length > 0;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context; // It's easier to recalculate lineStart here rather than tracking down the
    // last context from which to read it -- eemeli/yaml#2

    let lineStart = _Node.Node.startOfLine(src, start);

    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling
    // -- eemeli/yaml#17

    firstItem.context.parent = this;
    this.valueRange = _Range.Range.copy(firstItem.valueRange);
    const indent = firstItem.range.start - firstItem.context.lineStart;
    let offset = start;
    offset = _Node.Node.normalizeOffset(src, offset);
    let ch = src[offset];
    let atLineStart = _Node.Node.endOfWhiteSpace(src, lineStart) === offset;
    let prevIncludesTrailingLines = false;

    while (ch) {
      while (ch === '\n' || ch === '#') {
        if (atLineStart && ch === '\n' && !prevIncludesTrailingLines) {
          const blankLine = new _BlankLine.BlankLine();
          offset = blankLine.parse({
            src
          }, offset);
          this.valueRange.end = offset;

          if (offset >= src.length) {
            ch = null;
            break;
          }

          this.items.push(blankLine);
          offset -= 1; // blankLine.parse() consumes terminal newline
        } else if (ch === '#') {
          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {
            return offset;
          }

          const comment = new _Comment.Comment();
          offset = comment.parse({
            indent,
            lineStart,
            src
          }, offset);
          this.items.push(comment);
          this.valueRange.end = offset;

          if (offset >= src.length) {
            ch = null;
            break;
          }
        }

        lineStart = offset + 1;
        offset = _Node.Node.endOfIndent(src, lineStart);

        if (_Node.Node.atBlank(src, offset)) {
          const wsEnd = _Node.Node.endOfWhiteSpace(src, offset);

          const next = src[wsEnd];

          if (!next || next === '\n' || next === '#') {
            offset = wsEnd;
          }
        }

        ch = src[offset];
        atLineStart = true;
      }

      if (!ch) {
        break;
      }

      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {
        if (lineStart > start) offset = lineStart;
        break;
      }

      if (firstItem.type === _constants.Type.SEQ_ITEM !== (ch === '-')) {
        let typeswitch = true;

        if (ch === '-') {
          // map key may start with -, as long as it's followed by a non-whitespace char
          const next = src[offset + 1];
          typeswitch = !next || next === '\n' || next === '\t' || next === ' ';
        }

        if (typeswitch) {
          if (lineStart > start) offset = lineStart;
          break;
        }
      }

      const node = parseNode({
        atLineStart,
        inCollection: true,
        indent,
        lineStart,
        parent: this
      }, offset);
      if (!node) return offset; // at next document start

      this.items.push(node);
      this.valueRange.end = node.valueRange.end;
      offset = _Node.Node.normalizeOffset(src, node.range.end);
      ch = src[offset];
      atLineStart = false;
      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range
      // has advanced to check the current line's indentation level
      // -- eemeli/yaml#10 & eemeli/yaml#38

      if (ch) {
        let ls = offset - 1;
        let prev = src[ls];

        while (prev === ' ' || prev === '\t') prev = src[--ls];

        if (prev === '\n') {
          lineStart = ls + 1;
          atLineStart = true;
        }
      }

      const ec = grabCollectionEndComments(node);
      if (ec) Array.prototype.push.apply(this.items, ec);
    }

    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.items.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      items,
      range,
      value
    } = this;
    if (value != null) return value;
    let str = src.slice(range.start, items[0].range.start) + String(items[0]);

    for (let i = 1; i < items.length; ++i) {
      const item = items[i];
      const {
        atLineStart,
        indent
      } = item.context;
      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';
      str += String(item);
    }

    return _Node.Node.addStringTerminator(src, range.end, str);
  }

}

exports.Collection = Collection;

/***/ }),

/***/ 80768:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.CollectionItem = void 0;

var _constants = __webpack_require__(87270);

var _errors = __webpack_require__(61298);

var _BlankLine = __webpack_require__(68633);

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

class CollectionItem extends _Node.Node {
  constructor(type, props) {
    super(type, props);
    this.node = null;
  }

  get includesTrailingLines() {
    return !!this.node && this.node.includesTrailingLines;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context;
    let {
      atLineStart,
      lineStart
    } = context;
    if (!atLineStart && this.type === _constants.Type.SEQ_ITEM) this.error = new _errors.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
    const indent = atLineStart ? start - lineStart : context.indent;

    let offset = _Node.Node.endOfWhiteSpace(src, start + 1);

    let ch = src[offset];
    const inlineComment = ch === '#';
    const comments = [];
    let blankLine = null;

    while (ch === '\n' || ch === '#') {
      if (ch === '#') {
        const end = _Node.Node.endOfLine(src, offset + 1);

        comments.push(new _Range.Range(offset, end));
        offset = end;
      } else {
        atLineStart = true;
        lineStart = offset + 1;

        const wsEnd = _Node.Node.endOfWhiteSpace(src, lineStart);

        if (src[wsEnd] === '\n' && comments.length === 0) {
          blankLine = new _BlankLine.BlankLine();
          lineStart = blankLine.parse({
            src
          }, lineStart);
        }

        offset = _Node.Node.endOfIndent(src, lineStart);
      }

      ch = src[offset];
    }

    if (_Node.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== _constants.Type.SEQ_ITEM)) {
      this.node = parseNode({
        atLineStart,
        inCollection: false,
        indent,
        lineStart,
        parent: this
      }, offset);
    } else if (ch && lineStart > start + 1) {
      offset = lineStart - 1;
    }

    if (this.node) {
      if (blankLine) {
        // Only blank lines preceding non-empty nodes are captured. Note that
        // this means that collection item range start indices do not always
        // increase monotonically. -- eemeli/yaml#126
        const items = context.parent.items || context.parent.contents;
        if (items) items.push(blankLine);
      }

      if (comments.length) Array.prototype.push.apply(this.props, comments);
      offset = this.node.range.end;
    } else {
      if (inlineComment) {
        const c = comments[0];
        this.props.push(c);
        offset = c.end;
      } else {
        offset = _Node.Node.endOfLine(src, start + 1);
      }
    }

    const end = this.node ? this.node.valueRange.end : offset;
    this.valueRange = new _Range.Range(start, end);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    return this.node ? this.node.setOrigRanges(cr, offset) : offset;
  }

  toString() {
    const {
      context: {
        src
      },
      node,
      range,
      value
    } = this;
    if (value != null) return value;
    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
    return _Node.Node.addStringTerminator(src, range.end, str);
  }

}

exports.CollectionItem = CollectionItem;

/***/ }),

/***/ 34272:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Comment = void 0;

var _constants = __webpack_require__(87270);

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

class Comment extends _Node.Node {
  constructor() {
    super(_constants.Type.COMMENT);
  }
  /**
   * Parses a comment line from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const offset = this.parseComment(start);
    this.range = new _Range.Range(start, offset);
    return offset;
  }

}

exports.Comment = Comment;

/***/ }),

/***/ 23353:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Directive = void 0;

var _constants = __webpack_require__(87270);

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

class Directive extends _Node.Node {
  constructor() {
    super(_constants.Type.DIRECTIVE);
    this.name = null;
  }

  get parameters() {
    const raw = this.rawValue;
    return raw ? raw.trim().split(/[ \t]+/) : [];
  }

  parseName(start) {
    const {
      src
    } = this.context;
    let offset = start;
    let ch = src[offset];

    while (ch && ch !== '\n' && ch !== '\t' && ch !== ' ') ch = src[offset += 1];

    this.name = src.slice(start, offset);
    return offset;
  }

  parseParameters(start) {
    const {
      src
    } = this.context;
    let offset = start;
    let ch = src[offset];

    while (ch && ch !== '\n' && ch !== '#') ch = src[offset += 1];

    this.valueRange = new _Range.Range(start, offset);
    return offset;
  }

  parse(context, start) {
    this.context = context;
    let offset = this.parseName(start + 1);
    offset = this.parseParameters(offset);
    offset = this.parseComment(offset);
    this.range = new _Range.Range(start, offset);
    return offset;
  }

}

exports.Directive = Directive;

/***/ }),

/***/ 85805:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Document = void 0;

var _constants = __webpack_require__(87270);

var _errors = __webpack_require__(61298);

var _BlankLine = __webpack_require__(68633);

var _Collection = __webpack_require__(42399);

var _Comment = __webpack_require__(34272);

var _Directive = __webpack_require__(23353);

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

class Document extends _Node.Node {
  static startCommentOrEndBlankLine(src, start) {
    const offset = _Node.Node.endOfWhiteSpace(src, start);

    const ch = src[offset];
    return ch === '#' || ch === '\n' ? offset : start;
  }

  constructor() {
    super(_constants.Type.DOCUMENT);
    this.directives = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.documentEndMarker = null;
  }

  parseDirectives(start) {
    const {
      src
    } = this.context;
    this.directives = [];
    let atLineStart = true;
    let hasDirectives = false;
    let offset = start;

    while (!_Node.Node.atDocumentBoundary(src, offset, _constants.Char.DIRECTIVES_END)) {
      offset = Document.startCommentOrEndBlankLine(src, offset);

      switch (src[offset]) {
        case '\n':
          if (atLineStart) {
            const blankLine = new _BlankLine.BlankLine();
            offset = blankLine.parse({
              src
            }, offset);

            if (offset < src.length) {
              this.directives.push(blankLine);
            }
          } else {
            offset += 1;
            atLineStart = true;
          }

          break;

        case '#':
          {
            const comment = new _Comment.Comment();
            offset = comment.parse({
              src
            }, offset);
            this.directives.push(comment);
            atLineStart = false;
          }
          break;

        case '%':
          {
            const directive = new _Directive.Directive();
            offset = directive.parse({
              parent: this,
              src
            }, offset);
            this.directives.push(directive);
            hasDirectives = true;
            atLineStart = false;
          }
          break;

        default:
          if (hasDirectives) {
            this.error = new _errors.YAMLSemanticError(this, 'Missing directives-end indicator line');
          } else if (this.directives.length > 0) {
            this.contents = this.directives;
            this.directives = [];
          }

          return offset;
      }
    }

    if (src[offset]) {
      this.directivesEndMarker = new _Range.Range(offset, offset + 3);
      return offset + 3;
    }

    if (hasDirectives) {
      this.error = new _errors.YAMLSemanticError(this, 'Missing directives-end indicator line');
    } else if (this.directives.length > 0) {
      this.contents = this.directives;
      this.directives = [];
    }

    return offset;
  }

  parseContents(start) {
    const {
      parseNode,
      src
    } = this.context;
    if (!this.contents) this.contents = [];
    let lineStart = start;

    while (src[lineStart - 1] === '-') lineStart -= 1;

    let offset = _Node.Node.endOfWhiteSpace(src, start);

    let atLineStart = lineStart === start;
    this.valueRange = new _Range.Range(offset);

    while (!_Node.Node.atDocumentBoundary(src, offset, _constants.Char.DOCUMENT_END)) {
      switch (src[offset]) {
        case '\n':
          if (atLineStart) {
            const blankLine = new _BlankLine.BlankLine();
            offset = blankLine.parse({
              src
            }, offset);

            if (offset < src.length) {
              this.contents.push(blankLine);
            }
          } else {
            offset += 1;
            atLineStart = true;
          }

          lineStart = offset;
          break;

        case '#':
          {
            const comment = new _Comment.Comment();
            offset = comment.parse({
              src
            }, offset);
            this.contents.push(comment);
            atLineStart = false;
          }
          break;

        default:
          {
            const iEnd = _Node.Node.endOfIndent(src, offset);

            const context = {
              atLineStart,
              indent: -1,
              inFlow: false,
              inCollection: false,
              lineStart,
              parent: this
            };
            const node = parseNode(context, iEnd);
            if (!node) return this.valueRange.end = iEnd; // at next document start

            this.contents.push(node);
            offset = node.range.end;
            atLineStart = false;
            const ec = (0, _Collection.grabCollectionEndComments)(node);
            if (ec) Array.prototype.push.apply(this.contents, ec);
          }
      }

      offset = Document.startCommentOrEndBlankLine(src, offset);
    }

    this.valueRange.end = offset;

    if (src[offset]) {
      this.documentEndMarker = new _Range.Range(offset, offset + 3);
      offset += 3;

      if (src[offset]) {
        offset = _Node.Node.endOfWhiteSpace(src, offset);

        if (src[offset] === '#') {
          const comment = new _Comment.Comment();
          offset = comment.parse({
            src
          }, offset);
          this.contents.push(comment);
        }

        switch (src[offset]) {
          case '\n':
            offset += 1;
            break;

          case undefined:
            break;

          default:
            this.error = new _errors.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');
        }
      }
    }

    return offset;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    context.root = this;
    this.context = context;
    const {
      src
    } = context;
    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM

    offset = this.parseDirectives(offset);
    offset = this.parseContents(offset);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.directives.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
    this.contents.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
    return offset;
  }

  toString() {
    const {
      contents,
      directives,
      value
    } = this;
    if (value != null) return value;
    let str = directives.join('');

    if (contents.length > 0) {
      if (directives.length > 0 || contents[0].type === _constants.Type.COMMENT) str += '---\n';
      str += contents.join('');
    }

    if (str[str.length - 1] !== '\n') str += '\n';
    return str;
  }

}

exports.Document = Document;

/***/ }),

/***/ 24370:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.FlowCollection = void 0;

var _constants = __webpack_require__(87270);

var _errors = __webpack_require__(61298);

var _BlankLine = __webpack_require__(68633);

var _Comment = __webpack_require__(34272);

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

class FlowCollection extends _Node.Node {
  constructor(type, props) {
    super(type, props);
    this.items = null;
  }

  prevNodeIsJsonLike(idx = this.items.length) {
    const node = this.items[idx - 1];
    return !!node && (node.jsonLike || node.type === _constants.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context;
    let {
      indent,
      lineStart
    } = context;
    let char = src[start]; // { or [

    this.items = [{
      char,
      offset: start
    }];

    let offset = _Node.Node.endOfWhiteSpace(src, start + 1);

    char = src[offset];

    while (char && char !== ']' && char !== '}') {
      switch (char) {
        case '\n':
          {
            lineStart = offset + 1;

            const wsEnd = _Node.Node.endOfWhiteSpace(src, lineStart);

            if (src[wsEnd] === '\n') {
              const blankLine = new _BlankLine.BlankLine();
              lineStart = blankLine.parse({
                src
              }, lineStart);
              this.items.push(blankLine);
            }

            offset = _Node.Node.endOfIndent(src, lineStart);

            if (offset <= lineStart + indent) {
              char = src[offset];

              if (offset < lineStart + indent || char !== ']' && char !== '}') {
                const msg = 'Insufficient indentation in flow collection';
                this.error = new _errors.YAMLSemanticError(this, msg);
              }
            }
          }
          break;

        case ',':
          {
            this.items.push({
              char,
              offset
            });
            offset += 1;
          }
          break;

        case '#':
          {
            const comment = new _Comment.Comment();
            offset = comment.parse({
              src
            }, offset);
            this.items.push(comment);
          }
          break;

        case '?':
        case ':':
          {
            const next = src[offset + 1];

            if (next === '\n' || next === '\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace
            char === ':' && this.prevNodeIsJsonLike()) {
              this.items.push({
                char,
                offset
              });
              offset += 1;
              break;
            }
          }
        // fallthrough

        default:
          {
            const node = parseNode({
              atLineStart: false,
              inCollection: false,
              inFlow: true,
              indent: -1,
              lineStart,
              parent: this
            }, offset);

            if (!node) {
              // at next document start
              this.valueRange = new _Range.Range(start, offset);
              return offset;
            }

            this.items.push(node);
            offset = _Node.Node.normalizeOffset(src, node.range.end);
          }
      }

      offset = _Node.Node.endOfWhiteSpace(src, offset);
      char = src[offset];
    }

    this.valueRange = new _Range.Range(start, offset + 1);

    if (char) {
      this.items.push({
        char,
        offset
      });
      offset = _Node.Node.endOfWhiteSpace(src, offset + 1);
      offset = this.parseComment(offset);
    }

    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.items.forEach(node => {
      if (node instanceof _Node.Node) {
        offset = node.setOrigRanges(cr, offset);
      } else if (cr.length === 0) {
        node.origOffset = node.offset;
      } else {
        let i = offset;

        while (i < cr.length) {
          if (cr[i] > node.offset) break;else ++i;
        }

        node.origOffset = node.offset + i;
        offset = i;
      }
    });
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      items,
      range,
      value
    } = this;
    if (value != null) return value;
    const nodes = items.filter(item => item instanceof _Node.Node);
    let str = '';
    let prevEnd = range.start;
    nodes.forEach(node => {
      const prefix = src.slice(prevEnd, node.range.start);
      prevEnd = node.range.end;
      str += prefix + String(node);

      if (str[str.length - 1] === '\n' && src[prevEnd - 1] !== '\n' && src[prevEnd] === '\n') {
        // Comment range does not include the terminal newline, but its
        // stringified value does. Without this fix, newlines at comment ends
        // get duplicated.
        prevEnd += 1;
      }
    });
    str += src.slice(prevEnd, range.end);
    return _Node.Node.addStringTerminator(src, range.end, str);
  }

}

exports.FlowCollection = FlowCollection;

/***/ }),

/***/ 80317:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Node = void 0;

var _constants = __webpack_require__(87270);

var _sourceUtils = __webpack_require__(14022);

var _Range = __webpack_require__(23387);

/** Root class of all nodes */
class Node {
  static addStringTerminator(src, offset, str) {
    if (str[str.length - 1] === '\n') return str;
    const next = Node.endOfWhiteSpace(src, offset);
    return next >= src.length || src[next] === '\n' ? str + '\n' : str;
  } // ^(---|...)


  static atDocumentBoundary(src, offset, sep) {
    const ch0 = src[offset];
    if (!ch0) return true;
    const prev = src[offset - 1];
    if (prev && prev !== '\n') return false;

    if (sep) {
      if (ch0 !== sep) return false;
    } else {
      if (ch0 !== _constants.Char.DIRECTIVES_END && ch0 !== _constants.Char.DOCUMENT_END) return false;
    }

    const ch1 = src[offset + 1];
    const ch2 = src[offset + 2];
    if (ch1 !== ch0 || ch2 !== ch0) return false;
    const ch3 = src[offset + 3];
    return !ch3 || ch3 === '\n' || ch3 === '\t' || ch3 === ' ';
  }

  static endOfIdentifier(src, offset) {
    let ch = src[offset];
    const isVerbatim = ch === '<';
    const notOk = isVerbatim ? ['\n', '\t', ' ', '>'] : ['\n', '\t', ' ', '[', ']', '{', '}', ','];

    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];

    if (isVerbatim && ch === '>') offset += 1;
    return offset;
  }

  static endOfIndent(src, offset) {
    let ch = src[offset];

    while (ch === ' ') ch = src[offset += 1];

    return offset;
  }

  static endOfLine(src, offset) {
    let ch = src[offset];

    while (ch && ch !== '\n') ch = src[offset += 1];

    return offset;
  }

  static endOfWhiteSpace(src, offset) {
    let ch = src[offset];

    while (ch === '\t' || ch === ' ') ch = src[offset += 1];

    return offset;
  }

  static startOfLine(src, offset) {
    let ch = src[offset - 1];
    if (ch === '\n') return offset;

    while (ch && ch !== '\n') ch = src[offset -= 1];

    return offset + 1;
  }
  /**
   * End of indentation, or null if the line's indent level is not more
   * than `indent`
   *
   * @param {string} src
   * @param {number} indent
   * @param {number} lineStart
   * @returns {?number}
   */


  static endOfBlockIndent(src, indent, lineStart) {
    const inEnd = Node.endOfIndent(src, lineStart);

    if (inEnd > lineStart + indent) {
      return inEnd;
    } else {
      const wsEnd = Node.endOfWhiteSpace(src, inEnd);
      const ch = src[wsEnd];
      if (!ch || ch === '\n') return wsEnd;
    }

    return null;
  }

  static atBlank(src, offset, endAsBlank) {
    const ch = src[offset];
    return ch === '\n' || ch === '\t' || ch === ' ' || endAsBlank && !ch;
  }

  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
    if (!ch || indentDiff < 0) return false;
    if (indentDiff > 0) return true;
    return indicatorAsIndent && ch === '-';
  } // should be at line or string end, or at next non-whitespace char


  static normalizeOffset(src, offset) {
    const ch = src[offset];
    return !ch ? offset : ch !== '\n' && src[offset - 1] === '\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);
  } // fold single newline into space, multiple newlines to N - 1 newlines
  // presumes src[offset] === '\n'


  static foldNewline(src, offset, indent) {
    let inCount = 0;
    let error = false;
    let fold = '';
    let ch = src[offset + 1];

    while (ch === ' ' || ch === '\t' || ch === '\n') {
      switch (ch) {
        case '\n':
          inCount = 0;
          offset += 1;
          fold += '\n';
          break;

        case '\t':
          if (inCount <= indent) error = true;
          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;
          break;

        case ' ':
          inCount += 1;
          offset += 1;
          break;
      }

      ch = src[offset + 1];
    }

    if (!fold) fold = ' ';
    if (ch && inCount <= indent) error = true;
    return {
      fold,
      offset,
      error
    };
  }

  constructor(type, props, context) {
    Object.defineProperty(this, 'context', {
      value: context || null,
      writable: true
    });
    this.error = null;
    this.range = null;
    this.valueRange = null;
    this.props = props || [];
    this.type = type;
    this.value = null;
  }

  getPropValue(idx, key, skipKey) {
    if (!this.context) return null;
    const {
      src
    } = this.context;
    const prop = this.props[idx];
    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
  }

  get anchor() {
    for (let i = 0; i < this.props.length; ++i) {
      const anchor = this.getPropValue(i, _constants.Char.ANCHOR, true);
      if (anchor != null) return anchor;
    }

    return null;
  }

  get comment() {
    const comments = [];

    for (let i = 0; i < this.props.length; ++i) {
      const comment = this.getPropValue(i, _constants.Char.COMMENT, true);
      if (comment != null) comments.push(comment);
    }

    return comments.length > 0 ? comments.join('\n') : null;
  }

  commentHasRequiredWhitespace(start) {
    const {
      src
    } = this.context;
    if (this.header && start === this.header.end) return false;
    if (!this.valueRange) return false;
    const {
      end
    } = this.valueRange;
    return start !== end || Node.atBlank(src, end - 1);
  }

  get hasComment() {
    if (this.context) {
      const {
        src
      } = this.context;

      for (let i = 0; i < this.props.length; ++i) {
        if (src[this.props[i].start] === _constants.Char.COMMENT) return true;
      }
    }

    return false;
  }

  get hasProps() {
    if (this.context) {
      const {
        src
      } = this.context;

      for (let i = 0; i < this.props.length; ++i) {
        if (src[this.props[i].start] !== _constants.Char.COMMENT) return true;
      }
    }

    return false;
  }

  get includesTrailingLines() {
    return false;
  }

  get jsonLike() {
    const jsonLikeTypes = [_constants.Type.FLOW_MAP, _constants.Type.FLOW_SEQ, _constants.Type.QUOTE_DOUBLE, _constants.Type.QUOTE_SINGLE];
    return jsonLikeTypes.indexOf(this.type) !== -1;
  }

  get rangeAsLinePos() {
    if (!this.range || !this.context) return undefined;
    const start = (0, _sourceUtils.getLinePos)(this.range.start, this.context.root);
    if (!start) return undefined;
    const end = (0, _sourceUtils.getLinePos)(this.range.end, this.context.root);
    return {
      start,
      end
    };
  }

  get rawValue() {
    if (!this.valueRange || !this.context) return null;
    const {
      start,
      end
    } = this.valueRange;
    return this.context.src.slice(start, end);
  }

  get tag() {
    for (let i = 0; i < this.props.length; ++i) {
      const tag = this.getPropValue(i, _constants.Char.TAG, false);

      if (tag != null) {
        if (tag[1] === '<') {
          return {
            verbatim: tag.slice(2, -1)
          };
        } else {
          // eslint-disable-next-line no-unused-vars
          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
          return {
            handle,
            suffix
          };
        }
      }
    }

    return null;
  }

  get valueRangeContainsNewline() {
    if (!this.valueRange || !this.context) return false;
    const {
      start,
      end
    } = this.valueRange;
    const {
      src
    } = this.context;

    for (let i = start; i < end; ++i) {
      if (src[i] === '\n') return true;
    }

    return false;
  }

  parseComment(start) {
    const {
      src
    } = this.context;

    if (src[start] === _constants.Char.COMMENT) {
      const end = Node.endOfLine(src, start + 1);
      const commentRange = new _Range.Range(start, end);
      this.props.push(commentRange);
      return end;
    }

    return start;
  }
  /**
   * Populates the `origStart` and `origEnd` values of all ranges for this
   * node. Extended by child classes to handle descendant nodes.
   *
   * @param {number[]} cr - Positions of dropped CR characters
   * @param {number} offset - Starting index of `cr` from the last call
   * @returns {number} - The next offset, matching the one found for `origStart`
   */


  setOrigRanges(cr, offset) {
    if (this.range) offset = this.range.setOrigRange(cr, offset);
    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
    this.props.forEach(prop => prop.setOrigRange(cr, offset));
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      range,
      value
    } = this;
    if (value != null) return value;
    const str = src.slice(range.start, range.end);
    return Node.addStringTerminator(src, range.end, str);
  }

}

exports.Node = Node;

/***/ }),

/***/ 36242:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.ParseContext = void 0;

var _constants = __webpack_require__(87270);

var _errors = __webpack_require__(61298);

var _Alias = __webpack_require__(19550);

var _BlockValue = __webpack_require__(31181);

var _Collection = __webpack_require__(42399);

var _CollectionItem = __webpack_require__(80768);

var _FlowCollection = __webpack_require__(24370);

var _Node = __webpack_require__(80317);

var _PlainValue = __webpack_require__(48314);

var _QuoteDouble = __webpack_require__(59745);

var _QuoteSingle = __webpack_require__(83284);

var _Range = __webpack_require__(23387);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createNewNode(type, props) {
  switch (type) {
    case _constants.Type.ALIAS:
      return new _Alias.Alias(type, props);

    case _constants.Type.BLOCK_FOLDED:
    case _constants.Type.BLOCK_LITERAL:
      return new _BlockValue.BlockValue(type, props);

    case _constants.Type.FLOW_MAP:
    case _constants.Type.FLOW_SEQ:
      return new _FlowCollection.FlowCollection(type, props);

    case _constants.Type.MAP_KEY:
    case _constants.Type.MAP_VALUE:
    case _constants.Type.SEQ_ITEM:
      return new _CollectionItem.CollectionItem(type, props);

    case _constants.Type.COMMENT:
    case _constants.Type.PLAIN:
      return new _PlainValue.PlainValue(type, props);

    case _constants.Type.QUOTE_DOUBLE:
      return new _QuoteDouble.QuoteDouble(type, props);

    case _constants.Type.QUOTE_SINGLE:
      return new _QuoteSingle.QuoteSingle(type, props);

    /* istanbul ignore next */

    default:
      return null;
    // should never happen
  }
}
/**
 * @param {boolean} atLineStart - Node starts at beginning of line
 * @param {boolean} inFlow - true if currently in a flow context
 * @param {boolean} inCollection - true if currently in a collection context
 * @param {number} indent - Current level of indentation
 * @param {number} lineStart - Start of the current line
 * @param {Node} parent - The parent of the node
 * @param {string} src - Source of the YAML document
 */


class ParseContext {
  static parseType(src, offset, inFlow) {
    switch (src[offset]) {
      case '*':
        return _constants.Type.ALIAS;

      case '>':
        return _constants.Type.BLOCK_FOLDED;

      case '|':
        return _constants.Type.BLOCK_LITERAL;

      case '{':
        return _constants.Type.FLOW_MAP;

      case '[':
        return _constants.Type.FLOW_SEQ;

      case '?':
        return !inFlow && _Node.Node.atBlank(src, offset + 1, true) ? _constants.Type.MAP_KEY : _constants.Type.PLAIN;

      case ':':
        return !inFlow && _Node.Node.atBlank(src, offset + 1, true) ? _constants.Type.MAP_VALUE : _constants.Type.PLAIN;

      case '-':
        return !inFlow && _Node.Node.atBlank(src, offset + 1, true) ? _constants.Type.SEQ_ITEM : _constants.Type.PLAIN;

      case '"':
        return _constants.Type.QUOTE_DOUBLE;

      case "'":
        return _constants.Type.QUOTE_SINGLE;

      default:
        return _constants.Type.PLAIN;
    }
  }

  constructor(orig = {}, {
    atLineStart,
    inCollection,
    inFlow,
    indent,
    lineStart,
    parent
  } = {}) {
    _defineProperty(this, "parseNode", (overlay, start) => {
      if (_Node.Node.atDocumentBoundary(this.src, start)) return null;
      const context = new ParseContext(this, overlay);
      const {
        props,
        type,
        valueStart
      } = context.parseProps(start);
      const node = createNewNode(type, props);
      let offset = node.parse(context, valueStart);
      node.range = new _Range.Range(start, offset);
      /* istanbul ignore if */

      if (offset <= start) {
        // This should never happen, but if it does, let's make sure to at least
        // step one character forward to avoid a busy loop.
        node.error = new Error(`Node#parse consumed no characters`);
        node.error.parseEnd = offset;
        node.error.source = node;
        node.range.end = start + 1;
      }

      if (context.nodeStartsCollection(node)) {
        if (!node.error && !context.atLineStart && context.parent.type === _constants.Type.DOCUMENT) {
          node.error = new _errors.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');
        }

        const collection = new _Collection.Collection(node);
        offset = collection.parse(new ParseContext(context), offset);
        collection.range = new _Range.Range(start, offset);
        return collection;
      }

      return node;
    });

    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
    this.indent = indent != null ? indent : orig.indent;
    this.lineStart = lineStart != null ? lineStart : orig.lineStart;
    this.parent = parent != null ? parent : orig.parent || {};
    this.root = orig.root;
    this.src = orig.src;
  }

  nodeStartsCollection(node) {
    const {
      inCollection,
      inFlow,
      src
    } = this;
    if (inCollection || inFlow) return false;
    if (node instanceof _CollectionItem.CollectionItem) return true; // check for implicit key

    let offset = node.range.end;
    if (src[offset] === '\n' || src[offset - 1] === '\n') return false;
    offset = _Node.Node.endOfWhiteSpace(src, offset);
    return src[offset] === ':';
  } // Anchor and tag are before type, which determines the node implementation
  // class; hence this intermediate step.


  parseProps(offset) {
    const {
      inFlow,
      parent,
      src
    } = this;
    const props = [];
    let lineHasProps = false;
    offset = _Node.Node.endOfWhiteSpace(src, offset);
    let ch = src[offset];

    while (ch === _constants.Char.ANCHOR || ch === _constants.Char.COMMENT || ch === _constants.Char.TAG || ch === '\n') {
      if (ch === '\n') {
        const lineStart = offset + 1;

        const inEnd = _Node.Node.endOfIndent(src, lineStart);

        const indentDiff = inEnd - (lineStart + this.indent);
        const noIndicatorAsIndent = parent.type === _constants.Type.SEQ_ITEM && parent.context.atLineStart;
        if (!_Node.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
        this.atLineStart = true;
        this.lineStart = lineStart;
        lineHasProps = false;
        offset = inEnd;
      } else if (ch === _constants.Char.COMMENT) {
        const end = _Node.Node.endOfLine(src, offset + 1);

        props.push(new _Range.Range(offset, end));
        offset = end;
      } else {
        let end = _Node.Node.endOfIdentifier(src, offset + 1);

        if (ch === _constants.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, end + 13))) {
          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather
          // than an empty but 'foo.bar' private-tagged node in a flow collection
          // followed without whitespace by a plain string starting with a year
          // or date divided by something.
          end = _Node.Node.endOfIdentifier(src, end + 5);
        }

        props.push(new _Range.Range(offset, end));
        lineHasProps = true;
        offset = _Node.Node.endOfWhiteSpace(src, end);
      }

      ch = src[offset];
    } // '- &a : b' has an anchor on an empty node


    if (lineHasProps && ch === ':' && _Node.Node.atBlank(src, offset + 1, true)) offset -= 1;
    const type = ParseContext.parseType(src, offset, inFlow);
    return {
      props,
      type,
      valueStart: offset
    };
  }
  /**
   * Parses a node from the source
   * @param {ParseContext} overlay
   * @param {number} start - Index of first non-whitespace character for the node
   * @returns {?Node} - null if at a document boundary
   */


}

exports.ParseContext = ParseContext;

/***/ }),

/***/ 48314:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.PlainValue = void 0;

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

class PlainValue extends _Node.Node {
  static endOfLine(src, start, inFlow) {
    let ch = src[start];
    let offset = start;

    while (ch && ch !== '\n') {
      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;
      const next = src[offset + 1];
      if (ch === ':' && (!next || next === '\n' || next === '\t' || next === ' ' || inFlow && next === ',')) break;
      if ((ch === ' ' || ch === '\t') && next === '#') break;
      offset += 1;
      ch = next;
    }

    return offset;
  }

  get strValue() {
    if (!this.valueRange || !this.context) return null;
    let {
      start,
      end
    } = this.valueRange;
    const {
      src
    } = this.context;
    let ch = src[end - 1];

    while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) ch = src[--end - 1];

    ch = src[start];

    while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) ch = src[++start];

    let str = '';

    for (let i = start; i < end; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        const {
          fold,
          offset
        } = _Node.Node.foldNewline(src, i, -1);

        str += fold;
        i = offset;
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (i < end && (next === ' ' || next === '\t')) {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    return str;
  }

  parseBlockValue(start) {
    const {
      indent,
      inFlow,
      src
    } = this.context;
    let offset = start;
    let valueEnd = start;

    for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
      if (_Node.Node.atDocumentBoundary(src, offset + 1)) break;

      const end = _Node.Node.endOfBlockIndent(src, indent, offset + 1);

      if (end === null || src[end] === '#') break;

      if (src[end] === '\n') {
        offset = end;
      } else {
        valueEnd = PlainValue.endOfLine(src, end, inFlow);
        offset = valueEnd;
      }
    }

    if (this.valueRange.isEmpty()) this.valueRange.start = start;
    this.valueRange.end = valueEnd;
    return valueEnd;
  }
  /**
   * Parses a plain value from the source
   *
   * Accepted forms are:
   * ```
   * #comment
   *
   * first line
   *
   * first line #comment
   *
   * first line
   * block
   * lines
   *
   * #comment
   * block
   * lines
   * ```
   * where block lines are empty or have an indent level greater than `indent`.
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar, may be `\n`
   */


  parse(context, start) {
    this.context = context;
    const {
      inFlow,
      src
    } = context;
    let offset = start;
    const ch = src[offset];

    if (ch && ch !== '#' && ch !== '\n') {
      offset = PlainValue.endOfLine(src, start, inFlow);
    }

    this.valueRange = new _Range.Range(start, offset);
    offset = _Node.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);

    if (!this.hasComment || this.valueRange.isEmpty()) {
      offset = this.parseBlockValue(offset);
    }

    return offset;
  }

}

exports.PlainValue = PlainValue;

/***/ }),

/***/ 59745:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.QuoteDouble = void 0;

var _errors = __webpack_require__(61298);

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

class QuoteDouble extends _Node.Node {
  static endOfQuote(src, offset) {
    let ch = src[offset];

    while (ch && ch !== '"') {
      offset += ch === '\\' ? 2 : 1;
      ch = src[offset];
    }

    return offset + 1;
  }
  /**
   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
   */


  get strValue() {
    if (!this.valueRange || !this.context) return null;
    const errors = [];
    const {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (src[end - 1] !== '"') errors.push(new _errors.YAMLSyntaxError(this, 'Missing closing "quote')); // Using String#replace is too painful with escaped newlines preceded by
    // escaped backslashes; also, this should be faster.

    let str = '';

    for (let i = start + 1; i < end - 1; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        if (_Node.Node.atDocumentBoundary(src, i + 1)) errors.push(new _errors.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));

        const {
          fold,
          offset,
          error
        } = _Node.Node.foldNewline(src, i, indent);

        str += fold;
        i = offset;
        if (error) errors.push(new _errors.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));
      } else if (ch === '\\') {
        i += 1;

        switch (src[i]) {
          case '0':
            str += '\0';
            break;
          // null character

          case 'a':
            str += '\x07';
            break;
          // bell character

          case 'b':
            str += '\b';
            break;
          // backspace

          case 'e':
            str += '\x1b';
            break;
          // escape character

          case 'f':
            str += '\f';
            break;
          // form feed

          case 'n':
            str += '\n';
            break;
          // line feed

          case 'r':
            str += '\r';
            break;
          // carriage return

          case 't':
            str += '\t';
            break;
          // horizontal tab

          case 'v':
            str += '\v';
            break;
          // vertical tab

          case 'N':
            str += '\u0085';
            break;
          // Unicode next line

          case '_':
            str += '\u00a0';
            break;
          // Unicode non-breaking space

          case 'L':
            str += '\u2028';
            break;
          // Unicode line separator

          case 'P':
            str += '\u2029';
            break;
          // Unicode paragraph separator

          case ' ':
            str += ' ';
            break;

          case '"':
            str += '"';
            break;

          case '/':
            str += '/';
            break;

          case '\\':
            str += '\\';
            break;

          case '\t':
            str += '\t';
            break;

          case 'x':
            str += this.parseCharCode(i + 1, 2, errors);
            i += 2;
            break;

          case 'u':
            str += this.parseCharCode(i + 1, 4, errors);
            i += 4;
            break;

          case 'U':
            str += this.parseCharCode(i + 1, 8, errors);
            i += 8;
            break;

          case '\n':
            // skip escaped newlines, but still trim the following line
            while (src[i + 1] === ' ' || src[i + 1] === '\t') i += 1;

            break;

          default:
            errors.push(new _errors.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));
            str += '\\' + src[i];
        }
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (next === ' ' || next === '\t') {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    return errors.length > 0 ? {
      errors,
      str
    } : str;
  }

  parseCharCode(offset, length, errors) {
    const {
      src
    } = this.context;
    const cc = src.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;

    if (isNaN(code)) {
      errors.push(new _errors.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));
      return src.substr(offset - 2, length + 2);
    }

    return String.fromCodePoint(code);
  }
  /**
   * Parses a "double quoted" value from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = QuoteDouble.endOfQuote(src, start + 1);
    this.valueRange = new _Range.Range(start, offset);
    offset = _Node.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

exports.QuoteDouble = QuoteDouble;

/***/ }),

/***/ 83284:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.QuoteSingle = void 0;

var _errors = __webpack_require__(61298);

var _Node = __webpack_require__(80317);

var _Range = __webpack_require__(23387);

class QuoteSingle extends _Node.Node {
  static endOfQuote(src, offset) {
    let ch = src[offset];

    while (ch) {
      if (ch === "'") {
        if (src[offset + 1] !== "'") break;
        ch = src[offset += 2];
      } else {
        ch = src[offset += 1];
      }
    }

    return offset + 1;
  }
  /**
   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
   */


  get strValue() {
    if (!this.valueRange || !this.context) return null;
    const errors = [];
    const {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (src[end - 1] !== "'") errors.push(new _errors.YAMLSyntaxError(this, "Missing closing 'quote"));
    let str = '';

    for (let i = start + 1; i < end - 1; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        if (_Node.Node.atDocumentBoundary(src, i + 1)) errors.push(new _errors.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));

        const {
          fold,
          offset,
          error
        } = _Node.Node.foldNewline(src, i, indent);

        str += fold;
        i = offset;
        if (error) errors.push(new _errors.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));
      } else if (ch === "'") {
        str += ch;
        i += 1;
        if (src[i] !== "'") errors.push(new _errors.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (next === ' ' || next === '\t') {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    return errors.length > 0 ? {
      errors,
      str
    } : str;
  }
  /**
   * Parses a 'single quoted' value from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = QuoteSingle.endOfQuote(src, start + 1);
    this.valueRange = new _Range.Range(start, offset);
    offset = _Node.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

exports.QuoteSingle = QuoteSingle;

/***/ }),

/***/ 23387:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.Range = void 0;

class Range {
  static copy(orig) {
    return new Range(orig.start, orig.end);
  }

  constructor(start, end) {
    this.start = start;
    this.end = end || start;
  }

  isEmpty() {
    return typeof this.start !== 'number' || !this.end || this.end <= this.start;
  }
  /**
   * Set `origStart` and `origEnd` to point to the original source range for
   * this node, which may differ due to dropped CR characters.
   *
   * @param {number[]} cr - Positions of dropped CR characters
   * @param {number} offset - Starting index of `cr` from the last call
   * @returns {number} - The next offset, matching the one found for `origStart`
   */


  setOrigRange(cr, offset) {
    const {
      start,
      end
    } = this;

    if (cr.length === 0 || end <= cr[0]) {
      this.origStart = start;
      this.origEnd = end;
      return offset;
    }

    let i = offset;

    while (i < cr.length) {
      if (cr[i] > start) break;else ++i;
    }

    this.origStart = start + i;
    const nextOffset = i;

    while (i < cr.length) {
      // if end was at \n, it should now be at \r
      if (cr[i] >= end) break;else ++i;
    }

    this.origEnd = end + i;
    return nextOffset;
  }

}

exports.Range = Range;

/***/ }),

/***/ 74947:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.parse = parse;

var _Document = __webpack_require__(85805);

var _ParseContext = __webpack_require__(36242);

// Published as 'yaml/parse-cst'
function parse(src) {
  const cr = [];

  if (src.indexOf('\r') !== -1) {
    src = src.replace(/\r\n?/g, (match, offset) => {
      if (match.length > 1) cr.push(offset);
      return '\n';
    });
  }

  const documents = [];
  let offset = 0;

  do {
    const doc = new _Document.Document();
    const context = new _ParseContext.ParseContext({
      src
    });
    offset = doc.parse(context, offset);
    documents.push(doc);
  } while (offset < src.length);

  documents.setOrigRanges = () => {
    if (cr.length === 0) return false;

    for (let i = 1; i < cr.length; ++i) cr[i] -= i;

    let crOffset = 0;

    for (let i = 0; i < documents.length; ++i) {
      crOffset = documents[i].setOrigRanges(cr, crOffset);
    }

    cr.splice(0, cr.length);
    return true;
  };

  documents.toString = () => documents.join('...\n');

  return documents;
}

/***/ }),

/***/ 14022:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.getLinePos = getLinePos;
exports.getLine = getLine;
exports.getPrettyContext = getPrettyContext;

function findLineStarts(src) {
  const ls = [0];
  let offset = src.indexOf('\n');

  while (offset !== -1) {
    offset += 1;
    ls.push(offset);
    offset = src.indexOf('\n', offset);
  }

  return ls;
}

function getSrcInfo(cst) {
  let lineStarts, src;

  if (typeof cst === 'string') {
    lineStarts = findLineStarts(cst);
    src = cst;
  } else {
    if (Array.isArray(cst)) cst = cst[0];

    if (cst && cst.context) {
      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
      lineStarts = cst.lineStarts;
      src = cst.context.src;
    }
  }

  return {
    lineStarts,
    src
  };
}
/**
 * @typedef {Object} LinePos - One-indexed position in the source
 * @property {number} line
 * @property {number} col
 */

/**
 * Determine the line/col position matching a character offset.
 *
 * Accepts a source string or a CST document as the second parameter. With
 * the latter, starting indices for lines are cached in the document as
 * `lineStarts: number[]`.
 *
 * Returns a one-indexed `{ line, col }` location if found, or
 * `undefined` otherwise.
 *
 * @param {number} offset
 * @param {string|Document|Document[]} cst
 * @returns {?LinePos}
 */


function getLinePos(offset, cst) {
  if (typeof offset !== 'number' || offset < 0) return null;
  const {
    lineStarts,
    src
  } = getSrcInfo(cst);
  if (!lineStarts || !src || offset > src.length) return null;

  for (let i = 0; i < lineStarts.length; ++i) {
    const start = lineStarts[i];

    if (offset < start) {
      return {
        line: i,
        col: offset - lineStarts[i - 1] + 1
      };
    }

    if (offset === start) return {
      line: i + 1,
      col: 1
    };
  }

  const line = lineStarts.length;
  return {
    line,
    col: offset - lineStarts[line - 1] + 1
  };
}
/**
 * Get a specified line from the source.
 *
 * Accepts a source string or a CST document as the second parameter. With
 * the latter, starting indices for lines are cached in the document as
 * `lineStarts: number[]`.
 *
 * Returns the line as a string if found, or `null` otherwise.
 *
 * @param {number} line One-indexed line number
 * @param {string|Document|Document[]} cst
 * @returns {?string}
 */


function getLine(line, cst) {
  const {
    lineStarts,
    src
  } = getSrcInfo(cst);
  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
  const start = lineStarts[line - 1];
  let end = lineStarts[line]; // undefined for last line; that's ok for slice()

  while (end && end > start && src[end - 1] === '\n') --end;

  return src.slice(start, end);
}
/**
 * Pretty-print the starting line from the source indicated by the range `pos`
 *
 * Trims output to `maxWidth` chars while keeping the starting column visible,
 * using `` at either end to indicate dropped characters.
 *
 * Returns a two-line string (or `null`) with `\n` as separator; the second line
 * will hold appropriately indented `^` marks indicating the column range.
 *
 * @param {Object} pos
 * @param {LinePos} pos.start
 * @param {LinePos} [pos.end]
 * @param {string|Document|Document[]*} cst
 * @param {number} [maxWidth=80]
 * @returns {?string}
 */


function getPrettyContext({
  start,
  end
}, cst, maxWidth = 80) {
  let src = getLine(start.line, cst);
  if (!src) return null;
  let {
    col
  } = start;

  if (src.length > maxWidth) {
    if (col <= maxWidth - 10) {
      src = src.substr(0, maxWidth - 1) + '';
    } else {
      const halfWidth = Math.round(maxWidth / 2);
      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '';
      col -= src.length - maxWidth;
      src = '' + src.substr(1 - maxWidth);
    }
  }

  let errLen = 1;
  let errEnd = '';

  if (end) {
    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
      errLen = end.col - start.col;
    } else {
      errLen = Math.min(src.length + 1, maxWidth) - col;
      errEnd = '';
    }
  }

  const offset = col > 1 ? ' '.repeat(col - 1) : '';
  const err = '^'.repeat(errLen);
  return `${src}\n${offset}${err}${errEnd}`;
}

/***/ }),

/***/ 61298:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.YAMLWarning = exports.YAMLSyntaxError = exports.YAMLSemanticError = exports.YAMLReferenceError = exports.YAMLError = void 0;

var _Node = __webpack_require__(80317);

var _sourceUtils = __webpack_require__(14022);

var _Range = __webpack_require__(23387);

class YAMLError extends Error {
  constructor(name, source, message) {
    if (!message || !(source instanceof _Node.Node)) throw new Error(`Invalid arguments for new ${name}`);
    super();
    this.name = name;
    this.message = message;
    this.source = source;
  }

  makePretty() {
    if (!this.source) return;
    this.nodeType = this.source.type;
    const cst = this.source.context && this.source.context.root;

    if (typeof this.offset === 'number') {
      this.range = new _Range.Range(this.offset, this.offset + 1);
      const start = cst && (0, _sourceUtils.getLinePos)(this.offset, cst);

      if (start) {
        const end = {
          line: start.line,
          col: start.col + 1
        };
        this.linePos = {
          start,
          end
        };
      }

      delete this.offset;
    } else {
      this.range = this.source.range;
      this.linePos = this.source.rangeAsLinePos;
    }

    if (this.linePos) {
      const {
        line,
        col
      } = this.linePos.start;
      this.message += ` at line ${line}, column ${col}`;
      const ctx = cst && (0, _sourceUtils.getPrettyContext)(this.linePos, cst);
      if (ctx) this.message += `:\n\n${ctx}\n`;
    }

    delete this.source;
  }

}

exports.YAMLError = YAMLError;

class YAMLReferenceError extends YAMLError {
  constructor(source, message) {
    super('YAMLReferenceError', source, message);
  }

}

exports.YAMLReferenceError = YAMLReferenceError;

class YAMLSemanticError extends YAMLError {
  constructor(source, message) {
    super('YAMLSemanticError', source, message);
  }

}

exports.YAMLSemanticError = YAMLSemanticError;

class YAMLSyntaxError extends YAMLError {
  constructor(source, message) {
    super('YAMLSyntaxError', source, message);
  }

}

exports.YAMLSyntaxError = YAMLSyntaxError;

class YAMLWarning extends YAMLError {
  constructor(source, message) {
    super('YAMLWarning', source, message);
  }

}

exports.YAMLWarning = YAMLWarning;

/***/ }),

/***/ 52590:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.foldFlowLines = foldFlowLines;
exports.FOLD_QUOTED = exports.FOLD_BLOCK = exports.FOLD_FLOW = void 0;
const FOLD_FLOW = 'flow';
exports.FOLD_FLOW = FOLD_FLOW;
const FOLD_BLOCK = 'block';
exports.FOLD_BLOCK = FOLD_BLOCK;
const FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line
// returns index of last newline in more-indented block

exports.FOLD_QUOTED = FOLD_QUOTED;

const consumeMoreIndentedLines = (text, i) => {
  let ch = text[i + 1];

  while (ch === ' ' || ch === '\t') {
    do {
      ch = text[i += 1];
    } while (ch && ch !== '\n');

    ch = text[i + 1];
  }

  return i;
};
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 *
 * @param {string} text
 * @param {string} indent
 * @param {string} [mode='flow'] `'block'` prevents more-indented lines
 *   from being folded; `'quoted'` allows for `\` escapes, including escaped
 *   newlines
 * @param {Object} options
 * @param {number} [options.indentAtStart] Accounts for leading contents on
 *   the first line, defaulting to `indent.length`
 * @param {number} [options.lineWidth=80]
 * @param {number} [options.minContentWidth=20] Allow highly indented lines to
 *   stretch the line width
 * @param {function} options.onFold Called once if the text is folded
 * @param {function} options.onFold Called once if any line of text exceeds
 *   lineWidth characters
 */


function foldFlowLines(text, indent, mode, {
  indentAtStart,
  lineWidth = 80,
  minContentWidth = 20,
  onFold,
  onOverflow
}) {
  if (!lineWidth || lineWidth < 0) return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep) return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);
  let split = undefined;
  let prev = undefined;
  let overflow = false;
  let i = -1;

  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1) end = i + endStep;
  }

  for (let ch; ch = text[i += 1];) {
    if (mode === FOLD_QUOTED && ch === '\\') {
      switch (text[i + 1]) {
        case 'x':
          i += 3;
          break;

        case 'u':
          i += 5;
          break;

        case 'U':
          i += 9;
          break;

        default:
          i += 1;
      }
    }

    if (ch === '\n') {
      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = undefined;
    } else {
      if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') {
        // space surrounded by non-space can be replaced with newline + indent
        const next = text[i + 1];
        if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i;
      }

      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = undefined;
        } else if (mode === FOLD_QUOTED) {
          // white-space collected at end may stretch past lineWidth
          while (prev === ' ' || prev === '\t') {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          } // i - 2 accounts for not-dropped last char + newline-escaping \


          folds.push(i - 2);
          escapedFolds[i - 2] = true;
          end = i - 2 + endStep;
          split = undefined;
        } else {
          overflow = true;
        }
      }
    }

    prev = ch;
  }

  if (overflow && onOverflow) onOverflow();
  if (folds.length === 0) return text;
  if (onFold) onFold();
  let res = text.slice(0, folds[0]);

  for (let i = 0; i < folds.length; ++i) {
    const fold = folds[i];
    const end = folds[i + 1] || text.length;
    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
    res += `\n${indent}${text.slice(fold + 1, end)}`;
  }

  return res;
}

/***/ }),

/***/ 58336:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.YAML = void 0;

var _parse = __webpack_require__(74947);

var _Document = __webpack_require__(24404);

var _errors = __webpack_require__(61298);

var _schema = __webpack_require__(2383);

var _options = __webpack_require__(5204);

var _warnings = __webpack_require__(33912);

const defaultOptions = {
  anchorPrefix: 'a',
  customTags: null,
  indent: 2,
  indentSeq: true,
  keepCstNodes: false,
  keepNodeTypes: true,
  keepBlobsInJSON: true,
  mapAsMap: false,
  maxAliasCount: 100,
  prettyErrors: false,
  // TODO Set true in v2
  simpleKeys: false,
  version: '1.2'
};
const scalarOptions = {
  get binary() {
    return _options.binaryOptions;
  },

  set binary(opt) {
    Object.assign(_options.binaryOptions, opt);
  },

  get bool() {
    return _options.boolOptions;
  },

  set bool(opt) {
    Object.assign(_options.boolOptions, opt);
  },

  get int() {
    return _options.intOptions;
  },

  set int(opt) {
    Object.assign(_options.intOptions, opt);
  },

  get null() {
    return _options.nullOptions;
  },

  set null(opt) {
    Object.assign(_options.nullOptions, opt);
  },

  get str() {
    return _options.strOptions;
  },

  set str(opt) {
    Object.assign(_options.strOptions, opt);
  }

};

function createNode(value, wrapScalars = true, tag) {
  if (tag === undefined && typeof wrapScalars === 'string') {
    tag = wrapScalars;
    wrapScalars = true;
  }

  const options = Object.assign({}, _Document.Document.defaults[defaultOptions.version], defaultOptions);
  const schema = new _schema.Schema(options);
  return schema.createNode(value, wrapScalars, tag);
}

class Document extends _Document.Document {
  constructor(options) {
    super(Object.assign({}, defaultOptions, options));
  }

}

function parseAllDocuments(src, options) {
  const stream = [];
  let prev;

  for (const cstDoc of (0, _parse.parse)(src)) {
    const doc = new Document(options);
    doc.parse(cstDoc, prev);
    stream.push(doc);
    prev = doc;
  }

  return stream;
}

function parseDocument(src, options) {
  const cst = (0, _parse.parse)(src);
  const doc = new Document(options).parse(cst[0]);

  if (cst.length > 1) {
    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';
    doc.errors.unshift(new _errors.YAMLSemanticError(cst[1], errMsg));
  }

  return doc;
}

function parse(src, options) {
  const doc = parseDocument(src, options);
  doc.warnings.forEach(warning => (0, _warnings.warn)(warning));
  if (doc.errors.length > 0) throw doc.errors[0];
  return doc.toJSON();
}

function stringify(value, options) {
  const doc = new Document(options);
  doc.contents = value;
  return String(doc);
}

const YAML = {
  createNode,
  defaultOptions,
  Document,
  parse,
  parseAllDocuments,
  parseCST: _parse.parse,
  parseDocument,
  scalarOptions,
  stringify
};
exports.YAML = YAML;

/***/ }),

/***/ 89153:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.listTagNames = void 0;

var _Collection = __webpack_require__(67404);

var _Pair = __webpack_require__(22007);

var _Scalar = __webpack_require__(55858);

const visit = (node, tags) => {
  if (node && typeof node === 'object') {
    const {
      tag
    } = node;

    if (node instanceof _Collection.Collection) {
      if (tag) tags[tag] = true;
      node.items.forEach(n => visit(n, tags));
    } else if (node instanceof _Pair.Pair) {
      visit(node.key, tags);
      visit(node.value, tags);
    } else if (node instanceof _Scalar.Scalar) {
      if (tag) tags[tag] = true;
    }
  }

  return tags;
};

const listTagNames = node => Object.keys(visit(node, {}));

exports.listTagNames = listTagNames;

/***/ }),

/***/ 44058:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Alias = void 0;

var _constants = __webpack_require__(87270);

var _errors = __webpack_require__(61298);

var _toJSON = __webpack_require__(35613);

var _Collection = __webpack_require__(67404);

var _Node = __webpack_require__(70800);

var _Pair = __webpack_require__(22007);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const getAliasCount = (node, anchors) => {
  if (node instanceof Alias) {
    const anchor = anchors.get(node.source);
    return anchor.count * anchor.aliasCount;
  } else if (node instanceof _Collection.Collection) {
    let count = 0;

    for (const item of node.items) {
      const c = getAliasCount(item, anchors);
      if (c > count) count = c;
    }

    return count;
  } else if (node instanceof _Pair.Pair) {
    const kc = getAliasCount(node.key, anchors);
    const vc = getAliasCount(node.value, anchors);
    return Math.max(kc, vc);
  }

  return 1;
};

class Alias extends _Node.Node {
  static stringify({
    range,
    source
  }, {
    anchors,
    doc,
    implicitKey,
    inStringifyKey
  }) {
    let anchor = Object.keys(anchors).find(a => anchors[a] === source);
    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;
    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';
    throw new Error(`${msg} [${range}]`);
  }

  constructor(source) {
    super();
    this.source = source;
    this.type = _constants.Type.ALIAS;
  }

  set tag(t) {
    throw new Error('Alias nodes cannot have tags');
  }

  toJSON(arg, ctx) {
    if (!ctx) return (0, _toJSON.toJSON)(this.source, arg, ctx);
    const {
      anchors,
      maxAliasCount
    } = ctx;
    const anchor = anchors.get(this.source);
    /* istanbul ignore if */

    if (!anchor || anchor.res === undefined) {
      const msg = 'This should not happen: Alias anchor was not resolved?';
      if (this.cstNode) throw new _errors.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
    }

    if (maxAliasCount >= 0) {
      anchor.count += 1;
      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);

      if (anchor.count * anchor.aliasCount > maxAliasCount) {
        const msg = 'Excessive alias count indicates a resource exhaustion attack';
        if (this.cstNode) throw new _errors.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
      }
    }

    return anchor.res;
  } // Only called when stringifying an alias mapping key while constructing
  // Object output.


  toString(ctx) {
    return Alias.stringify(this, ctx);
  }

}

exports.Alias = Alias;

_defineProperty(Alias, "default", true);

/***/ }),

/***/ 67404:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Collection = exports.isEmptyPath = void 0;

var _addComment = __webpack_require__(5350);

var _constants = __webpack_require__(87270);

var _Node = __webpack_require__(70800);

var _Scalar = __webpack_require__(55858);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function collectionFromPath(schema, path, value) {
  let v = value;

  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    const o = Number.isInteger(k) && k >= 0 ? [] : {};
    o[k] = v;
    v = o;
  }

  return schema.createNode(v, false);
} // null, undefined, or an empty non-string iterable (e.g. [])


const isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;

exports.isEmptyPath = isEmptyPath;

class Collection extends _Node.Node {
  constructor(schema) {
    super();

    _defineProperty(this, "items", []);

    this.schema = schema;
  }

  addIn(path, value) {
    if (isEmptyPath(path)) this.add(value);else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }

  deleteIn([key, ...rest]) {
    if (rest.length === 0) return this.delete(key);
    const node = this.get(key, true);
    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }

  getIn([key, ...rest], keepScalar) {
    const node = this.get(key, true);
    if (rest.length === 0) return !keepScalar && node instanceof _Scalar.Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;
  }

  hasAllNullValues() {
    return this.items.every(node => {
      if (!node || node.type !== 'PAIR') return false;
      const n = node.value;
      return n == null || n instanceof _Scalar.Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }

  hasIn([key, ...rest]) {
    if (rest.length === 0) return this.has(key);
    const node = this.get(key, true);
    return node instanceof Collection ? node.hasIn(rest) : false;
  }

  setIn([key, ...rest], value) {
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  } // overridden in implementations

  /* istanbul ignore next */


  toJSON() {
    return null;
  }

  toString(ctx, {
    blockItem,
    flowChars,
    isMap,
    itemIndent
  }, onComment, onChompKeep) {
    const {
      doc,
      indent,
      indentStep
    } = ctx;
    const inFlow = this.type === _constants.Type.FLOW_MAP || this.type === _constants.Type.FLOW_SEQ || ctx.inFlow;
    if (inFlow) itemIndent += indentStep;
    const allNullValues = isMap && this.hasAllNullValues();
    ctx = Object.assign({}, ctx, {
      allNullValues,
      indent: itemIndent,
      inFlow,
      type: null
    });
    let chompKeep = false;
    let hasItemWithNewLine = false;
    const nodes = this.items.reduce((nodes, item, i) => {
      let comment;

      if (item) {
        if (!chompKeep && item.spaceBefore) nodes.push({
          type: 'comment',
          str: ''
        });
        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {
          nodes.push({
            type: 'comment',
            str: `#${line}`
          });
        });
        if (item.comment) comment = item.comment;
        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
      }

      chompKeep = false;
      let str = doc.schema.stringify(item, ctx, () => comment = null, () => chompKeep = true);
      if (inFlow && !hasItemWithNewLine && str.includes('\n')) hasItemWithNewLine = true;
      if (inFlow && i < this.items.length - 1) str += ',';
      str = (0, _addComment.addComment)(str, itemIndent, comment);
      if (chompKeep && (comment || inFlow)) chompKeep = false;
      nodes.push({
        type: 'item',
        str
      });
      return nodes;
    }, []);
    let str;

    if (nodes.length === 0) {
      str = flowChars.start + flowChars.end;
    } else if (inFlow) {
      const {
        start,
        end
      } = flowChars;
      const strings = nodes.map(n => n.str);

      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {
        str = start;

        for (const s of strings) {
          str += s ? `\n${indentStep}${indent}${s}` : '\n';
        }

        str += `\n${indent}${end}`;
      } else {
        str = `${start} ${strings.join(' ')} ${end}`;
      }
    } else {
      const strings = nodes.map(blockItem);
      str = strings.shift();

      for (const s of strings) str += s ? `\n${indent}${s}` : '\n';
    }

    if (this.comment) {
      str += '\n' + this.comment.replace(/^/gm, `${indent}#`);
      if (onComment) onComment();
    } else if (chompKeep && onChompKeep) onChompKeep();

    return str;
  }

}

exports.Collection = Collection;

_defineProperty(Collection, "maxFlowStringSingleLineLength", 60);

/***/ }),

/***/ 80022:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.findPair = findPair;
exports.YAMLMap = void 0;

var _Collection = __webpack_require__(67404);

var _Pair = __webpack_require__(22007);

var _Scalar = __webpack_require__(55858);

function findPair(items, key) {
  const k = key instanceof _Scalar.Scalar ? key.value : key;

  for (const it of items) {
    if (it instanceof _Pair.Pair) {
      if (it.key === key || it.key === k) return it;
      if (it.key && it.key.value === k) return it;
    }
  }

  return undefined;
}

class YAMLMap extends _Collection.Collection {
  add(pair, overwrite) {
    if (!pair) pair = new _Pair.Pair(pair);else if (!(pair instanceof _Pair.Pair)) pair = new _Pair.Pair(pair.key || pair, pair.value);
    const prev = findPair(this.items, pair.key);
    const sortEntries = this.schema && this.schema.sortMapEntries;

    if (prev) {
      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);
    } else if (sortEntries) {
      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);
      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);
    } else {
      this.items.push(pair);
    }
  }

  delete(key) {
    const it = findPair(this.items, key);
    if (!it) return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }

  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it && it.value;
    return !keepScalar && node instanceof _Scalar.Scalar ? node.value : node;
  }

  has(key) {
    return !!findPair(this.items, key);
  }

  set(key, value) {
    this.add(new _Pair.Pair(key, value), true);
  }
  /**
   * @param {*} arg ignored
   * @param {*} ctx Conversion context, originally set in Document#toJSON()
   * @param {Class} Type If set, forces the returned collection type
   * @returns {*} Instance of Type, Map, or Object
   */


  toJSON(_, ctx, Type) {
    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
    if (ctx && ctx.onCreate) ctx.onCreate(map);

    for (const item of this.items) item.addToJSMap(ctx, map);

    return map;
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);

    for (const item of this.items) {
      if (!(item instanceof _Pair.Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }

    return super.toString(ctx, {
      blockItem: n => n.str,
      flowChars: {
        start: '{',
        end: '}'
      },
      isMap: true,
      itemIndent: ctx.indent || ''
    }, onComment, onChompKeep);
  }

}

exports.YAMLMap = YAMLMap;

/***/ }),

/***/ 69375:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Merge = exports.MERGE_KEY = void 0;

var _Map = __webpack_require__(80022);

var _Pair = __webpack_require__(22007);

var _Scalar = __webpack_require__(55858);

var _Seq = __webpack_require__(74151);

const MERGE_KEY = '<<';
exports.MERGE_KEY = MERGE_KEY;

class Merge extends _Pair.Pair {
  constructor(pair) {
    if (pair instanceof _Pair.Pair) {
      let seq = pair.value;

      if (!(seq instanceof _Seq.YAMLSeq)) {
        seq = new _Seq.YAMLSeq();
        seq.items.push(pair.value);
        seq.range = pair.value.range;
      }

      super(pair.key, seq);
      this.range = pair.range;
    } else {
      super(new _Scalar.Scalar(MERGE_KEY), new _Seq.YAMLSeq());
    }

    this.type = _Pair.Pair.Type.MERGE_PAIR;
  } // If the value associated with a merge key is a single mapping node, each of
  // its key/value pairs is inserted into the current mapping, unless the key
  // already exists in it. If the value associated with the merge key is a
  // sequence, then this sequence is expected to contain mapping nodes and each
  // of these nodes is merged in turn according to its order in the sequence.
  // Keys in mapping nodes earlier in the sequence override keys specified in
  // later mapping nodes. -- http://yaml.org/type/merge.html


  addToJSMap(ctx, map) {
    for (const {
      source
    } of this.value.items) {
      if (!(source instanceof _Map.YAMLMap)) throw new Error('Merge sources must be maps');
      const srcMap = source.toJSON(null, ctx, Map);

      for (const [key, value] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key)) map.set(key, value);
        } else if (map instanceof Set) {
          map.add(key);
        } else {
          if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;
        }
      }
    }

    return map;
  }

  toString(ctx, onComment) {
    const seq = this.value;
    if (seq.items.length > 1) return super.toString(ctx, onComment);
    this.value = seq.items[0];
    const str = super.toString(ctx, onComment);
    this.value = seq;
    return str;
  }

}

exports.Merge = Merge;

/***/ }),

/***/ 70800:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.Node = void 0;

class Node {}

exports.Node = Node;

/***/ }),

/***/ 22007:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Pair = void 0;

var _addComment = __webpack_require__(5350);

var _constants = __webpack_require__(87270);

var _toJSON = __webpack_require__(35613);

var _Collection = __webpack_require__(67404);

var _Node = __webpack_require__(70800);

var _Scalar = __webpack_require__(55858);

var _Seq = __webpack_require__(74151);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const stringifyKey = (key, jsKey, ctx) => {
  if (jsKey === null) return '';
  if (typeof jsKey !== 'object') return String(jsKey);
  if (key instanceof _Node.Node && ctx && ctx.doc) return key.toString({
    anchors: {},
    doc: ctx.doc,
    indent: '',
    indentStep: ctx.indentStep,
    inFlow: true,
    inStringifyKey: true
  });
  return JSON.stringify(jsKey);
};

class Pair extends _Node.Node {
  constructor(key, value = null) {
    super();
    this.key = key;
    this.value = value;
    this.type = Pair.Type.PAIR;
  }

  get commentBefore() {
    return this.key && this.key.commentBefore;
  }

  set commentBefore(cb) {
    if (this.key == null) this.key = new _Scalar.Scalar(null);
    this.key.commentBefore = cb;
  }

  addToJSMap(ctx, map) {
    const key = (0, _toJSON.toJSON)(this.key, '', ctx);

    if (map instanceof Map) {
      const value = (0, _toJSON.toJSON)(this.value, key, ctx);
      map.set(key, value);
    } else if (map instanceof Set) {
      map.add(key);
    } else {
      const stringKey = stringifyKey(this.key, key, ctx);
      map[stringKey] = (0, _toJSON.toJSON)(this.value, stringKey, ctx);
    }

    return map;
  }

  toJSON(_, ctx) {
    const pair = ctx && ctx.mapAsMap ? new Map() : {};
    return this.addToJSMap(ctx, pair);
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx || !ctx.doc) return JSON.stringify(this);
    const {
      indent: indentSize,
      indentSeq,
      simpleKeys
    } = ctx.doc.options;
    let {
      key,
      value
    } = this;
    let keyComment = key instanceof _Node.Node && key.comment;

    if (simpleKeys) {
      if (keyComment) {
        throw new Error('With simple keys, key nodes cannot have comments');
      }

      if (key instanceof _Collection.Collection) {
        const msg = 'With simple keys, collection cannot be used as a key value';
        throw new Error(msg);
      }
    }

    const explicitKey = !simpleKeys && (!key || keyComment || key instanceof _Collection.Collection || key.type === _constants.Type.BLOCK_FOLDED || key.type === _constants.Type.BLOCK_LITERAL);
    const {
      doc,
      indent,
      indentStep
    } = ctx;
    ctx = Object.assign({}, ctx, {
      implicitKey: !explicitKey,
      indent: indent + indentStep
    });
    let chompKeep = false;
    let str = doc.schema.stringify(key, ctx, () => keyComment = null, () => chompKeep = true);
    str = (0, _addComment.addComment)(str, ctx.indent, keyComment);

    if (ctx.allNullValues && !simpleKeys) {
      if (this.comment) {
        str = (0, _addComment.addComment)(str, ctx.indent, this.comment);
        if (onComment) onComment();
      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();

      return ctx.inFlow ? str : `? ${str}`;
    }

    str = explicitKey ? `? ${str}\n${indent}:` : `${str}:`;

    if (this.comment) {
      // expected (but not strictly required) to be a single-line comment
      str = (0, _addComment.addComment)(str, ctx.indent, this.comment);
      if (onComment) onComment();
    }

    let vcb = '';
    let valueComment = null;

    if (value instanceof _Node.Node) {
      if (value.spaceBefore) vcb = '\n';

      if (value.commentBefore) {
        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
        vcb += `\n${cs}`;
      }

      valueComment = value.comment;
    } else if (value && typeof value === 'object') {
      value = doc.schema.createNode(value, true);
    }

    ctx.implicitKey = false;
    if (!explicitKey && !this.comment && value instanceof _Scalar.Scalar) ctx.indentAtStart = str.length + 1;
    chompKeep = false;

    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof _Seq.YAMLSeq && value.type !== _constants.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
      // If indentSeq === false, consider '- ' as part of indentation where possible
      ctx.indent = ctx.indent.substr(2);
    }

    const valueStr = doc.schema.stringify(value, ctx, () => valueComment = null, () => chompKeep = true);
    let ws = ' ';

    if (vcb || this.comment) {
      ws = `${vcb}\n${ctx.indent}`;
    } else if (!explicitKey && value instanceof _Collection.Collection) {
      const flow = valueStr[0] === '[' || valueStr[0] === '{';
      if (!flow || valueStr.includes('\n')) ws = `\n${ctx.indent}`;
    }

    if (chompKeep && !valueComment && onChompKeep) onChompKeep();
    return (0, _addComment.addComment)(str + ws + valueStr, ctx.indent, valueComment);
  }

}

exports.Pair = Pair;

_defineProperty(Pair, "Type", {
  PAIR: 'PAIR',
  MERGE_PAIR: 'MERGE_PAIR'
});

/***/ }),

/***/ 55858:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Scalar = void 0;

var _toJSON = __webpack_require__(35613);

var _Node = __webpack_require__(70800);

// Published as 'yaml/scalar'
class Scalar extends _Node.Node {
  constructor(value) {
    super();
    this.value = value;
  }

  toJSON(arg, ctx) {
    return ctx && ctx.keep ? this.value : (0, _toJSON.toJSON)(this.value, arg, ctx);
  }

  toString() {
    return String(this.value);
  }

}

exports.Scalar = Scalar;

/***/ }),

/***/ 74151:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.YAMLSeq = void 0;

var _toJSON = __webpack_require__(35613);

var _Collection = __webpack_require__(67404);

var _Scalar = __webpack_require__(55858);

// Published as 'yaml/seq'
function asItemIndex(key) {
  let idx = key instanceof _Scalar.Scalar ? key.value : key;
  if (idx && typeof idx === 'string') idx = Number(idx);
  return Number.isInteger(idx) && idx >= 0 ? idx : null;
}

class YAMLSeq extends _Collection.Collection {
  add(value) {
    this.items.push(value);
  }

  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }

  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return undefined;
    const it = this.items[idx];
    return !keepScalar && it instanceof _Scalar.Scalar ? it.value : it;
  }

  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === 'number' && idx < this.items.length;
  }

  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);
    this.items[idx] = value;
  }

  toJSON(_, ctx) {
    const seq = [];
    if (ctx && ctx.onCreate) ctx.onCreate(seq);
    let i = 0;

    for (const item of this.items) seq.push((0, _toJSON.toJSON)(item, String(i++), ctx));

    return seq;
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);
    return super.toString(ctx, {
      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,
      flowChars: {
        start: '[',
        end: ']'
      },
      isMap: false,
      itemIndent: (ctx.indent || '') + '  '
    }, onComment, onChompKeep);
  }

}

exports.YAMLSeq = YAMLSeq;

/***/ }),

/***/ 2383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Schema = void 0;

var _warnings = __webpack_require__(33912);

var _constants = __webpack_require__(87270);

var _errors = __webpack_require__(61298);

var _stringify = __webpack_require__(81147);

var _tags = __webpack_require__(40094);

var _string = __webpack_require__(94250);

var _Alias = __webpack_require__(44058);

var _Collection = __webpack_require__(67404);

var _Node = __webpack_require__(70800);

var _Pair = __webpack_require__(22007);

var _Scalar = __webpack_require__(55858);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const isMap = ({
  type
}) => type === _constants.Type.FLOW_MAP || type === _constants.Type.MAP;

const isSeq = ({
  type
}) => type === _constants.Type.FLOW_SEQ || type === _constants.Type.SEQ;

class Schema {
  constructor({
    customTags,
    merge,
    schema,
    sortMapEntries,
    tags: deprecatedCustomTags
  }) {
    this.merge = !!merge;
    this.name = schema;
    this.sortMapEntries = sortMapEntries === true ? (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0 : sortMapEntries || null;
    this.tags = _tags.schemas[schema.replace(/\W/g, '')]; // 'yaml-1.1' -> 'yaml11'

    if (!this.tags) {
      const keys = Object.keys(_tags.schemas).map(key => JSON.stringify(key)).join(', ');
      throw new Error(`Unknown schema "${schema}"; use one of ${keys}`);
    }

    if (!customTags && deprecatedCustomTags) {
      customTags = deprecatedCustomTags;
      (0, _warnings.warnOptionDeprecation)('tags', 'customTags');
    }

    if (Array.isArray(customTags)) {
      for (const tag of customTags) this.tags = this.tags.concat(tag);
    } else if (typeof customTags === 'function') {
      this.tags = customTags(this.tags.slice());
    }

    for (let i = 0; i < this.tags.length; ++i) {
      const tag = this.tags[i];

      if (typeof tag === 'string') {
        const tagObj = _tags.tags[tag];

        if (!tagObj) {
          const keys = Object.keys(_tags.tags).map(key => JSON.stringify(key)).join(', ');
          throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
        }

        this.tags[i] = tagObj;
      }
    }
  }

  createNode(value, wrapScalars, tag, ctx) {
    if (value instanceof _Node.Node) return value;
    let tagObj;

    if (tag) {
      if (tag.startsWith('!!')) tag = Schema.defaultPrefix + tag.slice(2);
      const match = this.tags.filter(t => t.tag === tag);
      tagObj = match.find(t => !t.format) || match[0];
      if (!tagObj) throw new Error(`Tag ${tag} not found`);
    } else {
      // TODO: deprecate/remove class check
      tagObj = this.tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);

      if (!tagObj) {
        if (typeof value.toJSON === 'function') value = value.toJSON();
        if (typeof value !== 'object') return wrapScalars ? new _Scalar.Scalar(value) : value;
        tagObj = value instanceof Map ? _tags.tags.map : value[Symbol.iterator] ? _tags.tags.seq : _tags.tags.map;
      }
    }

    if (!ctx) ctx = {
      wrapScalars
    };else ctx.wrapScalars = wrapScalars;

    if (ctx.onTagObj) {
      ctx.onTagObj(tagObj);
      delete ctx.onTagObj;
    }

    const obj = {};

    if (value && typeof value === 'object' && ctx.prevObjects) {
      const prev = ctx.prevObjects.get(value);

      if (prev) {
        const alias = new _Alias.Alias(prev); // leaves source dirty; must be cleaned by caller

        ctx.aliasNodes.push(alias);
        return alias;
      }

      obj.value = value;
      ctx.prevObjects.set(value, obj);
    }

    obj.node = tagObj.createNode ? tagObj.createNode(this, value, ctx) : wrapScalars ? new _Scalar.Scalar(value) : value;
    if (tag && obj.node instanceof _Node.Node) obj.node.tag = tag;
    return obj.node;
  }

  createPair(key, value, ctx) {
    const k = this.createNode(key, ctx.wrapScalars, null, ctx);
    const v = this.createNode(value, ctx.wrapScalars, null, ctx);
    return new _Pair.Pair(k, v);
  } // falls back to string on no match


  resolveScalar(str, tags) {
    if (!tags) tags = this.tags;

    for (let i = 0; i < tags.length; ++i) {
      const {
        format,
        test,
        resolve
      } = tags[i];

      if (test) {
        const match = str.match(test);

        if (match) {
          let res = resolve.apply(null, match);
          if (!(res instanceof _Scalar.Scalar)) res = new _Scalar.Scalar(res);
          if (format) res.format = format;
          return res;
        }
      }
    }

    if (this.tags.scalarFallback) str = this.tags.scalarFallback(str);
    return new _Scalar.Scalar(str);
  } // sets node.resolved on success


  resolveNode(doc, node, tagName) {
    const tags = this.tags.filter(({
      tag
    }) => tag === tagName);
    const generic = tags.find(({
      test
    }) => !test);
    if (node.error) doc.errors.push(node.error);

    try {
      if (generic) {
        let res = generic.resolve(doc, node);
        if (!(res instanceof _Collection.Collection)) res = new _Scalar.Scalar(res);
        node.resolved = res;
      } else {
        const str = (0, _string.resolveString)(doc, node);

        if (typeof str === 'string' && tags.length > 0) {
          node.resolved = this.resolveScalar(str, tags);
        }
      }
    } catch (error) {
      /* istanbul ignore if */
      if (!error.source) error.source = node;
      doc.errors.push(error);
      node.resolved = null;
    }

    if (!node.resolved) return null;
    if (tagName && node.tag) node.resolved.tag = tagName;
    return node.resolved;
  }

  resolveNodeWithFallback(doc, node, tagName) {
    const res = this.resolveNode(doc, node, tagName);
    if (Object.prototype.hasOwnProperty.call(node, 'resolved')) return res;
    const fallback = isMap(node) ? Schema.defaultTags.MAP : isSeq(node) ? Schema.defaultTags.SEQ : Schema.defaultTags.STR;
    /* istanbul ignore else */

    if (fallback) {
      doc.warnings.push(new _errors.YAMLWarning(node, `The tag ${tagName} is unavailable, falling back to ${fallback}`));
      const res = this.resolveNode(doc, node, fallback);
      res.tag = tagName;
      return res;
    } else {
      doc.errors.push(new _errors.YAMLReferenceError(node, `The tag ${tagName} is unavailable`));
      return null;
    }
  }

  getTagObject(item) {
    if (item instanceof _Alias.Alias) return _Alias.Alias;

    if (item.tag) {
      const match = this.tags.filter(t => t.tag === item.tag);
      if (match.length > 0) return match.find(t => t.format === item.format) || match[0];
    }

    let tagObj, obj;

    if (item instanceof _Scalar.Scalar) {
      obj = item.value; // TODO: deprecate/remove class check

      const match = this.tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
      tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);
    } else {
      obj = item;
      tagObj = this.tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }

    if (!tagObj) {
      const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
      throw new Error(`Tag not resolved for ${name} value`);
    }

    return tagObj;
  } // needs to be called before stringifier to allow for circular anchor refs


  stringifyProps(node, tagObj, {
    anchors,
    doc
  }) {
    const props = [];
    const anchor = doc.anchors.getName(node);

    if (anchor) {
      anchors[anchor] = node;
      props.push(`&${anchor}`);
    }

    if (node.tag) {
      props.push(doc.stringifyTag(node.tag));
    } else if (!tagObj.default) {
      props.push(doc.stringifyTag(tagObj.tag));
    }

    return props.join(' ');
  }

  stringify(item, ctx, onComment, onChompKeep) {
    let tagObj;

    if (!(item instanceof _Node.Node)) {
      const createCtx = {
        aliasNodes: [],
        onTagObj: o => tagObj = o,
        prevObjects: new Map()
      };
      item = this.createNode(item, true, null, createCtx);
      const {
        anchors
      } = ctx.doc;

      for (const alias of createCtx.aliasNodes) {
        alias.source = alias.source.node;
        let name = anchors.getName(alias.source);

        if (!name) {
          name = anchors.newName();
          anchors.map[name] = alias.source;
        }
      }
    }

    ctx.tags = this;
    if (item instanceof _Pair.Pair) return item.toString(ctx, onComment, onChompKeep);
    if (!tagObj) tagObj = this.getTagObject(item);
    const props = this.stringifyProps(item, tagObj, ctx);
    if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof _Collection.Collection ? item.toString(ctx, onComment, onChompKeep) : (0, _stringify.stringifyString)(item, ctx, onComment, onChompKeep);
    return props ? item instanceof _Collection.Collection && str[0] !== '{' && str[0] !== '[' ? `${props}\n${ctx.indent}${str}` : `${props} ${str}` : str;
  }

}

exports.Schema = Schema;

_defineProperty(Schema, "defaultPrefix", 'tag:yaml.org,2002:');

_defineProperty(Schema, "defaultTags", {
  MAP: 'tag:yaml.org,2002:map',
  SEQ: 'tag:yaml.org,2002:seq',
  STR: 'tag:yaml.org,2002:str'
});

/***/ }),

/***/ 12346:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.parseMap = parseMap;

var _constants = __webpack_require__(87270);

var _PlainValue = __webpack_require__(48314);

var _errors = __webpack_require__(61298);

var _Map = __webpack_require__(80022);

var _Merge = __webpack_require__(69375);

var _Pair = __webpack_require__(22007);

var _parseUtils = __webpack_require__(81359);

var _Alias = __webpack_require__(44058);

var _Collection = __webpack_require__(67404);

function parseMap(doc, cst) {
  if (cst.type !== _constants.Type.MAP && cst.type !== _constants.Type.FLOW_MAP) {
    const msg = `A ${cst.type} node cannot be resolved as a mapping`;
    doc.errors.push(new _errors.YAMLSyntaxError(cst, msg));
    return null;
  }

  const {
    comments,
    items
  } = cst.type === _constants.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
  const map = new _Map.YAMLMap();
  map.items = items;
  (0, _parseUtils.resolveComments)(map, comments);
  let hasCollectionKey = false;

  for (let i = 0; i < items.length; ++i) {
    const {
      key: iKey
    } = items[i];
    if (iKey instanceof _Collection.Collection) hasCollectionKey = true;

    if (doc.schema.merge && iKey && iKey.value === _Merge.MERGE_KEY) {
      items[i] = new _Merge.Merge(items[i]);
      const sources = items[i].value.items;
      let error = null;
      sources.some(node => {
        if (node instanceof _Alias.Alias) {
          // During parsing, alias sources are CST nodes; to account for
          // circular references their resolved values can't be used here.
          const {
            type
          } = node.source;
          if (type === _constants.Type.MAP || type === _constants.Type.FLOW_MAP) return false;
          return error = 'Merge nodes aliases can only point to maps';
        }

        return error = 'Merge nodes can only have Alias nodes as values';
      });
      if (error) doc.errors.push(new _errors.YAMLSemanticError(cst, error));
    } else {
      for (let j = i + 1; j < items.length; ++j) {
        const {
          key: jKey
        } = items[j];

        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {
          const msg = `Map keys must be unique; "${iKey}" is repeated`;
          doc.errors.push(new _errors.YAMLSemanticError(cst, msg));
          break;
        }
      }
    }
  }

  if (hasCollectionKey && !doc.options.mapAsMap) {
    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new _errors.YAMLWarning(cst, warn));
  }

  cst.resolved = map;
  return map;
}

const valueHasPairComment = ({
  context: {
    lineStart,
    node,
    src
  },
  props
}) => {
  if (props.length === 0) return false;
  const {
    start
  } = props[0];
  if (node && start > node.valueRange.start) return false;
  if (src[start] !== _constants.Char.COMMENT) return false;

  for (let i = lineStart; i < start; ++i) if (src[i] === '\n') return false;

  return true;
};

function resolvePairComment(item, pair) {
  if (!valueHasPairComment(item)) return;
  const comment = item.getPropValue(0, _constants.Char.COMMENT, true);
  let found = false;
  const cb = pair.value.commentBefore;

  if (cb && cb.startsWith(comment)) {
    pair.value.commentBefore = cb.substr(comment.length + 1);
    found = true;
  } else {
    const cc = pair.value.comment;

    if (!item.node && cc && cc.startsWith(comment)) {
      pair.value.comment = cc.substr(comment.length + 1);
      found = true;
    }
  }

  if (found) pair.comment = comment;
}

function resolveBlockMapItems(doc, cst) {
  const comments = [];
  const items = [];
  let key = undefined;
  let keyStart = null;

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    switch (item.type) {
      case _constants.Type.BLANK_LINE:
        comments.push({
          afterKey: !!key,
          before: items.length
        });
        break;

      case _constants.Type.COMMENT:
        comments.push({
          afterKey: !!key,
          before: items.length,
          comment: item.comment
        });
        break;

      case _constants.Type.MAP_KEY:
        if (key !== undefined) items.push(new _Pair.Pair(key));
        if (item.error) doc.errors.push(item.error);
        key = doc.resolveNode(item.node);
        keyStart = null;
        break;

      case _constants.Type.MAP_VALUE:
        {
          if (key === undefined) key = null;
          if (item.error) doc.errors.push(item.error);

          if (!item.context.atLineStart && item.node && item.node.type === _constants.Type.MAP && !item.node.context.atLineStart) {
            const msg = 'Nested mappings are not allowed in compact mappings';
            doc.errors.push(new _errors.YAMLSemanticError(item.node, msg));
          }

          let valueNode = item.node;

          if (!valueNode && item.props.length > 0) {
            // Comments on an empty mapping value need to be preserved, so we
            // need to construct a minimal empty node here to use instead of the
            // missing `item.node`. -- eemeli/yaml#19
            valueNode = new _PlainValue.PlainValue(_constants.Type.PLAIN, []);
            valueNode.context = {
              parent: item,
              src: item.context.src
            };
            const pos = item.range.start + 1;
            valueNode.range = {
              start: pos,
              end: pos
            };
            valueNode.valueRange = {
              start: pos,
              end: pos
            };

            if (typeof item.range.origStart === 'number') {
              const origPos = item.range.origStart + 1;
              valueNode.range.origStart = valueNode.range.origEnd = origPos;
              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
            }
          }

          const pair = new _Pair.Pair(key, doc.resolveNode(valueNode));
          resolvePairComment(item, pair);
          items.push(pair);
          (0, _parseUtils.checkKeyLength)(doc.errors, cst, i, key, keyStart);
          key = undefined;
          keyStart = null;
        }
        break;

      default:
        if (key !== undefined) items.push(new _Pair.Pair(key));
        key = doc.resolveNode(item);
        keyStart = item.range.start;
        if (item.error) doc.errors.push(item.error);

        next: for (let j = i + 1;; ++j) {
          const nextItem = cst.items[j];

          switch (nextItem && nextItem.type) {
            case _constants.Type.BLANK_LINE:
            case _constants.Type.COMMENT:
              continue next;

            case _constants.Type.MAP_VALUE:
              break next;

            default:
              doc.errors.push(new _errors.YAMLSemanticError(item, 'Implicit map keys need to be followed by map values'));
              break next;
          }
        }

        if (item.valueRangeContainsNewline) {
          const msg = 'Implicit map keys need to be on a single line';
          doc.errors.push(new _errors.YAMLSemanticError(item, msg));
        }

    }
  }

  if (key !== undefined) items.push(new _Pair.Pair(key));
  return {
    comments,
    items
  };
}

function resolveFlowMapItems(doc, cst) {
  const comments = [];
  const items = [];
  let key = undefined;
  let keyStart = null;
  let explicitKey = false;
  let next = '{';

  for (let i = 0; i < cst.items.length; ++i) {
    (0, _parseUtils.checkKeyLength)(doc.errors, cst, i, key, keyStart);
    const item = cst.items[i];

    if (typeof item.char === 'string') {
      const {
        char,
        offset
      } = item;

      if (char === '?' && key === undefined && !explicitKey) {
        explicitKey = true;
        next = ':';
        continue;
      }

      if (char === ':') {
        if (key === undefined) key = null;

        if (next === ':') {
          next = ',';
          continue;
        }
      } else {
        if (explicitKey) {
          if (key === undefined && char !== ',') key = null;
          explicitKey = false;
        }

        if (key !== undefined) {
          items.push(new _Pair.Pair(key));
          key = undefined;
          keyStart = null;

          if (char === ',') {
            next = ':';
            continue;
          }
        }
      }

      if (char === '}') {
        if (i === cst.items.length - 1) continue;
      } else if (char === next) {
        next = ':';
        continue;
      }

      const msg = `Flow map contains an unexpected ${char}`;
      const err = new _errors.YAMLSyntaxError(cst, msg);
      err.offset = offset;
      doc.errors.push(err);
    } else if (item.type === _constants.Type.BLANK_LINE) {
      comments.push({
        afterKey: !!key,
        before: items.length
      });
    } else if (item.type === _constants.Type.COMMENT) {
      comments.push({
        afterKey: !!key,
        before: items.length,
        comment: item.comment
      });
    } else if (key === undefined) {
      if (next === ',') doc.errors.push(new _errors.YAMLSemanticError(item, 'Separator , missing in flow map'));
      key = doc.resolveNode(item);
      keyStart = explicitKey ? null : item.range.start; // TODO: add error for non-explicit multiline plain key
    } else {
      if (next !== ',') doc.errors.push(new _errors.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));
      items.push(new _Pair.Pair(key, doc.resolveNode(item)));
      key = undefined;
      explicitKey = false;
    }
  }

  (0, _parseUtils.checkFlowCollectionEnd)(doc.errors, cst);
  if (key !== undefined) items.push(new _Pair.Pair(key));
  return {
    comments,
    items
  };
}

/***/ }),

/***/ 45028:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.parseSeq = parseSeq;

var _constants = __webpack_require__(87270);

var _errors = __webpack_require__(61298);

var _Pair = __webpack_require__(22007);

var _parseUtils = __webpack_require__(81359);

var _Seq = __webpack_require__(74151);

var _Collection = __webpack_require__(67404);

function parseSeq(doc, cst) {
  if (cst.type !== _constants.Type.SEQ && cst.type !== _constants.Type.FLOW_SEQ) {
    const msg = `A ${cst.type} node cannot be resolved as a sequence`;
    doc.errors.push(new _errors.YAMLSyntaxError(cst, msg));
    return null;
  }

  const {
    comments,
    items
  } = cst.type === _constants.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
  const seq = new _Seq.YAMLSeq();
  seq.items = items;
  (0, _parseUtils.resolveComments)(seq, comments);

  if (!doc.options.mapAsMap && items.some(it => it instanceof _Pair.Pair && it.key instanceof _Collection.Collection)) {
    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new _errors.YAMLWarning(cst, warn));
  }

  cst.resolved = seq;
  return seq;
}

function resolveBlockSeqItems(doc, cst) {
  const comments = [];
  const items = [];

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    switch (item.type) {
      case _constants.Type.BLANK_LINE:
        comments.push({
          before: items.length
        });
        break;

      case _constants.Type.COMMENT:
        comments.push({
          comment: item.comment,
          before: items.length
        });
        break;

      case _constants.Type.SEQ_ITEM:
        if (item.error) doc.errors.push(item.error);
        items.push(doc.resolveNode(item.node));

        if (item.hasProps) {
          const msg = 'Sequence items cannot have tags or anchors before the - indicator';
          doc.errors.push(new _errors.YAMLSemanticError(item, msg));
        }

        break;

      default:
        if (item.error) doc.errors.push(item.error);
        doc.errors.push(new _errors.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
    }
  }

  return {
    comments,
    items
  };
}

function resolveFlowSeqItems(doc, cst) {
  const comments = [];
  const items = [];
  let explicitKey = false;
  let key = undefined;
  let keyStart = null;
  let next = '[';

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    if (typeof item.char === 'string') {
      const {
        char,
        offset
      } = item;

      if (char !== ':' && (explicitKey || key !== undefined)) {
        if (explicitKey && key === undefined) key = next ? items.pop() : null;
        items.push(new _Pair.Pair(key));
        explicitKey = false;
        key = undefined;
        keyStart = null;
      }

      if (char === next) {
        next = null;
      } else if (!next && char === '?') {
        explicitKey = true;
      } else if (next !== '[' && char === ':' && key === undefined) {
        if (next === ',') {
          key = items.pop();

          if (key instanceof _Pair.Pair) {
            const msg = 'Chaining flow sequence pairs is invalid';
            const err = new _errors.YAMLSemanticError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }

          if (!explicitKey) (0, _parseUtils.checkKeyLength)(doc.errors, cst, i, key, keyStart);
        } else {
          key = null;
        }

        keyStart = null;
        explicitKey = false; // TODO: add error for non-explicit multiline plain key

        next = null;
      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {
        const msg = `Flow sequence contains an unexpected ${char}`;
        const err = new _errors.YAMLSyntaxError(cst, msg);
        err.offset = offset;
        doc.errors.push(err);
      }
    } else if (item.type === _constants.Type.BLANK_LINE) {
      comments.push({
        before: items.length
      });
    } else if (item.type === _constants.Type.COMMENT) {
      comments.push({
        comment: item.comment,
        before: items.length
      });
    } else {
      if (next) {
        const msg = `Expected a ${next} in flow sequence`;
        doc.errors.push(new _errors.YAMLSemanticError(item, msg));
      }

      const value = doc.resolveNode(item);

      if (key === undefined) {
        items.push(value);
      } else {
        items.push(new _Pair.Pair(key, value));
        key = undefined;
      }

      keyStart = item.range.start;
      next = ',';
    }
  }

  (0, _parseUtils.checkFlowCollectionEnd)(doc.errors, cst);
  if (key !== undefined) items.push(new _Pair.Pair(key));
  return {
    comments,
    items
  };
}

/***/ }),

/***/ 81359:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.checkFlowCollectionEnd = checkFlowCollectionEnd;
exports.checkKeyLength = checkKeyLength;
exports.resolveComments = resolveComments;

var _errors = __webpack_require__(61298);

var _constants = __webpack_require__(87270);

function checkFlowCollectionEnd(errors, cst) {
  let char, name;

  switch (cst.type) {
    case _constants.Type.FLOW_MAP:
      char = '}';
      name = 'flow map';
      break;

    case _constants.Type.FLOW_SEQ:
      char = ']';
      name = 'flow sequence';
      break;

    default:
      errors.push(new _errors.YAMLSemanticError(cst, 'Not a flow collection!?'));
      return;
  }

  let lastItem;

  for (let i = cst.items.length - 1; i >= 0; --i) {
    const item = cst.items[i];

    if (!item || item.type !== _constants.Type.COMMENT) {
      lastItem = item;
      break;
    }
  }

  if (lastItem && lastItem.char !== char) {
    const msg = `Expected ${name} to end with ${char}`;
    let err;

    if (typeof lastItem.offset === 'number') {
      err = new _errors.YAMLSemanticError(cst, msg);
      err.offset = lastItem.offset + 1;
    } else {
      err = new _errors.YAMLSemanticError(lastItem, msg);
      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
    }

    errors.push(err);
  }
}

function checkKeyLength(errors, node, itemIdx, key, keyStart) {
  if (!key || typeof keyStart !== 'number') return;
  const item = node.items[itemIdx];
  let keyEnd = item && item.range && item.range.start;

  if (!keyEnd) {
    for (let i = itemIdx - 1; i >= 0; --i) {
      const it = node.items[i];

      if (it && it.range) {
        keyEnd = it.range.end + 2 * (itemIdx - i);
        break;
      }
    }
  }

  if (keyEnd > keyStart + 1024) {
    const k = String(key).substr(0, 8) + '...' + String(key).substr(-8);
    errors.push(new _errors.YAMLSemanticError(node, `The "${k}" key is too long`));
  }
}

function resolveComments(collection, comments) {
  for (const {
    afterKey,
    before,
    comment
  } of comments) {
    let item = collection.items[before];

    if (!item) {
      if (comment !== undefined) {
        if (collection.comment) collection.comment += '\n' + comment;else collection.comment = comment;
      }
    } else {
      if (afterKey && item.value) item = item.value;

      if (comment === undefined) {
        if (afterKey || !item.commentBefore) item.spaceBefore = true;
      } else {
        if (item.commentBefore) item.commentBefore += '\n' + comment;else item.commentBefore = comment;
      }
    }
  }
}

/***/ }),

/***/ 81147:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.stringifyNumber = stringifyNumber;
exports.stringifyString = stringifyString;

var _addComment = __webpack_require__(5350);

var _constants = __webpack_require__(87270);

var _foldFlowLines = __webpack_require__(52590);

var _options = __webpack_require__(5204);

const getFoldOptions = ({
  indentAtStart
}) => indentAtStart ? Object.assign({
  indentAtStart
}, _options.strOptions.fold) : _options.strOptions.fold;

function stringifyNumber({
  format,
  minFractionDigits,
  tag,
  value
}) {
  if (typeof value === 'bigint') return String(value);
  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';
  let n = JSON.stringify(value);

  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
    let i = n.indexOf('.');

    if (i < 0) {
      i = n.length;
      n += '.';
    }

    let d = minFractionDigits - (n.length - i - 1);

    while (d-- > 0) n += '0';
  }

  return n;
}

function lineLengthOverLimit(str, limit) {
  const strLen = str.length;
  if (strLen <= limit) return false;

  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === '\n') {
      if (i - start > limit) return true;
      start = i + 1;
      if (strLen - start <= limit) return false;
    }
  }

  return true;
}

function doubleQuotedString(value, ctx) {
  const {
    implicitKey,
    indent
  } = ctx;
  const {
    jsonEncoding,
    minMultiLineLength
  } = _options.strOptions.doubleQuoted;
  const json = JSON.stringify(value);
  if (jsonEncoding) return json;
  let str = '';
  let start = 0;

  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
      // space before newline needs to be escaped to not be folded
      str += json.slice(start, i) + '\\ ';
      i += 1;
      start = i;
      ch = '\\';
    }

    if (ch === '\\') switch (json[i + 1]) {
      case 'u':
        {
          str += json.slice(start, i);
          const code = json.substr(i + 2, 4);

          switch (code) {
            case '0000':
              str += '\\0';
              break;

            case '0007':
              str += '\\a';
              break;

            case '000b':
              str += '\\v';
              break;

            case '001b':
              str += '\\e';
              break;

            case '0085':
              str += '\\N';
              break;

            case '00a0':
              str += '\\_';
              break;

            case '2028':
              str += '\\L';
              break;

            case '2029':
              str += '\\P';
              break;

            default:
              if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);else str += json.substr(i, 6);
          }

          i += 5;
          start = i + 1;
        }
        break;

      case 'n':
        if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
          i += 1;
        } else {
          // folding will eat first newline
          str += json.slice(start, i) + '\n\n';

          while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
            str += '\n';
            i += 2;
          }

          str += indent; // space after newline needs to be escaped to not be folded

          if (json[i + 2] === ' ') str += '\\';
          i += 1;
          start = i + 1;
        }

        break;

      default:
        i += 1;
    }
  }

  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : (0, _foldFlowLines.foldFlowLines)(str, indent, _foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx));
}

function singleQuotedString(value, ctx) {
  const {
    indent,
    implicitKey
  } = ctx;

  if (implicitKey) {
    if (/\n/.test(value)) return doubleQuotedString(value, ctx);
  } else {
    // single quoted string can't have leading or trailing whitespace around newline
    if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
  }

  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
  return implicitKey ? res : (0, _foldFlowLines.foldFlowLines)(res, indent, _foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
}

function blockString({
  comment,
  type,
  value
}, ctx, onComment, onChompKeep) {
  // 1. Block can't end in whitespace unless the last line is non-empty.
  // 2. Strings consisting of only whitespace are best rendered explicitly.
  if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return doubleQuotedString(value, ctx);
  }

  const indent = ctx.indent || (ctx.forceBlockIndent ? ' ' : '');
  const indentSize = indent ? '2' : '1'; // root is at -1

  const literal = type === _constants.Type.BLOCK_FOLDED ? false : type === _constants.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, _options.strOptions.fold.lineWidth - indent.length);
  let header = literal ? '|' : '>';
  if (!value) return header + '\n';
  let wsStart = '';
  let wsEnd = '';
  value = value.replace(/[\n\t ]*$/, ws => {
    const n = ws.indexOf('\n');

    if (n === -1) {
      header += '-'; // strip
    } else if (value === ws || n !== ws.length - 1) {
      header += '+'; // keep

      if (onChompKeep) onChompKeep();
    }

    wsEnd = ws.replace(/\n$/, '');
    return '';
  }).replace(/^[\n ]*/, ws => {
    if (ws.indexOf(' ') !== -1) header += indentSize;
    const m = ws.match(/ +$/);

    if (m) {
      wsStart = ws.slice(0, -m[0].length);
      return m[0];
    } else {
      wsStart = ws;
      return '';
    }
  });
  if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  if (wsStart) wsStart = wsStart.replace(/\n+/g, `$&${indent}`);

  if (comment) {
    header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
    if (onComment) onComment();
  }

  if (!value) return `${header}${indentSize}\n${indent}${wsEnd}`;

  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}\n${indent}${wsStart}${value}${wsEnd}`;
  }

  value = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent
  .replace(/\n+/g, `$&${indent}`);
  const body = (0, _foldFlowLines.foldFlowLines)(`${wsStart}${value}${wsEnd}`, indent, _foldFlowLines.FOLD_BLOCK, _options.strOptions.fold);
  return `${header}\n${indent}${body}`;
}

function plainString(item, ctx, onComment, onChompKeep) {
  const {
    comment,
    type,
    value
  } = item;
  const {
    actualString,
    implicitKey,
    indent,
    inFlow,
    tags
  } = ctx;

  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return doubleQuotedString(value, ctx);
  }

  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    // not allowed:
    // - empty string, '-' or '?'
    // - start with an indicator character (except [?:-]) or /[?-] /
    // - '\n ', ': ' or ' \n' anywhere
    // - '#' not preceded by a non-space char
    // - end with ' ' or ':'
    return implicitKey || inFlow || value.indexOf('\n') === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }

  if (!implicitKey && !inFlow && type !== _constants.Type.PLAIN && value.indexOf('\n') !== -1) {
    // Where allowed & type not set explicitly, prefer block style for multiline strings
    return blockString(item, ctx, onComment, onChompKeep);
  }

  const str = value.replace(/\n+/g, `$&\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and
  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
  // and others in v1.1.

  if (actualString && typeof tags.resolveScalar(str).value !== 'string') {
    return doubleQuotedString(value, ctx);
  }

  const body = implicitKey ? str : (0, _foldFlowLines.foldFlowLines)(str, indent, _foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));

  if (comment && !inFlow && (body.indexOf('\n') !== -1 || comment.indexOf('\n') !== -1)) {
    if (onComment) onComment();
    return (0, _addComment.addCommentBefore)(body, indent, comment);
  }

  return body;
}

function stringifyString(item, ctx, onComment, onChompKeep) {
  const {
    defaultType
  } = _options.strOptions;
  const {
    implicitKey,
    inFlow
  } = ctx;
  let {
    type,
    value
  } = item;

  if (typeof value !== 'string') {
    value = String(value);
    item = Object.assign({}, item, {
      value
    });
  }

  const _stringify = _type => {
    switch (_type) {
      case _constants.Type.BLOCK_FOLDED:
      case _constants.Type.BLOCK_LITERAL:
        return blockString(item, ctx, onComment, onChompKeep);

      case _constants.Type.QUOTE_DOUBLE:
        return doubleQuotedString(value, ctx);

      case _constants.Type.QUOTE_SINGLE:
        return singleQuotedString(value, ctx);

      case _constants.Type.PLAIN:
        return plainString(item, ctx, onComment, onChompKeep);

      default:
        return null;
    }
  };

  if (type !== _constants.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
    // force double quotes on control characters
    type = _constants.Type.QUOTE_DOUBLE;
  } else if ((implicitKey || inFlow) && (type === _constants.Type.BLOCK_FOLDED || type === _constants.Type.BLOCK_LITERAL)) {
    // should not happen; blocks are not valid inside flow containers
    type = _constants.Type.QUOTE_DOUBLE;
  }

  let res = _stringify(type);

  if (res === null) {
    res = _stringify(defaultType);
    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);
  }

  return res;
}

/***/ }),

/***/ 59061:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.core = exports.floatObj = exports.expObj = exports.nanObj = exports.hexObj = exports.intObj = exports.octObj = exports.boolObj = exports.nullObj = void 0;

var _Scalar = __webpack_require__(55858);

var _stringify = __webpack_require__(81147);

var _failsafe = __webpack_require__(14335);

var _options = __webpack_require__(5204);

/* global BigInt */
const intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);

const intResolve = (src, part, radix) => _options.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);

function intStringify(node, radix, prefix) {
  const {
    value
  } = node;
  if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);
  return (0, _stringify.stringifyNumber)(node);
}

const nullObj = {
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new _Scalar.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => null,
  options: _options.nullOptions,
  stringify: () => _options.nullOptions.nullStr
};
exports.nullObj = nullObj;
const boolObj = {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: str => str[0] === 't' || str[0] === 'T',
  options: _options.boolOptions,
  stringify: ({
    value
  }) => value ? _options.boolOptions.trueStr : _options.boolOptions.falseStr
};
exports.boolObj = boolObj;
const octObj = {
  identify: value => intIdentify(value) && value >= 0,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'OCT',
  test: /^0o([0-7]+)$/,
  resolve: (str, oct) => intResolve(str, oct, 8),
  options: _options.intOptions,
  stringify: node => intStringify(node, 8, '0o')
};
exports.octObj = octObj;
const intObj = {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^[-+]?[0-9]+$/,
  resolve: str => intResolve(str, str, 10),
  options: _options.intOptions,
  stringify: _stringify.stringifyNumber
};
exports.intObj = intObj;
const hexObj = {
  identify: value => intIdentify(value) && value >= 0,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'HEX',
  test: /^0x([0-9a-fA-F]+)$/,
  resolve: (str, hex) => intResolve(str, hex, 16),
  options: _options.intOptions,
  stringify: node => intStringify(node, 16, '0x')
};
exports.hexObj = hexObj;
const nanObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: _stringify.stringifyNumber
};
exports.nanObj = nanObj;
const expObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'EXP',
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: str => parseFloat(str),
  stringify: ({
    value
  }) => Number(value).toExponential()
};
exports.expObj = expObj;
const floatObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,

  resolve(str, frac1, frac2) {
    const frac = frac1 || frac2;
    const node = new _Scalar.Scalar(parseFloat(str));
    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;
    return node;
  },

  stringify: _stringify.stringifyNumber
};
exports.floatObj = floatObj;

const core = _failsafe.failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);

exports.core = core;

/***/ }),

/***/ 14335:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.failsafe = void 0;

var _map = __webpack_require__(80587);

var _seq = __webpack_require__(3787);

var _string = __webpack_require__(94250);

const failsafe = [_map.map, _seq.seq, _string.string];
exports.failsafe = failsafe;

/***/ }),

/***/ 80587:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.map = void 0;

var _Map = __webpack_require__(80022);

var _parseMap = __webpack_require__(12346);

function createMap(schema, obj, ctx) {
  const map = new _Map.YAMLMap(schema);

  if (obj instanceof Map) {
    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));
  } else if (obj && typeof obj === 'object') {
    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));
  }

  if (typeof schema.sortMapEntries === 'function') {
    map.items.sort(schema.sortMapEntries);
  }

  return map;
}

const map = {
  createNode: createMap,
  default: true,
  nodeClass: _Map.YAMLMap,
  tag: 'tag:yaml.org,2002:map',
  resolve: _parseMap.parseMap
};
exports.map = map;

/***/ }),

/***/ 3787:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.seq = void 0;

var _parseSeq = __webpack_require__(45028);

var _Seq = __webpack_require__(74151);

function createSeq(schema, obj, ctx) {
  const seq = new _Seq.YAMLSeq(schema);

  if (obj && obj[Symbol.iterator]) {
    for (const it of obj) {
      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);
      seq.items.push(v);
    }
  }

  return seq;
}

const seq = {
  createNode: createSeq,
  default: true,
  nodeClass: _Seq.YAMLSeq,
  tag: 'tag:yaml.org,2002:seq',
  resolve: _parseSeq.parseSeq
};
exports.seq = seq;

/***/ }),

/***/ 94250:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.string = exports.resolveString = void 0;

var _stringify = __webpack_require__(81147);

var _options = __webpack_require__(5204);

const resolveString = (doc, node) => {
  // on error, will return { str: string, errors: Error[] }
  const res = node.strValue;
  if (!res) return '';
  if (typeof res === 'string') return res;
  res.errors.forEach(error => {
    if (!error.source) error.source = node;
    doc.errors.push(error);
  });
  return res.str;
};

exports.resolveString = resolveString;
const string = {
  identify: value => typeof value === 'string',
  default: true,
  tag: 'tag:yaml.org,2002:str',
  resolve: resolveString,

  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({
      actualString: true
    }, ctx);
    return (0, _stringify.stringifyString)(item, ctx, onComment, onChompKeep);
  },

  options: _options.strOptions
};
exports.string = string;

/***/ }),

/***/ 40094:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.tags = exports.schemas = void 0;

var _core = __webpack_require__(59061);

var _failsafe = __webpack_require__(14335);

var _json = __webpack_require__(92574);

var _yaml = __webpack_require__(56962);

var _map = __webpack_require__(80587);

var _seq = __webpack_require__(3787);

var _binary = __webpack_require__(26701);

var _omap = __webpack_require__(81103);

var _pairs = __webpack_require__(68120);

var _set = __webpack_require__(81413);

var _timestamp = __webpack_require__(96221);

const schemas = {
  core: _core.core,
  failsafe: _failsafe.failsafe,
  json: _json.json,
  yaml11: _yaml.yaml11
};
exports.schemas = schemas;
const tags = {
  binary: _binary.binary,
  bool: _core.boolObj,
  float: _core.floatObj,
  floatExp: _core.expObj,
  floatNaN: _core.nanObj,
  floatTime: _timestamp.floatTime,
  int: _core.intObj,
  intHex: _core.hexObj,
  intOct: _core.octObj,
  intTime: _timestamp.intTime,
  map: _map.map,
  null: _core.nullObj,
  omap: _omap.omap,
  pairs: _pairs.pairs,
  seq: _seq.seq,
  set: _set.set,
  timestamp: _timestamp.timestamp
};
exports.tags = tags;

/***/ }),

/***/ 92574:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.json = void 0;

var _map = __webpack_require__(80587);

var _seq = __webpack_require__(3787);

var _Scalar = __webpack_require__(55858);

var _string = __webpack_require__(94250);

var _options = __webpack_require__(5204);

/* global BigInt */
const intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);

const stringifyJSON = ({
  value
}) => JSON.stringify(value);

const json = [_map.map, _seq.seq, {
  identify: value => typeof value === 'string',
  default: true,
  tag: 'tag:yaml.org,2002:str',
  resolve: _string.resolveString,
  stringify: stringifyJSON
}, {
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new _Scalar.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^null$/,
  resolve: () => null,
  stringify: stringifyJSON
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^true|false$/,
  resolve: str => str === 'true',
  stringify: stringifyJSON
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^-?(?:0|[1-9][0-9]*)$/,
  resolve: str => _options.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),
  stringify: ({
    value
  }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
  resolve: str => parseFloat(str),
  stringify: stringifyJSON
}];
exports.json = json;

json.scalarFallback = str => {
  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);
};

/***/ }),

/***/ 5204:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.strOptions = exports.nullOptions = exports.intOptions = exports.boolOptions = exports.binaryOptions = void 0;

var _constants = __webpack_require__(87270);

const binaryOptions = {
  defaultType: _constants.Type.BLOCK_LITERAL,
  lineWidth: 76
};
exports.binaryOptions = binaryOptions;
const boolOptions = {
  trueStr: 'true',
  falseStr: 'false'
};
exports.boolOptions = boolOptions;
const intOptions = {
  asBigInt: false
};
exports.intOptions = intOptions;
const nullOptions = {
  nullStr: 'null'
};
exports.nullOptions = nullOptions;
const strOptions = {
  defaultType: _constants.Type.PLAIN,
  doubleQuoted: {
    jsonEncoding: false,
    minMultiLineLength: 40
  },
  fold: {
    lineWidth: 80,
    minContentWidth: 20
  }
};
exports.strOptions = strOptions;

/***/ }),

/***/ 26701:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.binary = void 0;

var _constants = __webpack_require__(87270);

var _errors = __webpack_require__(61298);

var _stringify = __webpack_require__(81147);

var _string = __webpack_require__(94250);

var _options = __webpack_require__(5204);

/* global atob, btoa, Buffer */
const binary = {
  identify: value => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: 'tag:yaml.org,2002:binary',

  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve: (doc, node) => {
    const src = (0, _string.resolveString)(doc, node);

    if (typeof Buffer === 'function') {
      return Buffer.from(src, 'base64');
    } else if (typeof atob === 'function') {
      // On IE 11, atob() can't handle newlines
      const str = atob(src.replace(/[\n\r]/g, ''));
      const buffer = new Uint8Array(str.length);

      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);

      return buffer;
    } else {
      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';
      doc.errors.push(new _errors.YAMLReferenceError(node, msg));
      return null;
    }
  },
  options: _options.binaryOptions,
  stringify: ({
    comment,
    type,
    value
  }, ctx, onComment, onChompKeep) => {
    let src;

    if (typeof Buffer === 'function') {
      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');
    } else if (typeof btoa === 'function') {
      let s = '';

      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);

      src = btoa(s);
    } else {
      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
    }

    if (!type) type = _options.binaryOptions.defaultType;

    if (type === _constants.Type.QUOTE_DOUBLE) {
      value = src;
    } else {
      const {
        lineWidth
      } = _options.binaryOptions;
      const n = Math.ceil(src.length / lineWidth);
      const lines = new Array(n);

      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = src.substr(o, lineWidth);
      }

      value = lines.join(type === _constants.Type.BLOCK_LITERAL ? '\n' : ' ');
    }

    return (0, _stringify.stringifyString)({
      comment,
      type,
      value
    }, ctx, onComment, onChompKeep);
  }
};
exports.binary = binary;

/***/ }),

/***/ 56962:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.yaml11 = void 0;

var _Scalar = __webpack_require__(55858);

var _stringify = __webpack_require__(81147);

var _failsafe = __webpack_require__(14335);

var _options = __webpack_require__(5204);

var _binary = __webpack_require__(26701);

var _omap = __webpack_require__(81103);

var _pairs = __webpack_require__(68120);

var _set = __webpack_require__(81413);

var _timestamp = __webpack_require__(96221);

/* global BigInt */
const boolStringify = ({
  value
}) => value ? _options.boolOptions.trueStr : _options.boolOptions.falseStr;

const intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);

function intResolve(sign, src, radix) {
  let str = src.replace(/_/g, '');

  if (_options.intOptions.asBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;

      case 8:
        str = `0o${str}`;
        break;

      case 16:
        str = `0x${str}`;
        break;
    }

    const n = BigInt(str);
    return sign === '-' ? BigInt(-1) * n : n;
  }

  const n = parseInt(str, radix);
  return sign === '-' ? -1 * n : n;
}

function intStringify(node, radix, prefix) {
  const {
    value
  } = node;

  if (intIdentify(value)) {
    const str = value.toString(radix);
    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
  }

  return (0, _stringify.stringifyNumber)(node);
}

const yaml11 = _failsafe.failsafe.concat([{
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new _Scalar.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => null,
  options: _options.nullOptions,
  stringify: () => _options.nullOptions.nullStr
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => true,
  options: _options.boolOptions,
  stringify: boolStringify
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => false,
  options: _options.boolOptions,
  stringify: boolStringify
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'BIN',
  test: /^([-+]?)0b([0-1_]+)$/,
  resolve: (str, sign, bin) => intResolve(sign, bin, 2),
  stringify: node => intStringify(node, 2, '0b')
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'OCT',
  test: /^([-+]?)0([0-7_]+)$/,
  resolve: (str, sign, oct) => intResolve(sign, oct, 8),
  stringify: node => intStringify(node, 8, '0')
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^([-+]?)([0-9][0-9_]*)$/,
  resolve: (str, sign, abs) => intResolve(sign, abs, 10),
  stringify: _stringify.stringifyNumber
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'HEX',
  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
  resolve: (str, sign, hex) => intResolve(sign, hex, 16),
  stringify: node => intStringify(node, 16, '0x')
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: _stringify.stringifyNumber
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'EXP',
  test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: str => parseFloat(str.replace(/_/g, '')),
  stringify: ({
    value
  }) => Number(value).toExponential()
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,

  resolve(str, frac) {
    const node = new _Scalar.Scalar(parseFloat(str.replace(/_/g, '')));

    if (frac) {
      const f = frac.replace(/_/g, '');
      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;
    }

    return node;
  },

  stringify: _stringify.stringifyNumber
}], _binary.binary, _omap.omap, _pairs.pairs, _set.set, _timestamp.intTime, _timestamp.floatTime, _timestamp.timestamp);

exports.yaml11 = yaml11;

/***/ }),

/***/ 81103:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.omap = exports.YAMLOMap = void 0;

var _errors = __webpack_require__(61298);

var _toJSON = __webpack_require__(35613);

var _Map = __webpack_require__(80022);

var _Pair = __webpack_require__(22007);

var _Scalar = __webpack_require__(55858);

var _Seq = __webpack_require__(74151);

var _pairs = __webpack_require__(68120);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class YAMLOMap extends _Seq.YAMLSeq {
  constructor() {
    super();

    _defineProperty(this, "add", _Map.YAMLMap.prototype.add.bind(this));

    _defineProperty(this, "delete", _Map.YAMLMap.prototype.delete.bind(this));

    _defineProperty(this, "get", _Map.YAMLMap.prototype.get.bind(this));

    _defineProperty(this, "has", _Map.YAMLMap.prototype.has.bind(this));

    _defineProperty(this, "set", _Map.YAMLMap.prototype.set.bind(this));

    this.tag = YAMLOMap.tag;
  }

  toJSON(_, ctx) {
    const map = new Map();
    if (ctx && ctx.onCreate) ctx.onCreate(map);

    for (const pair of this.items) {
      let key, value;

      if (pair instanceof _Pair.Pair) {
        key = (0, _toJSON.toJSON)(pair.key, '', ctx);
        value = (0, _toJSON.toJSON)(pair.value, key, ctx);
      } else {
        key = (0, _toJSON.toJSON)(pair, '', ctx);
      }

      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
      map.set(key, value);
    }

    return map;
  }

}

exports.YAMLOMap = YAMLOMap;

_defineProperty(YAMLOMap, "tag", 'tag:yaml.org,2002:omap');

function parseOMap(doc, cst) {
  const pairs = (0, _pairs.parsePairs)(doc, cst);
  const seenKeys = [];

  for (const {
    key
  } of pairs.items) {
    if (key instanceof _Scalar.Scalar) {
      if (seenKeys.includes(key.value)) {
        const msg = 'Ordered maps must not include duplicate keys';
        throw new _errors.YAMLSemanticError(cst, msg);
      } else {
        seenKeys.push(key.value);
      }
    }
  }

  return Object.assign(new YAMLOMap(), pairs);
}

function createOMap(schema, iterable, ctx) {
  const pairs = (0, _pairs.createPairs)(schema, iterable, ctx);
  const omap = new YAMLOMap();
  omap.items = pairs.items;
  return omap;
}

const omap = {
  identify: value => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: 'tag:yaml.org,2002:omap',
  resolve: parseOMap,
  createNode: createOMap
};
exports.omap = omap;

/***/ }),

/***/ 68120:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.parsePairs = parsePairs;
exports.createPairs = createPairs;
exports.pairs = void 0;

var _errors = __webpack_require__(61298);

var _Map = __webpack_require__(80022);

var _Pair = __webpack_require__(22007);

var _parseSeq = __webpack_require__(45028);

var _Seq = __webpack_require__(74151);

function parsePairs(doc, cst) {
  const seq = (0, _parseSeq.parseSeq)(doc, cst);

  for (let i = 0; i < seq.items.length; ++i) {
    let item = seq.items[i];
    if (item instanceof _Pair.Pair) continue;else if (item instanceof _Map.YAMLMap) {
      if (item.items.length > 1) {
        const msg = 'Each pair must have its own sequence indicator';
        throw new _errors.YAMLSemanticError(cst, msg);
      }

      const pair = item.items[0] || new _Pair.Pair();
      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\n${pair.commentBefore}` : item.commentBefore;
      if (item.comment) pair.comment = pair.comment ? `${item.comment}\n${pair.comment}` : item.comment;
      item = pair;
    }
    seq.items[i] = item instanceof _Pair.Pair ? item : new _Pair.Pair(item);
  }

  return seq;
}

function createPairs(schema, iterable, ctx) {
  const pairs = new _Seq.YAMLSeq(schema);
  pairs.tag = 'tag:yaml.org,2002:pairs';

  for (const it of iterable) {
    let key, value;

    if (Array.isArray(it)) {
      if (it.length === 2) {
        key = it[0];
        value = it[1];
      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
    } else if (it && it instanceof Object) {
      const keys = Object.keys(it);

      if (keys.length === 1) {
        key = keys[0];
        value = it[key];
      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);
    } else {
      key = it;
    }

    const pair = schema.createPair(key, value, ctx);
    pairs.items.push(pair);
  }

  return pairs;
}

const pairs = {
  default: false,
  tag: 'tag:yaml.org,2002:pairs',
  resolve: parsePairs,
  createNode: createPairs
};
exports.pairs = pairs;

/***/ }),

/***/ 81413:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.set = exports.YAMLSet = void 0;

var _errors = __webpack_require__(61298);

var _Map = __webpack_require__(80022);

var _Pair = __webpack_require__(22007);

var _parseMap = __webpack_require__(12346);

var _Scalar = __webpack_require__(55858);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class YAMLSet extends _Map.YAMLMap {
  constructor() {
    super();
    this.tag = YAMLSet.tag;
  }

  add(key) {
    const pair = key instanceof _Pair.Pair ? key : new _Pair.Pair(key);
    const prev = (0, _Map.findPair)(this.items, pair.key);
    if (!prev) this.items.push(pair);
  }

  get(key, keepPair) {
    const pair = (0, _Map.findPair)(this.items, key);
    return !keepPair && pair instanceof _Pair.Pair ? pair.key instanceof _Scalar.Scalar ? pair.key.value : pair.key : pair;
  }

  set(key, value) {
    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = (0, _Map.findPair)(this.items, key);

    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new _Pair.Pair(key));
    }
  }

  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);
    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');
  }

}

exports.YAMLSet = YAMLSet;

_defineProperty(YAMLSet, "tag", 'tag:yaml.org,2002:set');

function parseSet(doc, cst) {
  const map = (0, _parseMap.parseMap)(doc, cst);
  if (!map.hasAllNullValues()) throw new _errors.YAMLSemanticError(cst, 'Set items must all have null values');
  return Object.assign(new YAMLSet(), map);
}

function createSet(schema, iterable, ctx) {
  const set = new YAMLSet();

  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));

  return set;
}

const set = {
  identify: value => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: 'tag:yaml.org,2002:set',
  resolve: parseSet,
  createNode: createSet
};
exports.set = set;

/***/ }),

/***/ 96221:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.timestamp = exports.floatTime = exports.intTime = void 0;

var _stringify = __webpack_require__(81147);

const parseSexagesimal = (sign, parts) => {
  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);
  return sign === '-' ? -n : n;
}; // hhhh:mm:ss.sss


const stringifySexagesimal = ({
  value
}) => {
  if (isNaN(value) || !isFinite(value)) return (0, _stringify.stringifyNumber)(value);
  let sign = '';

  if (value < 0) {
    sign = '-';
    value = Math.abs(value);
  }

  const parts = [value % 60]; // seconds, including ms

  if (value < 60) {
    parts.unshift(0); // at least one : is required
  } else {
    value = Math.round((value - parts[0]) / 60);
    parts.unshift(value % 60); // minutes

    if (value >= 60) {
      value = Math.round((value - parts[0]) / 60);
      parts.unshift(value); // hours
    }
  }

  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
  ;
};

const intTime = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'TIME',
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
  stringify: stringifySexagesimal
};
exports.intTime = intTime;
const floatTime = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'TIME',
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
  stringify: stringifySexagesimal
};
exports.floatTime = floatTime;
const timestamp = {
  identify: value => value instanceof Date,
  default: true,
  tag: 'tag:yaml.org,2002:timestamp',
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
  '(?:(?:t|T|[ \\t]+)' + // t | T | whitespace
  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
  '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
  ')?' + ')$'),
  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
    if (millisec) millisec = (millisec + '00').substr(1, 3);
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);

    if (tz && tz !== 'Z') {
      let d = parseSexagesimal(tz[0], tz.slice(1));
      if (Math.abs(d) < 30) d *= 60;
      date -= 60000 * d;
    }

    return new Date(date);
  },
  stringify: ({
    value
  }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};
exports.timestamp = timestamp;

/***/ }),

/***/ 35613:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.toJSON = toJSON;

function toJSON(value, arg, ctx) {
  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));

  if (value && typeof value.toJSON === 'function') {
    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
    if (anchor) ctx.onCreate = res => {
      anchor.res = res;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (anchor && ctx.onCreate) ctx.onCreate(res);
    return res;
  }

  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);
  return value;
}

/***/ }),

/***/ 33912:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.warn = warn;
exports.warnFileDeprecation = warnFileDeprecation;
exports.warnOptionDeprecation = warnOptionDeprecation;

/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */
function shouldWarn(deprecation) {
  const env = typeof process !== 'undefined' && process.env || {};

  if (deprecation) {
    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;
    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
  }

  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;
  return !env.YAML_SILENCE_WARNINGS;
}

function warn(warning, type) {
  if (shouldWarn(false)) {
    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to
    // https://github.com/facebook/jest/issues/2549

    if (emit) emit(warning, type);else {
      // eslint-disable-next-line no-console
      console.warn(type ? `${type}: ${warning}` : warning);
    }
  }
}

function warnFileDeprecation(filename) {
  if (shouldWarn(true)) {
    const path = filename.replace(/.*yaml[/\\]/i, '').replace(/\.js$/, '').replace(/\\/g, '/');
    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');
  }
}

const warned = {};

function warnOptionDeprecation(name, alternative) {
  if (!warned[name] && shouldWarn(true)) {
    warned[name] = true;
    let msg = `The option '${name}' will be removed in a future release`;
    msg += alternative ? `, use '${alternative}' instead.` : '.';
    warn(msg, 'DeprecationWarning');
  }
}

/***/ }),

/***/ 75992:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(58336).YAML


/***/ }),

/***/ 11304:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"1.7.6"};

/***/ }),

/***/ 19521:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ }),

/***/ 52306:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"0.2.0"};

/***/ }),

/***/ 53412:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"1.3.7"};

/***/ }),

/***/ 97992:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"Text_Key":"Text Key","Text_Value":"Text Value","Additional_Information":"Additional Information"}');

/***/ }),

/***/ 13086:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"ERROR_SPECIFICATION_MISSING":"Seems specification package is missing. Please execute command \'npm i @sap/ux-specification --save-dev\' in root (where package.json is) of your project. \'{{root}}\'. Error was: {{error.message}}`","ERROR_VOCABULARY_NOT_FOUND":"Vocabulary not found! namespace: {{namespace}}, uri: {{- uri}} ","ERROR_READING_METADATA":"Error while reading service metadata {{path}}. Error was: {{error}}","ERROR_SERVICE_NOT_FOUND":"Service for uri: \'{{- uri}}\' not found. Available services: {{- services}}","ERROR_READING_CAP_SERVICE_METADATA":"Error while reading CAP service metadata. Path: {{- root}}, service uri: {{- uri}}, error: {{- error}}","ERROR_RESOLVING_CDS_ROOTS":"Error while resolving cds roots for \'{{projectRoot}}\'. {{error}}","ERROR_RETRIEVING_CDS_FILES":"Error while retrieving the list of cds files for project {{projectRoot}}, envRoot ${envRoot}. Error was: {{error}}","ERROR_PROJECT_ROOT_WORKSPACE":"Error while trying to find project in workspace root {{root}}. Error was: {{error}}","ERROR_INVALID_PACKAGE_JSON":"Found invalid package.json. {{error}}","ERROR_INVALIND_PACKAGE_JSON_FOR_APP":"Found invalid package.json in \'{{- root}}\'","ERROR_REQUIRED_APP":"Appication ID required.","ERROR_INVALID_APP_ID":"Invalid application ID.","CONSOLE_SHOULD_NOT_BE_HERE":"Should not be here \' {{currentValue}}","ERROR_LOADING_ANNOTATIONS_FROM_CAP":"Loading annotations from CAP project failed. {{error}}","ERROR_LOADING_ANNOTATIONS":"Loading annotations failed. {{error}}","ERROR_DEL_CAP_APP_SAPUX":"Property \'sapux\' in \'{{- packageJsonPath}}\' is not an array. Leaving..","ERROR_DEL_CAP_APP_MODIFY_CDS":"Could not modify file \'{{- cdsFilePath}}\'. Skipping this file.","INFO_DEL_CAP_APP":"Deleting app \'{{appName}}\' from CAP project \'{{- projectRoot}}\'.","INFO_DEL_LAST_CAP_APP":"This was the last app in this CAP project. Deleting property \'sapux\' from \'{{- packageJsonPath}}\'.","INFO_DEL_CAP_APP_FILE_UPDATED":"File \'{{- packageJsonPath}}\' updated.","INFO_DEL_CAP_APP_DIR_DELETED":"Directory \'{{- appPath}}\' deleted.","INFO_DEL_CAP_APP_DELETE_USING":"Removing using statement for \'./{{appName}}/annotations\' from \'{{- cdsFilePath}}\'.","INFO_DEL_CAP_APP_DEL_CDS":"File \'{{- cdsFilePath}}\' is now empty, removing it.","INFO_DEL_CAP_APP_FOLDER_EMPTY":"Directory \'{{- appPath}}\' is now empty. Deleting it.","ERROR_DETAIL_PROJECT_TYPE":"Cannot determine project type for app \'{{- appRoot}}\' with project root \'{{- projectRoot}}\'"}');

/***/ }),

/***/ 18622:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@sap/ux-telemetry","version":"1.4.6","description":"SAP Fiori tools telemetry library","main":"dist/src/index.js","author":"SAP SE","license":"MIT","private":true,"azureInstrumentationKey":"0a65e45d-6bf4-421d-b845-61e888c50e9e","azureProdKey":"0a65e45d-6bf4-421d-b845-61e888c50e9e","scripts":{"pre-commit":"lint-staged --quiet","clean":"rimraf ./dist","build":"ts-node ./build-script/ && yarn run clean && tsc --project ./","test":"jest --maxWorkers=1 --silent --ci --forceExit --detectOpenHandles --colors","lint":"eslint . --ext .ts","lint:summary":"eslint . --ext .ts -f summary","lint:fix":"eslint --fix","lint:fix:all":"eslint . --ext .ts --fix","lint:report":"eslint . --ext .ts -f multiple --report-unused-disable-directives","format:fix":"prettier --write --loglevel silent --ignore-path ../../../.prettierignore","format:fix:all":"prettier --write \'**/*.{css,scss,html,js,json,ts,tsx,yaml,yml}\' \'!**/{out,dist,node_modules}/**\' \'!**/*.{svg,png,xml}\' --ignore-path ../../../.prettierignore","madge":"madge --warning --circular --extensions ts ./"},"dependencies":{"@sap/ux-cds":"1.4.6","@sap/ux-common-utils":"1.4.6","@sap/ux-feature-toggle":"1.4.6","@sap/ux-project-access":"1.4.6","applicationinsights":"1.4.1","performance-now":"2.1.0","yaml":"1.10.2"},"devDependencies":{"ts-node":"8.5.2","typescript":"3.8.3"},"files":["dist/"],"jestSonar":{"reportPath":"reports/test/unit","reportFile":"test-report.xml"},"eslint-formatter-multiple":{"formatters":[{"name":"stylish","output":"console"},{"name":"json","output":"file","path":"reports/lint/eslint.json"},{"name":"checkstyle","output":"file","path":"reports/lint/eslint.checkstyle.xml"}]}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(48368);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;